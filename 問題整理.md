

#

## 1. 裸機開發，第一件事應該做甚麼?

在裸機開發中，第一步是確保 MCU 能正確進入 `main()`。  
這通常依靠啟動程式 (Startup Code) 來完成，主要工作包括：  

1. 初始化 **堆疊指標 (Stack Pointer)**。  
2. 將 **.data 區段** 從 Flash 搬到 SRAM。  
3. 將 **.bss 區段** 清零。  
4. （有 system_stm32f4xx.c 時）呼叫 `SystemInit()` 完成系統時鐘等基本設定。  
5. 最後跳轉到 `main()`。  

我使用的是 **STM32CubeIDE** 建立的空白專案，IDE 會自動產生啟動檔 (`startup.s`) 和一個空的 `main.c`，因此基本的進入點流程已經就緒。  

由於要控制的周邊 (GPIO、USART、SPI、I2C…) 本質上都是透過記憶體映射的暫存器來操作，所以我自己額外寫了 `io_write` / `io_read` 函式（使用 GCC 內嵌組語），透過輸入位址與數值即可存取對應暫存器，實現對外設的控制。  

---

### 追問1：直接寫記憶體去控制暫存器，這裡的「記憶體」是什麼意思？  

這裡的「記憶體」指的是 **ARM Cortex-M 的記憶體映射地址空間 (Memory-Mapped I/O)**。  

在 Cortex-M 系列 MCU 中，外設暫存器都被配置在 **0x4000_0000 之後的 Peripheral 區域**。  
當程式碼對這些位址進行讀寫時，CPU 其實是透過總線向外設控制器發出操作指令，進而改變硬體狀態。  

所以雖然程式上看起來是「存取記憶體」，但實際上是在「操作硬體」。  

---

### 追問2：為什麼不直接用 CMSIS 提供的定義，而要寫自己的 `io_write/io_read`？  

我知道 STM32CubeIDE 內建的套件有 HAL/LL 庫，也有 CMSIS 的暫存器結構體定義，可以用 `GPIOK->ODR` 這種寫法，程式可讀性與維護性更高。  
但我自己選擇寫 `io_write/io_read`，是為了更貼近硬體原理，練習對記憶體映射與暫存器操作的理解。  
本質上兩種方式都一樣，都是在對 memory-mapped register 做讀寫。  

---

### 追問3：如果沒有 `system_stm32f4xx.c`，是不是就沒有時鐘初始化?  

是的，如果沒有 `system_stm32f4xx.c`，啟動流程中的 `SystemInit()` 不會有實際的實作，MCU 就會維持預設的 **HSI 內部時鐘 (16 MHz)** 作為 system clock。  

因此，我會在 `main()` 的一開始自行呼叫 `system_clock_setup()`，把系統時鐘切換到需要的設定（例如 180 MHz）。  

---

### 追問4：為什麼需要 `system_stm32f4xx.c`？可不可以不用？  

這個檔案主要提供：  

- `SystemInit()`：開機時的系統時鐘初始化與基本系統配置。  
- `SystemCoreClockUpdate()`：更新 `SystemCoreClock` 全域變數，讓中介層（如 HAL/RTOS）知道現在的核心時脈。  

如果不用它，也可以完全手動在 `main()` 或自己的初始化函式中設定時鐘與分頻，只是要自己維護 `SystemCoreClock` 的值。  
所以它不是「必須」，但能讓程式架構更一致、方便與官方套件（HAL/RTOS）協同使用。  

---

## 2. 為甚麼專案選擇 STM32F429 開發版

本專案的目的在於熟悉各個周邊介面 (GPIO、USART、SPI、I2C …)，並實作觸控面板應用。選擇 STM32F429 的原因如下：  

1. **整合顯示與觸控**  
   開發板原生配備 LCD 與觸控晶片，能快速上手顯示與觸控應用，不需要額外設計硬體介面。  

2. **處理效能充足**  
   主頻最高可達 180 MHz，在中階 MCU 中屬於較高等級，能同時驅動多個周邊，並具備足夠效能執行 RTOS 排程。  

3. **記憶體資源完善**  
   內建共計 **256 KB SRAM**，其中：  
   - **64 KB CCMRAM** 可配置給中斷處理或高效能運算，提升 ISR 反應速度。  
   - **192 KB 主 SRAM** 可用於 stack、heap，以及顯示緩衝等資料存放。  

整體而言，STM32F429 開發板在硬體資源、效能與開發便利性之間達到良好平衡，適合用來學習並實作各類周邊應用。

---

### 追問 1：180 MHz 是甚麼頻率

180 MHz 指的是 **MCU 的主時脈頻率 (system clock frequency)**，也就是 CPU 核心運行的基本節拍。  
180 MHz = 每秒 1.8 億次震盪。每一次時脈週期都能推動 CPU 完成一個最小動作，例如取指令或執行 ALU 運算。  

可以理解為：  
**時脈越高，CPU 每秒可執行的指令越多，整體處理效能就越高。**

**實際應用層面**：  
- **周邊驅動**：GPIO、UART、SPI、I²C、LCD 等周邊會觸發中斷，CPU 必須即時處理。  
- **RTOS 管理**：即時作業系統需要進行任務切換 (context switch)、排程與堆疊管理，這些都消耗 CPU 資源。  
- **即時性需求**：若 CPU 頻率過低，可能在多工環境下「同時處理任務與中斷」時反應不及，造成延遲或不穩定。  

因此，**180 MHz 的意義**在於提供足夠的處理能力與效能裕度，讓 MCU 在同時驅動多個周邊並執行 RTOS 時，仍能維持即時性與穩定性。

---

#### 180 MHz 算是中階比較好的，那甚麼是高階、低階的？

一般來說，MCU 的「高階、中階、低階」常以 **主頻範圍** 作為粗略區分，但實際上還要考慮周邊與架構特性。

- **低階 MCU**  
  主頻約 1 MHz ~ 80 MHz。  
  特色：功耗低、成本低，周邊簡單，常用於家電控制、簡單感測器、基礎工業監控。  
  範例：STM32F0/F1、PIC16/18、8-bit AVR。  

- **中階 MCU**  
  主頻約 80 MHz ~ 200 MHz。  
  特色：效能足以支援較複雜的控制與通訊協定，例如伺服馬達控制、USB、Ethernet，並能搭配 RTOS。  
  範例：STM32F4/F7、NXP Kinetis 系列。  

- **高階 MCU**  
  主頻 200 MHz 以上。  
  特色：具備更高效能與更強周邊支援，常內建 DSP、FPU、快取 (cache)，可支援外部 SDRAM，應用於高速馬達控制、影音處理、進階工業協定（如 EtherCAT）。  
  範例：STM32H7、NXP i.MX RT、TI C2000。  

**補充**  
MCU 的等級不僅取決於時脈頻率，還要考慮：  
- 周邊整合度（是否內建 LCD、Ethernet、USB OTG 等）  
- 記憶體架構（是否支援外部 SDRAM / QSPI Flash）  
- 是否具備 DSP/FPU/快取等加速單元  

因此，180 MHz 雖屬於中階較高規，但實際定位仍需綜合評估架構與應用需求。

---

#### 怎麼說 180 MHz 跑得動這些周邊與 RTOS，所以低於就跑不動嗎，低於就沒有意義嗎？

事實上，即使在更低主頻（例如 72 MHz 的 STM32F103），也能執行 RTOS 並驅動大部分周邊，只是系統負荷會比較緊繃。  

- **低頻率 MCU**：仍能完成任務，但在多工環境下，任務切換、周邊中斷與應用邏輯同時發生時，可能造成延遲或 jitter 增加。  
- **高頻率 MCU**：提供更大的效能裕度，能同時處理更多運算或更高資料流量的周邊，降低反應不及的風險。  

以 RTOS 為例，任務排程與 context switch 本身會消耗 CPU 資源。當主頻較低時，若再加上 LCD 更新、中斷服務、通訊協定處理，CPU 可能來不及在時限內完成所有工作。  

**結論**  
180 MHz 的價值在於「效能裕度」：  
不只是讓系統能運作，而是能在多周邊同時運行下，仍保持平順與穩定，並具備未來擴充的彈性。  

---

### 追問 2：怎麼知道 RAM 夠大，怎麼樣才算 RAM 夠大？

以專案需求來看，STM32F429 的 LCD 面板解析度為 240 × 320，若使用 **RGB565** 介面，每個像素需要 2 Bytes，  
因此 frame buffer 至少需要：  

```
240 × 320 × 2 = 153,600 Bytes ≈ 150 KB
```

F429 的主 SRAM 容量為 **192 KB**，扣除系統 stack、靜態變數與 FreeRTOS heap 後，仍能容納一個完整的 frame buffer。  

若未來需要 **雙 buffer**（例如用於畫面翻轉 / 避免撕裂），或應用需要更大容量，可以透過 **FMC 外掛 SDRAM**（例如 8 MB）來擴充，將顯示緩衝區與其他資料移到外部 RAM。

---

#### 如何評估 RAM 分配是否足夠應付變數、heap 與 stack 的需求？

RAM 是否足夠，通常會從幾個面向評估：  

1. **靜態變數大小**  
   編譯時編譯器會輸出一個 `.map` 檔，裡面會顯示 `.data` / `.bss` 段大小，可以直接檢查。  
   在本專案中：  
   - `.data = 0x0C (12B)`：存放「有初始值」的全域變數或 `static` 變數。  
   - `.bss = 0x41E8 (~16.9KB)`：存放「沒有初始值」的全域變數或 `static` 變數，其中包含 FreeRTOS `ucHeap = 16KB`（任務堆疊、TCB、queue、timer 皆自此分配）。  
   - `._user_heap_stack = 0x604 (1,540B)`：這是 linker script 中預留的最小 C-heap（512B）+ 最小 MSP 主堆疊（1KB）的占位符號，並非實際使用的空間。  

   整體靜態配置約 17KB 多，加上 linker 預留的 1.5KB 區域，報表上約為 18KB。  

2. **Stack（堆疊）**  
   Stack 存放「函式的區域變數」，在裸機程式中包含 `main` 與中斷 handler 的執行空間。  
   - 若不使用遞迴、也不建立過大的 local array，main stack 通常不需要很大。
   - Stack 由啟動碼配置在 RAM 的高位址，向下成長。
   - FreeRTOS 的各任務堆疊則來自 `ucHeap`，而非 main stack。  
   
3. **C 標準庫 heap（_sbrk / malloc）**  
   - Heap 由 `_end` 起始往高位址成長，僅在使用 `malloc` / `free` 等動態配置時才會消耗。  
   - 本專案並未使用 `malloc`，因此實際 C-heap 需求為 0。 

以此案的 **STM32F429** 為例：  
- 主 SRAM 總容量 192 KB，其中 150 KB 已分配給 LCD frame buffer。  
- 剩餘約 42 KB 可分配給 `.data` / `.bss` / stack。  
- 目前靜態區（含 FreeRTOS heap）約 17 KB，再加上 stack 的需求後仍有相當餘裕。  

**注意事項**  
若要在內部 SRAM 固定一塊 frame buffer，建議：  
- 在 linker script 中建立獨立 section 以存放 buffer，或  
- 設定 `__sbrk_heap_end` 上限，避免 C-heap 誤長進 frame buffer 區域。  

---

### 追問 3：RAM 是否需要安全裕度？如果真的發生 stack overflow 怎麼 debug？

**1. 為什麼需要安全裕度**  
- **程式不可預期性**：函式呼叫深度、區域變數大小、外部函式庫的行為，都可能隨程式修改而改變。  
- **中斷處理**：ISR（中斷服務常式）會額外使用 stack，若有巢狀中斷更難估計。  
- **RTOS 任務切換**：每個任務都有自己的 stack，需要預留空間避免多任務同時運行時溢出。  

通常建議 **至少預留 20%~30% RAM** 當作安全 buffer，避免在尖峰負載下發生 overflow。

**2. 如果真的發生 stack overflow，如何 debug？**

- **硬體檢查**  
  系統若常常隨機重啟或執行一段時間後當機，常見原因就是 stack overflow 或 heap 損壞，可以先從這裡排查。  

- **Linker/MPU 保護**  
  - **MPU 法（推薦）**：MPU (Memory Protection Unit) 是 MCU 裡的一個小硬體，可以設定記憶體區域是否可讀/寫/執行。把 stack 邊界設成「禁止存取」，一旦越界就會馬上觸發錯誤，方便定位。  
  - **未映射區法**：MCU 記憶體不是每個位址都有實體 RAM，有些範圍是「空的」。如果 CPU 嘗試讀/寫這些位址，會立即觸發 Fault。把 stack 放在記憶體邊界附近，超出時就會撞到這些「空區域」，馬上報錯。  

- **哨兵值檢查 (stack watermark)**  
  Stack 是連續記憶體，程式運行時會從高位往低位存資料。在初始化時，把整塊 stack 都填上特定數字（例如 0xA5），，之後檢查還有多少沒被覆蓋，就能推算實際使用過的深度。  
  FreeRTOS 提供 `uxTaskGetStackHighWaterMark()` 可直接查詢剩餘可用 stack。

- **使用除錯器**  
  透過 debugger（如 ST-Link）監看 stack pointer (SP)。當程式異常時，利用 call stack 追蹤，就能知道是哪個函式或任務把 stack 撐爆。

---



























NVIC(Nested Vectored Interrupt Controller)，它是 ARM Cortex-M 核心內建的中斷控制器，它的暫存器用來 控制中斷的啟用/禁用、設定優先權、觸發或清除掛起狀態，以及查詢中斷是否正在執行。
簡單來說，就是透過 NVIC 暫存器去「管理 IRQ」。





SYSCLK 可以來自：

HSI（內部高速振盪器，16 MHz）

HSE（外部晶振，例如 8 MHz）

PLL（相位鎖定環，倍頻後，像 180 MHz）

SYSCLK 再透過分頻器輸出給：

AHB (CPU, SRAM, DMA…)

APB1 / APB2 (USART, SPI, I2C, Timer…)























































# HackerRank

## C

1. 基本輸入輸出 & 運算
- (easy) Playing With Characters
- (easy) Sum and Difference of Two Numbers

2. 條件判斷 (Conditionals)
- (easy) Conditional Statements in C
- (easy) Boxes through a Tunnel

3. 迴圈 (Loops & Pattern Printing)
- (easy) For Loop in C
- (easy) Sum of Digits of a Five Digit Number
- (medium) Printing Pattern Using Loops

4. 陣列 (Arrays & 操作)
- (easy) Students Marks Sum
- (medium) 1D Arrays in C
- (medium) Array Reversal
- (medium) Digit Frequency

5. 運算子細節
- ++i vs i++ (前置/後置遞增)
- 實際寫 for 迴圈時觀察 i++ 與 ++i 的差異
- 運算子優先順序、結合律

6. 字串與字元處理 (Strings & Tokens)
- (medium) Printing Tokens
- (medium) Permutations of Strings
- 標準函式庫
- C 字串 vs 字元陣列
- (hard) Querying the Document

7. 函數與指標 (Functions & Pointers)
- (easy) Functions in C
- (easy) Pointers in C
- (medium) Variadic functions in C

8. 型別相關 (sizeof, typedef)
- sizeof(type)
- typedef

9. Bitwise Operators
- (easy) Bitwise Operators → 位元運算

10. 巨集 (Macro)
- #define 常數、巨集函數
- #ifdef / #ifndef 條件編譯

11. 儲存類別修飾詞 (static, const, volatile)
- static、const、volatile
- 特別注意 volatile，韌體工程必考，用於記憶體對映暫存器 (MMIO)

12. 記憶體配置與佈局 (Memory layout, merged)
- stack / heap / data / bss
- 全域 vs 區域變數
- static 在函數內外差異
- const/volatile 的使用場景
- 指標與位址的關聯

13. 動態陣列 / 記憶體管理
- (medium) Dynamic Array in C → 動態記憶體配置

14. 結構 struct
- (medium) Small Triangles, Large Triangles → 結構 (struct) + 排序/函數
- (hard) Structuring the Document

15. union / enum
- (hard) Post Transition
- union (常用於暫存器 mapping)
- enum (常用於狀態機、錯誤碼)

16. Sort (排序)
- (hard) Sorting Array of Strings
- 陣列排序（bubble sort, insertion sort, quicksort 等）
- qsort() (標準函式庫)
- struct 排序 (題庫 Small Triangles, Large Triangles 有涉及)

## Data Structures（必刷的部分）

- Arrays
- Strings
- Sorting
- Stacks
- Queues
- Linked List（至少要會基本操作）
- Bit Manipulation
- Trees（可挑基礎遍歷題，其他可跳過）

## Algorithm

- Strings（強化字串處理能力，和 parser、通訊協定解析有關）
- Sorting（進一步練習各種排序 & 複雜度分析）
- Search（binary search、子字串搜尋，跟韌體的資料查詢/比對很像）













