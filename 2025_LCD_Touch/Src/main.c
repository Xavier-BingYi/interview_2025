/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <mem_io.h>
#include <clock.h>
#include <gpio.h>
#include <rcc.h>
#include <usart.h>
#include <exti.h>
#include <ltdc.h>
#include <fmc.h>
#include <spi.h>
#include <timer.h>
#include <i2c.h>
#include <lcd_render.h>
#include <button.h>
#include <watchdog.h>
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
SemaphoreHandle_t semButton = NULL;
SemaphoreHandle_t semTouch  = NULL;


void delay_us(uint32_t us) {
    for (volatile uint32_t i = 0; i < us * 8 ; ++i) {
        __asm__("nop");
    }
}

/* 寫 AIRCR：把優先權分組設成 4 個 preempt bits（= PRIGROUP=3）
   注意：寫入 AIRCR 時一定要帶 VECTKEY=0x5FA，否則硬體會忽略 */
static void nvic_set_priority_grouping_4bits(void)
{
    const uint32_t SCB_AIRCR_ADDR   = 0xE000ED0CUL;
    const uint32_t VECTKEY_FIELD    = 0xFFFFUL << 16;
    const uint32_t PRIGROUP_FIELD   = 0x7UL    << 8;
    const uint32_t VECTKEY_WRITE    = 0x5FAUL  << 16;  // 必須帶入的 key
    const uint32_t PRIGROUP_4BITS   = 3UL      << 8;   // 等價 NVIC_PRIORITYGROUP_4

    io_writeMask(SCB_AIRCR_ADDR,
                 VECTKEY_WRITE | PRIGROUP_4BITS,
                 VECTKEY_FIELD | PRIGROUP_FIELD);
}

/* 把「人類看得懂的優先權數字 0..15」換成 NVIC 寄存器實際要寫的 8-bit 值
    MCU 有 4 個優先權位（configPRIO_BITS=4），所以左移 (8-4)=4 bits */
static inline NVIC_Priority NVIC_PRIO(uint32_t p /*0..15*/)
{
    return (NVIC_Priority)( (p & 0x0F) << 4 );
}

static void NVIC_ConfigForFreeRTOS(void)
{
    nvic_set_priority_grouping_4bits();

    /* 目前使用的 IRQ：EXTI0、EXTI15_10、TIM7
       凡是 ISR 會呼叫 FreeRTOS 的 ...FromISR()，preempt priority 要 >= 5 */
    nvic_set_priority(EXTI0_IRQn,     NVIC_PRIO(5));
    nvic_set_priority(EXTI15_10_IRQn, NVIC_PRIO(5));
    nvic_set_priority(TIM7_IRQn,      NVIC_PRIO(6));
}

static void vBeat1000(void *arg)
{
    (void)arg;
    for (;;)
    {
        usart_printf("[beat] tick=%lu\r\n", (unsigned long)xTaskGetTickCount());
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

/* 每 16ms 更新一次畫面 + 檢查觸控模式是否該結束 */
static void TaskUI(void *arg)
{
    (void)arg;
    TickType_t last = xTaskGetTickCount();

    for (;;)
    {
        /* === 原本 super-loop 的 timeout 區塊 === */
        if (touch_state) {  /* 1=觸控模式, 0=旋轉模式 */
            uint32_t now = micros_now(TIMER2);
            if ((int32_t)(now - touch_until_us) >= 0) {  // 到期了
                touch_state = 0;                         // 退出觸控模式
            }
        }

        if (!touch_state && lcd_rotate_tick) {
        	lcd_rotate_tick = 0;
            if (++lcd_rotation_state > 3) lcd_rotation_state = 0;
        }

        /* === 原本 super-loop 的 lcd_update() === */
        lcd_update();

        /* 16ms 一次，約 60 FPS；你也可改 33ms(30 FPS) */
        vTaskDelayUntil(&last, pdMS_TO_TICKS(16));
    }
}

static void TaskButton(void *arg)
{
    (void)arg;
    for (;;)
    {
        /* 由 EXTI0_IRQHandler 給 semaphore 後才會醒來 */
        xSemaphoreTake(semButton, portMAX_DELAY);  // EXTI0 → giveFromISR
        vTaskDelay(pdMS_TO_TICKS(30));             // 簡易去抖

        for (int i = 0; i < 3; ++i) {
            gpio_set_outdata(GPIOG_BASE, GPIO_PIN_14, 1);
            vTaskDelay(pdMS_TO_TICKS(100));
            gpio_set_outdata(GPIOG_BASE, GPIO_PIN_14, 0);
            vTaskDelay(pdMS_TO_TICKS(100));
        }

        /* 如果你想沿用原先的去抖 + 切紅燈邏輯，也可改成：
           button_handle_event();  // 你已有這個函式（含去抖與紅燈切換） */
    }
}

static void TaskTouch(void *arg)
{
    (void)arg;
    for (;;)
    {
    	/* 由 EXTI15_10_IRQHandler 給 semaphore 後才會醒來 */
	    xSemaphoreTake(semTouch, portMAX_DELAY);   // EXTI15 → giveFromISR

	    /* Delay 2ms to ensure the touch controller has written data into FIFO.
	       Without this, reading immediately after interrupt may return empty (239,319,0). */
	    vTaskDelay(pdMS_TO_TICKS(2));

        /* 把你原本 super-loop 裡 touch 的處理搬過來 */
        /* 進入觸控模式 2s、讀一次座標（你現有的流程） */
        if (touch_state == 0) {
            touch_handle_event();                  // 會設定 touch_state=1、touch_until_us += 2s 並讀座標
        }

        /* 清掉 FIFO / 釋放 reset、清中斷狀態（你原本 while(1) 的三步） */
        i2c_master_write(I2C3_BASE, SLAVE_ADDR7, FIFO_STA_ADDR, FIFO_RESET);
        i2c_master_write(I2C3_BASE, SLAVE_ADDR7, FIFO_STA_ADDR, 0x00);
        i2c_master_write(I2C3_BASE, SLAVE_ADDR7, INT_STA_ADDR, 0xFF);

        /* 讓出一下 CPU；是否等到 timeout 結束要不要輪詢看你需求
           最小實作：做完一次就回去等下一個中斷 */
        vTaskDelay(pdMS_TO_TICKS(1));
    }
}

static void vIwdgFeedTask(void *arg)
{
    (void)arg;
    TickType_t last = xTaskGetTickCount();

    for (;;)
    {
        iwdg_feed();  // feed watchdog
        vTaskDelayUntil(&last, pdMS_TO_TICKS(5000U)); // repeat every 5s
    }
}


int main(void)
{
    // --- system init ---
    system_clock_setup();
    NVIC_ConfigForFreeRTOS();
    timer_init();
    gpio_init();
    usart_init();
    spi_init();
    ili9341_init();
    ltdc_init();
    iwdg_init();

    /* --- RTOS 同步物件 --- */
    semButton = xSemaphoreCreateBinary();
    semTouch  = xSemaphoreCreateBinary();

    /* --- 中斷事件對應的任務（已經有函式本體）--- */
    xTaskCreate(TaskButton, "Button", 256, NULL, tskIDLE_PRIORITY + 2, NULL);
    xTaskCreate(TaskTouch,  "Touch",  512, NULL, tskIDLE_PRIORITY + 2, NULL);

    /* --- 畫面刷新任務 --- */
    xTaskCreate(TaskUI, "UI", 512, NULL, tskIDLE_PRIORITY + 1, NULL);

    /* --- 心跳任務（可留作觀察系統節拍）--- */
    xTaskCreate(vBeat1000, "Beat", 256, NULL, tskIDLE_PRIORITY + 1, NULL);

    /* --- feed the watchdog regularly --- */
    xTaskCreate(vIwdgFeedTask, "FeedIwdg", 128, NULL, tskIDLE_PRIORITY + 1, NULL);

    exti_init();
    i2c_init();
    i2c_touch_init();

    // debug print LTDC registers
    usart_printf("== LTDC core ==\r\n");
    usart_printf("GCR   = 0x%08X\r\n",  io_read(LTDC_BASE + 0x18));
    usart_printf("SSCR  = 0x%08X\r\n",  io_read(LTDC_BASE + 0x08));
    usart_printf("BPCR  = 0x%08X\r\n",  io_read(LTDC_BASE + 0x0C));
    usart_printf("AWCR  = 0x%08X\r\n",  io_read(LTDC_BASE + 0x10));
    usart_printf("TWCR  = 0x%08X\r\n",  io_read(LTDC_BASE + 0x14));
    usart_printf("BCCR  = 0x%08X\r\n",  io_read(LTDC_BASE + 0x2C));
    usart_printf("SRCR  = 0x%08X\r\n",  io_read(LTDC_BASE + 0x24));

    usart_printf("== Layer1 ==\r\n");
    usart_printf("L1CR   = 0x%08X\r\n",   io_read(LTDC_BASE + 0x84));
    usart_printf("L1WHPCR= 0x%08X\r\n",   io_read(LTDC_BASE + 0x88));
    usart_printf("L1WVPCR= 0x%08X\r\n",   io_read(LTDC_BASE + 0x8C));
    usart_printf("L1PFCR = 0x%08X\r\n",   io_read(LTDC_BASE + 0x94));
    usart_printf("L1CACR = 0x%08X\r\n",   io_read(LTDC_BASE + 0x98));
    usart_printf("L1CFBAR= 0x%08X\r\n",   io_read(LTDC_BASE + 0xAC));
    usart_printf("L1CFBLR= 0x%08X\r\n",   io_read(LTDC_BASE + 0xB0));
    usart_printf("L1CFBLNR= 0x%08X\r\n",  io_read(LTDC_BASE + 0xB4));

    // initial rainbow bars
    bsp_lcd_fill_rect(0xEE82EE, 0, 240, 46*0, 46); // Violet
    bsp_lcd_fill_rect(0x4B0082, 0, 240, 46*1, 46); // Indigo
    bsp_lcd_fill_rect(0x0000FF, 0, 240, 46*2, 46); // Blue
    bsp_lcd_fill_rect(0x008000, 0, 240, 46*3, 46); // Green
    bsp_lcd_fill_rect(0xFFFF00, 0, 240, 46*4, 46); // Yellow
    bsp_lcd_fill_rect(0xFFA500, 0, 240, 46*5, 46); // Orange
    bsp_lcd_fill_rect(0xFF0000, 0, 240, 46*6, 44); // Red




    /* 最後啟動排程器 */
    vTaskStartScheduler();

	#if 0
    while (1) {
        if (button_event_pending) {                    // flag set by EXTI ISR
            button_event_pending = 0;                  // clear button flag
            button_handle_event();                     // process button press
        }

        if (touch_event_pending) {
            touch_event_pending = 0;                   // clear touch flag
            if (touch_state == 0) {
            	touch_handle_event();}                      // process touch event
            i2c_master_write(I2C3_BASE, SLAVE_ADDR7, FIFO_STA_ADDR, FIFO_RESET);
            i2c_master_write(I2C3_BASE, SLAVE_ADDR7, FIFO_STA_ADDR, 0x00);  // release reset
            i2c_master_write(I2C3_BASE, SLAVE_ADDR7, INT_STA_ADDR, 0xFF);   // clear touch INT
        }

        if (touch_state) {
            uint32_t now = micros_now(TIMER2);
            if ((int32_t)(now - touch_until_us) >= 0) { // check if timeout reached
                touch_state = 0;                        // exit touch mode
            }
        }

        lcd_update();                                  // update LCD display

    }
	#endif
}
