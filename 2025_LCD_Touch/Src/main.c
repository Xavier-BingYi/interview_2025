/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <mem_io.h>
#include <clock.h>
#include <gpio.h>
#include <rcc.h>
#include <usart.h>
#include <exti.h>
#include <ltdc.h>
#include <fmc.h>
#include <spi.h>

void delay_us(uint32_t us) {
    for (volatile uint32_t i = 0; i < us * 8 ; ++i) {
        __asm__("nop");
    }
}


int main(void)
{
	system_clock_setup();
	gpio_init();
	usart_init();
	spi_init();
	ili9341_init();
	ltdc_init();
	exti_init();

	usart_printf("== LTDC core ==\r\n");
	usart_printf("GCR   = 0x%08X\r\n",  io_read(LTDC_BASE + 0x18));
	usart_printf("SSCR  = 0x%08X\r\n",  io_read(LTDC_BASE + 0x08));
	usart_printf("BPCR  = 0x%08X\r\n",  io_read(LTDC_BASE + 0x0C));
	usart_printf("AWCR  = 0x%08X\r\n",  io_read(LTDC_BASE + 0x10));
	usart_printf("TWCR  = 0x%08X\r\n",  io_read(LTDC_BASE + 0x14));
	usart_printf("BCCR  = 0x%08X\r\n",  io_read(LTDC_BASE + 0x2C));
	usart_printf("SRCR  = 0x%08X\r\n",  io_read(LTDC_BASE + 0x24));

	usart_printf("== Layer1 ==\r\n");
	usart_printf("L1CR   = 0x%08X\r\n",   io_read(LTDC_BASE + 0x84));
	usart_printf("L1WHPCR= 0x%08X\r\n",   io_read(LTDC_BASE + 0x88));
	usart_printf("L1WVPCR= 0x%08X\r\n",   io_read(LTDC_BASE + 0x8C));
	usart_printf("L1PFCR = 0x%08X\r\n",   io_read(LTDC_BASE + 0x94));
	usart_printf("L1CACR = 0x%08X\r\n",   io_read(LTDC_BASE + 0x98));
	usart_printf("L1CFBAR= 0x%08X\r\n",   io_read(LTDC_BASE + 0xAC));
	usart_printf("L1CFBLR= 0x%08X\r\n",   io_read(LTDC_BASE + 0xB0));
	usart_printf("L1CFBLNR= 0x%08X\r\n",  io_read(LTDC_BASE + 0xB4));

	bsp_lcd_fill_rect(0xEE82EE, 0, 240, 46*0, 46); // Violet
	bsp_lcd_fill_rect(0x4B0082, 0, 240, 46*1, 46); // Indigo
	bsp_lcd_fill_rect(0x0000FF, 0, 240, 46*2, 46); // Blue
	bsp_lcd_fill_rect(0x008000, 0, 240, 46*3, 46); // Green
	bsp_lcd_fill_rect(0xFFFF00, 0, 240, 46*4, 46); // Yellow
	bsp_lcd_fill_rect(0xFFA500, 0, 240, 46*5, 46); // Orange
	bsp_lcd_fill_rect(0xFF0000, 0, 240, 46*6, 44); // Red

	usart_print(USART1_BASE, "USART\r\n");
	usart_write(USART1_BASE, 't');
	usart_write(USART1_BASE, 'e');
	usart_write(USART1_BASE, 'x');
	usart_write(USART1_BASE, 't');
	usart_write(USART1_BASE, '\r');
	usart_write(USART1_BASE, '\n');

	gpio_set_outdata(GPIOG_BASE, GPIO_PIN_13, 1);
	gpio_set_outdata(GPIOG_BASE, GPIO_PIN_14, 1);

	uint8_t lcd_change_color = 0;
	uint32_t led_blink_state = 0;
    while (1) {


    	if (lcd_button_state) {
    		lcd_button_state = 0;
        	switch (lcd_change_color) {
        		case 0: fill_framebuffer_rgb888(0x000000); break;
        		case 1: fill_framebuffer_rgb888(0x0000FF); break;
        		case 2: fill_framebuffer_rgb888(0x00FF00); break;
        		case 3: fill_framebuffer_rgb888(0xFF0000); break;
        		case 4: fill_framebuffer_rgb888(0xFFFFFF); break;
        	}
        	lcd_change_color = (lcd_change_color + 1) % 5;
    	}


    	if (led_blink_state < 400000) {
    		gpio_set_outdata(GPIOG_BASE, GPIO_PIN_13, 0);
    	}else if (led_blink_state >= 400000) {
    		gpio_set_outdata(GPIOG_BASE, GPIO_PIN_13, 1);
    	}

		if (led_blink_state == 799999) {
			led_blink_state = 0;
		} else {
	    	led_blink_state++;
		}
    	delay_us(1);
    }
}
