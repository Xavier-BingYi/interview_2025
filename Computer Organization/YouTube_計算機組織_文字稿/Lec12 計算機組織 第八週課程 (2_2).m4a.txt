undefined
我們上一次跟同學介紹到這個control的部分我們這邊上一次也看過了我們再review一次就是說我們知道說我們這個LU的這四個control1234實際上對應真正的operation就是no還有加減set就是set less than還有一個nor大概就是這幾個operation我們等一下我們就是要來看說我們要如何產生這四個 ALU 的 control signal還有還有什麼呢還有我們前面的這一些我們是 memory to register,

memory write, memory read我們等一下就是要來看說如何產生這一些的這個 control signal在我們來看一下這個這個 control 的部分如何設計之前我們先來看一下這個 table這個 table 呢它基本上做了一個簡單的分類就是我們这边load、stored还有这个veq然后还有这个rtype这个rtype的话我們上一次有提到过说这个rtype基本上我们从OP从OP没有办法分辨出说这个rtype是要做加减no或者是setless length这些operation我们必须要再透过这个functional field这个栏位至于load跟stored跟veq这三个指令的话

它只需要OP就可以知道说到底是哪一个它根据OP就可以知道说它是load或者是store或者是veq所以在产生跟它相关的control signal的时候其实它并不需要这些function field它已经很清楚就只需要OP它就知道说是哪一个指令如果它知道它是load它就知道它要做addstore的话它也知道它要做add如果是beq的话它

就知道它要做减所以在这个table里面同学要了解的就是这一条线的这个上面就是这一条线上面的只要透过OP就可以这个rtype的话它还必须要再搭配functional field就是这几个information它才能够正确的知道它到底LU到底要做哪一个operation所以在我们的control呢我们就主要就是两个部分一个是我们前面看到的那些individual的control signal控制multipressor控制register控制memory第二个是控制LU在这个部分呢同学就要很清楚的知道说这个

的差异因为这个跟我们等一下设计的方法是有关系的在谈到detail的设计之前首先我们先做一个假设这个假设其实我们等一下也就实际上就可以realize这个假设是说同学可以发现说我們这边多了一个LUOP多了一个LUOP前面没有这个东西前面没有这个LUOP这个两个bit的这个control signal这

是我们多出来的那为什么这里需要一个LUOP呢因为同学可以看到在我们这个简单的设计里面呢我们现在假设我们就是考虑了这四个instructionLow,Store,V,E,Q,I,L, R type那所以我们要分别这四个不同的这个type我们只需要两个bit来分辨那我们在这边我们就是用 ALUOP 来分辨说到底这个指令是 load 还是 store 还是 beq

还是 type它用做这个功能00的时候我们就知道说它是 load00的时候它也是 store它为什么这个 load 跟 store 这边都是用 00因为同学可以发现说 ALU 的 function对 load 跟 store 都是什么呢都是加都是同样的它并没有什么不一样它并不是说load跟store一个做加一个做减两个都对LU而言对LU而言它看到load跟

看到store都是一样所以对它的这个encode的方式是用同样的就全部都是0 0那BEQ的话它就是0101的话它就知道说它是要做一个减如果是Rtype的话它就是10那10是什么意思呢E0就是表示说它还不知道它要做什么样种类的运算所以你只要看到A-L-U-O-P是E0就表示

它还不知道A-L-U到底要做什么样的一个运算它必须还要搭配什么呢还要搭配这个functional field再来判断它才知道说它这是做A的这substraction然后N-O-C-S-T-A-M就是这样子所以我们就是多加了这个A-L-U-O-P這樣子的話他說這個LUOP它可以從OP code把它衍生出來我們直接去看這個OP code就可以

決定說LOP到底是它的值到底是00還是01還是10這個當然沒有問題因為我們從OP code就可以知道說它到底是load還是store還是veq還是rtype所以我們當然就可以直接從OP code直接從來決定說LUOP的值到底是这三个里面的哪一个所以这个是第一个接着我们再分析一下就是我们的这几个指令它的instruction不同的栏位它到底代表了什么意思这个同学其实都已经知道但是我们只是在做一个review而已加强等一下

同学follow up的速度我们可以看一下就是说第一个是OP这个feel这没有问题第二个呢这个是R这是RS那RS呢它always specify什么呢不管是R type load store或者是branch它都需要一个input source是从哪边来从那个register过来对不对它都需要一个所以这个RS呢这个always read它就是都是从register这边读一个

子出来这个子它就是直接送到ALU的第一个input source第二个input source它就有两个不同的来源一个是什么呢一个是从register过来另外一个就是从instruction的constant所以它是有两个不同的来源所以我们这边第二个这个RT它说它也是read除了什么呢除了这个loadload的这个field它是做什么用load的field

它是做什么用它其实是做它是做这个specify write destination它是做这个就是你要写到哪一个register从记忆体里面读一笔资料出来那你要把它load到register的什么地方去所以對 load 而言它實際上這個是指到說你的 write destination就是到哪一個 register 就是這樣子這個我們就知道了 這個就是它的 offset這個是 memory 的 offset然後這個是 instruction 它的一個 offset所以這個是它不同的 field所以我們這邊可以看到說這邊說 write for rtype rtype 是指這一個

它是指write你要写到哪一个register如果是load的话，它是存在这个地方就是这样子另外这边它需要做sign extension它也需要，如果是算，就是说它还要再做一个shift left by 2 bit这样子的一个operation主要是在这边constant所以我们从这个instruction这个format我们再review一下这个资讯大概就是这样子接下来我们就要来看一下说

这个整个datapath再加上control它的一个structure这个结构跟我们前面看到的基本上是一样的差别就是多了一个黑盒子多了这个control这个control同学我们就可以来看一下说它有这么多个output它的input当然就是读它的OP同学可以发现这个control unit它的input就是instruction 31到26这个就是它的OP这一段就是它的OPinstruction的OP当作control unit的input同学还可以看到这边还有一个ALU control关于control的字眼它有两个我们在这边就先

跟同学说明一下它的设计的观念它是一个Two-level的一个control它为什么是一个Two-level的一个control呢它的重点就是在这个地方我们这边已经跟同学很清楚地描述了一件事实就是什么呢？根据我们这边的分析，我们发现这三个instruction，它完全不需要function field，它就可以完全决定它到底要做什么样的事情，它完全

不需要function field所以对它而言，它的input只需要什么，只需要OP，但是对R-type而言，你如果只有给OP的话，它没有办法决定它所有的control signal，它没有办法，所以如果是R-type的话，它还需要搭配这个function field所以如果我们把所有的这个control signal，就是刚刚那些什么Memory to register那些Multiplexer Memory register的control再加上LU的control再加上这四个，这

四个output全部都把它当作一个circuit的话，那它的input就必须包含什么，它的input这个combinational circuit的input就必须包含OP再加上function field，它必须要包含这么多个input可是实际上它并不需要这么多个对它而言，它只需要OP所以我们就把它分成两个LabelFirst Label的Control Unit，它的Input只有OPFirst Label的Control Unit它的Input只有OP这个OP它就可以决定了决定了那些Multiplier还有Memory还有Register的那些Write Enable那一类的Control Signal它的值

就全部都可以由NAS来决定而且它也决定了LU OP这个我们新定义的两个bit的这个control这两个bit的control是第一个level的control unit的output第一个level的control unit的output这一个第一个level的control unit的output也就是第二个level的control unit的input也是它的input所以我们就把这个第一个level first level control unit output把它拿来当作

second level control unit的这个第一个level的output当作第二个level的input那第二个level其实它要产生什么呢它要产生的就是这一些它只需要产生这一个所以我们在这里就很清楚地把它分成first level它的output就是产生了这个东西再加上multi-pressure还有register,memory,write, read相关的control signal那second level呢它就产生了控制ALU的这个operation所以我们用这样子two level的一个designphilosophy呢我们就可以

简化我们可以简化整个这个control circuit它的复杂度就第一个level它的input不需要再把functional field加进去它完完全全就简单的一个OP当input就可以第二個Level由 ALU-OP當Input再加上FunctionField然後來決定這一些Operation就是這樣子所以這就是我們的所謂的Two-Level Control Unit的一個Design Philosophy基本上就是這樣子而來的所以我們在這裡這個Structure很明顯看到第一個Level它的Input就是一個OPInput進來之後它會產生RegisterRight

来决定说这个instruction要不要写资料写到register然后来决定什么ALU sourceALU source是这一个ALU source它决定说它的ALU的second input source到底是来自于register还是来自于这个instruction的const ant它的constant是从这边过来所以这个是ALU source这个是memory write这个指令要不要写资料写到memory然后它也产生了LUOP。如果是Low Store的话

这两个值就是00如果是10就表示是BEQ如果01是BEQ10的话就是RType另外还有一个Memory to Register它这个就要来决定说到底你这个写回Register的这个值它的InputWriteData就是你要写到Register里面的这个Data到底是来自于Memory还是来自于 ALU 计算的结果。如果是 ALU 计算的结果我们知道说这个就是 R-type它是算完之后就把它写回 register。如果是从 memory

读出来然后写回 register这很明显就是什么呢就是所谓的 load就是 load 把它写回去。所以你如果是 load我们就知道说我们要把这个值设为多少设为 1。如果是 R-type 我们就要把這個值設為零基本上就是透過這樣子來控制那MemoryRead一樣我需不需要讀Memory。那你要讀Memory基本上就是只有做什麼呢就是做RAW的時候你才要讀你不做RAW的話你基本上你就不需要做一個Read的一個動作。還有如果你的指令是VEQ的話這個Branch就會設為1那你如果不是Branch

它这个就设为0设为0的话不管你这边的值是多少这个OS是0OS是0它就会走这条路这条路基本上它就是一个Sequential Execution就是PC加4还有另外一个Register的Destination这个是控制什么呢就是控制我们要写到Register的Destination到底是从哪边过来那如果说它是从这个15到11的话呢这很明

显是什么呢是Rtype对不对最右边的那一个最右边的最右边的这个RD最右边的这个这个Specify Register Destination Number所以这个就是Rtype那你如果说是从这边过来的话呢从这边过来specify这是什么这是load所以你如果是load的话你这个register reg dst你就要设成0你如果是rtype的话你这个就要设为1它才会选这个它才会选这个input到这边过来所以控制control基本上它是一个很琐碎的事情但是它没有什么复杂的观念

它就是我们把这些0101该有multipleaser的加multipleaser该有控制read write你加控制read write之后你的control signal就是根据你这个指令在这里是要放哪一条路过去你就input selection就设定那个指令就放那一条路让它走所以我们的control的design基本上就是这么简单到這裡同學有沒有問題因為後面大概其實沒有什麼重要的觀念

OP是最左邊這個最右邊這個因為一開始就是說我們在這邊First Label我們最主要的是要產生控制這個RegisterMemory, Rewrite, Enable還有Multipleaser它的Input Selection那我们要知道multipleaser还有这个memory跟register的rewrite enable实际上我们只需要知道说它到底是load store或者是veq或者是rtype我们只

需要知道这样子那这样子我们只需要op判断就够了不需要function那另外一个呢另外它的一个功用就是说它还要产生luop这是我们新定义的两个这个你可以把它当成是一个intermediate的一个control signal所以它是first label的output这个实际上它就是second label用来决定LU control它的这个input所以它的定义基本上就是在我们这边看到的就是load跟store它是属于同一类的所以是属于00那veq的话它是01它是减那rtype 10它没办法决定它还要再搭配

所以这一边我们要决定它到底是这几种的哪一个这个是在second level决定的是在second level决定那它决定它由什么来决定呢它就是由这一个这个来决定再加上这一个它由这一个可以决定这三个它透过LUOP可以决定这三个如果是E0的话再搭配function就可以决定这几个这个就是我们的two level

的一个精神就是在这个地方还有没有要讨论的同学如果这边懂了其实回去复习就很快了所以有问题一定要不要留到回家自己慢慢想有问题就问我们就choose几个这边有一个R-type instruction根据我们刚刚的这个structure我们来看一下这边课本它的这个图它很贴心的就把跟这个R-type instruction相关的这个signal还有它会用到的这个functional unit全部都把它highlight出来所以同学可以看到这些就是比较看不清楚的这个不是没印好这不是没印好

表示說在 Rtype 裡面實際上它是沒有用的它不會用到當然就 hardware 而言它還是會運作只是說它的資訊對我們也並沒有用所以我們說 Rtype我們說這個 control 呢同學可以看到我們從左往右看好了我們說它的 right destination 是哪一條呢這邊有兩條 input它是 highlight 下面這一條highlight下面這一條所以這個就是R-

type destination是透過它直接就是由11到15就是這幾個bitspecify它的destination所以我們的REG destination要設為多少我們直接把它寫出來好了這要設為多少設為1接著我們來看我們就從這邊由上往下看好了所以这个是reg destination这个branch当然是0因为它不是branch那memory read它需不需要读memory它不需要那memory to register这个是指到这边这边指的就是指你要写回register到底是要由哪一个指传回去写呢它当然是由这一个

ALU算完RTYPE就是ALU算完的寫回去所以這個是多少這個就是0ALUOP根據我們剛剛的定義它是E0所以它會我們從OP我們就知道說它是RTYPE所以我們就會把它產生ALUOP產生E0這是我們定義的Memory Write不需要所以這個也是0ALU Source是多少呢我們知道說 ALU Source它兩個 Source 都是從 Register所以是 Highlight 上面這一條所以，它是要設為 0就是這樣，那 RUG Write

要不要當然要我們 ALU 算完的結果要寫回去，所以這邊要 Write就是這樣子，所以這個就是我們 R Type它的 Control Signal就是這樣子，所以透過這樣子的一個 Trace 呢同學其實就可以把每一个指令，它所相对应的这几个control signal应该指示要多少同学都可以把它写出来。我们再来看一个load-load说，我们这边reg destination我们知

道说，它是透过这一条，所以它的这个要设为0这个branch也是0然后memory read这个是1那memoryToRegister它是从记忆体这边过来的所以这个要设为1上面这一条是1LuOp Load它是0 0如果记错的话，同学要提醒一下。如果是MemoryWrite，它不需要MemoryWrite，所以它是0LuSource Load它是要算它的Memory的Address所以它第一个Input是从这边过来第二个Input是从instruction这边过来的所以这边要设为1它才会选择这一条所以这个要设为1register write这个也是1它必须要写回register它要load的一个值，所以我们透过这样子，我们又把这个load它的control unit如果是load的话它这个first table它的control unit它的output的值就是要写成这个样子

你說哪一個這個reg destination因為就是說這個是指說這個就是指說我要寫到register裡面的哪一個register它要寫到哪一個register比如說我要寫到12還是14 15它的destination如果說是Rtype的話呢如果是Rtype它的destination是擺在這個地方所以是11到15如果是Load的話呢它destination是擺在這個地方所以是16到20它的來源是不一樣的所以我們可以看到我們這邊這個Load它是16到20這個是Load它的就是說因為它的

instruction type不一樣所以它的destination是擺在不一樣的位置所以我們這邊才需要設為0就只是因為它的destination放的位置不一樣所以這個是load同學還有沒有問題同學可以看這邊它都把它disable掉了它不需要然後這些都不需要 它都把它disable掉就是這樣子最後我們再來看一個VEQ branch這個branch我們知道說它要做的是什麼呢這個LU它要做一個comparisoncomparison就是做減的，另外它要去算它的target address，所以同學可以看到說第一個，我們這邊

需不需要REG destination，它不需要，它没有要做寫資料寫到register这个动作，它只是比較比完就跳就決定要不要跳是这样，所以这个它是什么Don't care反正你01对它而言都一样没有意义这是Don't care，你设点设1都无所谓这是Don't care，Branch呢，所以这个是Branch，它是1Memory Read，Memory Read实际上它也没有要ReadMemory to Register，它有没有要选资料

写回去呢，也没有，所以你01对它也都不重要，所以这个也是Don't Care，这也是Don't Care，Branch呢，它的LEOP是多少，是01，LEOP是01，接著這個就重要了，Memory Write，這個當然是一定要設為0，這一定要設為0，你不能說我don't care，你如果don't care的話，那就慘了，你don't care，這个值是什麼，你都不知道萬一是1的話，它搞不好就寫進去，所以這種不能寫的，你就一定要

把它就是要把它disable掉設為0，这個 ALU source，我们知道說它是两个register值的comparison，所以它是走这一条，所以我们要设为0因为这一条是用0来选这个register right当然也是一样就要把它disable掉所以我们这个也要设为0那你这边设为0以后你不管它的这个right data指是多少你的Multipleaser的Input Selection是多少對它也都不重要因為它就是不會Write所以這個就是我們的

Branch它的產生First Label它產生出來的這個Control Signal的這個指所以Store的話同學會想自己回去可以就是一樣化糊爐去看一下產生一下這個指看到底這樣對不對到这边同学有没有问题好 那我们就继续再往下看这个jump呢jump它的instruction就比较简单它就是只有一个op再加上这个26bit的这个address所以我们知道说这个jump我们都知道它是word address因为它最后两个byte

都是0所以因為它是Word的line都是0所以我們就把它省略下來是Word所以同學記得第一個要做Sine Extension要把它轉成26轉成32 bit接著還要再做一個Shift Left by 2 bit做這樣子這樣子做完以後最後如果OP偵測說它就是Jump其實它就是直接就是直接跳過去了它後面根本都不需要做任何的operation這個是jump所以我們來看這邊jump這邊它不是做sine extension抱歉

剛講太快了它是先做一個shift left by 2 bit先把右邊填兩個0先往左邊shift兩個bit右邊填兩個0接著再做整合的一個動作這個整合的動作就是我們這邊看到的就是說它的Jump這邊就是0到25總共26個bitShift Left 2 bit所以你這邊就變成多少呢28個bit這邊就變成28個bit28個bit跟32個bit還缺4個bit我們之前已經知道在第二章的時候我們已經知道說它缺的這4個bit是從哪邊補過來的

就是從这个PC加4最左边那4个bitMSB最左边那4个bit拿过来跟它这边28个bit把它合在一起就是PC加4的MSB左边4个bit拿过来跟这边的28个bit兜在一起这样就变成32个bit所以兜起来之后这边就是变成新的32个bit它就是直接又多了一层Multiplexer所以如果要考虑JUMP的话我们的这一边就是

Next Instruction它的控制的部分又多了一个Multipressor之前没有这一个同学应该还记得之前是长这个样子之前就是这个是PC加4这个是BranchPC加4跟Branch两个二选一现在就是这边这个是PC加 4branch2選1的結果、2選1的結果2選1的結果再跟jump再做一個2選1就是這樣子，所以如果是jump的話，我們在這裡面又會多一個jump這個jump會設為1設為1的話，它就是走這一條這個就是jump的 address，它就是jump的 address就直接從這邊過來其他這邊它都用不到

它都不會用所以就是被disable掉了，所以這個就是jump。接著我們就要來開始看我們剛剛只是透過一個簡單的觀念然後我們就把這些子都把它derive出來同學可以再回去check一下這個應該就是我們剛刚寫出來的這個子如果不一樣的話應該寫錯應該是沒有寫錯我剛剛也看得還蠻清楚的應該是

沒有寫錯，所以這個值就是我們照剛剛的順序寫出來說。如果它是load的話，它的每一個input selectionwrite enable disable它的值應該是多少就是透過那樣子的一個流程把這些值都寫出來這個就是我們第一個得到的一個table。这个Table其实是我们初步的一个结果而已，我们现在要看的是说我们的那个黑盒子到底

要怎么去设计谈到黑盒子要怎么设计，同学第一个想到的就是说我们是不是要用以前在Logic Design学到的Color Map我们要有这个Input然后要一个Choose Table然后，Choose Table我们就开始画圈圈。你可以画两个、 画四个或者是画八个。但是问题是，当你的变数如果不是只有4个，那么你的变数如果说有8个10个，它的

长相就有一点像这个有一点像什么东西呢。可能会像有一部电影叫Contact，英文叫Contact，中文好像是叫接触未来同学还记得那部电影吗？他们不是在解码对不对，在解码的过程里面，它完全解不出外星生物的讯息到底是代表什么意义到最后是一个在太空一个垂死的有钱人在太空船里面，他用一种反正就异常人，因为反正他们在太空转来转去不是我们一般的这种2D 3D的这种viewpoint，所以他这样转来转去合在一起，他就可以

看出这个information真正这个encode在里面的意义。如果你要用color map你的variable数目多的话，你可能必须要具备那种能力必须要转来转去你才有办法选出一个最大的cube然后得到一个最小literal的control signal。所以，在这边我们不用那些方法，我们用一些简单的判断我们想办法来得到一个简单的一个control unit。首先我们

要先把input跟output定出来，那input我们知道说first label的input当然就是OP code，OP code，这边它告诉我们，就是6个bit那output就是我们刚列出来的这些control signal再加上LUOP的那两个bit这就是我们的output所以根据我们前面说比如说rtypertype它的OP就是長這個樣子它的output就是這個row這個table我們只是把這

個row轉成column就這樣子而已沒有什麼特別的同學可以看到它就是把這個row把它轉成90度轉成column所以這個代表的就是這個column然後這個column就是代表什麼呢load它的outputLoad的output這個column它是怎麼來就是我們剛剛用剛剛的方式把它derive出來的它就長這個樣子Store就是它的output然後Veq就把這個轉過來就變成這個column所以這個都是可以查表查出來的它的OP就是長這個樣子所以重點來了我們要如何從這一個

我们暂且把它也叫做choose table我们要如何从choose table我们要把它derive出每一个output比如说reg, dstregister, destination它到底是要等于什么东西，我们就来看我们这个table就是前一页的table其实这个很简单，同学可以看根本不需要什么color map，因为RGDST等于1的情况是什么呢，就是这个嘛，对不对？ RGDST它要1 2 3

4 4个，就这个case是等于1那它等于1是什么呢做一个NOR对不对？做一個NOR就是OP5吧，OP4吧，OP3吧，OP2吧 应該說OP5吧，一直到OP0吧做一個AND就是這一個就是OP0到OP5它每一個都是取吧做一個AND然後它的OPEN就是REGDST就这么简单，它一点都不复杂，就这么简单那第一个同学知道了，那我相信后面同学就会想要自己来了，因为它的方法就是这么简单这个ALU source根据刚刚的方法我们就取这两个就好了，就是把这两个就是这一个end起来，

这一个AND起来两个AND的结果做一个OR对不对？就是LUSource，它会等于1，它会等于1的情况就是OP0跟OP1跟OP2跟OP3跟OP4跟OP5这六个讯号做一个AND所以在哪里呢，我们可以看到OP0 OP1 OP2bar、OP3bar、OP4bar再加一個OP5所以這一個其實就是這一個然後這一個就是這一個這一個我們可以來看就是說這個是OP0、OP1、OP2bar、

OP3这是OP3OP4BOP5所以这个AND在哪里呢，这个AND在这里，所以我们可以看到说它把这一个跟这一个两个做一个OR这边跟这边做一个OR就会得到LUSource就是这个LUSource就是这两个后面的方法都一样Memory to register就是这一个所以这个直接拉出来就是Memory to register然后这两个做all就是Register write就是这一个跟这一个做all就是Register write这一个就是Memory read这一个直接拉出来就是Memory read这一个直接拉出来就是Memory write

这个直接拉出来就是memory write然后branch是这一个所以这个product就是在这个地方所以这个直接拉出来就是branch然后LuOp1就是这个拉出来直接就是Lop1这个Lop2就只有这个是1所以我们就把最后一项直接拉出来就是LuOp0就这么简单所以我們First Level的Control Unit我們不需要用到那些Colon Map在那邊看了老半天看不出來我們就直接用這樣簡單的方式就可以

把它推導出來所以這個是First Level同學如果First Level有問題的話就是要趕快把它弄清楚就是可以來討論一下因為等一下First Level 2雖然不是很複雜不過會比這個複雜一點用的觀念又有一點不太一樣我們休息一下我們再來看這個Sec ond Level的這個Control Unit我們這個新版的課本它把一些比較複雜的Control Design的部分把它省略掉在以前舊版它

實際上介紹了三個版本的CPU它有介紹一些Micro Programming方面的這個Control新版的這邊都把它拿掉所以就是剩下這個比較簡單的版本讓同學大概了解一下是說Control的部分大概是長什麼樣子那我們再來看這個Second LevelSecond Level基本上我們就是要來看一下先看一下第一個table第一個table我們知道說我們最主要其實就是要根據你的instruction type去產生跟它相對應的LU的control input那4個bit的control input所以我們這個table最主要就是來做

這樣子的一個描述如果是load的話同學可以看到它的L第一個label它的output就是00store的話是00那beq是01type是10在這個instruction它的operationload當然是loadword它LU要做的動作是加所以加它的那四個bit就是00、10A跟B的input都不需要做invert那它是它是選這個第三個第三個operation來當out put第一個是end第二個是all第三個是加跟減第四個是set list length所以它是選它這是選第三個那如果是store的話呢跟它一樣是0010那beq的話呢它的luo

op是01它是要做comparison所以它是做减如果是做减的话这边就是要01而不是00就是b要取bar等于要a加b的toothcomplement要加b的toothcomplement所以这边bbar要把它设为1rtype的话就是看你到底是做加你的指令是a的它就做加那你的指令是subtract你就做-那你如果指令是end它就做end,

boolean end那如果是all它就做boolean all或者是set as then就做set as then它就是這樣那差別在load跟store跟這個branch unequal它都不需要depend on function field但是rtype的話呢就是因為它的LUOP全部都是E0E0它還必須要透過function field才能分辨這五種就是這五種第一種加的值就是在這裡減的值就是長這個樣子所以這是我們第一個得

到的一個table首先我們還是一樣必須要把我們的table要怎麼樣呢要把它分出哪一些是input哪一些是output我們才能夠開始來derive每一個outputsignal它的function boolean function所以下面这个table就是我们根据上面的这个table稍微改写一下其实就是什么呢同学可以看到LUOP是second level的inputfunction field也是second level的input所以这边就是我们second levelcontrol unit的input它的input它的output是谁呢

它的output就是我們剛剛看到的這一個就是LU control signal LU control input那四個bit所以我們看到的就是這四個bit這四個bit就是output就我們而言它就是有四個signal比如說這是第0個這是第1個第2個第3個所以這是我們output當我們要这个output的时候我们要看的就是看这一个column我们就是要看这个column的值来决定说它的boolean function到底长什么样子那同理当我们要决定第二个output它的值的时候就要看第二个column所以这个就是我们稍微就是把不需要的information拿掉

然后把这个table把它保留下来同学可以看到说这一些是don't care,然后它已经把这两个合在一起了就是说第一个column第一个column它就是把load跟store把它合成一个因为长得都一模一样长得都一模一样0010 0010然后全部都是don't care全部都是00所以第一个column是00然后全部都是don't care第二个column是vEQ第

二个column是vEQ就是这个第二个row讲错了一直把row讲column第二个row呢第二个row就是这个vEQ这个vEQ呢基本上它是01它是01同学可以看到说它这边它不是写01它是写don't care 1为什么是don't care 1呢因为同学可以发现说这边是两个bit它有四种possibility00 01 10 11但是11在我们这边实际上是没有用的实际上没有我们有用的就是00 01 10就只有这三种情况

这三种情况呢这个branch它跟别人长得唯一不一样的地方是在哪里就是这一个它跟别人unique的地方就是这一个对不对我只要知道ALUOP0是1我就知道这个是vEQ我就知道它是vEQ所以这个就不需要了就don't care所以我们后面很多观念都是based on这样子的观念再做一个衍生再做进一步的简化所以

同学要记得，就是说我们在第二层级它在推演的过程最重要的观念就是我要找出我这个condition跟别人与众不同的地方，它的特点到底在什么地方就把那个特点抓出来这样子就可以。所以，我们在这里看到的这个，就是这边是don't care，它的原因就在这里同理我们的Rtype实际上它是E0为什么，它这边

都是写don't care原因是一样的我们就是Rtype跟别人唯一不同点的地方，就是它这个是E，所以它是E，所以我们就是说，它这边是E，其他的，我们这边就不用管了。接着，同学可以发现，这边原本是一 2 3 4 5 6六个bit，但是我可以发现，这边都是什么都是一顶，都是一顶，干嘛要放进来呢，就don't care，就不要

了，那个就不重要。你把这个一顶放进来，你没有办法改变什么事情，你没有办法根据这个一顶来决定什么做什么判断。你既然没有办法拿它来做判断，就把它设为don't care。重要的是，我们可以根据这个signal可以做一些有用的判断，这两个完全没有办法做什么判断，所以就不要了。同学会说，我这两个应该可以跟它做判断其实并不需要为什么呢，因为我00就可以知道是，它这边是一个1，就可以知道是，它根本不需要透过function field来判断Rtype跟

上面這三個的差異，所以我們這邊就是把這個全部都設為don't care 't care所以這個table就出來了就長這個樣子那到這邊同學有沒有問題我們在下一頁就是要based on這個table就是把second level的circuit它的booting function就直接把它推演出來我們也是不用color map你同學可以想想看這邊1 2 3 4 5 6 7 88個input看你怎麼畫你要寫成4去跑也是不容易這邊有沒有

問題我們繼續往下看這個table就是我們剛剛的table前一頁的table我們只是多加了C0 C1 C2 C3所以接著我們就開始來看我們先從C領開始好了我們從最右邊C領C領是這個column我們要決定C領呢同學應該都知道說我們以前我們以前最簡單的就是什麼呢我們就是說我們看看這個choose table它要哪幾個condition

這個相對應的output它的指示e我們就把那個e它所對應的那個product term全部都抓出來做一個or我們就可以得到這個output function它的output signal的什麼boolean function對不對就看看它哪一個是e就把它直接抓出來然後把它的product term做一個or就可以得到它的boolean function在這個地方我们也不用这样子的

方式来做因为你如果这样子做的话你可能会得到比较复杂的一个电路我们就来看说我们要如何做简化呢还是用刚刚的观念我们来看看这个1它有的就是这两个row第6个跟第7个row所以我们可以一个方法就是把这个当作一个product term把这个当作一个product term然后两个做all这样子出来

的结果是比较复杂我们希望得到一个比较简化的这个简化要怎么办呢我们就是希望说要从这两个肉里面找出有没有跟其他人不一样的地方有没有找出跟其他人不一样的地方比如说这一个肉好了这一个肉它有没有跟其他人有什么不一样的第一个它这边是1这边是1其实最主

要的就是说我这边是1所以它跟它就不一样就跟这两个不一样这个1就表示说它是这个row不是这两个row那它又怎么如何来跟这三个来区别呢所以我们要找出有没有某一个bit它的子跟其他的肉的子是不一样的有没有 這個都一樣這個也一樣這個也一樣這個跟它不一樣所以我就找出來了就這個bit是我要的這意思是什麼呢我要identify這個肉就吸引它的condition來看我就是把

ALUOP1設為1跟F0設為1其他什麼呢都是don't care其他都不重要其他的signal沒有辦法幫助你做判斷我只要這兩个bit就可以判斷說我只要F0是1跟ALUOP1是1我就可以確定它一定是第六個row就是這一個所以这样子有没有简化 有没有 有因为原本我的这个end它的input要几个1 2 3 4 5 6它要6个input那我现在这个end它的input剩下几个两个 F0跟ALU OP1它剩下两个input所以我们就把这个部分做了一个简化那同理

這一個肉 第七個肉我們也是要來做一個判斷就是這边一樣這边1表示它不是這兩個肉這边有没有长得跟别人特别不一样這个跟這幾個肉不一樣我們先把它劃出來這個跟它一樣這个跟它一樣這个也跟它一樣所以很明顯這三個是没有用的我没有辦法透過它来判斷我只要F3跟LUOP1兩個都是1我就可以確定它是第七個Row所以就是F3跟LUOP1就是这样子所以我们C0就推出來了

C0就很簡單F0 AND LUOP1我們來看F0這边它是把這个LUOP1抽出來LUOP1抽出來然後這边做一個OR就是F0跟F3做一個ORF3做一個OR再跟LUOP1做一個AND這個就是這個值就在這个地方

这边同学有没有问题C0C1 C2都是同样的方式接下来我们来看C1C1是第二个C1是第二个它是1的row是第一个row 第二个row第三个row 第四个row还有第七个肉就是还有第七个肉就是这样子所以我们同学可以看就是说我们要找出一二三四五这五个一二三四五这五个就是说这五个肉跟别人有什么不一样的地方其实在这个地方我们可以发现

這裡面基本上有兩個重要的差異第一個差異就是底下這個是Rtype那上面它是屬於RAW的STORE跟VEQRAW的STORE跟VEQ它的一個特點就是在我們可以看到的00 01這邊都是1所以實際上我們可以看到說假設這個是0它其实在这几种case里面它就已经区分出它是上面这两个row你只

要LUOP1是0它就是第一个row跟第二个row的condition绝对不会是3 4 5 6 7所以这两个row它都是1所以我们这一个第一个rowLUOP1它是0的话其他全部都是don't care它就已经cover了这两个row它就已经包含了这两个row那接下来这四个row三个row 1 2 3就是3 4 73 4 7接下来要怎

么看呢3 4 7我们就是要看说有没有什么样的一种情况是包含3 4 7在其他的row里面是找不到的有没有或者是3 4 7如果没有包含你必须要个别找比如说找row 3Row 4还有Row 7你就要个别去找很幸运的这三个Row有一个共通点同学可以看到3 4 7这三个Row它跟别人un

ique的点就是在F2它是0对不对F2是0我们就知道它一定是Row 3 Row 4跟Row7絕對不會是Row 5跟Row 6絕對不會是這兩個Row這邊是Don't care萬一是這兩個也無所謂因為這兩個它也是1所以這邊我們這個F2是0我們就可以identify一定是3 4 7這三個Row所以同學可以看到它的這個output又變得很簡單就是F2是0

其他全部都是don't care就是它長得跟別人不一樣的就是在这里就在这个地方所以这个就是C1那C2的话呢C2就是这个column这个column就是这个row是1这个row也是1它就是这三个row那这三个row是1的话呢我们就要来看说这个row veq很明显它跟别人unique它跟别人unique其实就是这个嘛对不对这个branch因为branch它根本不需要看那个function field它就是看luop这个那它跟别人unique就是这个是1所以它这个是1那它后面这些其他全部都是don't care

我們就可以identify它一定是Row 2第二個Row現在我們就要來看說4跟7有沒有長得跟別人是特別不一樣的你就是要去看看說0 1它自己也不一樣的跟别人就沒辦法分辨這個0 0這個也是0所以它也不行這個1 1其他都是0看起來像這個是可以這個0 0也不行其他也有人是0的所以這個也沒有辦法分辨它是Rho4跟Rho7所以就只有F1當它是1的時候我們就可以確定它是Rho4跟Rho7所以就是在這邊F1它確定它是Rho4跟Rho7C2呢

這裡面有一個重要的情況就是說C2因為它不包含Rho1所以這邊要注意的你要把Rho1跟這個4跟7要區分開來就是要確定LuOp1它是什麼呢它是1而不是0所以這邊這個1要保留下來所以這個1是在區分要確定它不是Rho1這個第一個Row然後這個F1它是在確保它是第四個跟第七個Row而不是3 5 6這三個Row所以F1是把4跟7跟3 5 6做一個分別然後LOP1是把4跟7跟1第一個Row做分別所以它的目的就是這樣子

所以Second Level的Design就結束了就是這樣很瑣碎只有一個觀念你要去找Unique它長得跟別人Unique就是這樣子的一個觀念中間搭配了一些小的技巧什麼技巧呢就是說比如說為什麼有時候這邊是Don't Care有時候這邊又要設E呢同學要注意為什麼有時候這裡要Don't Care有時候要設E它如果是Don't Care其实就

是表示什么呢它不需要去分辨1 2跟R type它不需要去分辨因为1 2它可能也都是1像这个case因为1第一个row它不是1它是 0所以你必须要分辨出它是第四个第七个row而不是第一个row你要分辨就是透过这个bit它是1而不是0所以这边就要写1就是這樣子搭配這種小技巧我們

就可以把這一個它的output function就把它specify出來這個出來之後後面的結果就很簡單這是C0這是C1這是C2C3呢這就不用講了因為C3全部都是0D4都是0所以我們就4個4個LU的control input這樣子就出來了同學這邊有沒有問題你說哪一邊上面還是下面你說這個嗎 這邊6個bit 123456 就是這些value你說這邊為什麼是 0000 0010這邊嘛

這個其實就是我們的instruction encoding就是我們每一個instruction不是這要看那個第二章第二章它不是有我記得它有一張很大的table它透過OP code可以決定它是load, store跟veq或者是rtype那你rtype你還要再透過function field的值才能夠決定說這一個值它就是a的這一個值它就是subtraction這個值它就是and所以這個都是它定義出來的你的意思是說你直接把這個function field把它做一個and

把它直接看它是這個bar這個是true這個是force直接做end嗎你的意思是這樣子嗎我的意思是如果一樣改變那個field如果一樣function如果做addh100就是如果改變end的function field如果改變的話我們的控制方法會改變比較簡單您是說如果說這個add的這個function field改變的話那當然這個就不一定有辦法用這樣子的方式去derive出這樣simplify的一個我覺得它會改變比較盡量因為如果我們這樣做

我知道你的意思你的意思是說把這些紙做一些跟動或許可以design出更簡單的可是因为我们现在看的就是只有看只有看这几个instruction说实际的话实际上它当初怎么去决定这个function field的值是多少如果决定这个我不知道如果决定这个function field这一种目前的function field的一种设定到底是不是最佳化对control

circuit或者是其他方面的issue是不是最佳化这个可能都是有待讨论的问题这方面我不是很清楚所以的确像你讲的你如果说只有看这几个case你应该有办法去做一个改变然后让我这一个control的部分更容易不用在那一边看说这个要怎么比对找一个unique没有错如果单纯就这个观点来看的话你应该有办法找到一个更简单的设定就直接很容易的输出它的output为什么他当初没有做这样子的一个考量这个我就不清楚了

因为它的指令还蛮多的或许就这几个指令比较容易如果把所有的指令全部都考虑进来或许没有那么容易同学还有没有问题这个问题其实很好因为是你design CPU里面的一些细节的设定其实它会影响到很多后续的问题

沒有 我們就繼續再往下看我們剛剛跟同學介紹的第一個版本的CPU我們知道說它是一個簡單的版本我們在前面也提到過說我們就是在一個clock cycle我們就會把這個指令把它執行完所以就這樣子的觀點來看的話我們的clock period它的cycle timen当然就是我们前面一再强调的就是它是由longest delay来决定它的critical pace那critical pace是哪一个指令呢我们如果分析每一个指令的话其实我们可以发现说这个critical pace应该是所谓的load instructionn为什么

会是load instruction呢我们来看比如说每一个指令它都要去instruction memory去做read那instruction除了譬如說像jump它不需要不然我們大概也都是要做register file的一個read接著LU你必須要做不同的operationLU做完之後有一些指令它必須要把結果write back to data map就是有的你必須要把這個register的值write到data memory有的是把 ALU 算出來的值 write back 到 register file只有這個 load 同學可以看說這個 load 它是 data memory

也要做register 也要做 ALU 也要做 register file 也要做這個也要做 它每個都要做所以它是最浪費時間的大家都做完了都没事了他好像还有事情还没做完因为他最勤劳他读指令然后他从register读资料ALU算记忆体的位置到data memory读了一个纸然后再把读回来的纸再写到register file所以他是最长的如果说你的指令你的program里面一大堆load那就赚到了因为大家都

幾乎都是用最長的時間去執行那你的load的指令如果不多那你就幾乎很多指令都要去等這個load所以這一種實際上並沒有是一個很好的一種設計的方式所以我們必須要improve我們的performance現有的所有的CPU都會有所謂的pipeline在pipelining這個同學應該大家都知道這樣子的一個觀念課本用了一個很有趣的例子它的例子來說明說這個popline的一個laundry它的效能有popline跟沒有popline的效果在這個地方我們是用就是說

有四份衣服要洗其實以前在念書的時候我們一個寢室都四個人一個寢室四個人應該衣服都是各洗各的我们假设说有一件寝室有分工合作这个礼拜就是你洗下个礼拜就这样轮四个礼拜轮一次所以每个礼拜他轮到他就洗四人份的衣服可能说就全部把它丢在一起然后洗一洗这位同学他就说他必须要分开洗先洗A的再洗B的再洗C的再洗D的就是这样子所以他做了什么事呢

他就先丟到洗衣機洗完再丟到這個烘衣機去把它烘乾那烘完了之後再把它拿出來再摺一摺摺完之後再把它擺到這個衣櫥裡面去所以我們可以看他好忙他每天就是從6點開始洗然後坐著坐四個人坐完糟糕 好像快睡覺了已經2點了所以它等于是吃完晚饭之后然后就开始做做做

然后就做到两点然后就睡觉所以等于说每一个人一个月里面有一个礼拜每天晚上都在洗衣服我们说我们要如何来improve这样子的performance我相信大部分的同学会说大部分的男同学会说应该不用三个吧应该不用四个三个就够了干嘛要折衣服呢这烘干的衣柜打开丢进去关起来 对不对这样子就好了这样直接省掉三个小时这个是一个方法那有没有比较快的方法呢，另外一个比较快的方法大概就是下面。它告诉我们说，你一定要

做pipeline。你如果不做pipeline的话，这个是什么？这个就是衣服，就丢进去就跑到交易厅去看电视，看看差不多一个小时到，就跑过去，然后再把衣服拿到這個烘衣機，又开始烘又跑去教育廳去那边等，所以它就是這樣子做到兩點。它如果说是用這樣子的一個方式，它就是這個洗衣机洗完以後第一個人丢到烘乾机，第二個人就把它丢到這個洗衣机所以你看在第二個時段第一個人的就在烘了然後第二個人就在洗了

然後接著呢 第三個，你就把它這個洗完的第二個人洗完丢到烘乾机第三個人丢到洗衣机把第一個人趕快拿過去就折一折 就是這樣子以前， 現在不知道還會不會以前常常會發現說這個烘乾机怎麼烘到一半要去拿衣服的時候，衣服不見了，這不是有人要拿你的衣服，因為有人急著要烘衣服，但是发现大家都

在烘他干脆把里面烘的衣服就拿出来，就把它有的人比较好心就直接放在吊衣的线上面，我还曾经看过有人就直接把它塞到旁边的地上那个就比较恶劣一点，所以他这种pipeline的话，同学可以发现说他从六点开始做就做到几点呢差不多九点半，他就结束了这个是pipeline的一个观点，所以我们说它原本是8个小时，它现在缩小成3.

5小时，所以它的speed up呢2. 3这是2。 3倍的这个时间如果说他这个人比较歹命他是洗整个宿舍的衣服他不是洗一间这个N就很大了他就洗不完就一直洗一直洗这个N呢他就是2因为它洗衣份要两个小时有N份就是2N个小时我们来看这个POPLINE怎么算POPLINE它是第一份出来之后第二份

它是每隔半小时就会再完成每隔半小时就放到衣柜里面很快半小时 半小时 半小时这是半小时 半小时 半小时所以我们看就是看说前面这边是花了1. 5个小时1. 5个小时是什么呢1. 5个小时是第一份的1. 5个小时前面洗衣 烘衣 折衣服它有N个就直接放到衣柜每一份都是半小时就完成所以是0. 5乘以N再加上前面的1.

51. 5就是第一个人洗衣 烘衣 折衣这边1. 5这边是1. 5之后这边是N个0. 5所以是0. 5N加1. 5分支2N那這邊呢當你N很大的時候呢它趨近於4就趨近於4這個4是怎麼來的呢4就是你總共有4個stage你總共有4個stage所以這個眼尖的同學應該就會說那如果我speed up要多一點我會怎麼樣我就把這個4個stage呢比如說改成5個stage

改成6个stage它的speed up就会接近五接近六这个就是pipeline它的优点如果你分得越细的话它的speed up就越多但是你分得越细的话它有另外的缺点我们后面会看到大家不要小看这个pipeline这个pipeline就是我們台灣經濟起飛的重要基石我們以前台灣的經濟起飛是始於什么年代同學不知道就是我们的加工出口我們不是有很多加工出口区吗我們那时候有很多人在想办法改善工廠

生產的流程所以同學可以發現說其实现在所有的工廠他們生產線上面其實它並不是一個作業員完成一個product它不是這樣子做它是一個作業員他就完成整個product裡面的一小部分他可能甚至吸到說這個作業員他就是一直在上这个product的某一部分的螺丝或者是什么它就做很细的一件事

情我們人你如果做那种简单的事情不要太复杂重复一直做一直做做久了其实你的效率会非常的快所以我们的很多作业人在生产线上面你从生产线的最开始开始做这个operation一直到生产线结束一个产品就出现這個東西同學就可以把它看成是一個pup line因為所有的人每一個stage每一個

作業員每一個operator他都是一個stage所以你在同一個時間他那個就是一直跑一直跑所以你在同一個時間點你每一個stage同時都在operate這個就是標準的pup line這是一個pup line的一個觀念就是應用在生產線上面所以我們接下来再來看說我们的MIPS的publine这个作者他提到就是说它其实分成五个stage它是五个stage这五个stage其实我们已经蛮熟悉的第一个就是instruction fetch第二个就是instruction decode and register read这个decode其实就是我们看到的那个control unit

First label control你那個它去認說到底是哪一些指令還有register的read所以同學記得就是說第二個stage它是把instruction decoding跟register read兩個把它合在一起把它合在一起再放在第二個stage第三個stage就是ALU的execution是perform operation或者是calculate address第四个就是Memory Access Read或者是Write第五个StageWrite BackWrite Back就是指说把结果写到写回Register File所以我们把它分成这五个Stage所以它的缩写就是IFIDEXMAN就是WBWrite Back所以我们这边看到的一个例子我们说

我們假設它的每一個Stage所用的時間譬如說RegisterRead或者是Write它比較快是100個pe cosecond其他的Stage它都是會用掉200個pecosecond所以我們說E就是說InstructionFage然後200RegisterRead它是100Lu是200然後Memory的Access它就是做一個Read也是200RegisterWrite是100這個是誰呢什麼都有就是我們剛剛提到的LoadLoad什麼都有所以加起來是800如果是Store的話它不需要做RegisterWrite所以它是700Rformat它不需要做MemoryAccess是600BEQ它不需要做MemoryAccessRegisterWrite所以它是500所以同學可以看到它是這四個

这个最主要是要讓同学了解什麼呢就是要讓同学了解說我們前面那个版本的CPU到底好不好不好因为我們要等最慢的这一个如果算是Single Cycle每一个指令都是Single Cycle我們就是要等最慢的这一个其他的指令要等100個Ps到300個Ps100到300要做这样子没有意义的Waiting所以这个是不好的所以如果

说我們有这个popline的话当然很快的就是我们等于說每一個我们假設每一個cycle都是抓200所以它的这个就是說你每隔多少时间就会有一个instruction被执行完，如果是没有Popline的话，它就是800800。如果是POPLINE的話，第一個指令執行完之後，它每一個都是每個200 200 200它每一個就會完成一個指令完成一個指令完成一個指令，所以這個就是POPLINE它厲害的地方所以我們從這邊來看我們就知道說POPLINE它的效能增加是改變什麼改變Latency還是改變

throughput改變哪一個改變throughput latency它沒有變它花的時間還是一樣只是說同一個時間大家都很忙就是這樣子而且它把Cycle time變短因為它之前的Cycle time是看所有Stage要完成現在的CycleTime是看每一個Stage完成的時間所以CycleTime它也變短了，所以這個就是我們PupLine的SpeedUp這個同學可以自己看一下，它就是PupLine跟没有PupLine的時間其實最主要就是在這个Number of Stages但是你的SpeedUp如果要最佳化的話其實最主要是要什麼呢

要balance什么balance呢就是每一个stage要balance，如果你的stage没有balance的话它一样会发生single cycle的一样的问题只是说它的penalty可能稍微小一点但是它还是需要balance就是说每一个stage都是200个peak of second这样子是最好你如果不balance的话你还是会有这一种这种IDLE的情况接下来我们就要来看一下说根据我

们前面看的这个publine的这些information我们要知道说这个MIPS它的design它的instruction set architecture它的design来做publine到底适不适合到底容易不容易同学可以想可想而見說我們說這個MIPS它是所謂的這個RISC的一個架構它是比較簡單的要做POPLINE應該比較容易那我們知道說INTEL它也一定有

POPLINE可是INTEL它是典型的CISC然後再把一些RISC的一些東西全部都加進來它是很複雜的它都有辦法做POPLINE但是相對的它POPLINE的架構就會變得很複雜所以我們來看MIPS它有什麼優點它所有的指令全部就這個版本它是32bit的版本所有的指令都是32bit所以它要f

etch它要decode相對的都比較regular也比較simple所以它有辦法在一個比較短的一個clock cycle之內可以完成這一種fetch decode那如果是這個x86的話呢它的instruction從1到17個byte都有相對的你這樣子要做fetch decoding的機制就會比較複雜你要去fetch你要去decode的機制相對會比較複雜它所需要花的時間就會比較久所以它還有MIPS的instruction format是比較少它也比較regular所以它有辦法decode還有readregister在同一個step就把它放在一個stage裡面

所以這個也是它的一個優點還有load跟store這個address所以我們可以算這個address在第三個stage然後這個memory access在第四個stage這個都是兩個都是一致的一個動作就是你可以把它同步兩個是一致的一個動作它都是在第三個算 address 它都是在第四个 stage去 access memory那你这样子你要做 pipeline 相对也容易如果你的 instruction 的种类非常的

复杂有的是在第三个 stage有的是在第四个 stage那你那个就很麻烦所以这边就是我们提到的 low store它都是统一有这样子的一个特性那还有呢它的就是 memory operand就是它都是一个 align它是一个 wordalign它是alignment of memory operand所以它的memory access它也是一個cycle就可以完成所以這邊就是它的MIPS它的一個優點本來今天應該就要開始要再多20分鐘因為我還要再回到現場去show up一下表示人還在所以等一下就交給助教上那個

那个project要公布助教要跟同学公布一下那个project第三个project那下禮拜一下禮拜一还是要上课但是因为就是下课我要去赶飞机所以我要提早下课下禮拜四就停课一次下禮拜四停课同学记得下禮拜一要上课下禮拜四不用上課同學好這是LAB3的作業然後就這支應該是相對之前LAB1 LAB2比較簡單就是這支只是要就是依照依照之前LAB1和LAB2的那個spec去做這些instruction然後只是重點這次是要還有load和store指令然後重點是要填這個表你們對這個表有問題嗎就是重點要填這個表然後要就是附在你的Report裡面傳上來這表有對什麼訊號Signal不就是很陌生的嗎

然後其他的要求就跟之前一樣啦重點就是要交webform code然後還有你的report上來然後環境也都一樣就基本上跟之前差不多然後這次lab主要就是因為ALU那邊應該有寫個大概簡單的decode那這次就加上stored和load這樣而已大概就這樣有什麼問題嗎這次應該是就是沿用上次的因為這次應該是直接在你們原本之前的LAB上面再加一些東西所以這次應該是不會附程式的部分因為是直接加在你之前的上面就可以

了就你之前做的那個Decoder然後因為這兩個功能算是再加進去的這樣應該比較好做直接蓋如果沒有問題不然就下課然後有問題可以再寄信我們.