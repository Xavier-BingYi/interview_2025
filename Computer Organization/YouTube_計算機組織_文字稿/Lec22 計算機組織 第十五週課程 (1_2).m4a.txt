undefined
我們來看Virtual Memory我們前面跟同學提到的介紹的單元是Cache的部分我們說Cache是我們這個CPU跟Mate Memory中間的一個很快速的媒介如果沒有Cache的話都要到Mate Memory裡面Mate Memory去Access會非常浪費時間我們知道說實際上我們的我們的這個Data基本上都不是放在Memory我們是放在

Secondary的Storage比如說這個HD雖然說現在市面上有越來越多的這種Cloud Cloud ID就是雲端硬碟那這個它的優點就是你在任何一個地方你只要能夠上網你都可以使用到Access到你的這個File那這個缺點當然就是要付錢就是每個月都要付錢那另外一種方法就是它可以一直介紹朋友同學應該可能都有用這一招就是介紹很多朋友你的這個Storage就可以增加很多那像這一種這個Cloud這個Storage或者是我們的這個HD那基本上我們的

資料都是存在這個裡面在電腦 run 我們的 program 的時候我們的 CPU 它就必須要開始去 access data它就開始從 HD 裡面或者是 Cloud 的 HD 開始去搬資料把它搬到 memory 裡面來搬到 memory 裡面來我們也可以把它看成 main memory基本上就是相對應它也是一個Cache那什麼Cache呢是針對我們的電腦跟Secondary Storage就是所謂的

Disk中間的一個媒介所以很大的資料量我們是存在這個Disk裡面我們就是分批的把它搬到我們的Main Memory那我們知道說Main Memory Hierarchy當然就是我們再從Main Memory裡面再搬一小部分再搬到真正的Cache裡面這樣子我們就有一個 hierarchy 的系統像這樣子的一個 management我們要去管理 disk 跟 main memory 之間的系統我們基本上是需要我們的 CPU hardware我們 hardware 跟 software OS 他們來共同的來做這樣子的管理

有一個使用很久的叫Virtual MemoryVirtual Memory顧名思義它是一個虛擬好像是一個虛擬的記憶體它為什麼是叫一個虛擬的記憶體呢一般的Virtual Memory它的意思就是說我們Programmer看到Programmer看到可以用的Memory Space它的大小可能這麼大實際上Programmer看到的Memory Space並不是真正我們的Hard

ware裡面的這個Space我們的Memory裡面實際上並沒有這麼的大可能就是只有這麼大而已但實際上Programmer看到的是這麼的大那為什麼明明就這麼大然後要看這麼大呢它的原因當然就是因為就是說我們等一下會提到這個Virtual Memory它主要有兩個優點我們現在談第一個第一個優點就是

說我们programmer看到的memory它是一回事实际上在memory里面它的physical的memory它又是另外一回事所以就OS的角色来看的话它可以做一个管理它管理什么呢就是说它可以管理说这个virtual memory它到底这部分的virtual memory它是对应到physical memory里面的哪一个部分我们知道说就 cache 來看的話我們從 main memory

搬到 cache 裡面我們是搬一個 block這個 block 的 size 可能可以從幾十個 byte 到幾百或者是 1k 個 byte 這樣子當然越大的話我們前面有談到它的效應如果是從 disk 再搬到 main memory 的話我們知道說這個 size 當然不會就是這麼的小因為我們的資料量通常都很大就是同樣的另外一個 main memory它的size也相對跟 cache來比相對很大所以我們從 disk

搬到 main memory我們在這裡面我們不是叫一個 block我們是叫一個page，一個單位叫page，那一個page， 它的size就非常的大同學可以想想看， 就說我們知道其實這一個單元跟 OS 它有部分的重疊，所以可能有一些有一些這個觀念同學在OS裡面可能已經聽過了。我們知道說實際上我們在跑這個，我們在跑一個Program，它從開始跑然後到最後結束這個Program，它並不會OS都是佔據的這個CPU，因為我們知道說我們現在的OS至少都是Multitasking，所以你同時都有很多的Task在

在同時執行。我們假設是single core，我們CPU同時只能夠serve一個task，所以它是用那一種，就是每一個task就會進到CPU裡面run一陣子然後就一直換手一直換手，因為它中間的這個time period非常的短，所以會讓假設說每一個task都是一個user審密出去，所以它會讓這個不同的user看起來感覺好像CPU都是在幫我做

事，實際上它是這種Time Sharing的方式然後去Serve很多個Task，用這樣子的一個方式的話，我們知道說它既然沒有辦法都會一直進去出來還有另外一個原因就是Main Memory，它的Size也是固定大小當很多的task全部都進去的話，這個main memory它有可能會爆掉就會負了 它就會滿main memory如果是滿的話你必須還要再去

load一個task進來的話我們知道說你這個main memory要share給別人大概就是其中佔掉main memory的task它就必須要先移出去就是跟cache的機制基本上都是一樣的出去進來 出去進來所以我們看 cache 它的過程我們在 memory 看到的其實它是發生同樣的事情既然發生同樣的事情的話我們在第二章的時候跟同學介紹到loader就是說我們把一個 binary 的 code我們把它 load 到 memory 裡面去我們每一次 load 進去的絕對位置也是不一樣 對不對

它是每一次進去的位置都不一樣像我們剛剛提到的這個Task它必須要做這個Swap它如果從Memory裡面要In Out In Out所以它每一次一筆資料被從Memory踢出去以後當它又被叫到Memory裡面去的時候它也不一定都是會Load到會Assign到同一塊Physical的Memory的Address所以也就是說我們這個Virtual address對應到Physical address它會透過OS

的管理每一次進到Memory的位置都會不一樣那這個優點呢這種彈性呢當然就是要透過這樣子的一個機制然後有一個Manager在我們這一邊呢當然就是OS那OS，它就是負責在管理這些事情，那這樣子它就可以知道說你這一塊這個Virtual那你這次漏得到physical memory，你到底是漏到哪一個地方，這次可能在這

裡然後下一次再進來的時候它可能是漏得到這個地方，所以它會有一個mapping，它知道說這一塊這個virtual address現在是在這裡然後現在又是在這個地方時間點不一樣，它可能進到這個physical memory的位置就不一樣所以相對的這樣子就非常的有彈性跟這個issue有相關的是什麼呢就是所謂的security就是我們要

去保護我們的資料，我們知道說這個main memory是有很多個user他丟了很多task進來然後再share這一塊main memory有一些main memory它是share有一些是private那private當然就是指說大概就是只有這個task這個process它可以去access到这部分的资料如果它是private的话OS它知道说这一块其实是某一个virtual address对应到这一块physical memory如果它是private的话自然而然OS它就不会把这一块再assign给另外一个process另外一个task ask它的memory把它map到這邊來因為它知道這是private

所以它不可能再把這塊allocate給別人所以這些透過OS的管理我們可以很容易地去管理說這一塊physical的memory它是private給誰某一個task使用它也可以share給這個process1 process2可以讓它share這個都是可以透過OS來管理。所以我們從這邊來看的話像這種Virtual Memory它是非常有彈性的而且它也可以讓這個OS很容易來達到這種Private或者是Share這種Memory的機制讓Memory的Utilization可以在Task之間達到一個最好的效果而且它是安全的。所以這個是

我們提到的這個Virtual Memory它其中的一個要使用這種Virtual Memory的一個原因第二個原因就是我們提到的就是說Virtual Space看起來比較大然後Physical Space是比較小尤其是在早期就是說早期那種大家還是在那種大型主機上面寫這個程式那PC可能還不是很流行可能剛推出來沒多久所以學校的記中大部分都

是那一種什麼CDC cipher還是什麼Vex什麼之類的那種主機那它的這個memory在當時可能也是蠻。大的但是基本上你如果program寫大一點的話它大概也是沒有辦法就是把這些data program全部都load到memory裡面去那你必須要去管理這些也是非常的麻煩如果說類似像這種Virtual MemoryProgrammer它可以看到比較

大它好像有很大的一個solution可以用Memory的一個space可以使用實際上Memory就是只有這麼一小塊所以Programmer它在使用的時候它可以用比較大的記憶體實際上真正管理它是透過OS來管理它也是一樣是把這種比較大的記憶體它也是都是分成一個Page兩個Page然後就一次一個Pageload到Memory所以這樣子來看的話這個Virtual Memory它的優點就是有像我們剛提到的這兩項但是你既然使用了這種Virtual Memory也就是說

你用的時候它不是你不是直接使用這個Physical那你使用這個 virtual memory你自然就必須要有 translation那這個 translation 呢當然就是我們要把 virtual address我們要把它 translate 成 physical 的 address那這樣子的一個機制呢我們等一下最主要就是來探討這一種 translation它第一個要如何來做這樣子的 translation那這樣子的機制它是不是夠 efficient那如果不夠 efficient 是不是有

有另外一個方式來輔助讓Translation不要太大的Loading這個就是我們等一下後面要討論的議題這個就是我們剛剛提到的相對應於Cache我們都是一次搬一個Block我們就有這種Cache的所謂的Hit跟Miss在我們的Virtual Memory跟Disk跟Main Memory這中間我們也是一樣一次都是搬一個Page那就是有所

謂MIST的話就是所謂的Page 4那Page 4的話我們前面說如果Block MIST的話它是那個Nightmare因為它要畫很多的Cross Cycle那如果說這個是Page 4的話那更不得了因為我們知道說它要到Disk裡面去抓一個它要去抓一個PageDisk我們知道說它是mechanical的機制所以它這種機械裝置的話它在動的時間同學可以想像它是更久所以這個的話我們當然是會盡量讓Page4降到非常的

低在這裡面我們來看一個例子這個示意圖就是Virtual Memory跟Physical Memory它們之間的一個對應在左邊這個是Virtual address右邊是Physical地址Virtual address，它就是這邊當然看起來一般，這邊是比較大，然後右邊Physical address的sizePhysical memory的size是比較小，所以它也會像我們前面提到的，你是比較多的對應到比較少的大概就會有所謂的多對一，多對一的一種mapping

比如說我們可以看到這边有一个这里有一个map到这一个，然后这里面有一个map到这个地方所以同樣的physical memory的同一個位置，它是有两个不同的virtual address來做这样子的一个mapping。但是同学要知道的就是說你如果是不同的virtual address同一個 physical address，那兩個 virtual address 一定是來自於不同的 process它的一個access，因為同一個 process就是它會 create 一個我們後面會看就是一個 page table那你 page table

裡面不會有那種多對一的情況發生，它不會有多對一，所以這個我們這邊看到的是，就是一個 virtual的一个memory space，右边是一个physical memory space，所以这种大概就是来自于不同的process之间的一个demand它才会有这种情况这里面就是我们刚刚提到的我们所有的资料都是放在这个disk里面我们现在都是用这个hardd其实早期当然也是放在这个大部分都是放在hardd

但是在早期我們備份的時候現在同學備份大概都是我就再買一個外接式的硬碟就可以了你要備份就再買一個外接式硬碟甚至有人就是買這個handy drive就是USB那種裝置都可以其實在早期我們是用那個TAP有同學用過TAP的有沒有因為應該都沒有年紀這麼大的應該都沒有用過TAP那有看過TAP的舉手也沒有因為我是不知道現在是不是TAP已經絕跡了因為以前在園區的時候

那時候他們還是用TAP他們就是整個公司的智慧財產就是那些code source code就是把那些source code用TAP備份起來然後送到銀行保險就保全就是鎖在銀行裡面這樣子就不會說公司萬一失火燒掉了機器全部燒光Source code全部都沒了至少還有這個Tab可以放在銀行裡面就是保全這樣子最早的Apple不知道是Apple I還是Apple II我忘了他們那時候灌軟體也都是用Tab他們那時候Tab是那種

小袋的那個Tab所以它就是好像在放音樂好像在你們大概也沒有用過就古早時候的收錄音機它現在音樂都用CD以前是用那種卡夾就是大概這麼小的卡夾它的Program都是存在卡夾裡面要load的Program就是好像在放音樂一樣就放下去然後就用那個耳機然後接到那個電腦裡面就把它灌進去你如果把它耳機的那個接孔拔掉你就會聽到很高的很尖的聲音很尖的聲音那就是最早最早的時候

那個Apple它就是用這種把Program灌在Tab裡面然後再輸到那個它的電腦裡面去那這個就是我們的這個Secondary的這個Storage所以資料都放裡面這一張圖它告訴我們的什麼事情呢就是說因為我們知道這一個它就是告訴我們說箭頭指到這裡的就是表示它這一筆資料這一個page這個page的資料還存在disk裡面它還沒有從disk搬到main memory如果說這個箭頭是指到physical address

就是这一块的那就表示说这个page它已经被搬到main memory所以这个箭头它的意思就是这样子所以我们在读这个资料的时候我们当然它就只有两种情况一种情况就是这个page之前已经被access过它被从disk抓过来放到某一个physicalMemory裡面的某一個Page所以之後它每一次要Access的話它

就是很容易就知道它可以很容易的就是知道說它Data已經是在Memory裡面它不需要再到Disk裡面去抓如果是箭頭直到這裡的就是表示說這個Data之前還沒有被Access過所以是放在這個地方或者是什麼呢這筆這個Page之前雖然被Access過曾經被搬進到Physical Memory裡面但是因為這個Memory滿了有人還要進來所以舊的就要踢一個出去所以它可能就被踢出來所以直到這邊的就是兩種情況一種就是我剛剛講的它還沒有被Access過

所以從來沒有被抓到 main memory 裡面去第二種情況就是它曾經被 access 過然後抓到 main memory 裡面但是因為 main memory 裡面滿了又有新的 page 要進來所以它必須要被移出去移一個舊的出去一個新的才能夠進到 main memory所以它被移出來之後這個 page 它又會直到 hard disk 裡面它的这个location所以这个箭头的意思大概就

是这样子所以你只要是指到这一边的那就是所谓的page 4那我们就必须要到这个hardd里面去读资料这浪费非常久的时间那如果是指到这一边的呢它就会怎么样呢我们就知道说这个不是在main memory不是说不是它一定在main memory但是更好的情况它其实就在cache里面它現在cache 一抓就到所以如果是指到這裡它就是可能在cache也有可能不在cache至於我們講的這個translation我們可以看到的就是這一張圖右邊這一張圖這一張圖它告訴我們的就是說

virtual address它是32個bit實際上physical的address它只有2的30次方它可以定值這麼大的範圍它就是有這麼大的空間但是我們實際上看到virtual是2的32次方所以它必須要做一個translation它的translation是這樣子的因為我們不管是在virtual address或者是在physical address我們一個page的大小都是固定的一個page的大小都是固定所以你在disk裡面一個page就是這麼大

你搬到MateMemory裡面當然也是同樣大小的Page你不可能這麼大搬到MateMemory變小了那你資料跑哪裡去所以不管是在HD、MateMemoryPage大小一定是一樣大所以我們的Page的Offset當然是固定的所以這邊用一個例子就是它的Page一個大小就是4K就是一個Page就是4K那4K的話我們這邊就是用12個bit來定值這個page的offset區

分這個page的offset所以這是4K 4K byte所以這邊是12個bit0到11總共是12個bit當然你在physical的edges它也一定是12個bit所以0到11 0到11它在virtual edges跟physical edges都是0到11來當作Page Offset所以它12到31這個就是Virtual的Page Number剩下的就是Virtual Page Number那Physical因為它是只有30個bit所以它是12到30這邊就是Physical Page Number所以我們要做的Translation是要Translate什麼就是要把Virtual Page Number透過一個

查詢的一個動作我們可以把virtual page number把它轉成physical page number這個查詢的動作就可以知道說我們對應到我們這一筆virtual address實際上是對應到physical memory的什麼地方就是用這樣子這個就是叫translation就在這個地方所以我們等一下會跟同學介紹如何做這個translation

這邊其實我們剛有跟同學提過它的Virtual Memory它的運作的機制它這邊就是講到Page 4的Panelty我們剛提到說Page 4就是你的Data是還放在Disk裡面所以這個時候你要到Disk裡面把資料抓到Main Memory裡面去，這個它講說你必須要花費minions of clock cycles時間或許也是很短，但是你轉換成clock cycle的number它已經不是數十個或者是上百個，它是minions of clock cycles這個對CPU而言它簡直就馬上就昏倒了，所以我們這一部分是由OS的code來handle

我們知道說這個pitch fall是很恐怖的一件事情所以我們如果要去minimize這個pitch fall的話呢，要去minimize pitch fall rate我們大概就是使用這個fully associative的這個placement我們前面已經知道說fully associative的placement它的hit rate是最高的，雖然我們前面也有提到說on the associativity的這個degree你一直增加即使你的hit rate它增加的game會越來越少越來越少，但是它還是會增加，意思就是說

你花很大的代價，即使你得到的game是越來越少越來越少不是說沒有或者是變小，而是說你增加的game是越來越少，所以你如果要真正要去minimize這個pacefall rate，你還是不得不用這種fully associative才能够得到最好的这种hit rate当然还有另外一个就是我们要让我们的replacement的机制更smart我们最好的replacement的机制就是我们前面提到的就是list就是L-R-U就是list recentlyuse and use的一个机制

這樣子就是你最近最沒有被使用的這個page要把它replace掉可是我們前面提到說你如何來評估哪一個真的是最常不被使用的哪一個是其他的你不會去誤把那個最近剛剛被使用的然後把它replace掉我們等一下也會提一個簡單的方法因為anyway你不可能去真正去找一個它真的是最少被

使用的因為你要這樣子的話你要一直去記錄就有一個時間time period你必須要一直去記錄它到底被用幾次用幾次然後多少時間這個是比較浪費時間的一種機制我們前面提到的translation其實它就是用所謂的這個page tablepage table當然就是記錄說我們這個virtual的patch number它實際上它在name memory裡面它

是對應到哪一個physical的patch number所以它這個就是記錄什麼呢placement的information那patch table基本上就是一個patch table entry就我們之前在cache看到的一個row一個row就是它不是有很多個 row 嗎一個 row 一個 row 我們可以就把它看成是一個 entry所以這個 pass table 它有很多個 entry它就是一個 array of pass table entry所以它是很多個 entry它這個 pass table entry它就是由 virtual pass number 來 index因為我們前面提到說

這個translation就是由virtual paste number轉成physical paste number所以我們當然就是由這個virtual的paste number我們就可以直接index這個virtual paste number它是對應到這個paste table裡面的哪一個entry你這樣馬上可以直接找到這個entry這個entry實際上就是記錄什麼呢就是記錄physical paste number就是這樣子我們前面也有提到什麼

呢我們前面提到說每一個process它會create一個pass table給它每一個process它會有一個pass table所以你這個pass table你在run的時候你這個process在run的時候我們這個hardware裡面有一個叫pass table registerpass table register它就會指到什麼呢指到只到你这个process你的PatchTable所在的位置因为同学会讲说那我的PatchTable又是什么东

西呢它是Table可是这Table要放哪里呢第一个我们知道它绝对不会放Hd对不对因为Hd那个慢得要命我们不可能把这个PatchTable常常要去做translation的放Hd那这个PatchTable摆哪里呢当然是擺這個 main memory 裡面所以我們在 main memory 裡面你一個 process 被 create 之後它就會幫它 create 一個 paste table這個 paste table 它既然是存在 main memory 裡面自然而然就有它的所謂的 starting address因為我們在 computer 裡面我們做 memory access 的機制都是一樣的你只要 data 是

放在MapMemory裡面你要去Access Data存在Memory裡面的Data它的機制都一樣你要知道這筆資料到底放在MapMemory裡面的哪個Location這個PageTable既然是在MapMemory所以它需要有一個Starting Address，它是一個Array，所以它要有一個Starting Address，這個Starting Address OS，它會知道當你這個Process要開始去Run這個Process的時

候，在CPU裡面有一個叫Paste Table Register這個Register，它就會把它update成這個Process所對應的Paste Table，在Memory裡面的Starting Address，樣子它就可以開始去抓這個Process所對應的Paste Table，如果去抓就是透過這個Paste Table Register，就是這樣子，所以這邊就講說這個Page，如果是在Memory裡面，我們的PageTableEntry，這個PageTable，你用VirtualPageNumber/VirtualAddress的VirtualPageNumber，那一部分就是我們VirtualAddress的這一部分，我們可以用這一個部分直接去定值PageTable，就是說這個VirtualPageNumber到底是存在PageTable的什麼地方，

就可以直接是在這邊嗎，是在這邊，它就可以直接去Access到你的PageTable的那個Entry ry，這個Entry它存什麼呢，它就是存PhysicalPageNumber你就把它讀出來，讀出來以後就再跟那個PageOffset就可以組成一個Physical的Address所以它就是這樣子做這個存Station當然每一個PatchTableEntry不是只有存PhysicalPatchNumber這是Translation用的我們知道說Cache它除了存我們要的Data以外，它還必須要存Maintain的一些Information對不對，那PatchTable當然也是一樣 PatchTable它是要做Translation所以它的Data就是PhysicalPatchNumber除了這個之外

還有一些for maintenance的一些information哪一些呢，比如說，reference dirty它是不是dirty，dirty就是這個，有沒有被寫過，reference它有沒有被reference過，它有沒有被access過，因為讀不一定是寫，所以這個reference是包含，就是讀跟寫，那這個dirty的話就是只有寫，所以它還包含了這種所謂的status bit所以每一個page entry除了state us bit之外還有這個所謂的physical page

number如果page它不是在main memory裡面那這個page table entry它就不是指到這種physical page number它會指到什麼地方呢它會指到這個disk裡面的swapped space swap space什麼時候被create它也是你這個process被create的時候OS它會在HD裡面create一個space在HD裡面create一個space那個space就是這個process的swap space就是這個process它專門在main memory跟你這個disk裡面它要做swap用的資料swap用

他create這一些資料的時候呢他也會create說你這一個process你的virtual的這個page number到底是直到你的hd的哪一個位置因為我們不是在main memory就是在hd那你如果要去hd你總要知道說這個virtual page number到底是在hd的哪一個location你要知道這個他才有辦法去定指那個hd的位置然後去access這個hd的資料所以它也會去create這樣子

的一個data structure來存virtual page number對應到HD的information那virtual page number對應到HD的location這個information它有可能是放在page table裡面它也有可能不是放在page table裡面所以這個不一定反正它如果不是放在page table裡面大概也是類似像table的這種形式可以很容易被access到它可能就必須要跟Patch Table搭配來使用所以這個是比較detail的細節所以我們這邊有一個是在Memory一個不在Memory就是有這兩種情況接著我們來看一個圖這個圖就是一個例子這個例子告訴我們說

這個是Patch Table Register我們剛剛提到的這個Process你要開始Run的時候我們在CPU裡面的這個Patch Table Register它會替換成這個Process跟它對應的Patch Table所在Main Memory裡面的Starting Address就是這個地方這個地方它就指到這裡面來所以這邊Virtual Patch Number它當然就會根據它的Patch Table Register這個就是所謂的Base Address然後再加上它的這種Offset它就可

以找到它的這個Virtual Address到底是在Main Memory裡面的哪一個位置譬如說它就找到這個地方找到以後這個當然首先這邊只有一個叫Value BitValue Bit我們知道說Value Bit如果是類似像Cache一樣Value bit如果是1的話表示有資料在這裡面如果Value bit是0的話在Cache那邊我們知道說Value bit是0就表示還沒有資料搬到Cache的這個位置對不對這是在Cache的部分這裡面它也是告訴我們說它如果是ValueValue bit turn on就表示說這邊可能就指到這個Memory裡面的某一個Physical paste number

如果說Value bit是0的話這個大概就是資料還在hardd裡面我們必須要到hardd裡面把這個資料把它搬到main memory裡面去假設這個Value bit是1我們這邊就會讀出一個physical的page number然後再搭配原本的這個virtual address裡面的page offset這兩個搭配起來它就是一個physical address那就是一個physical address所以這個就是我們使用page table register然

後從 virtual address到physical address它的一個translation的一個detail我們這邊舉一個例子因為課本的這個例子剛好搭配這張圖看起來可能會比較清楚一點我們來看它說有一個32bit的一個virtual address然後4kb pages就是說它的page size是4kb它的page size是4kb然後每一個page table entry是4個byte每個page table entry就是一個page table entry就是這是一個entry它就是

它總共大小是4個byte所以這4個byte是包含什麼status flag還有它的physical page number就是這些東西加起來是4個byte他問說這樣子這個page table的size到底有多大我們要知道page table的size就是這一個到底有多大基本上就是我們要知道有多少個page table entryPatchTableEntry的數目有多少個有多少個知道之後再乘以每一個PatchTableEntry的size所以它的size是多少就是4個byte這樣子

就知道說PatchTable的size大概有多大這個例子只是要讓同學有一個大概有一個sense說，如果你是4KB這樣子的一個PatchSize你的Patch Table Entry的Size是4個Byte大概我們一個Process它會佔掉多少個就是它Patch Table會佔掉Memory多少的空間所以我們要知道它大概有幾個Patch Table Entry Patch Table Entry其實就是這一個就是這一個就是

這個因為它就是由VirtualPageNumber來直接定值這個PageTable裡面的某一個位置就是這個這個很簡單我們只要先知道說它用掉了多少個bit在PageOffset它用掉多少bit在PageOffset我們就知道它的VirtualPageNumber有多少個bit我們就會知道它有多少個Page Table Entry所以它的Page Offset是要幾個bit呢我們要知道說Page Offset幾個bit我們就要知道說一個

Page有多大它已經告訴我們說一個Page是4KB 4KB就是需要12個bit Page Offset就是需要12個bit 4K個byte所以我們需要這個4K 4K就是12個bit所以我們這邊就是0到11就是總共12個bit是用在Page Offset Page Offset分完以後剩下的就是Virtual Page NumberVirtual Page Number它就是32減掉12這邊Total 32減掉12就是20個bit20個bit它就是Total有2的

二十次方個Patch Table Entry就是這樣比如說我這一邊如果只有兩個bit它就只能定指四個Patch Table Entry對不對如果只有兩個bit它就只能夠定指四個那它現在有二十個bit所以它就是二的二十次方所以你二的二十次方個Patch Table Entry那每一個Entry是4 byte所以一層呢 乘出來大概你的Path Table大概就是這麼大你的Path Table就是這麼大所以你如果一直丟Process你就可以

測測看說它可以容納可以丟多少個Process有的系統它的Performance會degrade非常的快或者甚至不是叫degrade它可能就是他可能就直接近乎shut down這樣子然後就當在那一邊就死給你看有一些系統做得比較好的我們都說他是degrade gracefully他就很優雅的他不會馬上就死給你看他死的時候他也會死得很優雅這樣子所以他的performance不會這樣馬上就

然後就crash掉它會這樣慢慢地你process一直丟你會發現它越來越慢，但是它不會這樣馬上就好像就當掉了，它就慢慢地這一種就是做得比較好的，所以同學要測你的系統有沒有夠robust，你就一直丟看看它一直丟的時候它的效能到底怎麼樣；接著我們再來看一個圖我們剛剛前面看到第一個圖

我們看到的是一個Virtual address到Physical address我們這邊看的是什麼呢就是我們這邊已經有一個Virtual address透過Virtual address裡面的Virtual page number這個Virtual page number我們可以找到它在Page table裡面的某一個Entry這個Entry;其实就跟刚刚是一样的意思，这个意思就是指到这边就表示说这一个page现在是落在memory里面，它的位置就在这个地方，如果是这个地方指到这里就很不幸，它目前不在memory，它在disk里面的某一个位置所以这边是0； 这边往这边指这个是Page table我们说1

是每一個Process它會有它自己的Patch Table而且它這邊不會有多對一的一個Mapping实际上也沒有必要都自己一個Process裡面你幹嘛要多對一呢，所以同學可以看這邊没有像剛刚前面的Virtual Address跟Physical Address它會有一個是多對一的一個Mapping這邊都是一對一的一個Mapping從這個圖裡面我們也可以知道說它這一次Map到

這邊來如果說它被丟出去有人要進來覺得這一塊是最少被使用到的它就把它丟掉從Memory裡面把它排除另外一塊進來下一次這個Virtual Page要再進來的時候它不一定會進到這邊它可能會進到這邊假設這邊是空的它可能就進到這裡這個完全全都是由OS來控制的所以就是我們前面提到的

它是private或者是sharedOS它都知道它可以well control這樣子的一個mapping不會讓整個系統亂掉所以我們這邊有所謂的repressment的一個機制這個repressment的機制我們來看一下就是這邊它說我們如果要減少page4 的 rate這是我們提到的 list recently used 的 replacement最少被使用的一個 page 它要被搬出來這個時候它就多加了一個叫 reference bit在 page table entry 裡面多加了一個 reference bit它不是叫 dirty bit因為 dirty bit 是 write 的時候被 write 它就會被設為 e它是叫 reference bit 被 access

如果說它被 access的話這個reference bit或者是叫use bit它就會被設成1但是同學會說你怎麼不是用加的因為我們不是要統計嗎統計誰最少被使用到因為有可能大家都被用到所以大家都是1都不是0所以你應該要用Counter才對用Counter是最準但是你就要看看你的這個Cost你每一個Page就要一個Counter那你這個Counter要多大你是要8個Bit還是16個Bit還是32個Bit也會有Overflow的這個問題所以它使用的方式它就是週期性的由OS去把它Reset

週期性的有 OS ResetReset 完以後就大家都是 0但是 Reset 完之後 0 沒有關係如果那些常常被 Access 到的它被 Reset 成 0 之後它又被 Set 成 1被 Access 馬上又被設成 1所以我們由 Reference Speed 來判斷它有某個程度的準確性同學會說那你如果剛剛被 Reset 完馬上馬上要搬一個走那怎麼辦這個機制當然總是有不是很準的時候但是用這樣子

的機制的話他還是認為說就是算是在Hardware cost然後Accuracy可能是一個不錯的一個Trade off所以就是Prioritically reset然後被Access馬上要Set所以我們要去看說誰沒有被用到就是去看reference bit或者叫use bit就是這樣子所以這邊的問題就是我們剛提到就是在這個不過這是一個trade-off我們今天介紹到這個地方.