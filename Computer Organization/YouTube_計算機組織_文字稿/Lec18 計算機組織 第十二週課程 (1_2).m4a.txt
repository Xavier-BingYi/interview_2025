undefined
今天還是從一八二十一頁開始就一二一 一二二 一二三我們上一次三頁有講過的地方我們再重錄一遍這樣子所以同學可以再仔細再聽一下再當作review一下就是跟上一次講的地方有一點點不太一樣我們上一次跟同學提到的這個aesthetic的dual issue我们在这里面的架构最主要是有两

个Path其中一个Path它是专门执行LU跟Branch另外一个是执行Load跟Store所以在我们看来的话我们如果要避免这个Structure Hazard因为我们知道说我们现在有两个Data Path在这个Pathline上面流上面是LU Branch下面是所谓的Load Store如果我们要避免structural hazard我们就必须要把适当的functional unit

复制就是要duplicate适当的这个functional unit所以我们在原本的这个publine的话原本它所有的是就是这边黑色instruction memory然后register file一个sign extension然后还有这个branch target的HS的computation然后一个LU还有一个data memory我们以前大概是这样子我们现在要分成两个部分的话我们这边蓝色的部分是我

们新加进来的，所以在这里面原本它只有一次读一个instruction。我们在这边现在加了一个蓝色，就表示说它读了两个一次读两个 instruction。黑色的部分属于 ALU 跟 branch，蓝色的部分是属于 load 跟 store，这边右边都是一樣藍色的部分的話它都是屬於load跟store就是負責load跟store它的一些data flow還有它的一些functional unit比如說這個是多出來的sign extension我們在這裡面的register file這邊同學可以看到它也是一樣就是會讀藍色的資料for load跟store因為在load跟store

它的这个从register这边读出来的它只有一笔资料，这笔资料就是当做是这个base address所以就是这笔资料来当这个LU的第一个input source，那第二个LU的第二个input source它就是从它的instruction的这个operand，它的constantinstruction的constant这边来当做它的一个offset，所以这边是蓝色的这个flow另外这边蓝色的上面的这个flow我们知道说蓝色

的是负责load跟storestore的话就是我们要把register的一个词把它写到memory里面去所以这边就是for store所以它从register这边读一个data出来然后到这边写入memory另外就是在这边这个multiplexer下面這個 multiplexer的部分我們知道說我們在這裡面最主要是為了要因應就是在publine我們知道說所有的control signal跟它的所有的information它必須要跟著它這個instruction pack在一起然後stage一個stage跨過一個stage再走到下一个stage所以我們在這裡面就是說假設它是這個load的一個指令它必須

就是說load或者是rtype的指令它必須要把這個data把它寫回register我們必須要有所謂的destination就是write destination的register所以我們必須要把這筆資料然後pack跟這個instruction跟著它一起走這邊下面列出來的就是我們以前提到過的這個popline的一個機制在這裡面我們發現說這边这个蓝色的部分它是只有一条line这一条

line当然就是for load因为我们store的话它并没有要写回registered file所以这个是for loadload它的write destination它是固定储存在rt这边所以它是只有一个source所以就是这样子feedback回来但是對於 ALU 而言的話 ALU 的 instruction我們知道說 ALU 譬如說 add or它把 ALU 運算的結果它會寫回 register file對 ALU 而言它有兩種 type第一種就是我們說它的兩個 source這個 input source 都是來自 register所以這種 type

它的write destination是放在rd另外一種type我們知道說它有所謂的immediateimmediate就是它是add i加一個i所以它的兩個input source一個是來自於register另外一個是來自於instruction裡面的constant在這一種format我們就會把rd這一種fear把它拿去給存Constant所以这种ADDI这种Immediate的这个Mode我们就是把它

的Write Destination存在它的这个RT所以我们在这里面就有两个Source一个就是Write Back这是Write Destination一个是来自于RT一个是来自于这个RT所以就是二选一然后接着再把它再导回这个Register，所以这个就是我们在这边介绍的因应我们上一次跟同学提到的，就是static dual issue，这个就是静态的，它每一次都是pack两个instruction，每一个instruction pair，一个一定是LU或者是branch，另外一个一定就是load跟store，这两个把它配在一起当然不是只有这两，

这两类，因为我们有时候为了这个hazard的关系，我们没有办法把两个instruction pack在一起，所以它必须就是有所谓的这个no operation，我们也可以把这个no operation当做是一个instruction，如果你是跟no operation搭配的话，那基本上这个pack进来在这个pipeline里面，它就是只有上面或者是下面的这个flow，它有instruction在流，另外一个，它基本上就

好像是一个bubble一样，但是no operation，所以在这边就是我们要介绍的static dual issue接着我们再来看有关于dual issue的这一种架构，它有这个hazard，这个hazard，因为它会让我们没有办法说很理想的，可以每一次都issue两个instruction到Deal Issue的Pipeline裡面來所以我們還是一樣要Remove HazardRemove Hazard我們在這邊提到就是說它有兩個機制一個就是所謂的Compiler-based一個是Hardware-based。第一個機制顧名思義我們就知道說我們是由CompilerCompiler它來根據它的Code Sequence來決定，

当然它还可以做reordering之类的reordering之后它把这个instruction把它pack在一起之后它会决定说这个没有hazard，然后它们可以把它pack在一起两个pack之间它可以确保说在每一个pack里面的两个instruction它们之间是没有data dependency，因为我们知道说你如果说在同一个pack里面它的两个instruction是同时执行那你两个instruction进来同时执行

结果它有data dependency，那这个是没有办法这是无解的，你没有办法透过什么forwarding什么机制来解所以你必须要确保这个问题，所以有必要的话它就会加入所谓的这个no operation，所以这个就是有这个compiler based的机制那hardware机制的话基本上它也并不是说所有的这种hazard。的问题都是由这个hardware来解决它还是有会有

Compiler来辅助所以基本上 Compiler它还是解决什么呢就是一个Pack裡面的两个Instruction它们之間绝对不会有Hazard的问题。 Hardware的话它可以来判断就是说Pack跟Pack之间它是否需要加Store它可能没有办法透过Forward来执行所以它就必须要有store的一个机制。所以这种hardware的base基本上是由Compiler跟Hardware的store的机制两个来相辅相成。在这里面我们可以来看一个例子就是说这边有包含一个是ex的一个hazard另外一个就是发生在execution stage另外一个是load use这两个差别我们都知道说

在这个case里面我们的这个output在execution stage结束它就算出来在这个例子它必须要在memory的stage结束之后才能够从memory把这个output读出来所以它们之间差了一个stage的delay。我们知道说这个在我们的single issue里面类似像这种ex的hazard我们可以透过forwarding来避免比如说我们如果说是这样子的一个instruction sequence一个是aid一

个是load这两个指令如果是在single issue的话我们知道说比如说你这个在clack i把它丢到publine这个load我们就是在clack i加1就把它丢到publine里面去这样子基本上还要再透过一个forwarding的机制来解我们就可以避免说你必須要等到把 S0 加 S1 的這個值全部都存到 T0 以後這樣子的話這個 load

才能夠把 T0 讀出來這個 load 它就必須要等寫進去我們透過 forwarding 機制可以解決這個問題可是如果我們在這樣子我們說 two issue這兩個又是被 packed 在一起的話基本上它是沒有解的你不可以把这两个指令Pack在一起所以你必须要把这两个指令把它分散就是把它分散在两个不同的Pack比

如说这个Pack在前面这个Pack在后面这样子的话这两个Pack它还是要分开来就是说这个Pack是在Clark i丢进来这个Pack是在Clark i加1丢进来所以它必须要把它分散开来所以我们回过头来看这样子的一个DataPath这个DataPath其实我们刚刚没有提到Forwarding的机制这里面它也没有画出来实际上这里的Forwarding的机制它应该是可以比如说我们来看同一个Path比如说上面都是LU的Instruction

在同一个Path这边它可以有Forwarding的机制就是说我们这边算完之后马上Feedback回到这一边提供给下一个Pack下一个Pack它们两个都是LU的Instruction它们有Data Dependency所以你就说这个是I 这个是I加1这是第I个Pack这是第I加1个Pack所以你第I个Pack它指令执行完结果出来以后

你不用再寫回去就直接從這邊 forward 回來它後面 i 加一個 rtype 的 instruction它就可以執行所以這樣子的機制我們這邊沒有畫出來實際上它是有的兩個不同的 data flow我們說這邊有一條 path這邊有一條這邊有個 flow 這邊有個 flow其實你 forwarding 的機制它一樣是可以提供給不同的 flow这边也是没有画出来所

以你如果说它这边这个Pack iPack i是一个LU的instructionPack i加1它是一个load的instruction所以它是两个不同的packLU的instruction跟load的instruction它们两个data dependency所以这个时候怎么办呢它还是一样就是说pack i进来以后下一个clock cycle pack i加1它就可以进来所以我们可以看到我们可以看到什么我们可以看到说当pack i在这里的时候pack i加1在这里所以pack i在上面的时候

pack i加1在下面的这个data paste这个是i加1当你i进到这一边的时候因为它是LU所以这里面的output已经出现了那我们的I加1进到这边来其实它就是要把它拿来当作比如说当作是一个base的一个edges假设是这样子所以其实我们也可以透过一个forwarding的机制我们可以到这边来那这样子它的这个Pack I跟Pack I加1它们之间的关系就不需要说

你必须还要再等一个clock cycle等两个clock cycle等到它写回register之后它才能够使用所以在这边的话在这里面DataPath它都没有highlight出这样子一个机制但是基本上这个forwarding的精神之前我们提到的forwarding的精神在这边我们都可以suppose它依然都有这样子的一个机制存在所以透过这样子的一个机制的话我们在这

里面刚提到的这一个原本的一个Sequence那你用这个To Issue我们就必须要把它强迫这个是Pack I这个是Pack I加1把它在不同的就是连续一个就是连续的Clock cycle上 uck这个Cluck进来之后下一个Cluck这个Pack接着就进来，那这样子它就可以解决这样子的一个问题，那个是Execution Stage产生output的一个情况，这个是load

use，我们知道说它是在memorystage结束之后从memory读出一个这个值，如果是在所谓的我们在single issue的这种condition里面，我们知道说即使有forward的一个机制，我们知道说在这个load use我们还是必须要delay一個cut cycle譬如說load的townload是在di一個cut cycle後面我們假設它是一個rtype的指令，這個rtype指令這個rtype指令它不能在di加1個cycle進來，它必須要在i加2個cycle 對不對我們看， 就是說假設

假设 i 在这里， i 加 1 在这里，所以当 i 进到这边的时候i 加 1 就跑到这边了这个时候它的 data 还没有出来进到这边的时候它已经把这个值 memory 读出来i加1进到这边的时候i到这里的时候它就可以forward到这边来把这个memory stage的output把它forward到execution stage这边来让它执行，所以我们知道说它必须要空中间这边要间隔一个clock cycle，这是在single issue的一个情况

所以这种情况我们就是所谓的说它是所谓的one cycle的use latencyuse latency是什么意思呢use latency就是我们这边有一个我们这边把它highlight出来的use latency它就是说number of clock cycles在load跟它后面的这个指令要使用load的output的这个指令它们之间要间隔多少个clock cycle它们之间要间隔多少个class cycle它才能够使用这个

指令才不会说它进来之后还要必须被store所以你间隔几个class cycle进来之后它就可以顺利地用到这个load像我们刚刚看到的这个情况i在这里的时候i加1在这里所以它中间其实就是间隔了间隔了一个class cycle 对不对所以它是one cycle的一个use latency当你碰到这种dual issue的时候它还是一样但是

它还是一样是需要一个cycle的use latency但是差别是什么呢差别是说这个时候它隔了一个cycle之后再进来一个pack这个pack里面有两个instruction这里面有两个instruction我们来看一个情况这个情况就是这样子我们假设有一个load然后有一个 aid然后有一个store我们假设一个code sequence是长这个样子我们说这边是pack i然后这边呢

然後是 pack i 加 1就是 deal issue 的时候它是用這樣子的一個情況就是 pack i pack i 加 1這個 add 它就是把 load從 memory 讀出來的資料拿出來做運算所以它是在 executionadd 的 execution stage會使用到它這個 store 呢store 它也是拿 load 它的結果要來當作 base addressbase address 它在什麼地方使用到呢它也是在 execution stage 對不對因為 store 它是要去算它要把紙存到 memory 的什麼地方算 memory 的 address 也是在 execution stage所以這兩個 instruction 都是在它的 execution stage來使用到 load 的一個 output如果說是

single issue的这一种情况的话我們可以发现到load在这里的时候aid就可以进来了load在这里的时候aid就可以进来当你load在这里的时候aid就到这里来然后这个时候store就到这里来所以我们如果看這三個instruction的話呢我們說store什麼時候進來我們說這個假設load是在load是在dk個clock cycle那aid呢它就是在dk加2個clock cycle進來然後store呢它是在

dk加三个class cycle进来这是single issue它是这个样子这样子的话它不会有hazard的问题它不会说进来还要被store它就可以进来以后就可以很顺利的在publine里面把它走完这个是我们说single issue我们现在来看如果是dual issue的情况呢dual issue的情况就是我们这边提到的这个是pack i这个是pack i加1

当你load在这里的时候add跟store一起进来对不对add跟store它是一起进来的所以这个时候我们说load它是在第k个clock cycle进来然后下一个pack是add跟store这个packet它是在dk加2个cycle进来所以其实它们在解决hazard的情况并没有什么特别它所碰到的情况所碰到的问题解决的方式都是一模一样但是差别就是在我们提到的说假设有这种case的话我们可以发现说在dual issue它有没有game有没有game

有啊它有gain 对不对它还是有得到好处它得到好处是什么呢它在k加2个cycle的时候它是进来了两个指令这个store它原本是k加3的时候才会进来那你现在deal issue的时候它k加2的时候就进来了它k加2就进来了所以对store而言它提早了一个clock cycle进来所以我们就等于是提早时间就把这个store就把它执行完毕所以这个是这个dual issue他们在讨论这个dual issue的时候

这个地方要注意的就是说他可能不是讲得很清楚那实际上他说他一样是one cycle的use latency但是他现在是一次进来两个指令同学说那有什么game吗当然有game我们刚看到的那种situation他就是会把第三個指令 Store提早一個 cross cycle進到這個 pipeline但是這樣子的一個機制我們知道說其實我們的scheduling相對的它會比較複雜我們的

scheduling你也必須要就是你就是要很這邊寫的就是說你必須要那種aggressive你要很積極積極進取你要想盡各種辦法把所有可以擺到前面的就是你可以做得越多的話你的 gain 就越多那你如果還是就是 sequential 的去 pack然後不行 然後就把它 delay那你這樣這個效能大概沒有辦法 improve 太多所以這邊是這裡面提到的那接下來我們來看一個課本的一個例子這個例子就是把這邊有五個 instruction那這五個 instruction 我們要把它透過這個 dual issue 的一個機制

我们来看说这五个instruction它有没有办法可以让performance得到比较好的结果首先我们来看这里面很明显就是这三个指令它有data dependency这两个指令看起来好像也是有data dependency因为这后面两个都是S1前面三个都是T0它们都是针对T0在做operation所以右边这个是它的中文解释instruction是做什么同学

可以自己看一下针对于这样子的一个情况我们一般做法我们说第一个这个load这边已经是to issue所以我们把load我们就把它丢到这边这个cycle丢到这个cycle我们就说我们就是要放第二个指令我们说这第二个指令可不可以跟它摆在一起我们知道说这个是load use这是它的output这是它的input

所以这是标准的load use hazard所以我们知道说load跟add u第一个它不能够pack在同一个packet里面你不能放在同一个packet里面所以它是不同的packet不同的packet它可以怎么摆呢第一个绝对不能摆这里这里也不能摆根据我们刚刚的讨论我们知道说它必须要摆这个地方所以我们就把这个add U

这个第二个指令把它摆到这个地方来我们把它摆到这个地方来之后我们就会发现说这个storestore是跟ADDU相关的，那你store ADDU还没有执行，你当然也没有办法执行，所以store它能摆哪里呢？它当然不能摆这里，也不能摆这里所以它的store也只能够摆这里，因为是ADDU算出这个结果之后，store才能够把它存

进去。所以我们从这里面就知道说，从这样子下来至少这三个，我们第一个填了，这一个第二个填了，这一个第三个填了，这一个接下来我们当然就要想办法说，有没有办法把后面的一些指令，把它往前搬？你后面的指令往前搬，第一个我们看到的是什么？第一個看到的就是所謂的ADDI，ADDI基本上它

是使用到S1，你這個S1前面這三個指令，並沒有任何一個指令，它的output會更改S1前面這三個指令都沒有一個instruction，它的output是要去update S1，所以你S1在這裡面是固定的。我们在这边呢，我们S1这个指令ADDI这个就可以把它搬到前面来，所以我们同学就可以看到说，你摆这里摆这里其实都一样，但是你摆这边等于这边两个都是no operation，那我们摆在第二个看起来比较好看，每一个cycle都有指令进到part 9所以我们把ADDI把它摆到cycle 2可是我们把它摆到

把後面的往前擺我們就要注意到說後面的這個指令它實際上是更動了S1這個register的內容S1的這個register的內容它會被誰用到呢我們在這裡面看得到的就是什麼呢在這個call sequence store它是先用了S1當base addressS1用完之後後面的ADDI才去把S1檢視現在不一樣現在我們已經把S1

先檢視檢視完之後這個Store才會執行所以這邊就是變成說我們就必須要把這個Store的offset因為已經先檢視了所以這邊我們就把Store這邊的offset0變成正式所以這樣子就做了一個update所以这个纯粹就是我们把后面搬到前面之后我们要看看它动了哪一个register然后再看看这个register在前面被谁用到最后BNE就是摆在跟store摆在同一个slot所以我们在这里面就可以

看到它的一个最后的一个dual issue的一个arrangement就是变成这个样子所以它原本是1 2 3 4 5它原本是五个cycle complete我们现在变成四个cycle所以它就是IPC等于四分之五1. 25它的pick IPC是2所以2跟1. 25基本上它就improveimprove了25%所以这是我们在课本里面看到的一个例子我们看到这个例子

好像它的game并没有很多实际上还有一些方法课本这边介绍的就是所谓的loop enrolling顾名思义loop enrollingloop我们知道说我们的program里面一定是有很多loop这个loop就在那边跑举个例而言这里面看到的一个case它说for i等于5i大于等于0i减减AI等於AI加5這是一個loop的指令如果我們把這個loop把它展開來實際上它是做什麼事情呢這邊好像寫錯了這邊一開始是I等於5所以這邊應該是從5開始我們假設這個是對的

所以你把它展開來之後就是A4等於A4加5A3等於A3加5所以基本上它是針對一個Array它的ElementSequentially去對每一個Array的Element它把這個0到5之間全部都怎麼樣呢 都加5每一個Element它都加5所以這個是我們用這種High Level的Code來看的話我們可以很清楚的知道一件事情

什麼事情呢我們在這個Loop裡面我們看到的它每一個都是叫AI我們如果是用它的Name來判斷的話AI好像每一次加都是AI等於AI加多少所以你這邊總共加了6次的AI所以这AI都是什么data dependent它都是对这个AI来做加法所以它好像都是同样的一个变数如果我们是看这边的话看起来好像都是这六个加法的硬算式子都是data dependency可是我们用这样子来看的话展开来我们就知道说A4 A5 A4 A3 A2 A1 A0

其实都是不同的location它指的都是不同的memory location的一个valueA5 A4 A3 A2 A1 A0它是不一样的它们之间根本完全没有任何的data dependency所以这是我们从high level的一个program的code来看我们可以很明显的知道说它们之间是没有data dependency如果我们是用MIPS我们用 miss 的 instruction我们来看类似的 code我们说这个 code 可能它在这个 loop 的 code可能就类似长得像这个样子它先 load然后 s1就是 load 它把 s

这个 base address把它叫出来然后接着就是这边就是譬如說它這邊這邊就是把這個Array的Element讀出來之後接著做了一個加的operation加完以後再把這個值再把它Store回Array裡面的Element然後接著這邊就減4減4之後它再繼續再做下一個下一個Iter ation所以它是一直对这个element做同样的事情只是说这边是A4

这边是A3这边是A2 这边是A1所以它每一个copy基本上其实就是在high-level的program里面对应一个loop的一个iteration当我们把这个loop所对应的mipscode把它展开来其实它就长这个样子所以你如果要loop要执行4次的话它展開來就是這個四個copy四個copy長的是一模一樣長的是一模一

樣它是ADDI減四然後接著就是element的下一個array的下一個element然後讀出來加再寫回去然後再減四然後再下一個copy就是array的下一個element所以它就是四份copy所以當我們在分析這四份copy的時候同學你會不會覺得說這個t0它的input就是它的output所以它們之間有沒有data dependency有沒有 有 對不對這邊t0 這邊也t0這邊也t0所以它跟它有dependency它跟它有 它跟它也有

你copy的 不管你copy幾份每一份的load的T領這些全部都跟前面的都有data dependency所以你會發現說你copy越多份你的dependency的數目越多越來越複雜那你說那我幹嘛要做loop enrolling你把它展開來展開來是dependency的數目變成一大堆這樣變得非常的複雜這個有什麼好處呢一點好處都沒有所以实

际上我们刚从这边已经看到了它的每一个iteration这一个值都是不一样的值都是不一样的值一个是A5一个是A4一个A3一个A2一个A1一个A0它指的都是不一样的值只是我们在MIPS里面我们这边都是用register我们是用register我们不是用这种array index你从array index就可以看出它

是不同的variable不同的location但是我们在MIPS里面是用register那你register的name是一样的所以你看起来它都是data dependency所以这一种错误的印象就是所谓的anti dependency它实际上并没有data dependency但是却是因为使用同样的register让我们误以为它是有data dependency所以我们就会把它的这种schedule做出比较不好的

结果所以这种就是所谓的anti dependency如何解决这种anti dependency呢这个方法就是所谓我们就是要用什么呢就是要去把这个register的name把它改掉把它rename把它改掉因為我們知道什麼呢，我們知道說這個值跟這個值是不一樣的下一個copy的值跟前面兩個的值也是不一樣，它們的location都是不一樣，一個是值

到A4，一個值到A3，一個值到A2，所以我沒有必要每一次都是使用什麼呢都是使用T0，我就第一個copy用T0，第二個copy用T1，第三個copy用T2，再下一個copy用T3，我就直接把它改掉，所以你把名字改掉以後，我們就可以把原本誤以為它有data dependency的這一種假的這種anti dependency，我們就可以把它解掉，所以這個就是loop unrolling的一個機制，所以我們來看一下，我們假設說，有四個copy，這四個copy同學記得，第一個是load，

第二个是ADDU，第三个是Store，那Load跟ADDU跟Store呢，它们同样的，就是ADDU跟Store都会用到什麼呢，这边都会有T0这个T0就是Load的一个outputT0，那ADDI呢，它是把S1做一个减，所以我们把这个copy成四份，我们可以来看它是怎么schedule這邊应该再把那四份codecopy在这边当作一个reference，我們來看這個是它原始的，這份codeload addu，然后还有一个store，还有一个add i就是-s1-4，就是用s1-4所以它每执行完一个iterations1它就-4所以

load理所當然是放在第一個slab第一個packet接著跟它相關的addUaddU我們知道說這邊怎麼樣它必須要跟它隔一個clock cycle所以這個是clock cycle1所以它進來的時候就是clock cycle3它就是clock cycle3接著我們來看它把addIS1一次就减掉什么呢减掉16因为同学可以看到我们如果有四份copy的话

它其实是有四个ADDI它每一个ADDI都是把S1的sequential形序的一次减4一次减4所以你总共要减4次你总共要减4次减4次所以就是total减掉16那干脆就一次就把它减16把它减掉所以同学就是说你可以看ADDI它这边就剩下一个而已而且它把它搬到最前面来它一次就减掉16那一次减掉16以后会发生什么样的一个情况呢后面不是还有三个loads1 0对不对它还有三个第二个load

我们已经把这个T0改成T1了后面三个copy一个是load T0第一个是load T0第二个copy是load T1第三个copy是load T2第四个copy是load T3它为什么要把load都先摆前面呢因为我们知道说load use的data hazard一定要有一个 cycle的use latency它的ADDU一定要跟load要間隔一個clock cycle才能夠進來所

以我們最好的scheduling就是你如果可以把所有的load盡量往前擺的話對整個performance是有幫助的因為你的load如果越往後面擺的話跟它相關的ADDU它就要越擺後面所以我們這邊的policy就是第一個policy就是把四個load盡量往前擺所以這裡它就把四個load連續擺在前面四個class cycle所以這是四個copy的load所以我們來看第二個

load以這個例子來看這是第一個load這是第二個load第二個load執行第二個load之前它會先SI S1-4它會S1-4所以S1-4之後他才會執行第二個load你要執行第三個load的時候最前面的S1要減多少 要減8再來就是S1要減12所以這邊第二個copy是減4再來是減8 再來是減12所以我們來看他已經先把S1減16了減16之後我們就把offset改掉就好了

所以-16加12它变多少-4它就变-4这是第二个copy第三个copy它应该是要-8它应该是要-8这边已经减掉16了这边加8所以它就变-8第四个copy它要减掉12一样它已经减掉16所以这边就是加4-16加4它就是等于多少就是等于-12所以我们完完全全跟前面的那个

例子是用同样的方法这个同样的方法它就是使用改变这个offsetoffset的constant可以改变它改变这个offset的这个值来使得它所address的那个location是同样的所以同学我们可以看到前面四个load摆好以后它的相关的ADDU就容易了这边间隔一个class cycle第二个copy也是间隔一个class cycle第三个copy也是间隔一个class cycle第四个copy也是间隔一个class cycle它的register都被remame

都已經不再叫T0因為他們是指到不同的location沒有必要用同一個register name來讓人家誤會所以這邊就從T0改T1第三個copy從T0改T2第四個copy從T0改成T3同學這邊update一下這邊的T3這個load跟add排完之後當然接著就要排storestore也是一樣我們就照著這四個順序store t0store t1store t2store t3同學記得我們的store這邊原本都是0

现在的store你的offset也必须要改这是第一个copy这是第二个copy这是第三个copy这是第四个copy，第一个copy的store它的offset是多少是0结果这边为什么变16因为它前面已经给人家减掉16了，所以你这边要加16所以16正负相减正负相加它这边就是变成它的offset是0第二个copy它的store应该是-4这

边-16这边就加12加回来加12所以就变成-4第三个store应该是要-8所以-16加8它就变-8然后这边第四个store它要-4所以是-12它这边-16加4它就变成-12，所以这个就是我们要注意的永遠都是你必須要去update它的offset最後再加一個bme，所以我們就可以很漂亮的把這個四個copy把它schedule在8個cycle裡面，它原本是4416个指令，这边不是算16因为它是算这里面有多少个指令，因为原本是四个ADDI其实它现在变成一个ADDI它变成一个ADDI，所以我们就可以发现说使用这个loop enrolling我们的IPC就可以变成这个1. 75可以得到比较好的improvement到这边同学有没有问题

你說這個嗎沒有 是0你是說這個嗎因為因為我們可以看我們說第一個copy它都是0這個0是基於S1是一開始的S1我們可以來看這個例子這個load當它access S1的時候它的S1還沒有被update它還沒有寫回這個它還沒有到writeback的一個stage所以它還是Original的S1所以它就是0但是到這裡的時候因為它已經被update了所以要改成是6同學這個問題非常好就是這邊的最主要的差異就是在這個S1的這個值有沒有被update差異就在這個地方還有沒有問題

因為它大概是使用什麼呢它是使用Forward它使用Forward因為Forward它是只要滿足這一種可以Forward的condition它就Forward了它不會說我這邊不要Forward所以它不用改這個它是偵測到它可以Forward它直接就forward所以这边它是使用forward过来的新的S1的值同学还有没有问题同学的问题都很好这样子对这个就会更加的清楚

我們把這個講完好不好我們接下來看Dynamic的Multiple Issue下一堂當然不會耽誤同學太多時間先看一下下一堂有課的同學舉手因為同學可能要趕教室下一堂課有課好 我們利用兩分鐘把這一頁講完就好我們來看一下Dynamic的Multiple Issue我們前面看到的是static multiple issuedynamic的m

ultiple issue我們把它稱作叫superscalarsuperscalar它是一個就是說它在issue這個instruction的時候它是一個動態的機制它不像我們前面static就是它已經把它pack就是pack在不同的packet裡面有兩個或三個或四個它就固定按照这样子把它摆好dynamic multiple issue它最主要的一个精神就是在它在执行的时候

它可以out of order它不一定要根据我们的code sequence怎么说code sequence是这样子的一个顺序一二三四五六七八九它的execution的一个order就是follow这样子的一个sequence它不需要所以它就是所谓的dynamic这样子的一个机制我们就可以想见的就是说这个机制一定会变得一个比较复杂的一个机制所以我

们说它是一个advanced的一个publine的一个technique它可以enable它可以允许这个processor去执行就是一个class cycle可以执行超过一个指令它就是在execution timerun time的一个stage在决定我现在要执行哪一个指令所以它不是说你事先已经schedule好它就是follow这样的一个sequence它是runtime的时候动态决定谁

要来执行所以它每一个cycle我们的CPU都可以决定说我要执行谁谁谁因为它每一个run time的时候它complete就是前一个class cycle哪一些指令complete之后它就可以决定说下一个class cycle哪一些指令要执行当然你必须就是要避免structure hazard跟data hazard当然就是说你这样子的话我们就是可以避免透过compiler的一个scheduling当然compiler的scheduling如果有帮助的话你还是可以由compiler来做一些适当的scheduling但是实际上它真正最后决定谁要执行

它是由这个Hardware所以我們下一堂課會看到它是如何透過這個Hardware來決定說Runtime的時候決定這個Class Cycle哪一些Instruction要丟到這個就是要丟到這個Functional Unit裡面來做這個執行，這是Dynamic Multiple Issue跟Static Multiple Issue最大的一個差別那我們今天先介紹到這個地方.