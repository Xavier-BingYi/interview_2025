undefined
我們就是開始跟同學介紹第四章，第四章的內容就是我們這門課裡面最主要介紹Processor，它一個很重要的一個章節。在以前比較舊版的課本，它其實還包括它總共介紹了三個版本的CPU。在現在新版的，它把其中一版把它拿掉，所以我們就介紹兩種版本的CPU，還有加上後面的Publine方面就是Parallel的功能首先，我們來看一下，就是說我們知道說我們的CPU的Performance，我們CPU Performance的Factor。我們從前面的介紹，我們了解說跟這個Instruction Count有這個關係/Instruction Count呢，

它是由instruction set architecture還有compiler它可以來決定我們要執行的program，它的instruction的指令到底有多少個，也跟CPI平均每一個instruction它需要多少個cycle還有每一個clock它的cycle的cycle time大概有多長基本上就是跟這邊有相關。在我們這個章節裡面，我們討論的其實最主要就是會影響到CPI還有Cycle Time，因為這兩個Factor，它是可以由CPU的Hardware來決定。我們說我們CPU的Hardware當然就是由我們的Circuit設計在我們這邊我們討論的設計大概只有Gate Level還有Structure

我們不會討論到Switch Level方面的設計所以我們在這個章節裡面我們會來探討一下兩個MIPS它的Version Implementation其中一個是比較簡單的另外一個是比較就是說現在的CPU當然都一定會有所謂的Popline如果沒有Popline的話它的效能大概都是非常的差所以我們大概就是會來看這兩個version的這個設計在我們的這

個設計裡面我們當然不會包含整個MIPS的它的instruction set的這個whole set我們不會把整個instruction set全部包含進來因為那個太複雜了我們大概只會看到的就是一個simple的一個subset包含的這個必要的Memory Reference InstructionLoad Store然後還有Arithmetic還有Logical InstructionAdd還有SubtractionEnd AllSet Less Than然後還有Control TransferBEQJump所以我們大概基本上我們有這幾個指令我們大概可以完成應該蠻多的program所以，我们大概就是把最重要的這幾個kernel的instruction

把它放到我們的討論範圍裡面其他的instruction其實同學有興趣也可以仿照課本的討論把它加到CPU的hardware design裡面。首先我們來看instruction的execution我們要了解就是說我們要來討論CPU的design我們當然要先知道一下說我們在CPU執行一個instruction它到底包含了哪一些。首先我們知道說我們要執行 instruction 之前我們要先把 instruction 先把它讀進來instruction 當然就是放在 memory 裡面，所以我們會有一個所謂的 program counterprogram counter 它是指到 instruction memory指到 instruction memory 裡面我們就是根據 program counter然後從 memory 裡面去抓 instruction

過來執行執行完之後這個point counter它自動會加4再指到下一個字令所以這個主要是用來做fetch instruction用的。 мы也會有所謂的register我們的register number其實它就是指到register file裡面的某幾個register一般我們會譬如說這個rtype我們就會指到兩個register把它讀出來然後接著再去再去執行執行完之後我們會把 output 再把它寫到某一個 register這個就是我們需要有 register 的 number另外我們就是說根據我們的 instruction 的類別我們會來讓 ALU 做不同的 operation做不同的 operation 是指它的 operation

到底是 for 什麼目的不同的instruction case它有不同的目的譬如說我們的errorU我們可能是純粹是算一個 arithmetic的結果也就是說這個指令基本上它就是要執行一個 arithmetic operation的instruction所以我們errorU當然就是拿來算這種算術的運算另外一種如果說它是load stored我們要做這個memoryreference我們知道說我們需

要去算memory的edges所以這個memory edges的computation我們就是也要用LU來做這個運算或者是我們如果是一個branch需要branch equal或者是branch less than之類的我們就是要有這個branch的target edgesbranch target edges就是由LU來算這一類的，就是用 ALU 來計算，只是 for 不同的 purpose另外我們也必須要去 access data memory，. look你是要去讀還是要去寫另外還要做 PC 加式這個 PC 加式也是一個加法，這個加法就是要去算 sequential execution它的 target address所以我們看到

基本上我們會有 ALU 的動作也會有 Data Memory 的 Read 跟 Write也會有 Targeted PC 加 4這麼多的運算如果說我們這些運算全部都是要由 ALU 來完成的話，我們會發現說即使我們的 ALU 在某一類的指令它會非常的 busy因為它要做不只一次的運算所以我們等一下後面會看到說在我們的 CPU 裡面我們的 ALU 並不會把這些這麼多說的事情全部都把它統籌全部由它來執行，因為分一些 operation 出去我們來看一個根據我們剛剛的描述

我們的CPU它的一個structure大概就長類似這個樣子當然最後我們的version不見得會長得跟這個一模一樣但是根據我們剛剛的描述同學可以看到這邊有一個ProgramCounter，ProgramCounter它就是指到我們的input address，這個我們會根據它的 address去到它的位置去讀出一個instruction所以我們這邊看到的是什麼呢，這個就是叫instruction memory我們在這裡把memory把它分成兩種一種是data memory，同學會說我們不是memory只有一塊嗎？我們這邊是suppose說我們假設我們的

memory假設說它一個clock cycle裡面，它大概就是可以做做这个read write，就是它可以做一次read一次write，它没有办法做兩次read或者是兩次write，suppose它沒有办法做它只能够做一次。如果是这样子，我们如果想要在一个clock cycle里面把这样子的一个flow把它跑完的话，我们铁定要把memory把它拆解成两种类别，一個是instruction memory，一個是data memory為什麼

呢，因為我們如果memory只有一種就一塊，所以就是說這一塊，它也是儲存instruction也儲存了data，同學可以合想而見第一個，我們要read instruction，instruction要read得出來呢，萬一它是要做什麼呢，它是要做load-load我們還要再從這個memory讀一筆資料出來，所以等於他要做兩次load，他要做兩次read 對不對這樣子就沒有辦法滿足就是說

我們的要求他希望在一個class cycle裡面把它完成所以我們在這個版本裡面我們必須要把memory把它分成一個是instruction memory一個是data memory這個instruction就是他的input來自於這個program counter他讀instructioninstruction讀出來之後它會告訴我們說你要讀這個比如說register read 1register read 2register write所以你要去哪邊讀兩個register就是從這邊過來你的運算的結果要寫到哪一個register就是從這邊來決定這個都是從instruction裡面讀出來就知道了Program counter它讀出一個instruction之後

我們發現說如果是Sequential Execution它就是透過這個PC加4所以如果是Sequential Execution它就是PC加4這樣子就是從這邊過來所以它就會再讀下一個指令然後PC加4然後再讀下一個指令所以它是一個Sequential Execution同學可以發現說這個它不是在LU這邊執行因為我們LU它有很多事情要做如果說我們要在一個class cycle裡面完成的話像這種固定你都是做一個加式的其實我們就是可以用另外一個adder來執行就可以

不需要把這個工作丟給這個LU來做因為你如果LU要做PC加式然後又要再去算其他的operation那你這個LU會非常的忙所以你在一个class cycle里面可能没有办法完成你如果一定要完成的话你的class cycle就会拉得非常长所以我們大概就是這邊用一個PC加4接着我們再來看如果是R-type學生可以看到register1 register2LU的兩個input operand它都是從register5裡面读出来

讀出來之後就是加減乘除所以你做了一個因算asmetic的operation 因算完之後從這邊feedback回來這個data是什麼呢這個是write的input datawrite address在哪裡呢它可能就是透過這個input port就是要write到register file裡面的哪一個register它的input就在這個地方所以它再把它寫進去所以這個就是所謂的R-type如果是一個load的話load是什麼呢

load就是我們要從memory讀一個資料把它寫到register所以我們要怎麼做呢我們已經知道說它必須要有一個base的addressbase address就是從register這邊讀出來另外還有一個offsetoffset是从哪一边呢同学应该还记得offset就是从instruction的后面的16个bit它就是一个operand它就是一个值它就是一个value这个const呢我们就是跟它的base再加上一个offset我们会算出我们要去memory的哪一个address去读data所以如果是load的话

这个LU算出来的不是从这边feedback它是从这边过来它走这条路所以它会定指到data memory里面去定指一个address这个location被identify之后它的data就从这边读出来然后读出来拉到这边所以这个又是一个write operation的input operand要写到什么地方去呢就從這邊決定然後它再把它寫進去這個就是所謂的load如果是這個store呢store我們知道說就是要從register裡面去讀一筆資料然後寫到memory讀一筆資料我們就知道說第一個

它需要一個base的address它一樣是從這邊base的address第二個它需要一個constantconstant value也是從instruction這邊直接拉過來所以拉過來到LU所以一個是從register file一個是從instruction這邊所以它就會算出要寫到memory裡面的哪一個location它的value是從哪邊來呢它的input datawrite input data是從這邊過來的因為我們是要從register裡面某一個

register把它的值把它讀出來讀出來之後透過這個line拉到這邊它就是這個store的write operation的input data所以如果是store的話就是走這條路然後再把它寫進去所以我們就看到一個是type一個是load跟store如果是branchBranch怎么走呢Branch就是我们这边我们刚刚看到的这一条是Sequential Execution这边还有一个Multipressor就表示说我们Feedback到Program Counter的除了Sequential Execution之外还有一个什么呢就是Branch这个Branch呢这个Branch就是什么呢我们前面提到的它的Target address就是PC加4再加上一个Offset

那个offset从哪边来呢offset也是从inst ruction这边过来的所以这个就是PC加4然后这个是offset加完之后这个就是branch的target address所以这个算完之后我们刚指错了我们刚sequential execution不用经过这一条sequential execution就是直接这样子回来這是Sequential Execution 更正一下如果是Branch的話就是PC加4再加上offset這個就

是Branch的target所以你如果是Sequential Execution就是走這一條如果是Branch的話就是走這一條這邊更正一下所以這就是BranchBranch到底要不要Branch是從哪邊決定的呢我們當然就是它要比較到底是不是一樣然後再決定要不要 branch所以它就是透過 ALU 做一個減法它做 comparison就是 input operand 1 input operand 2然後在這裡面做一個 subtraction那它如果 0 flag 被 turn on 的話就表示它是 equal這兩個值是一樣的 equal那 equal 的話它就會選擇是走這一條

就是這樣子所以我們可以從這一個簡單的一個CPU的structure我們大概就可以trace我們剛談到的那幾個operation R-type 就是RAW store然後還有BRANCH大概就這幾個指令所以其實基本上第四章前半段的內容差不多就講完了就是在講這些只是說我們後面呢我們會慢慢的把它的information越來越多的

informationattached到這個flow裡面同學會發現說線越來越多然後好像越來越複雜其實這個觀念就是我們剛剛trace的flow在剛剛提到的這個flow裡面有三個地方我們剛剛都有說它有兩條路比如說sequential execution是走這一條如果是Branch的話它是會走這一條所以這個地方表示它有什麼呢它有兩筆Data會在

這個地方匯合對不對它會流經這個地方匯合匯合我們在Hardware裡面Signal裡面你二選一就是什麼呢就是Multi-pressure兩個選一個這個就是兩條路兩筆資料選一筆讓它通過這就是Multi-pressure我們剛剛看到的 ALU 的第二個 operand 它有同樣的情況ALU 的第一個 operand 它的 source 一定是來自 register第二個 operand 它有的來自 register 有的來自 instruction 就是它的 constant所以是二選一 所以這邊也必須要選一個

加一個 multiplex er還有這一個我們說register file如果要write執行這個write它的input data一個source就是從ALU的運算而來這個就是rtypetype運算的結果直接寫到register另外一個如果是load它是從memory讀一筆資料過來然後到這邊所以這也是兩筆input選一個讓它通過到这边所以这个是一个Multipleaser所以我们可以看到这个Multipleaser就出

现了这个是Sequential Execution这是Branch那Multipleaser它必须要有一个Input Selection它的Input Selection就是来自于就是说第一个这边做一个End这End表示什么意思呢因为我们这个Multipleaser基本上就是要选择说决定它到底是Sequential Execution或者是branch所以第一個你必須要由這個instruction去判斷它到底是不是branch這個指令如果它是branch這個指令所以這個flag就會turn on它是1如果是branch的指令它就是1而且 ALU做comparison之後做一個減法它是00表示兩個相等

所以 branch 跟 0 兩個都是 1 的時候它就會選擇 branch 的 address如果它不是 branch 的指令如果它不是 branch 的指令這個是 0 這是 0 的話這個就是 0 了或者它是 branch 的指令但是它們相比之後不相等這個也是 0這個是 1 這個是 0所以它就會選擇 sequential execution就是這樣子另外这边就是我们刚刚提到的这个是register的

write input一个是来自于LU一个是来自于data memory另外这边有一个这个东西这里面我们后面要讨论的一个就是control unit同学现在先把它当作就是一个breakbox这个breakbox它的input是什么呢它的input就是instruction它的instruction其中的某幾個field它會當作control unit的一個input它從這個instruction的指令它就會決定 它就會知道說這個instruction到底是哪一個instruction它是rtype 還是load 還是store還是branch 還是setless than之類的它會知道當它知道以後 它就會把這幾個

這幾個 multiplexer的input selection設定成適當的值比如說它決定要不要做一個register write如果是rtype的話它的control unit就會把這個設為1就會enable register write因為rtype我們運算的結果是要存回這個register如果是branch的話 branch的指令这个control unit它就会把register write把它disable你把它disable之后你就不用担心这个资料

是什么它的target是哪一个你就不用担心因为你把它disable之后这个register它就不会做write的指令所以这个control的signal基本上它就是等同于turn on turn off或者是enable disable只要是 enable 的話它就會做一個 write如果它被 disable 的話它就不會做 write所以通常我們在控制這種 write或者是不 write通常都是由一個這樣子一個 write enable 的一個 flag 來控制你把它 disable 之後你都不用擔心這個值是什麼東西同理 data memory 也是一樣data memory 我們這邊有一個 memory write

你只要把MemoryWrite把它Disable掉之後你不用擔心這個值是什麼這個值是什麼因為它完全不會做Write你如果把這個En能够之後這個Edges要算對這個值要對的值送過來就是這樣所以基本上這個Control就是在設這些MultipleSer這個值要怎麼設呢我們等一下會看就是說在這一個章節裡面我們會看

到說這個值到底要設0還是設1還是要設其他的值。在我們正式介紹第一個version之前，我們先這邊有review一下同學，在Digital System或者是Logic Design不同的科系，它的名稱不一樣就是數位電路設計，同學有學過這個 combinational circuit design還有 sequential circuit design。我們很快的把它go through一遍。我们知道說我們在这个digital的system裡面信息encode就是in binarylow voltage是0 high voltage是1one wire per bit，你 multi-bit data encode就是可以把它encode在multi wire的这个bus上面

另外最主要就是两個Element，一個Combination Element，一個是Sequential Element或者是State Element，这个基本上它就是在做Booting Operation，它有一個Booting Function這個State Element它就是做一個StoreStore的一個動作所以這個and a的Multiplecessor arithmetic這個我們就不用再跟同學介紹了Sequential Element這邊看到的是所謂的Register所以我們這邊有一個Clock這

個Clock這邊描述的它就是屬於Positive Edge Triggering它只有瞬間Rising的時候它這個Data可以把它寫到它的Output裡面來所以它的Output會做一個改變就只有在這個地方它會做一個改變一般我們剛剛看到的會有一個WriteEnableWriteEnable就是當你是WriteEnable的時候它才有寫入的功能這個W

rite的Flag被Disable之後你不管你的這個D你的Input怎麼改變你的Clock怎麼做這個Triggering它都沒有用所以同學可以看到在這個WebFont上面就只多了一個Write這個Write的E的時候它在triggering的時候它才會做write的功能這個output才會做改變當你write是0的時候這邊有一個triggering但是它的output不會做任何的改變在enable write下一個triggering的時候

它又會做一個改變所以基本上就是多了一個write的功能這個我們之前就跟同學介紹過了就是Clarkin的mystology基本上我們一般general的design有包含sequential還有combinational的circuit我們可以把它model成這樣子的一個簡化的一個graph就是我們這邊有所謂的state element它裡面有很多state element它的output就是所謂的combinational logic的input我們把它算完之後

然後feedback回到stack element的input來改變sequential的circuit所以我們說這樣子的circuit它的longest delay就決定了clock它的cycle time之前都有跟同學介紹過我們在設計一個CPU我們前面第一章就有跟同學介紹說CPU裡面它基本上包含了兩個部分一個是datapath一個是control circuitdatapath基本上是做運算的核心做 arithmetic logic operation如果是control的話當然就是決定我們剛剛看到的那些決定那些 flag或者是input selection就是做這些設定指揮datapath所以我們後面

就要開始跟同學介紹要如何build一個MIPS的一個datapath我們方法還是follow我們剛刚看到的這個就是從一個一個instruction一次介紹一個instruction首先我們在介紹這個instruction之前就是要執行instruction之前第一步一定是要去做一個fetch instruction fetch的一個動作這個我們前面大概已經有解釋過了它是一個sensor bit的register program counter它指的這

個就是instruction memory它的read address所以根據這個位置我們可以讀出一個instruction然後這個sequential execution就是加4這個沒有問題如果是r-type我們要執行instruction讀進來之後我們decode我們decode知道說它是一個R-format的instruction我們說我們可以讀兩個register operand執行 arithmetic或者是logical operation然後再把這個結果再把它寫回register所以我們這邊說read register 1還有read register 2，這個就是讀兩個input operand ALU的input operand，它的

要去哪一邊讀就是這兩個決定的WriteRegister就是你LU算完之後結果要寫到哪一個Register寫到哪一個就是由它來決定的要把哪一筆資料寫進去就是從這邊進來這筆資料要寫到Register裡面，所以它讀出來兩個output，這個output就是接到LU兩個input這個LU同學應該還記得它有4 bit的control signal LU operation，它有4個bit我們上

禮拜才剛考過它就是有這個a invert b invert然後你要選擇兩個從4個operation裡面去選擇一個來當output所以它需要multi-pressure，就是4選1，所以需要兩個input selection，所以這個就是我們看到的R format基本上它需要的element就是這樣子load跟store我們知道說它要去read一個memory的value然後store就是把它load到register或者是你要把這個值把它存到memory裡面去所以基本上就是有一個data memory，

那你有這個MemoryWrite MemoryRead然後這個是不管你是Read還是Write它的Adress那你如果是要Write的話它的InputData就是從這邊過來那你如果是要Read就從這邊讀出去那同學應該還記得就是說我們LowStore我們要算它的Adress的時候要一個Base加上一個Offset可是我們的Base是32bitLU也是32bit所以你必須要做一個sine extension這個sine extension就是從steel bit到32bit的一個sine extension的一個unit這樣子的話才會能夠位到LU的second input它的input operand就是這樣子如果是branch的話我們知道說branch它要

決定要不要跳要先做一個比較這個比較是從register的operand這邊讀出來所以它要read比較是透過LU做比較它是做減來看看減的結果有沒有turn on這個zero flag如果有turn on就表示它的comparison的結果是equal另外還有一個它必須要去算targets因為我們的LU已經做了一個減法所以我們就不再把TargetEdges的computation把它放到

LU這邊來所以我們前面有看到我們就有兩個加法，一個是PC加4，另外一個在PC加4再加上一個offset，這個offset我們同學應該要記得，它也是一樣需要做一個sign extension它也需要做一個shift left shift 2 bit，因為它擺進去的時候是一個Word，所以我們要把這個Word把它換成byte然後接著再加這個PC加4就是這樣，所以它要做的operation就是這些，這些operation我們可以看到的，我們需要的component就在這個地方，這個首先

我們就是要讀兩個operand，所以register1 register2從這邊讀出來然後做一個減法，減法之後，它這邊會有個zero flag去決定到底要不要跳這邊，原本有一個PC加4，這個是target address的base，然後再加上一個offset，offset首先我們必須要把我們的constant做一個sign extension，sin extension 乘 32 bit 之後，再往左 shift 兩個 bit，所以這邊是 shift left shift left 2 bit，然後這邊才是所謂的 offset，這個 offset 接著就 base 加 offset 出來，就是它的 branch 的target，所以這個就是我們的 branch instruction它的 component我們在這邊首先要跟同學介紹的就是說

我們上上禮拜跟同學介紹的Sine Extension或者是所謂的 Left Shift by 2-bit這種東西基本上你不需要一個general的shifter因為你如果是一個general'shifter的話它也是需要一些delay我們可以來看說類似像這種Sine Extension或者是Shift它可以怎麼做因為它是Sine Extension我們知道說假設它是從1 2 3 4 4個bit變成8個bit它的做法很簡單就是這邊不變的

原本不變的你就是直接做一個Forward當你要做Sine Extension你就把這個Sine bit就原本4bit裡面的MSB那個bit做一個Copy的動作 直接拉出4條線它就會從4變8那你如果是16變32你就把16bit's MSB把它拉出去拉到上面的16個bit這樣子就變成16轉32的Sine Extension這樣子做的話基本上你並不需要額外的這種Hardware它只是一個Wiring的一個OperationShift也是一樣可以我們這邊Shift是怎麼樣呢是往左Shift

兩個bit而且右邊你如果每次要填的值都不一樣那你這個就要用Hardware來決定你右邊要填什麼可是我們的Shift是你往左Shift兩個bit右邊OS都是填領所以這個又可以Hardware把它寫死它就是右邊兩個OS都是填領進去這個都可以把它寫死所以你不需要額外的這個Hardware所以這樣子的一個operation就是一個bypass一個bypass就是直接送過去你要做shift的話就是右邊OS是甜點這個就是一個we worry的一個動作這樣子

就是一個shift left by 2 bit所以同學可以看到這個就不需要就是general purpose的shiftergeneral purpose的shifter它是什麼呢你要shift 1 bit 要shift 2 bit 3 bit它都可以做可是這種它有沒有辦法做shift left by 1 bit有沒有辦法 沒辦法它也沒有辦法做shift right by 2 bit它沒有辦法 它只能做shift left by 2 bit然後右邊填0 就這樣所以這種簡單的你就不需要透過那種general purpose的shiftergeneral purpose的shifter它可以shift left shift right1 bit 2 bit所以這個是

不一樣的這樣子它所需要的 delay當然就會比較多，所以我們剛剛已經把每一個instruction，它所需要的component，我們大概已經都介紹過之後，我們就要把這些component開始把它兜起來兜成一個簡單的一個CPU。我們來看，我們這個D版的CPU，它有什麼樣的一個特徵，這邊它說，我們的這個datapath，我們是一個class cycle，就一個instruction，就一個class cycle，就把它完成，所以基本上，

它並不允許什麼，呢它並不允許說，主要的那些component，在一個clock cycle之內，它要做兩次operation，這是我們剛剛提到的，它只能夠做一次operation，因為，如果要做兩次operation的話，你的data flow要控制好，不然，你怎麼能夠讓它，一個clock cycle裡面，让它做兩次operation然後，它的source是來自於不同的的input，所以你的這個flow，你必須要控制好那

你，如果flow可以控制好，它可以做兩個operation，那它的cycle time也會拉長，所以我們這邊就是說，它就是一個cut cycle，它會完成一個指令，所以這邊提到的說，each data pass element，它說只能夠do one function at a time，一次所以我們在這邊，我們就會需要把memory把它separate必須要next to separate instruction還有data memories必須要把它隔開來隔開來之後data read其他的部分有不同的data flow要merge你必須要透過multipleaser這都是我們剛剛提到過的所以首先我們來看第一個rtype的load跟store它的datapath

所以我們可以看到說這個是我們剛剛看到的 register然後它有一個 register write然後它的ALU 兩個 input第一個inputalways 來自 register第二個 input 它可以來自 register也可以來自 instruction透過 sign extension 兩個 source所以這邊要加一個multipressor如果是來自 register 的話，它的 input selection 是設為 0如果是來自於 instruction 的話，它的 input selection 要設為 1這個其實很重要這個已經透露出等一下你的 control unit到底要怎麼產生它的 value它都已經幫你設定好當然你可以這個是 1 這個是 0 都可以這個看你怎麼 assign

都可以另外這個就是我們剛剛提到instruction,16 bit變成32 bit另外還有就是如果說你要把資料從register寫到memory的話它就是從這邊直接過來、你如果說是rtype你的資料運算完之後要把它送回寫到register它就是走這條路把它寫進去、那你如果是从memory把值读出来的话它就是走这一条路所以这个multiplier到底要memory to register这个control signal到底要设1还是要设0就是由什么决定的呢由instruction type決定的当你的instruction如果是rtype你就要设为0

當你的 instruction如果是rtype你就要設為0當你的 instruction 是 Rtype你就必須要把 memory to register 設為 0因為你設為 0 它才能夠把 ALU 的 output透過 multipressor 回傳 register file如果說你的 instruction 如果是 load你必須要把 memory to register 設為 1它才能夠把 memory 讀出來的Memory的output data透過multiplecer回傳到register file所以這個就純粹是由control unit去decode instruction知道說這個是哪一個instruction然後它就決定這個是0還是1所以我們的control signal基本上就是由這樣子的一個方式來決定說

它要射0還是射1這個也是一樣就是說control unit它去decode instruction它知道說它要做一個store的一個動作所以它就會把memory write射為1如果它不做memory write它就會把這個control signal射為0所以基本上這個flow 同學大家都了解唯一的差別就是說這個要怎麼射我們等一下就會來看說這個 ALU operation 它是怎麼設

它是比較複雜一點不過也不會很複雜所以整個 database我們剛剛看到的 database基本上就是這個部分那整個 full database 就包含了什麼呢包含了 instruction fetch還有它的 sequential execution或者是 branch execution它的一個Flow所以這一條路就是所謂的Sequential Execution那PC加4就走這一條如果是Branch的話就是PC加4這個是Base再加上Offset那Offset就必須要包含我們剛剛提到的它把這個Constant經過Sine Extension轉成32 bit然後這邊再Shift Left by 2 bit然後再做一個加減完之後這個就是Branch的Target.

Branch的Target就是這個所以Sequential Branch 2選1然後回傳這個Program Counter其他這邊整個Flow都一樣所以這邊到這裡同學有沒有問題同學有沒有哪一條Path不是很清楚他在做什麼的這個不是指說當它的input同學不要誤會說這個0好像是當作data memory的input它只是一個output而已它這個線畫太長了讓大家感覺說好像它是要把這個結果位到這邊來它就是一個單純的output就是這樣。接著我們同學如果沒有問題的話我們就再來看這個LU的control.

LU的control呢這個就是我們之前在前面我們跟同學介紹的它會執行四個and all還有這個加減還有set less than這四個operation 四選一四選一我們根據這個解讀我們知道說 ALU control基本上它這四個bit它的順序它指的就是指a invert b invert還有這個multiplexer它的input selection這邊兩個bit所以這邊如果是做and的話我們知道你

不需要做invert所以它就00然後接著從這四個operation它選擇這個和這個是0所以它的input selection也是0如果是all的話前面也是00然後01它就要選這個1所以這個就01如果是加的話它也是00它不做invert 00那加呢 加是12所以它是10如果是減的話我們這邊就是A-B就是A invert它不做所以是0那B要不要做invertB要invert所以B是1然後接著它也是做加的動作所以這也是10

就是把B變成Tooth ComplementB的Tooth Complement就變成A加B的Tooth Complement就變A減B所以是從這邊出來所以這個也是毅力如果是set less than同學都知道說它就是在這邊它就在做這邊它也是做減的所以這邊是0 101之後這邊它自然加了它就會做減但是它這邊set less than它是選1 1就是從這個這邊出來它就做1 1

所以就是setless than如果是nor operation就是兩個a跟b都要做invert所以a跟b都是1 1因為你是a bar b bar做一個and它就會變成一個nor所以就是從這邊出來所以是0 0所以這個就是我們看到的ALU control這四個input control它的值相對應的operation就是根據這個table這個table很重要因為我們後面就要來決定說這一些instruction你要如何產生正確的ALU control如何產生正確的這四個bit的data首先我們要了解說

比如說 load 跟 store 它 ALU 是做什麼呢load 跟 store 我們之前就知道說load, store 它就是做 add它去算 memory address 所以是做一個加如果是 branch 它是做 comparison 所以它是做減如果是 Rtype 的話 Rtype 完全就是 depend on這個 Rtype 的指令到底是 and,或 或者是 add哪一種指令這些是由什麼決定呢是由instruction的function field同學應該還記得就是Rtype我們從OP code沒有辦法決定它到底是哪一個指令我們從OP code那邊我們只能夠引到某一個範圍接著再透過function field才能夠決定它到底是AND OR

還是 ADD的指令所以基本上就有這樣子的一個特徵這個應該講不完所以根據我們前面的介紹我們禮拜四就會跟同學介紹這張表格這張表格就是我們告訴我們我們要如何從一個instruction來產生 ALU 的它的這4個bit的control signal它的值到底要怎麼決定就是由這張table來決定的我們今天上到這裡.