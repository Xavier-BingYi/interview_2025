undefined
那我們繼續上一次我們跟同學介紹到這個Branch Edges那我們提到說我們比較常見的這一種Edges ModePC Relative Edges那我們知道說我們在算它的這個Target Edges我們是用這個PC然後再PC就是Program Counter然後再加上它的這個Offset那这边的offset的话它这边乘以4那当然最主要就是因为我们在

mips里面我们前面有提到过说它是这个word-align那word-align的话所有的word它的word的address它都是4的倍数所以它这边就乘以4所以这边的offset指的是指我们存在存在这个fee里面的这个value所以这个value的话我们就是再把它乘以4那实际上同学常常在这个地方有一点confuse他说那为什么要乘以4你为什么不直接就是储存这个word的这个address其实我们可以从这边的分析来看的话我们说

我们知道对这个word address而言不管它前面这边我们这边总共是32个bit对一个word address而言不管它的值是多少其实它最右边LSB的那两个bitOS是多少OS是永远都是多少因为它是4的倍数它从0开始0 4 8所以它的最右边的两个bit这两个值永远是多少永远都是0既然永远都是0，那我们有必要把这永远都是0的这个值把它存到这个feel里面来吗当然没有必要因为我们知道说

我們的32個 bit欄位就是32個，所以我們每一個 bit都是斤斤計較說它能夠儲存越多的東西越好我們也知道说這个 field給的 bit number 越多的話我們可以表示越大的數不管是你要 branch 的範圍或者是你如果要處理immediate 的 operand 之類的它的 bit number 越多的話當然就是我們可以處理越大的一個範圍那所以說 既然說它如果是這個 world address它的最右邊兩個 bit always

都是 0我們當然就不需要去存這兩個 0 的東西我們就把它省略掉在存的時候實際上是忽略了等於說把這兩個 bit 把它省略掉那所以省略掉的話呢你要把它還原的話呢當然就是就是還要再怎麼樣再往左 shift 兩個 bit那你往左 shift 兩個 bit其實就是乘以什么呢就是乘以4其实它就是等于

就是往左shift两个bit然后最右边这两个bit全部都填引进来就是这样子所以在我们前面提到的还有我们这边看到的这个例子在MIPS里面其实它有这样子一个重要的特性这边要注意的是说我们的这边PC这个值到底是多少PC这个值到底是多少因为我們在加我們在算這個target address的時候，這

個時候其實它的PC它已經是指到這個branch的下一個指令，所以如果說我們要知道說我們的這個L1，L1我們知道說這個是一個label，這個是assembly讓我們看的。我們知道說L1，它是跳到這個地方，那L1跳到這個地方。但是，如果說我們是要把它轉換成這一種Machine Instruction那這個Machine Instruction的話呢，當然就是它就是一個

Offset它是一個Offset。那這個Offset的值是多少呢，那同學就要知道說它就是一個Offset再加上這一個值加起來會等於L1值的這個位置L1就是直到這個地方來，所以我們等一下後面會有一個简单的例子讓同学知道說你这边的L1这个在Machine Instruction里面的offset你不是说我從Branch这个指令的位置加上一个offset会等于这个位置，这是错的因为你在执行到这边你要去算target address的时候你的Program Counter它已经指到BEQ的下一个指令，

那這個當然會有差別啦，因為你如果是從這邊來算的話你的offset要多4那你如果是已經知道說你的Program Counter是指到這裡不是指到這裡你的off set你就可以少4就是可以少掉4這樣子所以這邊有一個比較minor的觀念同學要了解那另外還有一個叫這個jump這個axis那這個jump我們知道說它就是要跳到很遠的

的一個location它是j或者是jljl我們知道說它就是在call這個function的時候它這邊就是6個bit然後這邊是26個bit address它是26個bit同理跟我們前面那邊一樣這個26個bit你要把它轉成byte byte address的時候你必須要把它在後面再把它加兩個加兩個0就是往左Shift兩次那它的這個Adres它的計算的方式呢這一

種叫Pseudo Direct Jump Adres它是把這個26轉成2828個bit也就是往左Shift兩個bit之後呢然後這邊只有28我們知道說我們總共有32所以還缺4個bit那4個bit是從哪邊來呢就是PC Program Counter的這個MSB最左邊的4個bit最左边的4个bit PC program counter最左边的4个bit再加上这边的28个bit这样子把它接起来就是刚好是32个bit所以这个operation我们就是叫contonation就是一个接合的动作所以左边接PC MSB 4个bit右边接这边往左shift过shift两个bit过后的一个结果就是这样子

所以这个是这边两个的addressing mode那我们这边有一个例子就是这个target addressing的一个example我们是假设说这个loop它一开始的location是这个8000每一个instruction当然都是32个bit所以这边8000这边就是004 008 012 016 020还有0 24所以这边一个是对一个3 4 5 6所以这边jump是对到这一个

然后exec这边要有一个exec这个label它是对应到这一个这个label的instruction是什么我们就不要管但是我们知道说我们要这边比如说branch not equal它要跳到exec这个位置它就是跳到这个location跳到这个地方来所以我们这边要看的其实我们是要看什么呢我们是要看说以这个BranchNotEqual它

的这个offset这个值要填多少还有这个jump这个jump到底这个值要填多少这个是我们在这个例子里面要注意的一个地方所以根据我们刚刚的解释我们知道说BranchNotEqual这边的offset它是exit是跳到80024那024呢80024它基本上它是等於Program Counter這個時候Program Counter它已經指到這個地方來

了。 Branch Not Equal的下一個字令所以Program Counter是等於這個值，所以我們等於是等於80016再加上某一個值要等於80024，所以我們就很清楚的知道說這邊是80016要加上8它才會等于这个80024。那么你加8它才会等于这个80024那你加8的话呢，我们知道说8，你再往右shift两个bit就是除以4，它就是等于2。所以这边这个2，它是从这边来的2乘以4等于8，然后8再加上80016就会等于80024，代表说它是jump到这个地方来，所以这个就是我们这个PC relative addressing

它的一种计算的一个方式。另外，我们在这边，我们这边说，我们有一个Jump，现在应该所有的这个记概的这个课程大家都是一开始都是从C或C++没有人是从这个Basic开始。如果早期像很久很久以前有人在写这个Basic的时候，它里面有一个指令很好用叫GoTo就是写一写觉得好像实在是扯不下去

了就用GoTo，这一招大概都可以解你就觉得你的Program的structure已经实在是兜不下去就GoTo终于就脱困了，就可以跳来跳去跳来跳去像在我们知道在Headed Language里面这种东西是绝对不能用的，因为你用一个GoTo的话，那整个结构就都被你破坏掉了，但是我们在Assembly里面这个jump这个go to就一定要用了，不用这个

go to的话，这个assembly大概是很难写，所以我们来看说这个jump它就跳到这个loop这边来的话，我们说这个值应该要等于多少，因为它这边是8,000所以实际上我们这边就填2,000我们当然就是说我们这边suppose就是我们的PCProgramCounter，它的MSB最左边的这4个bit全部都是0，所以你这样子再跟这个做结合的话它就会等于8,000所以这样子的话，我们就可以知道说Jump跟Branch这两种as a small我们要去算这个value到底是要怎么一个算法，

同学会问说有时候我的城市很大的时候我要branch到很远的地方，这个时候怎么办，这个时候怎么办其实我们这边都讲说branch far away，它实际上已经远超过我们在这个BEQ里面的16个bit它所能够表示的一个范围，我明明就是BEQ BNE之类的，我要跳的一個offset实在是太遠，它没有办法，那怎麼辦呢，它這邊就告訴我們說，我们在寫的時候，

我们當然不會管說你的這個label你要跳到什麼地方，我們在寫大概就只是一個jump to branch equal然後到一個level 1我們大概不會去算它的這個offset如果說太大沒有辦法表示assemble它會幫我們處理所以这边告诉我们说assemble它会重写这一段的code其实它等于是assemble通常它会做两件事情一种就是重写一种

就是可能它可以做最佳化它可以帮我们做最佳化之类的这边它就是属于重写这边它没有办法跳那没有办法跳怎么办呢它就是说如果等于的话就跳到L1它就把它改写成如果不等于的话它就是跳到L2L2是谁呢L2就是BEQ的下一个指令L2就是BEQ的下一个指令所以原

始的program structure是说这两个相等的话它就会跳到label是L1的地方去执行如果这两个不相等的话它就是一个sequential execution循序的执行所以sequential execution就是执行下一个指令所以他就把它改写成说当它不相等的时候我们前面原本不相等是Sequential Execution所以当你不相等的时候其实你的L2那个地方就是你原本VEQ的下一个指令比如说它如果是ADD假设是这样子的话那它就是ADD然后前面加L2然后它就跳到这个地方来

所以就变成说如果相等的话它就会执行这个jump那jump因为它的范围比较远所以BEQ它没办法表示的那Jump就可以跳过去了Jump就可以跳到那个地方所以就是Jump L1就是这样子所以这个是Assemble它会帮我们process的地方所以我们来看在Maps里面我们看到的这种edges我们从第二章一開始到現在我

們第一個知道的就是什麼Immediate的一個Address然後還有Register的這個Address兩個Register做處理然後再存到這個Register這邊是一個Register另外一個是Immediate的一個Operand另外一個叫Basebase就是這種Load跟Store它的一个Base Address是存在某一个Register然后再加上它的Offset Offset它就会指到Memory里面某一个地方我们刚刚提到的PC Relative addressing的话它就是Program

Counter这个时候已经指到BEQ BNE的下一个指令然后再加上你的Offset这个Offset当然就是我们里面的这个Address Field里面的Value然后再乘以4所以它就会直到某一个位置刚刚前面提到的这个Sudo Direct Addressing的话它是把这个PC跟最左边 MSB最左边的4个bit，然后跟这个address，然后再Lab shift两个bit乘以4或者是乘以4之后的结果做一个结合，

结合之后就知道这一个memory的某一个location，所以这个大概就是我们看到的这几个 edges more。接下来，我们跟同学介绍一个一般比较不会注意到的，就是说大概这个其实也不能说它很重要，但是确实的是有人一直在用这些方法，我们来看要介绍所谓的reverse engineering，这一种operation，我们要先看一下MIPS，它的instruction的encoding，这边我们就同学大概了解一下，说它这边就是列表，你直接用OP就可以判断了。 OP31到26这几个bit可以判断的指令就是在这个地方，

它这边都有列出来所以这边如果是000，然后010，这一个column它是31到29，然后这一个row是28到26，所以你搭配起来就是000 010，这OP六个bit是长这个样子，那这个指令就是Drum。那你如果是000然后100，OP那六个bit，如果是000100它就是BQ所以你就000然後11，101就是BNE這邊還有幾個，這個就是你如果是OP它31到26它是010、000然後再搭配RS就是25到21這些bit的值，它是這幾個比較少見的指令另外還有我們常用到的像這種加減乘除加減

然后还有excuseAll、null、all这类的这个 arithmetic operation基本上就是它的OP是000000然后再搭配什么呢用这个function field去判断function field就是0到5这6个bit所以这6个bit它如果说是100再搭配000的话它就是一个加就是一个加的指令所以我们就这个同学只要知道要如何去查这个表就可以接下来我们这边是

要让同学了解说我们如何从一个machine code来解码把它解成说我们知道说这个是什么样的一个assembly的instruction所以就decoding machine code用的方法当然就是我们刚刚去认那一个table的方法我们第一个要先看什么呢先看它的OP code所以以这个例子来看的话OP code是000000所以我们就回到上一页上一页OP code000000是在这个地方所以我们就知道说OP这个OP是6个0的时候你没有办法单独判断你还要再加上functionfunction field所以我们再回过去去看function field是100

0 0 0所以1 1 0 0是这一个1 0 0然后0 0 0是这一个就是我们刚刚提到的加所以我们就知道说这个是一个加的指令，这是一个add，所以我们就知道根据这两个op跟function，我们就知道说它是一个add，既然是知道add，我们就可以知道后续后续到底要怎么样什么意思呢，就是说我们到底是

要分成三个register三个register，它的三个register field还是说它是一个immediate，因为它是ADD，它不是ADDI，ADD，它就是一个register的一个mode，所以我们就知道这边我们就是要切成三块，五个bit， 五个bit， 五个bit，所以这边就三个register，就出现了，所以我们就知道说第一个是S0，接下来是A1，接下来是T7，我们就知道说这边就是A1加T7，然后把结果存到S0，那这个呢当然这个，因为它是没有用到shift amount不会用到，所以这边就是0，所以这个就是我们在做一个machine code

的一个decoding的一个方式，大概就是类似用这样子的一个方式，同学说我们现在什么时候会用到这样子的一个operation，我可以跟同学讲其实我也不知道，所以我不知道什么时候会用到这个不过我们以前很早的时候是会用到这个，因为以前的程式都比较短以前程式比较短，所以当你要看一个那个code其实你可以

去dump memory看谁的那个程式因为你买到tool你不可能去买一个有source code除非它是open source你如果是commercial的话你大概都是买到这种就是它编译好的所以你可以把这个memory里面的code把它dump出来memory的codedump出来之后你就可以开始慢慢去解慢慢去解你大概就可以猜出来说它那个程式大概是怎么写的

像这样子的一个方式的话这个reverse engineering这样子的一个工作其实现在都一直有而且有公司专门在做这种事情其实我们台湾早期的半导体产业是从reverse engineering开始的我们以前早期我们知道说公安院是我们台湾半导体这个产业发展的一个重心在早期就是从那边开始慢慢茁壮我们前面已经让同学看到说我们要设计一个IC的时候

其实最后IC画出来要送到Foundry去生产的时候它是什么呢它是一大堆Polygon 对不对它是一大堆集合图形这些集合图形就是我们所谓的Layout早期就是说我們知道說國外他們的Design的技術非常的好我們的Design的技術比較差所以我們當然希望知道說這個Design到底是怎麼做的所

以其實最簡單的方式就是把這個IC你IC買過來之後其實你就可以大概可以你把那個盒子把它拆開來你用顯微鏡看你可以看到一些Layout至於他們如何把一层一层的layout画出来这个我不知道他们是怎么做的但是他们可以把这个layout就把它画出来画出来之后就开始去繁解怎么

繁解呢我们就说我这边是一个transistor从这个集合图形可以看得出来这个是一个transistor这边是一个transistor这两个transistor中间有metal把它接在一起这个时候就变成什么呢就好像说你在画图的时候说我这边有一个transistor然後我這邊也有一個 transistor結果它有一個 metal wire 把它接在一起我的這個 schematic 的圖就出現了它是用這種方式慢慢接

慢慢接 慢慢接它就可以把整個 layout把它解成是這種 transistor level 的 circuit然後接著你就可以知道說這個 circuit 是怎麼去做這個 design當然你如果要看人家的 code 是怎麼做的你也可以用這樣子的方式不過現在用這種方式太累了因為現在城市都大得不得了你如果要這樣看的話那應該是不太可能所以有一

些公司他們在幫人家做這種reverse engineer的工作接著我們再來看這個synchronization這邊有提到兩個指令這個指令的synchronization當然是為了配合我們的就是說我們現在的一個趨勢就是MaticoMulticode。我們要做這個平行處理我們知道說平行處理它是需要做這一種不同的Process。它同時在Run的時候你要如何去做這個Synchronization這邊提到的就是說兩個Processor。它如果是Share一個Memory的Area舉例來講我們說P1 Write然後P2 Read。我们知道說我們在

在平行化意見工作的時候其實你很难做到說比如說我把它分成四个Processor同時進行你大概很难是四個Processor是independent的去做independent去做那你如果说四个Processor它都是independent去做的話那這個要切得這麼乾淨大概是很難所以通常比如說你四個Processor它們之間是有data dependency、Beta dependency的意思就是类似像这边写的我说P1它

产生一个output然后P2它会去read那你P2read了之后你P1它会再输出再write它下一个next output然后P2再read下一个input如果说你的P1它比较快P2比较慢那它会有什么样的一个结果呢就是说你可能P1它已经做了五个write,P2它才做了三个read。所以你如果没有做synchronization的话，它有可能会发生什么事情就是你P2去read第三次的时候

实际上你是read到P1第五个write的output。这样子的一个operation它就错掉了我们必須要有這種Synchronization的機制當然你不一定說一定要P1 P2就P1在那邊等P2，但是你至少你要讓P2它都可以read到它要讀的那一個對的version。所以你可能就是要有一些buffer有一些緩衝的機制讓P1它可以一直寫但是不會把還沒有被讀過的data把它給蓋掉就是類似這樣子的一個機制。

所以像这种Synchronization的话我们通常都需要这个Hardware的一个Support这个Hardware其实就是说你用Hardware去做的话其实它就要做什么呢就是要做所谓的这种Read Write Memory的Operation。它的意思就是说比如说我写了一笔Data进去以后，我写了这笔Data之后data在被堵之前它不可以再被update。如果说我把一笔data写到A结果这个A它在

被堵之前又被update一次那这个就是错的。它要知道说现在有这样子的一个情况发生，它必须要通知说你这个写到A还没有被read就已经又被write。必须要有这种这种状态让人家知道有这种状态发生，所以他在这边就提到说，就是没有其他的access to the location。他不允许说有这个access其他的access去存取这个location，在read跟write之间，因为他read write他是一组搭配就是同一个version产出一批，

然后另外一批就要被堵，就要被使用掉，就是这样子，一种hardware support通常就是透过instruction。当然你既然已经提供instruction，你hardware的design里面就必须要去realize、implement这样子的instruction。你可以是一个single的instruction，你也可以是一个atomic pair of instruction，就是一组一组，就是读跟写这样一组搭配起来。这边它说，你也可以是一个single instruction/single instruction是什么呢？它这边举的就是一个admic swap，比如说你是memory跟register两个之间的一个swap operation。为什么这边是一个swap呢同学你可以想想看swap是不是

就是等同于一个read一个write对不对如果我们站在register的角度来看的话我们站在register的角度来看的话register跟memory它们的一个swap的一个operation是不是就是等于我register到memory里面去read然后还有把我的register的datawrite到memory对不对所以其实你这个一个swap其实就是等同一个read跟一个write所以你不管是用一个instruction或者是用一个

admit pair of instruction基本上它要做的事情就是这边跟同学提到它在一个rewrite之间不允许有其他的access发生如果有的话必须要知道有这种情况所以我们在MIPS里面这边提到的这个synchronization它就是一个是load link一个是store conditional一个叫load link是LL它就是说我要把这个memory我要把这个memory里面的某一

个位置的这个值我把它load到这个register里面来接着它把它load进来之后它后面会搭配一个叫storeconditionalstore是什么呢？存储我们就是要把这个register写到同样的这个当我们执行store conditional它会有什么样的情况呢？就是说你在执行完 error之后你这个location它没有被update它没有被update的话那就表示说我这个store的这个operation它成功了。意思就是说，在read write中间没有其他的access去更改这个location的这个值，

所以它就會把這個e呢，就是success的一个state的一个flag，它會把它寫入這個rt這個register，那如果說fail，fail就是說這個location被change被更改那它就會把這個0把它寫到這個rt那它如何來完成這樣子的operation那當然是，它的hardware design自然就會提供這樣子的機制那hardware它會幫我們做這個check-in他会知道说LL之后如果还

有在SC之前还有其他的把这个location的值把它更改过下一个SC执行的时候他就会把这个0写入rt就是这样子所以就是一个这么简单的机制，所以这边只是这边有列出课本有列出一个就是列出一个范例他说这是一个admin的swap实际上它就是做什么事情呢？它就是把這個S4這個 register跟S1加0這個memory location它的這個值兩個做swap把S4跟S1加0的這個memory location兩個值把它做swap所以同學可以看到第一個它先把S4的這個值

先把它存到這個T0裡面來先存到T0接著它又把這個S1加0S1這個register它的指導的memory的location它裡面的指把它抓出來抓到T1接著它就是SC然後T0T0就是S4它把S4的內容寫到S1指到的memory的location把它写进去这个时候写进来的时候如果说因为它这个是parallel有其他的这个process在跑所以不是只有这段程序在跑所以它从这里到这里之间如果有其他的process去update这个location的值的话它执行SC的时候它就会侦测到它就会把这个0

把0写入T0所以它这边就是侦测T0是不是等于0如果T0是等于0的话就表示SC执行失败有其他的access去update在LL跟SC中间去update这个location所以它就有一个机制這邊的機制就很簡單說它要回到這边來就是這樣子它没有去它没有去管說你再回到這边來然后再重新做是不是你要的反正這

是一个简单的example只是讓同學了解說它有提供这两个指令来可以让同学完成这种synchronization的动作最后面这个指令当然就是做一个swap你这边把S4存到S1的location然后再把S1的location再存到S4里面所以这个是这课本里面提到MIPS里的Synchronization接着后面就是会介绍这个Assembler然后还有这个LoaderLink Loader这样子的一个观念这个同学有修过系统程式的话应该这部分的内容应该都了解

同學有沒有修過系統程式沒有這部分的內容都有上過嗎有沒有也沒有我們就大概看一下這邊的這個flow我們知道說我們寫一個program叫compile我們compile之後我們在PC裡面通常compile它就通常我們都懶得Compile在執行它會有一個Button也是Compile兼執行然後就開始Run我們比较不會去管那些如果同學有在Wallstation上面或者是Linux上面 Develop你的Program而且你的Program不是只有一個Source file同學必須要寫MAC file同學應該就會知道說我們在Compile的时候我们一般都是会先把它

便利成这个. o的object file那。 o的object file基本上它那个是没有办法执行的，因为它有很多东西都还没有做linking都认不得，因为你在program A里面你可能用到你要call一个function可能是在program B里面被define之类的，所以其实这整个flow它就是在解决这件事情，还有包含什么事情呢，包含说当我的程式全部都compile完成

一個execution file的時候，它要執行的時候同學應該可以理解說我們每一次要執行同樣一個program的時候，這個computer裡面它的memory的狀態都不一樣，所以也就是說你每一次去run program A的時候，它並不是每一次都把program A把它load到同一個memory location去執行你的狀態不一樣，它就看看哪一边是available的memorymemory是available，它就load到什么地方去，所以像load的话，它就必须要take care这种事情，还有在早期的时候，比如说我写程式，我们会用到很多library，library我们就会去买很多这种一些

software company提供的这种library之前已经跟同学提过以前很多公司在做类似这种东西，所以你买了一个很棒的一个graphics或者是mathemat ical的routine library当你程式写完之后你compile它就会去那边把它抓抓抓然后compile成一个资金档以前可能他们就是怎么样呢就是说它的这个library里面如果说它有很多这种它

有种类你如果说有使用到一个API的话它可能就去找相对应的那一个它把那一个类似像这种object file它就会把它放进来一起linklink成一个执行档可是那个. o里面就类似. o这种东西，它里面不是只有routine，它可能还有其他很多function，但是它不管，它就是整个全部抓进来，所以你整个抓进来你的执行党就会变得非常的大，很明显这种方式是很不好的，所以在早期这种方式很快就被改成说，它不是利用这种方式。所以我们等一下

后面会跟同学提到，它是那种dynamic这种linking的这种方式它甚至不是说你执行之前，它就把你有用到的的这些binary全部都把它link进来，它是在执行的时候，它才去把它抓进来，所以你compile成一个execution file的时候，实那些东西都还没有进来，你用到外面的那些API，它都还没有进到你的execution file，所以基本上它就是我们这边提到的，它就是说先compile之后，比如说，这边提到的assembly language program，然后再assemble，然后把它转成很多的.

o，接着link就会把我们的。 o再加上我们使用到的library的routine然后link成一个executable的program所以这个就是machine language的program但是在这个时候你要到memory里面去还要再经过一个loader就是你要load到哪一个位置里面去执行这个都还不一定每一次都不一樣所以你要loader要來解決這樣子的一件事情類似像這樣子

的一個方式我們就是使用到誰我們就用link就直接把它弄成整成一個一個executable的一個program這種叫static的一個linking所以你static linking的話你用到什麼的時候linking它就全部都把它抓進來就把它抓到你的executable的這個program這個缺點就是它就很慢所以我们后面再来看现在的方式大概是怎么样首

先我们来看这个assemble它这个sudo的instruction这个之前跟同学提过比如说在MIPS里面它没有提供move但是我们却可以写move可以看到move这一类的指令这个move其实就是说assemble它会自动帮我们转它会帮我们转成就是利用MIPS它里面的指令來使用比如說我們提到說MIPS它其實沒有類似

這種BLT這樣子的指令但是你也可以寫當然前提必須要你的Assembler它有去認這樣子的東西如果Assembler它本身沒有去認這個東西那你當然不能亂寫所以這一類的就是所謂的Pseudo-instruction或者是有人稱作Macro-instruction都有所以它就把它轉成這個樣子所以可见说assemble它必须要做一些

operation做它自己做的事情把这些macro转成mips它的instruction set或者是它可能要做一些optimization的事情所以我们有一个register叫register1它就是这个前字号add它是assemble专用的register是assemble专用的那这边提到的说产生这个object module就是它assemble它就会translate这个program成这个machine instruction那它会提供这个指令往后要建构一个complete program的时候要使用的包含什么呢我们都会这个.

o都会有一个header那这个header基本上就是在描述你这个object module它的这个内容然后还有texttext就是我们的这个instruction然后还有static data的这个segment就是我们这个. o里面就是说这个program里面它有用到的static的这个data还有relocation information就是我们知道就是说relocation顾名思义就是什么呢就是你要重新定值什么是重新定值呢就是你每一次进到memory里面去它的值都会变的所以很明显你这个relocation你就必须要包含一些offset

還有一些Base的一些Information你有Base 你有Offset所以你每一次你的Base一改變以後你的再加Offset你的絕對的Location進到Memory裡面的Absolute Location它就會不一樣所以這一類的Location InformationSymbol Table它就是一些Global Definition還有External Reference比如說它會記錄這種Level到底是指到什麼地方去還有我們剛剛提到的NEO去code到你不是在這個。 org裡面define的那

一種routine的話，它就會有都會記錄在這個symbol table裡面。最後還有一個是什麼呢，就是debug information就是這個debug的資料，你必須要去你要debug的話，就是要加一個我們知道這是加-g它就會幫助我們去做這個Debugging。如果是link，它這邊提到說那為什麼要link，因為我們是每一個點C++或者是點C，我們會把它解譯成點O

的，然後再把這幾個點全部都把它整合在一起。所以第一件事情要做的當然就是我們最主要就是要產生一個executable的image，所以它必須要merge所有的這些codemerge這些segment你必須要去解這些level你必須要把level你要把它轉換要決定它們的位置還有我們提到的，就是說你如果有那種relocation還有external reference，你在不同的. o裡面，你必須全部都要把它一起放進來，你在linking的時候，如果所有的。 o所有的那些routine全部都information都進來了還是有一個

有一个name認不得这个时候当然就会有个arrow出现所以有时候你的arrow不是在compile的时候是在linking的时候出现的原因就是它是在这个步骤的时候去解这些问题把所有的刚刚不认的全部大家都对在一起这边就提到说你只要是跟location有相关的location dependency它就必须要透过一个这种其实就透过loader你要load到memory里面去的时候loader都要解决这些relocation的问题但是如果我们是用virtual memory如果是virtual memory的话基本上大概就不需要处理这些问题我们知道说

Virtual memory我们在最后面会有一个段落是跟同学介绍这个Virtual memory早期Virtual memory其实它另外还有一个功能就是做protect它可以做保护另外还有我们知道说Virtual memory在以前的时候它有一个优点就是说让programmer他看到的什么呢看到他所能够用的memory space是大于实际上你的MapMemory裡面可以用的一個space這個也是它的一

個優點VirtualMemory它的做法基本上就是我們會把資料把它分成很多個page我們每一次每一個page把它抓到Memory去的時候我們會透过一個table的一個mapping那個table它就是記錄說這個page這一次搬到記憶體裡面去的時候它是搬到記憶體裡面的哪一個地方所以可想而见我们知道说Memory是有限的当你塞很多Process进去很多User都在用的时候我们的Memory会爆掉，你的Memory不够的时候

你现在要执行的这个Process你要Memory不够你就必须要把占据Memory里面的一些Data把它搬出，所以我们同一笔Page的资料它可能你在你的Process执行完之前in out in out in out它会非常多次你in out很多次的时候它并不是每一次进去的时候都是放在同一个位置放在哪一个位置呢，OS它会知道说你的memory到底什么地方是free这个时候它就会把这个free的location就给你，这时候你page就会进到这个地方来，你的page table就会记录说你的这个page到底是存到

memory里面的哪一个位置，所以我们可想而见这个时候你要去manage这样子的一个location的动作其实际上它会take care，virtual memory它会take care，因为它就是它就是搭配OS，它哪一块memory是空的它就给你，在page table就会记录这个资讯，你使用你看到的virtual address都是一样，那实际上你每次进去的physical address实际上是不一样，所以类似

像这样子的话，在我们现阶段有一些就是早期必须take care的事情大概现在就不需要所以这边它说load一个program我们很快地把它看过去它就是把一个image一个program的image把它从disk把它load到memory所以当然首先一定要先讀這個header,header記錄你這個program裡面的資訊所以他header他就知道說你的segment size是多少那當然會create一個virtual address的一個space然後接著再把你的text你的data,

initialize的datacopy到你的這個memory然後當然也必須要把你的argument你的argument也必須要把它放到你的stack還有initialize這幾個就是你现在要执行这几个到底是指到什么位置这些位置当然就是要搭配你当初给的这些memory到底现在位置在什么地方那你使用到data使用到哪里这边要set好之后就jump到startup的一个routine就开始执行所以这个就是load一个program的一个机制我们下一堂课再跟同学介绍dynamic的一个linking

休息一下好 那我们继续看这个dynamic linkingdynamic linking它的这边它提到说就是根据我们前面提到的这个static linking它的这个缺点它只有在只有在被扣的时候呢就是说它的这个routine被扣的时候它才会去link跟load这个library的这个procedure所以类似像这样子的话它就是说它必须要了解就是说它

的每次要code的这个procedure它的这个code它是可以被relocatable它每次load到这个memory里面的位置其实它是不一样的这样子的一个方式它就可以避免我们之前提到的就是说我们的这个executable的image非常的肥胖就是会变得很大它的size会变得很大因为我们现在有太多的这种API可以用所以

很多都写得很好我们都不用自己写所以你在那边扣东扣西那你只要扣到使用到一次你就把它抓进来把它link到你的executable的这个file这样子是非常浪费的所以我们这边就来看一下它这边有一个叫lazy linkage它的一个方式这张图它有这个A图跟B图这个A图它是说我们如果是用这

个第一次扣去扣这个DLL routine的时候它的状态这是左边A图这张图当你第二次再扣它的时候扣第二次第三次以后它的执行的方式就是B这张图所以我们可以看到说它只有第一次的时候是比较复杂它只是做了几个indirect做了一次indirect的类似一个jump然后再去呼叫linker跟loader就是这样子第二次以后它就不需要再透过这种loader routine ID还有去call linker跟loader这两个它就可以省略掉所以我们来看一下它的机制

大概是怎么样基本上当我们要去扣某一个routinelibrary的一个routine的时候实际上它并不是在我们的executable里面它真正有它的routine存在它就可以直接去执行它首先它会去漏的一个到memory里面的某一个location去漏的一个字這個同學應該知道說我要去load我必須要specify一個base再加上一個offset這個base跟offset本身就都

是屬於這個instruction裡面的資料所以這些資料都是不能被更動的對不對你不太可能就是說你要去你的程式你的指令在執行的時候你要去更改某一個指令裡面的某一个内容然后去把它从A指令变B指令或者是把这个指令的register或者什么其他东西那些去做改变你如果是写这种program的话那

大概是非常危险所以我们这个load里面这个指令它就是长这个样子可是我们可以改什么呢我们可以改我要去memory里面的某个地址然后去load这个routine进来 ory里面的那个location里面的值那个值是可以变的，比如说我们这边如果是load我们是要到这边来做load这个location这个会load我们就到这个地方来

loadload什么值呢，这个值其实就是描述什么呢，这个值其实是描述一个我们要开始去做link跟load的一个startup开始要去启动这样子的一个机制，它的位置到底在什么地方，所以这个是我们下一个要执行程式的一个它的address开始的一个location所以我们把它load进来以后，然后你说JR这是什么呢，JR就是return，所

以从这边看起来，它应该就是把这边的location把它取代掉它的什么return address当然，它原本要return回去的这个address它必须要maintain它必须要把它keep起来，所以它把这一个memory的location把它取代掉它的return address，所以JR它就会跳到什么地方去，后面这个JR它就会跳到这个地方来，它就跳到这个地方来执行，这个执行就是

LIIDLIID，它就是把这一个IDLIID它就是把这一个ID把它load到某一个general purpose的registerload到某一个register，这个是什么number呢，这不是随便的number这个number就是我们要去code的那个routine，它独特的，它自己的一个ID这个ID是要做什么用？你把它load到某一个register准备给等一下link跟load的时候，link它知道要去抓哪一个routine？它要去抓哪一个routine？它要去抓哪一个routine就是透过这个地方来的，

它是透过这个地方的所以同学可以了解到的，就是说当我们要去扣某一个library的routine的时候，我们要去扣a这个a在我们前面assemble那些产生的code固定的是什么呢固定的就是这边的，这也是固定的，因为a有它相对应的ID，所以这边会有个liid。至於這邊這個位置到底直到什麼地方去呢，這個不重要，反正你每一次你每一次这个Program load進去的時候，

它要執行的時候，它的location可能會不一樣，反正不一樣，它自己就會set這个值，它就會從這边然後就跑到這边來Initialize你的Routine ID接著這边就Jump就開始Init什麼呢Init这个link它就去把那个routine抓进来，然后再把这个routine再把它load到memory里面，因为这个routine现在要执行了，所以就把它load进来，load进来之后呢当然它

这边也会有做一个连结知道说它就是要直到这边来它要开始执行那这边执行完之后呢因为这边都是一系列它们都是有关系的所以它有办法去keep这个information它要return的时候这个时候它就会把这个一开始的JR它的return address从这边就return回去就回到这边所以它原本是JR return到这里它

把它取代它用load去掩盖把这个资讯把它抓过来它是return到这个地方然后启动link loader执行完之后再return回到原本的位置这是第一次第一次看起来特别的复杂第一次做完之后它当然就知道了因为这个是一个data这个是可以被update的一个data这不是一个instruction这个是一个data原始第一次的时候

它的这个data它是指到这个位置我们第一次执行完之后我们就知道说它的library routine在memory里面的哪一个位置所以它就把它的starting addressupdate到这个地方来所以update到这个地方来他下一次第二次扣他的时候他就知道说他就知道就把这个抓过来然后一扣就是扣到这个地方来就扣到这个地方然后这边return也是一样return回去所以第二次以后这些都不需要他只有第一次的时候

要做linking跟loading的时候他需要做这个operation第二次以后他就是直接就直接扣到这边来这个就是一个标准Dynamic Linking的一个机制所以很明显我们就你用了很多Library的routine它都不需要进到什么呢不需要把它include到你的ExecutableImage你的ExecutableImage其实根本不包含这个东西你有一百个它每一个都很大没有关係这些都不會

進來，所以你的executable的image其实还是很小你多出来的大概这个都小小的所以这个就是我们的dynamic linking的机制。后面这边我们就我想同學回去自己看一下这个sort它是課本裡面是有一個章節跟同學介紹這个bubble sort如何就是用我们在MIPS介绍的这些instruction set然后还有这个procedure我们知道它的code就是这么简

单它里面其实这个不是bubble sort这是bubble sort里面的swap。它的kernel里面会用到一个swap，swap就是你把这个index k传进来还有把这个array starting address传进来它就会把k跟k加1两个做swap，这个swap大家自己看一下，它没有什么特别的，除了我们刚刚提到的，就是说它的array加1index加1其实，它的word address是加4，这边就是它的bubblesword就是这样子，所以这个swap就是我们前面介绍的那个function。后面，它有一段code其实就是在介绍这一段，它要把它写得

好像是一个很有规则，我们一般在寫的這種 function code，所以這邊我想，我也不仔細跟同學介紹，只是跟同學提一個地方就好，因為這個都是很的是像這邊的conditional 的判斷其實就是在這邊做它在这边做这个conditional的判断这个conditional的判断。同学大家自己回去看，且它这边都已经写得很清楚，它是前面的第一个

loop，这个是for i，这个i大于等于n之前，它会一直做，然后后面，是后面它另外内部还有另外一个loop。我這边要跟同学提的其实是在这个地方，它这边写起来好像是比较，就是同学可以看到说它这边做完以后，它就做了一个去扣这个swap，扣这个swap其实就是前面的这一个扣就是前面的这一段扣，

它前面这边就做了一大堆准备的工作，然后去扣了一个swap然后最后就结束。其实这个是很trivial的，它这边同学可以看到它在扣swap的时候，它会做什么动作呢，它会把这个v就是它会把這個 V 就是 Vj 跟 Vj 加 1 把它抓出來你看它會把 Vj 抓到 T3Vj 加 1 抓到 T4它這邊抓出來它最主要是要去做一個比較做比較說你的 Vj 加 1 是不是大於等於 Vj因為我們前面這邊有一個 comparison它就是在做這個 comparison它做這個 comparison

做完之後它如果覺得有必要做 swap 的話它就會做這樣子的一個這邊就是在扣這個swap的動作但是同學可以看到swap這邊它同時又做了一個什麼呢它又做了一個vj vj加1這只是從j變成k而已所以它這邊其實就是vj vj加1它又重新做了一次所以就是當你在寫類似這一

類的code的時候其實這一類的code你能夠省掉instruction你能夠省得越多的話其實你的速度就越快你這邊已經把它抓出來你去code swap你又再重新又抓了一遍所以這樣子的方式其實並不是很有效率當然你很多在做function code的時候都會有這樣子的一個情況但是你要看说你写的program到底是哪一类的program我们在做optimization的时候

通常有两类的program一类是针对演算法做optimization那一类的你大概就是要去你要斤斤计较的是你的algorithm的这个complexity到底是多少那你的complexity太高的话你在这边再怎么救都救不回去那另外一类比较是偏重比如说你在做driver那你是写 portable device 的一些界面或者是在 portable device 裡面 run 的一些 kernel那這一類的程式其實它當然也是會很大但是相對比一些其他 tool 而言它的 program 相對並沒有那麼的大那你如果是在寫這一類的 program

的話那類似像這一種東西你就要盡情計較你這邊兩個 load那一邊多執行幾個 move然後那邊又多執行幾個那個它那個kernel是一直被扣一直被扣然後使用者通常都很不耐煩尤其是在使用手機啊什麼iPad iPod之類的那種大家都很懶得去等所以那一種的code efficiency就是這種小地方就是要算清楚什麼時候用code適合什麼時候去code function其實是不適合

所以它后面有一个full procedure它就是把我們前面提到的这种要做这个save跟restore然后前面再去code它的main body所以這個同学回去自己对照一下接着來看compiler的optimization我想同学在run程式的时候compiler都会有那个经验就是不过現在同学写的这个在课堂上就是课程的这个program比较少会去比会去比说谁的程式

比较好谁的程式比较慢可是我们知道说以后在业界写的程式大家就是讲究就是看谁比较快看谁比较好所以同学应该要习惯就是说你写出来之后要问第一个你的memory到底是不是够compact尤其是再写我刚提到的第二类的那种程式跟Portable Device有相关的程式那个是Memory一定是斤斤计较第二个当然就要看说你的程式到底够不够快我们知道说我们在Compile的时候

有Optimization Mode 1Optimization Mode 2Optimization Mode 3这边其实它列出来的图表跟以前使用的经验其实差不多就是这样子你没有使用你没有加optimize的时候它的base假设是1那你如果启动它是MOD1的时候通常大概就是它这边讲说它是大概两倍实际上有的program可以到四倍你可以四倍快它其实不止到两倍所以O1 O2 O3这边就基本上都差不多如果是看instruction count的话同学可以看得出来

这边相对的是特别的多然后这三个其实都大概都差不多使用的纪念也是差不多一二三这三个optimization的level基本上大概速度上就没有太大的差别所以同学可以看到这个大概差不多那CPI的话呢CPI这边是比较高一点所以我们从这边来看的话你其实去看这个CPI基本上并不是很

准就是说你每一个instruction大概需要几个cycle你光是看这一个大概不会很准其实你要看最准的当然就是看我们之前前面提到的你的run time或者是你的cycle time这边就有提到说其实你的optimization的level跟你的language跟你的Algorithm也是有關係你不同的Algorithm就是說你用不同的Mode去比較的話

他們得到的效果其實也是不一樣所以其實這邊只是要跟同學傳遞這樣子的一個訊息尤其是同學如果是在Denas或者是Server或Station發展這個程式因為通常我們大概都是用這個Map file你在程式寫一寫 然後在那邊一直DEBUG DEBUG DEBUG然後DEBUG很久之後終於程式沒有BUG結果後來發現說奇怪

速度怎麼這麼慢然後在那邊抓BUG抓了很久最後終於發現說原來是MAC-5裡面負G忘記把它拿掉然後你就是要加一個這個負O什麼1 2 3 之類的這個也是差別很大不過你如果一開始你的turn on你的富G debugging mode比你的競爭對手大概還要慢只要不要超過一倍那你就幾乎可以確定你一定是比他快，所以這邊有列出來說Quitting Show Bubble show它的這個speed up就是說你不同的這個compile mode基本上它是不太一樣

那這边提到的其实重点就是最后这一个就是说我们前面讲到的这一些说你的optimization mode你可以让你的速度更快或者是说我们写这个assembly我们也可以得到比较好的成果比如说像我们刚刚看到说我们从assembly的program的角度来看的话其实我们可以那个bubblesaw我们只要cancel掉那个function code的话你就直接把那个swap直接把它imbed到你那个code里面其实它可以省掉很多个load还有很多个save restore之类的资历当你程式支进很多的时候

它的速度就很快跟同学讲一件事实不过不是鼓励大家这么做就是说以前我們研究所以後在寫程式都會去比較誰的程式比较快也會常常去參加外面的競賽以前有一個學生他的速度非常的快剛開始跟我討論的時候他說老師 我們速度比較慢 怎麼辦我就跟他講說演算法的這個complexity有

沒有辦法再進步一點他說他回去想想看結果他想了幾個禮拜後就很高興跑來跟我講說老師 那個速度變快了它速度已經比誰還要快還要快我說真的嗎，這樣結果很好。結果後來才發現它的速度快，是怎麼樣？它的速度快，就是就是我剛剛講的把很多這個function code全部都取消掉然後它還有反

正它就是用那種define的方式它在寫程式的時候它也不是說它的code就很多反正它就是變成說真正在code的時候實際上compile它是把整個程式全部都展開來把很多code全部都把它展開進去所以它的速度就變得很快不過這種方法絕對不能用因為如果說你在industry裡面code是這樣寫的話大概工作難

保因為這種code是沒有辦法被maintain的code没有辦法被maintain同學會說這有什麼不好就表示說沒有人有辦法maintain我的code我是沒有辦法被取代的這表示我在公司的地位一定很重要實際上這是錯的告诉同学一个观念就是说我们在公司治理的角度来看的话公司绝对不希望公司里面有一个人他是

没有办法被取代他会认为说你要走你就走当然是有重要的人你要走我再多发一些股票给你你还是要走那你就走吧公司的治理最好的就是说任何人走都有人可以来接如果说你的公司是run到说这个人走掉这个公司会倒掉那这个公司一定是有问题不过不能一概而论因为公司有分很多种一种是stop就是刚刚开始刚刚开始大家在奋斗那这种stop的公司的话呢通常一定要

有几个key person就是特别厉害的。如果说以后有人找你去开公司，因为我知道我们教大的学生对创业非常非常有兴趣，因为以前我开一个Seminar的课就是大四的课，就是找很多学术界还有业界的专家来演讲。我就发现说有一次请我们台湾目前这个创投业最大创投业的董事长来演讲就是那一次最热烈下课以后

一堆同學就围到前面除了那一次以外下課以後同學大家都走了结果那一次大家都围到前面去，然後同學還有自備名片的，然後就開始在那邊把名片自我介紹，然後還有跟他要名片這樣子，所以我知道我們學校的同學对創業非常有兴趣，但是告訴同學就是說创业成功的机率非常非常的低，大概就是说你一百家里面其实你有一家两家成功那个激励已经是非常的

高比例已经是非常高了所以大部分其实都是失败了。当你是一个stop公司的时候你要确定说你的公司里面有几个特别厉害的key person如果没有的话这种公司你就不要跟没有那种特别厉害没有他不行的那种key person的话你就绝对不要加入，因为那个绝对不会成功的可是当你的公司成功之后

它慢慢大大到一个程度以后如果说这个公司还是有那种不可取代的人那这个公司一定有问题所以你会发现说大部分的比较有规模的公司他们都是一直在做一件事情你会发现说公司变大它的制度一直在变它的变化就是说要让公司变成一个这个螺丝掉了就是拿一个螺丝再放进

去这个人走了再换一个人去递补都可以这个是对公司经营而言这是最低风险而且能够长久之计所以比如说我们有一个例子今天有一个大新闻大家都知道就是Steve Jobs好像是今天还是昨天好像已经过世像Steve Jobs他就是一个非常聪明然后又非常有远见的一个人所以大家都知道说苹果

他们很多那种成功的产品全部都是经过他的一人之手然后他在严厉地去督军然后才能够有这种这么成功的产品出现可是一家公司苹果现在市值已经这么大如果说这家公司还是看那一个人没有那个人不行的话那个公司一定有问题所以我们就看看说苹果它有没有第二個 steep job 出現如果沒有的話我們就看看說這家公司它往後十年到底會怎麼樣所以回到這一邊

最後一句Algorithm 如果不好的話你要怎麼做都沒有用所以還是要回到如果說你的工作的性質是屬於你要做 algorithm optimization還是要回到這邊來接著我們再來看Array跟這個PointerArray跟Pointer呢這個同學有寫過C的話應該Suppose應該都已經知道如果這部分同學還不知道的話就表示說你對C還不熟還必須要再多加把勁我們知道說我們在C裡面你宣告Array其實你也可以不用宣告Array你可以宣告這個Pointer看你是Initial的Pointer還是Character.

Pointer或者是14.-pointer之类的你不管用array或者是用pointer你都可以去access一个连续的data但是你如果是array的index的话它通常都必须要去做哪些事情呢你要把index把它乘以乘以多少看是你的element size接着还要再加上你的array base的一个address你這樣子做完之後就是base再加上offset你就可以去定指到你array裡面的某一

個element所以這是我們用array的一個方式如果是pointer的話pointer我們知道它其實就是直接指到這個memory的location指到某一個address指到那邊去它就可以去抓所以它這邊告訴我們說它可以避免index的complexityindex的complexity我们这边有一个例子就可以很清楚的看得出来说我用array写跟用point写它到底有什么样的不一样的效

果这边是典型的就是你宣告一个array你送过来是送一个array你就直接用index然后把这个array全部都设为0所以这边的code应该没有问题这边是i等于0接著你會把index你’ll把index乘以4然後接著再找出就是再把base跟offset相加就會得到它你這個array的element它的address就做後面的這個事情所以它的loop你同學可以看到你每一次它每一次loop就是說當你這個i是小於size的時候它回到這一邊它要去怎麼樣呢你的i要乘以4

就是你要去算你的offset然后你的base再加上offset所以你每次回到这个loop都要做这件事情但是我如果是用这个pointer的话它这边就说你的这个p它是一个integer的一个pointer所以它是第一个element的edges第一个element的edges然后这个p当你是小于等于最后一个其实它最后一个是size-1所以你这边是小於所以当你是小于等于你最后一个element的address的时候

它都会把这个element设为0我们这边P等于P加1我们知道说它是指这个element因为我们这边已经宣告是它这个pointer是integer的pointer所以它P加1的时候它的一个位移的offset就是一个integer就是一個integer一個integer這邊32個bit它實際上就是byte address就是加4就是這樣子所以它的code呢它的code是類似像這樣子所以它這邊先算出第一個element的 address第一個element的 address它已經算出來接著呢它算這個offset它算這個offset那offset算完之後呢它就是把這個

Element这个offset是指谁呢是指这一个Array的最后的那个Element的下一个word到底是多少就是ArraySize它的Edges所以这边它就是把这个Size直接乘以4所以它算出来比如说你Array如果是0到9的话这一个就是10这是10的位置Array10的位置可是实际上Array10它是out of boundary它已经out of range它已经超过这个array的这个range它只

有0到9所以这实际上是array4的这个位置所以你把第一个跟最后一个的下一个的位置都算出来之后它的loop就在这个地方所以你看它每一次它每一次这个address就是加4它每次address就是加4然后这边就是在做这个比较的动作然后它每次都把它先设为0然后再把P加4然后再做比较那

如果比较完之后呢它loop就是回到这个地方来所以同学可以发现的就是说这里跟这里的差别就是它这边要做indexindex定值但是它这边呢这边不需要做index的定值因为它这个就是address所以它每一次address都是加4加4加4那它就是它也把最後一個 address 也算出來就是比較 T2就是 T0 跟 T2

做一個比較所以很明顯這種用 pointer 的寫法它就不需要做 index 的 operation所以同學不用緊張說那以後我是不是都不要用 array或以後每次用 C++ 在寫的時候我全部都用這種方式來寫每次寫的時候都要想想看說我的我的assembly是不是会转得比较efficient同学不用紧张因为这种事情看起来就是compiler可

以做的事情就是compiler的optimization在做什么呢它就在做这也是一个例子它不会帮你compile成这种code它会帮你compile成这种code如果那个compiler它只能够帮你compile成这种code那当然就是這個Compiler一定比較便宜因為它的效能比較差它一定賣得比較便宜就是這樣所以這邊都是我剛跟同學提到的所以這個同學自己看一下我們就跳過ARM MIPS還有INTEL他們的這些比較這同學回去自己翻一下這些reference

第二章最后我们来看几个phoracy第一个它说我们这个powerful instruction就会有比较higher的performance为什么呢因为我们需要的指令会比较少其实这边都跟同学提过了在前面跟同学提过为什么呢主要的原因就是它powerful自然而然它叫complex它是complex的一个instructioncomplex的instruction你要用hardware去realize就会比较

难比较难的意思就是你设计出来的hardware它的delay可能会比较大那就变成我们前面有一页的投影片跟同学介绍的是什么呢你一个instruction它的delay如果比较长那它會影響到其他比較短的delay的instruction它都要cycle time實際上不是被短的來決定是被長的決定除非那個長的呢是短的兩倍那你可以cycle time可以設成短的delay如果它沒有到兩倍那你只能夠設成比較長的delay所以等於說你比較快的instruction它執行完每一個cycle它都要idle

這個實際上是不好所以這個是有問題另外一個牽涉到這種我們通常在做optimization的問題我們通常在解一些NPComplete的問題Compiler它也是需要解這一類的問題它說Compiler它怎麼樣呢它要去處理它要去產生optimization的code的時候通常它的效果会比较好什么样的情况之下效果会比较好

就是说它能够用的指令的instruction set种类越少越简单效果越好这是对compiler而言对compiler而言这科想的键应该是这个样子所以同学可以想想如果说给你给你十个工具跟给你一百个工具那请问你要把一件事情做最佳化请问你会觉得我相信有人会挑十个有人会挑一百个都有因为有人会觉得我有一百种工具那应该他可以做很多事情所以我想要做什么时候我就会拿那个这边都可以找得到但实际上你用另外一种design philosophy来

来看这件事情的时候我们可以说我只有十个工具的时候我对这十个工具的应用会如何澄清所以我要拿这十种instruction去do不同的operation的时候我通常会do得比较漂亮所以这是一种不同的设计的哲学所以他这边他的观念就是在传递这件事情所以你的instruction越简单總列越少你compiler它在做automization的時候

它的結果通常會比較好所以這個是它告訴我們的一件事另外一個在剛剛有提過就是說我們用這個assembly code的時候我們可以去精精計較很多一些instruction我們可以把它拿掉一看就看得出來說它是redundant就可以把它拿掉所以我們是不是所有的program大家都來寫assembly當然不是因為你如果

全部都是寫assembly的話你會碰到一件事情你會碰到就是說會有你要maintain的code是非常非常的大通常你要maintain的code的數目太大的時候錯誤就會錯誤百出就會錯得很離譜就對了或者是說就不好maintain我也可以举一个例子举一个例子就是说以前我们公司的Tool因为我们公司的Tool是卖给做IC设计的做IC设计虽然说世界各地都有不过最主要是集中在美国美国的西岸跟东岸他们在做IC设计的Designer他们有一个习性

就是我前面提过的如果说你是用PC的话下班之前请记得关机如果你是用Wallstation的时候大概没有人说你下班的时候要记得关机顶多是记得要关萤幕就是这样子所以那个Wallstation它是从来不关机的我们就有一个customer他就feedback一个bug他就说那個程式怎麼用用用之後他後來Memory

就爆掉了爆掉以後就沒辦法用了所以我們就派一個工程師去然後就提著一個手提箱通常這種Debugging的就拿著手提箱然後就是要行走天涯看哪個國家有bug就要去哪個國家他就到美國去然後一去之後就差一點就昏倒为什么呢 因为说那你那个可不可以reproduce给我看你要抓bug第一

个就是问我们在debug第一个就是什么reproduce 对不对你reproduce bug你才能够debug结果它reproduce我这个tool已经run了超过半年以上了这半年来它每天都在工作所以这个东西很难reproduce虽然说我们有去记录它的script但是script你要能够懂你也必须要你的电脑里面的那些design那些file全部都还在那边所以你的script你才能够从半年前开始慢慢跑把所有的program曾经跑过的stack从头再跑一次不过那个程式实在是太大了

就非常難抓他們花了很多很多的時間最後才發現說系統的Memory就是Memory Location還有Free它那個是有一點小bug後來他們就自己去寫才把那個bug改掉這個中間當然就會牽涉到很多問題因為一個程式那麼的大然後那麼多個team那麼多個team在maintain一碰到bug當然第一個就不要是我的bug是最好

所以当你bug那么大的时候，你要怎么去locate说你这个bug到底是A team还是B team还是C team的这个问题。所以你的code越多的话你的这个ever就越大。另外一个就是说我们有人会有一个观念说我们每一次deliver一个新的version的product我们必须要跟之前的version要能夠相容。那你如果要相容的話呢你就必須要怎麼樣比如說我們的CPU我們就是看它的instruction set那我們

說那你的這個CPU你的新的版本跟舊的版本是不是相容如果不相容的話呢那會有很大的問題那既然這樣子的話呢是不是我們的instruction set全部都不要變都不能改因為你改了之後它可能就會有問題实际上并不是这个样子以这个X86他们的instruction set而言课本那边就写说平均就是在X86他们这三

十几年来他们平均是一个月会增加超过一个instruction可能不到两个他们平均一个月就会增加一个instruction所以从早期一直到现在他的instruction它的instruction set已经变得非常非常的大所以它是有需求的时候它还是会增加所以我们可以看到它的这个数目是一直在增加的另外这个我们刚刚已经提过就是它的一个element如果是4个是4个byte它这边就加4不是加1另外还有一个这个是跟programming有相关的它讲说我们在你把一个这个pointer

你把它指到一个automatic variable这件事情是非常非常危险的一件事情因为我们知道说这个automatic variable你在你procedure return之后其实它那块就已经变free那free之后你又是什么时候会被改掉你如果有指到一个pointer指到那个地方那你后面程式怎么死的你都不知道你就每次call dump你就call them在那个地方可是你看一看怎么样都没有错所以这个是最头痛的一件事情

所以我们在写程式其实最头痛的就是memorymemory的bug是最头痛的不过我知道同学在学校写的程式很少都有这个memory的bug因为第一个第一个大概就是因为test case都很小所以大概很少会测试到这个memory的这个bug实际上你在外面写code最上脑筋的就是memory的bug所以同学如果说可以找到

一些open source就是可以帮你分析这个memory的一些information同学应该就要现在学着去用那一类的tool你每一个program写完之后你用那种memory的分析的tool去帮你做分析让你学会怎么去debug这个memory或者是同学就要自己去做这个memory的management尤其是你在写大程式的时候你一定要自己去manage那个memory你这样错的时候

比较容易debug所以我们第二章大概就是介绍到这个地方这边只是在做一个回顾就是说前面这四个很重要的design principle还有这个software hardware的这个layer就是我们刚刚看到的那一张斜线图然後這邊有列一張圖表MIPS它的designphilosophy就是要讓最常用的case讓它快一點然後不常用的它就不會把它放到instruction set裡面來所以它這邊有統計就是說以我們剛介紹過的這些指令在這個spec2006 integer的benchmark或者是spec2006 14-point的benchmark

它们占的比例大概是多少同学可以发现说它的比例非常的高这些都是很基本很简单的这些指令那也可以做得很快所以这个就是MIPS它的设计的哲学就是这个样子所以我们第二章大概就跟同学介绍到这里那下礼拜四下礼拜四的小考范围就是第一章跟第二章所以同学可能是选

择题跟是非题不会有问答题。同学不用把它想得很难，就观念观念清楚就没有问题所以这个是我们下礼拜四同学要记得，我们第三章我这个投影片还没有放上去。我们大概今天下午就会放上去，第三章我们是要跟同学介绍computer的 arithmetic，我们知道说 arithmetic其实这是电脑里面最核心的单元。我们很多

运算全部都是要靠 arithmetic的operation。这一个 arithmetic我们从最简单的AND OR还有加法器来看，就是说这边首先是要跟同学介绍basic arithmeticlogic unit所以包含算术包含logic的单元，所以我们来看说一个bit的LU，我们可以做AND做ALL还有做加它大概是长什么样子。如果要做AND ALL的话很简单就是这样子，可以做AND可以做ALL。同学不要以为说它做AND就不做ALL，它做ALL就不做AND其实它是AND ALL。

反正不管做不做它就全部都做做完之後再用一个Multipleaser去选择你到底是要把End Output輸出还是All Output輸出。所以同理，你如果再做一个加的话它也是一樣，所以这个是一个负A的，就是A然后B还有Carry In所以是一个负A的所以你Howard开始同时做它也是End All加大家都會做 做完之後用一個Multiplex

er看看要選End還是All還是Addition所以我們從這個最簡單的架構我們就可以看到說它一個1-bit的一個Cell是1-bit Input 1-bit A Input B Input還有一個Carry In然後這邊有一個Carry Out這邊有一個ResultResult也是1-bit那這邊呢就是这个 multiplexer它的input selectioninput selection就是决定说你到底要执行哪一个operation是这个 这个

还是这个我们再把这个刚刚看到的osmetic bludgeon unit再把它做一个做一个enhanceenhance什么呢同学可以看到就是说这边b是做一个notb是做一个notB是做一个NOT所以就等于说我们这边一个是B进来然后这个是NOT B从这边进来所以我们如果是以这个加来看的话这边就变成什么呢A加B或者是A加B bar那你A加B bar是什么东西呢A加B bar不是我们要的我们要的其实叫做减

我们知道说它如果是用tooth complement就是要有一个carry incarry in如果是E再加上not A它就是一个tooth complement所以我们这边carry in然后在这个not B再加上A这边就变成是一个A-BA-B的operation所以我们这里就提供了加法跟减法所以看你是要做加还是要做减就是由這个地方來控制就是B Invert如果說我們

要做這個NAND跟NOR的話就是連A也必須要提供NOT NOT B NOT A我们知道说NOT A NOT B做一个AND那就变成一个NOR 对不对就会变成一个NOR所以你如果要做NOR的话就是这边要设1这边也要设1然后NOR就是这一个这边就要设0它output就会从这边出来你如果是要做NAND的话就是这边设1这边设1这边就会从ORAORB变成AB的NAND然后这边要设1结果就从这边出来就是这样子所以这是一个基本的加减法还有NO

所以我们从这边看的话从一个bit再变成32个bit就是你把刚刚的1 bit cellcopy 32份copy 32份copy 32份每一份都有这个A invert这个都是同样的讯号A invertB invert这也是同样的讯号然后这边有carry in这边carry out变carry in然后这边的carry incarry out变成下一集的carry in这边的operation选择and or或者是加减就是从这边来选择这个都是同样的讯号这是LSB这是MSB就是这样就是32个bit这是一个标准的一个简单的32bit的LU我们今天上到这里.