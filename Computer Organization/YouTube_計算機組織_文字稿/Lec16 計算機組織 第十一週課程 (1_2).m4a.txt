undefined
那我们来看一下这个Branch Hazard我们前面已经跟同学介绍过Forwarding的机制然后还有就是检验是不是有这个Hazard发生那如果Hazard发生的话呢就是有Data Hazard发生的话我们必须要做这个Store的这个Operation它就是把那个Stage它的Control的这个Signal全部清为0那这边黑澤主要就

是在探討Branch這裡面提的一個例子他是說假設Branch的Outcome determine在Memory的Stage來決定Branch的Outcome所以他的在我們知道說Memory的Stage他就是在這個地方所以他說在這個Stage裡面他就決定了它这个branch到底是要跳到这个target它的target到底是要跳还是不要跳既然是在这个stage决定

的话所以其实它能够真正开始把正确的instruction把它导入的话它就是在下一个stage所以它说在这个stage决定然后进到下一个stage的时候我们在这里我们就可以知道说它的target就是这边所谓的load我们在这个例子里面它是beq下一个指令and再下一个是or再下一个是aid后面72的位置它是一个load的指令这个load实际上是这个branch它真正这次执行的时候它是会在beq它比较之后它会跳到load的指令所以它在这个stage决定了它的

要跳不要跳那它的address那些都算出來了所以進到下一個stage的時候它的target instruction就load進來就進到了這個pipeline裡面開始執行以這個例子來看的話就是說我們branch如果它的outcome必須要在這邊才決定然後到這裡才真正落實來執行的話我們可以發現這中間1 2 3的三個cycle发生了什么

事情呢它把一些无辜的指令全部都漏了进来包含这个AND也进来了然后ALL也进来了然后AID也进来了所以三个这个不应该执行的指令全部都进到PUBLINE所以它这边讲说我们必须要FLASH这些指令FLASH这些指令的意思就是说我真正target的instruction进到PUBLINE执行的时候我也必须要顺

便把这些不应该被执行的instruction把它从publine里面把它remove掉或者是好像把它洗掉一样也就是说它还没有执行完的我们当然就是不让它继续执行我们不让它继续执行基本上其实就是把那些相关的那些signal全部都怎么样全部都设为零你全部设为零的话他也不會Read他也不會W

rite那他不會Read不會Write那他即使做了什麼樣的Operation他也不會去影響這個CPU的這個整個State因為我們知道說State基本上就是由他所相關的這些Register在記錄說我們目前的CPU的狀態是什麼所以我們就是不允許他去做一些Write的這些Operation所以我們就是必須要把這些全部Flush掉那這個例子他為什麼會

把它舉例說我們要在這個地方這個Stage決定然後從這個Stage開始Initiate真正的Target Instruction的Execution實際上我們在前面介紹的這個CPU的這個Design的話我們知道說實際上它在這個Stage就可以決定了對不對因為我們的Comparison我們是在透過這個LU做Compare那我们这边也会有一

个addr来计算这个target的这个addresstarget instruction的address所以实际上我们在这个stage就会决定那它把它拉到这边我想这个只是在用一个例子来说明说你如果是在一二三四第四个stage才决定第五个stage才把这个target instruction把它issue到这个popline你中间其實已經塞了三個instruction進來因為我們真正的這個

CPU裡面的design它如果是一個比如說是一個CISCCISC的一個architecture那它的pipeline實際上可能會比較長它不是像我們這邊就是五個stage當你的pipeline比較長的時候你有可能你有時候你的這種Hazard的情況你必須要在比較後面的Stage才能夠決定那這個時候你可能會面臨像類似像這樣子的一個情況你會損失掉這邊就有三個Clark Cycle全部都浪費掉那你也必須要去Take care這些已經進來進到Popline那實際上不應該被執行我們必須要把這些全部都把它Flush掉

所以这个例子应该就只是让同学来了解这样子的一件事情我们前面其实已经提到过说我们前面介绍的第一个版本我们实际上在这里就可以决定但是这里决定的话还是不够快所以我们前面有提到说我们前面的一些讨论我们是suppose说我们已经加了一些hardware在第二个stage加了一些hardware在第二个stage使得我们的branch的outcome在第二个stage就可以

产生如果是这样子的话这个是最好的一个结果所以我们这边就讨论到说我们必须要reduce我们的branch的delay ay我们必须要把一些hardware去决定这些outcome的hardware把它move到哪一个stage呢就是第二个stage就是这个Decoding ID就ID的这个Instruction Decode这个Stage那它包含了什么呢当然就包含了我们第一个提到的就是Instruction Address你

要怎么得来因为我们的这个LU我们是在第三个Stage被执行所以你要在第二个Stage算出它的这个Target的Address所以你必须要把这个Ader把它搬到第二个Stage那第二个呢就是我们的这个Register它的內容它的content的comparison必须要有一個comparator就是要有一個comparator所以這個也不是利用我們的LU來算也是必须要有额外的一個hardware comparator這樣子的話我们把它搬到ID stage的话我们branch在第二个stage它就可以完成这个判断然後決定要跳到哪一個address這邊的一个例子

它就是一个Branch taken它就是veq它会跳但是compare是equal所以就会做一个Branch的动作那这个例子就是我们刚前面看到的那个例子就是它会跳到这个72这个load这边来所以我们可以来看一下就是说以我们说假设它是一个Branch taken的一个例子的话它veq是在这个地方veq就是说它下一个指令是一

个and这个and它的address是44它是44所以你44进来的时候它到这个instruction memory它就会把这个and的指令它把它抓过来那and是44所以veq是多少呢veq就是40BEQ的40所以当BEQ当初原本在这个stage的时候它这边是40BEQ进到第二个stage的时候大家记得它40加4是44所以44就会跟着BEQ进到第二个stage所以这边为什么是44这边44就是因为BEQ它的address是40那40我们知道说它把BEQ抓出来的时候

它的point counter就會加4所以就是40加4就變44所以這44就跟著VEQ一起進到第二個stage所以在VEQ算它的targets的時候就是它的44再加上它的一個offset一個offset所以就是44加28加offset加18所以就等於72這個72就是萬一要跳的時候它的target address就是72所以72从这边feedback回到这边来就是

这样子所以同学要了解这边有什么44就是我们前面讲的你在算VEQ它的算法就是PC加4再加上一个offset所以PC加4就是44我们在这里看到说这里多了一个ether这个ether就是要算这个target然后这边多了一个等号这边等号呢它等于就是把这个两个registerregister我们一次可以读两个register

出来所以这边是这个ALU的这个input source第一个input source这是第二个input source那读出来的时候呢我们就可以直接对它做一个comparison直接做一个比较所以我们在这个stage呢这个comparison做完以后呢它其实就已经等于可以决定那个flag就是说它们两个是不是相等相等的话相等再加上这个

control已经decode说这个是一个VEQ所以它有很多条件要满足这个control它已经知道说解读decode出来说这个是一个VEQVEQ的指令然后这个comparator也把这个两个register的内容做一个比较然后它也相等所以這樣子就可以決定說這一個要跳就是這一個跟這一個這一個是pc加4然後這一個

就是它的要taken的branch所以就可以從這個multiplecer就決定說72要過來所以72過來那72過來所以我們這個實際上是在這邊整個cycle結束之前，它就已經完成了這comparison然後這個加法，然後它已經決定了這邊這個Multiplexer就是要選擇72過來，然後它的Wait在這一邊等到下一個Clark Cycle這個Edge Trigger上來的時候，那這個Program Counter它就會被update成72那72這個就是什麼呢第一個Instruction Fetch的這個Staging它就會把72的指令把它抓出來，它就會把它抓出來所以

这边就是我们这边看到说Branch taken所以同学可以看到它下一个进来的时候这个72这边就会被update成72原本72已经wait在这边了，所以它在这里等那个Cloud Trigger上来的时候PC Program Counter update成72，272 load就会被抓出来，然后VEQ它就会进到这边其实VEQ进到这边来其实它该做的事情都已经做完了，它该做的事都

做完，这边是要做什么呢，这边就是要把这个stage，它目前应该要执行哪一个指令，我们知道这个stage目前是不应该执行任何指令，所以它也会把这个stage全部把它设成no operationNo operation 怎麼設呢其實就是把這個 control 全部都清為零，全部都清為零，它就選擇這一個零選擇進來，所以這個零就會跟著它一起跑一起跑跑到這邊整個 top line跑完一遍，所以這邊就等於是加了一個 bubble所以我們從這個例子來看的話，它就是會有這樣子的一個bubble 的存在，

它等於會有一個delay到這邊同學有沒有問題，你說它的output嗎？這一個這個output其實就是我們就看這個好了假設沒有做這個更動的話，没有加了這個Compare也没有加這個Aid是放在這個Stage，這個Target Aid是放在這個Stage，這個Compare是在哪邊做在這邊做， 對不對我們知道說在這邊做其實它Compare它就是做相減相減的話，

如果说两个相等的话，一减它就会变0变0话，我们以前这边LU不是有一个0的一个frag吗？那0的frag如果说它被turn on的话其实就是表示说它的这个减法减完以后是0就表示这两个这两个input是相等的它们两个是相等所以就是表示说BEQ它是equal所以它叫branch所以我们就说这边的这个ZeroFrag我

们会拉过来然后跟这个它是不是VEQ的那个指令做一个End然后来决定这个Multipressor到底是要选择Branch的Target还是要选择PC加4这是我们传统的这个做法，那我们现在这边加了一个Comparator其实同学就可以把它想象成说这个时候跟VEQ去做End的那一个已經不是這邊的Zero flag实际就是這個Comparator Comparator如果是它

的结果是True就它們兩個的結果是一樣的它们兩個结果是一樣，所以它的True就直接可以跟它的這個，它是不是VEQ的指令的這個flag它做一個End那 End，如果是True的話，它的這個Multipressor它就會選擇這個VEQ的Target進來，如果是Force它就會選擇PC加4對 它就是直接跟這個Ctrl我們已經判斷出來它是不是一個Branch的指令做一個End，直接做End，那樣子

就可以，這個就不用再做了，所以我們就說，如果加了這樣子的一個Hardware的話，我們就可以，在第二個Stage，我们可以把VEQ的Operation全部都Complete，他可以已经可以决定说target address是哪里，然后要不要跳他可以決定了，所以等到进到BEQ的指令进到这个stage的时候，它的真正的位置，它的instruction就可以进到这个废墟的stage

就是，从最右边寫到register那到底做什么，这边会不会有可能这些最右边的instruction会影响我们的register如果会影响的话我们会不会算太早我们右边还有两个instruction他们还没做完对会不会影响我们的register改变我们的branch当然会，这位同學的問題很好就是说我們以前在討論這個data hazard的時候我們是suppose什麼呢我們是假設說我們會用我們的register是在execution stage會使用對不對我們會使用這個我們會在execution stage來使用我們的register的內容

Register的内容我们在ExecutionStage决定的时候我们的Forwarding的机制不是都是假设说它就是在这边使用的可是我们现在我们把这两个Register我们已经不是在ALU里面执行我们是把它放到这边两个Comparator其实这边碰到的问题其实就是说我们的Forwarding的机制如果当初原本是假设它是在ExecutionStage这边执行的那其实我们在VEQ

的这个指令我们在讨论VEQ的这个指令如果是用这种机制的时候呢我们必须要把它移到移到哪一个Stage呢就移到这个Stage就是必须要移到这个Stage那如果说你没有办法在这个Stage执行的话呢就是forward ing你没有办法执行的话，那大概就是还是一样必须要用这个store的一个机制不过我想这部分

在课本里面它并没有讨论的非常的detail就是说同学可以发现说从课本后面以后就已经没有在讨论forward的机制我们forward的机制是在前面讨论的我们前面的讨论我们forwarding前面的这个机制我们其实都是我們都是assume說我們的register它的use是在execution stage所以這邊同學要搞清楚说前面的skin我們都是在這邊來使用register的data這邊只是說我們在加入說我們如果要把這個branch的結束

不要讓它在這個Stage結束我們必須要把它提早到前一個Stage所以這個時候在這裡會加了一個Comparator但是你這邊加了以後就會面臨到Forwarding你必須如果说要考慮到Forwarding不是在這个Stage可能就是它的機制必須要做修改但是這部分基本上我們要討論這部分的內容同學了解這個差異這樣子就可以了還有沒有

好 那我们继续再往下看这个就是我们刚刚提到的就是所以它进到第三个stage的时候这边就进来如果没有加这些hardware那传统的我们就是必须要beq进到这个stage的时候这个加载才会进来，它是传统的就是没有加这个的话，它是要在这里算完，compare比较完以后，它已经决定了VEQ进到这个stage的时候，

load才会进到这一边，所以这个是有加这一个跟这一个跟没有加这个的差异，所以这边就有提到刚刚同学提到的这个内容，这边看到的这个data hazard实际上我们以前是位到这个execution stage，现在我们已经把它搬到搬到什么呢搬到这个decodedecode的这个stage所以它这边分了几个case是，就是说BEQ，它compareregister1跟4这两个register，它在前面这边中间还隔了一个指令，这点点点不是说有好多个指令只有一个指令这边隔了一个指令，所以它的前一个指令的

它前一个指令跟它没有相关，但是它的前两个跟前三个指令它的这个output就是这个VEQ，它的要use要使用的register，所以以这种情况来看的话，我们可以发现说需不需要做一个store需不需要等它的output存到register之后再执行这个VEQ呢，我们发现其实是不用的，因为这个aid，因为它ExecutionStage结束，它的结果就算出来

了，所以我们可以直接位到这边来，这一个因为它是Memory它这个Stage它也算出来算出来再透过一个Stage的Transfer所以在这个地方它也一样直接可以透过Forward的一个机制Forward到这个InstructionDecoding这个Stage这个只是一个示意图这个示意图它并没有去在討論說我們前面去看到的就是說比較det

ail forward的一個機制你要怎麼去做這個修改同學有興趣可以去想想看說你如果是味道這一邊的話前面介紹的那個內容要怎麼做這個修改這個是第一個case第二個case它告訴我們說就是我們的這個BEQBEQ原本是在這個地方就是它一個load一个load1还有一个aid4接着再做一个VEQ1跟

4做一个比较这样子的一个比较我们可以发现说它就必须要做一个store它没有做store不行我们可以来看说假设VEQ是紧接着aid这个指令进到popline所以它decoding stage在这里它就必须要使用使用这个1跟4很不幸的1跟4都还没有出现1必须要memory stage结束之后才会把1读出来这个4呢

5跟6相加也必须要execution stage结束之后它才能够把它加出来所以它真正available是在这个time这个时间点它才出现所以同学可以发现它没有办法喂到这一边所以它只能够喂到这一边是最快的最快的是位到这边所以这样子的话我们在这边必须要storeStore我们的这个VEQ就让它keep在reg

ister里面经过一个cluck cycle它又回到这边让它重复delay一个cycle这样子就可以比较一跟四的一个内容所以这个是第一个case跟第二个case它们唯一的差别是说它的VEQ跟这个aid它们之间并没有间隔任何的instruction它是紧跟着它的output的那个instruction第三个case这个就比较长它是直接紧跟着什么

呢前一个case它的beq是紧跟着它的output的那个instruction但是那个output instruction它是一个rtype它是一个rtype的instruction因为我们知道说rtype它是在execution stage结果就算出来第三个casebeq它紧跟的那个output的instruction是什么呢是一个load我们知道说load它是会delay一个stage它不是execution它是一个memory的stage才会output它的结果它的结果才会从memory里面读出来所以我们在这里看这边怎么forward都没有用一个cycle也没有用要两个cycledelay一个cycle

它还是不够原本是在这里它delay一个cycle出现在这里还是来不及你还要再delay一个cycle它的decoding stage才会出现在跟它同一个time的这个时间点才可以做这个forwarding所以它要delay几个cycle一个 两个它要delay两个cycle所以这边就说我们必须要两个store cycle才能够才能够执行这个VEQ所以VEQ跟在

这个load然后又有data dependency这个是最不愿意碰到的一个情况你就要store to cycle所以既然已经加了一个hardware加到这个decoding stage它还是会碰到就是说我们前面看到的这个hazard它是属于它的就是說它的這個data那如果說因為它的這個data hazard的關係其實我們可以用什麼方法來解決呢就是用

我們前面有提到過的就是你如果可以instruction的reordering你可以給它做一些reordering那中間如果加了一些那個就是把一些指令加到veq跟load或者是它的這個rtype的這個中間那我们就可以解决掉这样子的一个问题那另外的就是说Branch它如果说碰到比如说像我们前面这边看到的的一个

例子它的Taken那它还是必须要做一个Store它还是要浪费一个Cycle所以我们有没有可能就是让它有没有办法让它不需要Store任何Cycle呢那这个就是我们前面提到的这个Branch的PredictionBranch的Prediction呢我们之前已经提到过Static的Branch Prediction我们现在跟同学介绍Dynamic的Branch PredictionDynamic我们前面已经介绍过它的观念就是我们会有一个所谓的History我们会记录它猜的历史过程这个就好像说

在買那個大樂透不是很多人都會去找什麼一些那個地方的什麼廟然後去求那個名牌有一些廟的香火特別旺就是什麼就是好像那邊有出過什麼名牌不知道是真的還是假的所以就會這一種就是他已經加入了什麼呢historyprediction的這種機制跟觀念就是要去找那個曾經有種過那個大樂透的還有

要去買那個千大樂透就會去找什麼就是哪一家曾經開過開過首獎 特獎這種也是所謂加入這種history的一個機制這個history的機制我們在這裡面來看一下就是說在一些比較深的這個popline我們這邊看到的popline stage只有5個stage我們前面講說popline stage有12個stage那你如果是在第6個stage然後猜錯

了結果你前面這五個進來的instruction全部都flush掉這種penalty非常的重所以我們需要一個比較好的猜測機制所以他這邊就提到說有所謂的BranchPredictionBuffer或者是所謂的BranchHistoryTable不管你是叫Table或者是叫Buffer基本上它就是一些Memory的一些Location這個Memory可能是特製的比較快的所以這種History Table或者是 Prediction Buffer它總是要來我們要去Index我們要去Access某一個Table的Entry或者是某一個Buffer我們必須要有這個位置Address所以它是Index by Recent Branch Instruction Address

它是最近這個Branch Instruction我們知道說VEQ它出現在很多地方每一個VEQ都有它的address所以我們可以透過每一個VEQ它的address來讀取說跟這個VEQ相關的這個buffer到底在什麼地方比如說我們可以取這個VEQ它的address的後面的幾個bit這樣子或者是前面取它的某一個特徵然後來index來去access這個buffer所以它的這個address的機制基本上就是用我們的

這個veq它的address的某一個某一些部分的bit來address來定值它的跟它相關的這個buffer這個buffer是存什麼東西呢就是存它到底是拆taken還是not taken就是說我们来看说我们这个BEQ它的behavior最近到底都是一直taken呢还是not taken所以在执行一个branch的时候我们会先check这个table我们就会希望说我们这一次的结果其实是跟它前一次的结果是一样的所以我们说我们预期

我們希望它是有相同的一個 outcome所以相同的 outcome 當然就是說它上一次如果是猜 Tekken那我們這一次大概就是跟著它猜 Tekken如果說萬一都是 Tekken 一直猜對的話它就會一直猜 Tekken一直猜一直猜一直猜直到猜錯了它才有可能去做這個改變基本上就是這樣子所以它如果猜錯的話它可能就是要做兩件事情

第一届就是要flush pipeline因为猜错了所以猜错了所以之前进到pipeline里面的那些指令都是错的因为我们之前是用猜的方式把下一个要执行的指令把它搬到pipeline既然猜错了那些进到pipeline的那些指令就要把它flush掉另外一个就必须flip你的prediction因为就是说我们比如说我们都是猜

Taken就猜错了就把它Flip变成Not Taken下一次进来的时候它就会猜Not Taken这个是一个最简单的一个Dynamic的一个Branch Prediction的一个机制所以我们等一下会来分析说这样子的机制它的Accuracy到底是多少有没有机会Improve它的Prediction的Accuracy所以这是后面要讨论的所以接着我们来看

第一个这是所谓的One-bit predictor就是说我们每一个VEQ它的这个buffer都只有一个bit只有一个bit就表示什么呢我们就根据那个bit来决定说我的这个VEQ这个指令到底要拆taken还是not taken我们用了一个例子这个例子就是它有两层的loop这个是inner的loop所以它BEQ就是在这边然后第二

个BEQ它是一个outer的一个loop我们程式里面常常有好多loop就是可能里面有四层五层如果写得太复杂的话它可能就要搞很久都跑不出来所以这种两层的loop的话我们说我们这边假设我们说这个inner loopiterate three times所以它就是iterate三次然後就離開然後再進來又三次又離開iterate三次其實就表示說我們到底會猜對幾次譬如說我們假設我們進來的時候都是猜taken它都要跳所以同學可以看one beat

就是說只有一個bit它就一進來 反正它要猜跳Taken我們說它要iterate就三次跳猜對了猜對了然後第二次又第二次它要再回去它執行第二次的時候執行完它要再回去因為它要執行三次它要執行三次所以執行第一次他猜 taken 沒有錯他要跳到這一邊跳回來他要跳回來你如果是 not taken就是

繼續執行他就繼續往下執行那你要回到前面去 loop你就是要 taken所以你執行完第一次他猜 taken所以猜對了所以這邊講說猜對了執行第二次還是 taken再回到前面執行第三次三次已經執行完了它要结束 要出来这个时候再猜taken这时候是怎么样猜错这时候就猜错了因为它执行三次以后就离开这个loop执行三次以后离开这个loop所以在这三次里面它的decision正确的decision应该是taken第二次taken第三次not taken应该是这样子

但是因为它都是照着前面的方法去猜照着前面第一次taken猜对第二次taken猜对第三次因为前一次猜taken猜对所以它第三次它要猜taken所以是猜错了猜错了以后它这边就会flip它的buffer就会flip从taken flip它的buffer就会从taken flip成not taken它的buffer这个VEQ它的buffer就会从taken flip成not taken接着它要

继续执行执行到这边这个是它的outer loop它要回到这边来回到这边来然后又进到这边又进入了这个VEQ假设它还是一样执行三次所以第二次经由outer loop又回到这个inner loop所以第一次执行的时候他會猜什麼他會猜什麼這個時候他會猜什麼他會猜 not taken對不對因為他剛剛離開的時候猜 taken 猜錯了實際上是 not taken所以他的 buffer 會被 flip 成 not taken因為他要 follow 他的前一個 iteration 的 outcome前一個 iteration 的 outcome 是 not taken

所以他这次第二次进来的第一个iteration他会猜not taken又猜错了第一次执行完not taken猜错第二次执行他就知道他猜错了所以又被flipped成not takenflipped成taken所以他第二次的时候他就学乖了他再猜taken猜对了第三次执行的时候其实是要离开了其实是not taken但是它要猜taken又猜錯了所以它等於怎麼樣呢它都

要錯兩次就是錯哪兩次呢就是這個iteration的最後一次要離開的時候它會猜錯要離開的時候要離開的最後一次要猜錯還有下一次再進到這個loop的第一次又會猜錯下一次進來的第一個下一次進來的第一個又猜錯然後又對 又對 又對對到要離開的最後一次又錯了所以它就是一定會連錯兩次它一定連錯兩次這個就是one bit的缺點就是如果我們每一個BEQ它的你的table entry或者是你的buffer就是one bit它只能夠記錄兩個state

一个是taken 一个是not taken所以你就是永远在那边flip他就是永远最后一次离开的时候会错还有第一次进来的时候也会错中间都会对所以如果你的iteration的次数很多的话你的accuracy会很高但是你的iteration次数很少的话你的accuracy会很低你的accuracy就非常的低最低的是什么最低就是两次所以你就在那边一

直错另外一个比较好的方法是什么呢是2-bit我们说1-bit它的accuracy没有那么的高所以我们希望说我们不要错了一次就被吓到了然后就换然后又再错所以这个时候你必须要加一个2-bit2-bit它的机制就是2-bit它可以代表四个state那四个state呢它就不會說就是只有taken not taken它可以什麼呢它可以兩個taken兩個not taken這兩個taken呢兩個taken跟兩個not taken你還可以把它區分開來區分開來什麼呢區分開來譬如說這個是

錯一次的taken然後這個是都沒有錯的taken為什麼要區分成這錯一次的taken然後這是沒有錯的technique因為我們說我們要改善這個one bit的現象就是什麼呢我們要容許它可以錯一次它之所以會連錯兩次就是它沒有辦法容許任何的錯誤它沒有辦法就是它只錯了一次它馬上就會改變它猜的方向所以你看它這邊猜錯了一次

下一次就改成是猜not taken如果我們要improve accuracy就是希望下一次進來的時候他還是猜taken下一次進來還是猜taken要怎麼辦呢就是我們必須要容許他錯一次所以我們說taken這裡猜錯了他只錯一次錯一次沒有關係下一次還是勇敢的再猜賭性堅強繼續猜taken那你就賭對了這邊還是猜taken你下次进来的时候就会怎么样

就会对所以我们这边就要区分什么呢区分它是taken的state有两种一种是说它错过一次一种是错过一次，那一种是它都没有错。这两种都是属于taken，所以我们等一下后面会看它的final state。它就是有四种state这四种state就是两种taken两种not taken，所以类似像这一种，它就会就我们刚提到的第二个iteration第二

次再进到这个loop的时候，它第一次就会对，就不会错，就是这样子。所以我们这边有一个例子，这边这个例子同学可以回去自己看一下。这就是它的iteration次数，它叫总共要执行十次，它的这个acracy相对而言就跟这个来比的话就高很多。你看你这边三次才对一次而已，就是你每三次就对一次，每三次就

对一次，那这边呢，你这边是每十次，你会对八次，第一次最后一次会错中间八次会对。所以次数会决定你的accuracy。所以我们来看一下，我们这边刚提到的2-bit predictor，这个是我们目前这个version第四版的这个testbook，它里面offer的这个2-bit predictor的一个final state'machine它就长这个样子。所以我们可以看到说这个0是predict taken，然后这个1也是predict taken，然后这个2是predict not taken，那这个3呢，它是predict not taken那这个3呢它是predict not taken它的差别是什么呢同学可以看到如果你是处在state 0的话

你就是會猜taken它一定會猜taken因為它的狀態就是叫predict taken顧名思義我在這個state它就是會猜taken如果說你猜對的話它就是一直在這個state一直在那邊輪迴它一直輪一直輪它永遠都是這個state如果說你猜錯的話因為它猜taken結果它實際上是not taken所以它就會沿著這個age它告诉我们

说这个age是你猜错了它叫not taken到这边来它就进到state 1这state 1它还是一样是猜taken所以就是在我们前面这个例子这个地方猜错了猜错了下一个iteration再进来它还是会猜taken因为它只是从0这个state进到1这个state它当然是猜taken所以如果你这一次猜taken又猜对了它会怎么办呢它告

诉我们说你猜对了它要回到这边来因为你猜对了所以刚刚猜错的那一个记录就被清掉了刚刚猜错的这个记录就被清掉所以它要退回这个state 0退回State 0就表示你可以再錯一次你可以再錯一次所以退回到這邊萬一錯一次它要回到這邊它還是猜Taken又對了它又回來如果你連錯兩次就是說我在State 0你猜錯了它就到這裡來你下一次又猜Taken又錯所以這個Age告訴我們又錯它就進到

State 3它進到State 3這個State 3它名字叫predict not taken所以顧名思義它已經很煩了就是已經錯了兩次它編譯再錯第三次所以它下一次它會猜什麼它會猜not taken這邊它就猜not taken就是這樣但是還沒有結束我們可以再來看說假设说他猜not taken猜对了这是比较好理解的他猜对了他会去到哪边呢他会从state 3进到state 2state 2也是predict not taken但是这个就告诉我们说这个not taken他的state就是表示说他允许你猜not taken猜错错一次

你处在这个状态表示它可以允许让你猜错一遍它还是一样会猜not taken但是你如果刚刚从predict taken换到predict not taken这个state然后你猜not taken结果猜错了它会怎么样它马上就回去所以这个状态你刚从taken变成not taken或者是刚从not taken变成taken的时候这个状态是最不稳定的你只要错它马上就回去所以它的这个版本的这个flow就是说它在做这个state transfer的时候

它刚transfer的时候它还是不太愿意它还是不太愿意换到另外一个状态，所以你刚换到另外一个状态的时候错了一遍，它马上就回去他马上回去他还是比较prefer原本的那个action，他还是比较prefer前面的那个prediction，所以这个版本是这个样子这边同学要注意的就是在这个地方他是从taken换到not taken的时候你只要错了他马上要回到前面的taken或者是你从not taken换到taken的时候

你猜錯了它馬上又回到not taken就是這樣之前的version实际就是你只要從taken換到not taken你就是還要再連錯兩次它才會再換到taken所以它是一个loop這是之前的version之前的版本的version同學可以看它是這邊taken錯一遍還是taken再錯一遍它就會變成not taken但是你剛剛換到這個not taken的時候你如果猜錯的話會怎麼樣在這裡你是要猜not taken萬一它的結果是taken它會怎麼樣它是往這邊走刚刚是往回走它馬上又回到這边表示它還是比较喜欢之前的状态

但是这个不是这个版本不是这个旧的版本是說你只要从taken換成not taken或者是not taken换成taken它就喜歡待在這一边所以你看它猜錯了它就到這裡來這边還是not taken它還是會猜not taken那你再錯一遍它才會回到taken所以這個版本跟前一個前一個版本跟我目前的版本的差異就在這個地方之前的版本是你只要換了你的狀態你就要連錯兩次它才會再換狀態我們目前這個課本的這個version就是說你剛從taken換成not taken或者是剛從not taken換成taken這個狀態是比較不穩定的你錯了它馬上又回去錯了它馬上又回去就是這樣好 我們先介紹到這裡.