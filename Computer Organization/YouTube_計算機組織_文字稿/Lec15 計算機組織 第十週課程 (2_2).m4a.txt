undefined
我們上次跟同學介紹到這個PipelineDataPaste就是要加這個PipelineRegister在加入PipelineRegister之後整個DataPaste它就是像我們這張圖一樣總共有1 2 3 4 4個PipelineRegister然後有5個Stage所以同學看一下這邊每一個Register有它的Name所以這個IFID當然就是指的就是指說這個register是由這個instruction stage這個stage它的output會寫入這個register，這個register它的output就是提供

給這個decode instruction decoding這個stage來做這個operation，所以它就是IFID。同理比如說這個的話EXMANYesMan它當然就是指所謂的ExecutionStage它的output寫入這個registerPubLineRegister這個register它讀進來它寫進來的這個data它output出去是for下一個stage就是Memory Memory Stage的這個operation，所以它的每一個Naming的每一個register它的Naming是有意義的，它其實就是代表說它是接收至前面的這個stage

然後它的這個signal是for下面的這個stage來做這個運算自用所以同學以後如果看到一個就是比如說index那是表示說這個publine register它是接收至這個decoding stage它的這個output當input輸入之後寫進去的資料再拿給下一個stage就是execution stage來讓它做這個operation所以同學要記得這個Naming它的意義是在這一邊其他的部分基本上我們上一次都跟同學介紹過了這是FetchDecoding然後ExecutionMemory然後WriteBackWriteBack實際上是包含了寫回Registered File所以實際上最後一個Stage包含這個Registered File的Functional Unit

我們等一下會讓同學看兩種的pipeline diagram這個pipeline diagram就是常見的有single clock cycle的pipeline diagram另外一個是multi clock cycle的diagram這個single clock cycle的pipeline diagram基本上它就是等於就是說你把這個data pathjustify是整個5個stage的datapath把它秀出每一個stage每一個stage它到底在執行某一個指令在執行哪一個指令所以這種顧名思義它single clock

cycle其實它就是要讓大家了解說在一個clock cycle裡面這個popline的datapath裡面它到底執行了哪幾個指令在一個clock cycle我們可以很清楚看到它執行了哪幾個指令所以這個就是single clock cycle的popline另外另外如果是multiple clock cycle它當然就是把這個time把它給展開來它把它展開來我們等一下會看到它就有很多個row每一個對每一個clock cycle而言對每一個instruction它有它自己的這個row所以我們同學可以視為就是說

好像是這個y軸它就是有不同的instructionx軸它就是這個time它就是時間,clock cycle i, i加1, i加2一直往右延伸它的歪軸一直往下就是第一個指令,第二個指令,第三個指令每一個指令它都有一個row代表說這個指令在哪五個clock cycle被執行這個就是所謂的multi-clock cycle的diagram我們等一下會使用single clock cycle的diagram我們來review一下load跟store這兩個

這兩個指令順便透過來review這兩個指令它的progression我們可以知道說我們前面介紹的第一個版本的這個popline database實際上是有問題的我們來看一下就是說為了這個假設比如說這個load假設說前面都是空的就表示說我們這個clock是第一個clock所以它第一個指令進來前面沒有指令這是它第一個指令第一個指令進來load就佔據這個stage就是instruction的stage同學可以看一下

說我們在show這個像這種functional unit基本上它是整個全部都highlight起來像這種memory或者是register我們會有highlight半邊highlight半邊其實就是像我們之前跟同學介紹過的就是代表說比如說如果是 register file如果是 highlight 左半的話就表示說它是在前半個 cut cycle 去 write然後它 read 的時候它是 highlight 右半部這一邊其實同學可以把它想像成就是說它 fetch 的 stage它的 data write in 的時候它是在前面的 edge triggering

剛發生的時候他把它寫進來，所以他把它highlight在左邊寫入之後之後他才在做一個read所以他read的時候就是highlight在右半部，所以這邊同學注意的就是說他有這樣子的不同的highlight代表不一樣的意思接著這個load進到第二個stage的時候就是像這樣子，就是說這邊讀出來資料出來之後它就會開始做所謂的de-coding控制的de-coding然後在結束在最後output的時候

再寫到下一個publine的register，在這裡面我們先不看說它後面有哪一個指令進來我們就只在這個datapath裡面我們就看說這個load好像從左邊往右邊走一趟到底有哪一些它的data flow還有它的functional unit哪一些被activate使用到所以這是第二個stage第三個stage我們知道說它就是做execution它要開始去算這個memory的address所以我們這邊有使用 ALU然後它的multiplacer它會選擇它的instruction裡面的constant offset

接著它就是這個Memory MemoryRead因為它是一個load所以這邊做了一個Read最後它在做一個什麼呢，在做一個Write Write Back就寫到這個Register所以這個是我們看到的一個load它的一個flow在這一邊我們要注意的是這樣子的一個operation它的結果是正確還是錯的根據我們剛剛這樣子來trace它的結果最後它這個load的結果最後是對的還是錯的應該是錯的如果是對的我就後面就沒有東西可以講了所以這個是錯的為什麼是錯的呢因為同學我們可以發現說

我們前面提到說這個Register它有一個功用就是我們知道說它的popline就是每一個指令在一個時間點它只會佔據某一個stage它只會使用某一個stage它的這個hardware還有跟它相關的所有的control signal也都跟它同樣的都是落在同樣的stage它不會說我的load指令執行到這裡結果跟這個load相關的control signal是在這一邊

或者是在這一邊這樣子很明顯是錯的對不對這樣很明顯是錯的因為為什麼因為所有跟load的指令我們就看前面這是從這一邊所有跟這個指令相關的所有的information全部都要pack打包跟著它一起走所以當它在這個stage所有的東西都在這個stage下一個clock cycle的時候它move到第二個stage跟它所有相關

的 information全部都要move到這個stage為什麼呢因為它前一個stage已經被後面的指令所佔據了所以你後面的指令就是在使用這個stage所以你不能說我漏的有某一些information留在這個地方你留在後面你就會被overwrite被後面進來的指令override掉所以要记得所有跟你有相关的东西就是要一起带走所以你看

下一个它move到这个stage所有跟它相关的signal全部都到这个stage然后再move到这个stage它就全部都搬到这里因为它后面的都被其他的指令所占据所以我们来看这一个ridebackrideback它这边有一个由右往左的一个DataFlow这个DataFlow是WriteData要写到Register的一个Data可是我们做WriteInformation包含什么呢包含WriteData还有什么呢还有一个Register的WriteEnable还有一个什么还有一个WriteRegister就是Write的Adress你要写到哪一个Register

所以包含了你要寫進去的資料是什麼然後還有包含你要寫到哪一個register同學可以發現說在這個datapath裡面我們只有這個data是跟著load一起pack一起打包， 一直往右走然後再走回來可是，它的這個register有沒有跟著它一起打包呢没有。 對不对，所以當你這個資料寫回來的時候呢，寫到哪裡去不知道，寫到哪邊去不知道，

可以確定的不會是當初你這個load的destination，不會是你load的destination，那會是誰的destination呢？那就要看說目前這個clock cycle到底哪一個指令是佔據這個stage哪一個指令佔據這個stage，那個指令的destination，它就是specify你這個load指令要寫到哪一個register，所以很明顯這個是錯誤的，這是錯的，所以我們必須要怎麼樣呢？從這裡我們就

知道說這個datapath是有問題，我們漏掉了一個information，這個information就是漏了它的right destination這一個，所以我們就知道說我們必須除了write dataright register也必須要從右邊feedback回來，feedback非常簡單怎麼簡單呢？其實當然就是把你這個instruction，它的right destination把它送到你的popline register就把它送到popline register，所以我們可以看到說這個version跟前面一個version唯一不一樣的地方在哪裡呢，它就是在這一邊，它的這個

這個 instruction 裡面，它的 RD 跟 RT 它會送到這邊，然後一直跟著它走，一直跟著指令走當指令走到 write back stage 的時候，它會 feedback 回來，specify 你的 write register所以這樣子就一致了，這樣子我們就確定我們把所有的 load signal information全部都 pack 在一起，然後透過publine register就是stage by stage，然後一直到write back，然後再feedback回這個register file，所以這樣子才是

一個完整正確的一個publine的一個datapath所以這邊同學有沒有問題我們後面會有很多這種就是前面到後面後面到前面的所以這邊是一個start同學要習慣這一種就是就是這個stage之間的這個information的一個transfer我們後面會跟同學介紹我們前面有跟同學介紹到這個forward我們已經知道說forward的一個concept，但是

concept你要如何去realize這個concept所以我們後面是跟同學介紹這個forward它的詳細 ection的一個skin那還有hazard的這個detection的一個skin那基本上它的訊號都是在不同的stage之間就是做一些交流所以這樣子的DataPath才是一個正確的我們來看一個就是說以這個當作如果是Store的話我們前面就不用看它就是到這個ExecutionStageExecutionStage在這個地方接著它就是做一個Write所以它就是這邊是左邊被Highlight起來

所以這個是Store的一個Memory那WriteBack基本上它沒有所謂的WriteBack的問題所以我們剛剛看到的這個例子就是利用透過SingleCycleSingleCycle就是PipelineDargon我們來修正我們前面第一個版本的Datapace我們後面會把前面的修正過的Datapace再把它更Detail更Detail要如何去選取它的WriteWriteRegister的這個destination我們先來看這個Multicycle的Popular Diagram這就是我們剛剛提到的

我們就是把Y軸這邊它就是一個就是Sequential的Instruction它把指令一個一個就好像一直往下把它列出來每一個指令它會佔據一個Row那X軸往右邊的Extension它是一個時間軸就是这个clock cycletime clock所以这是1 2 3 4 5 6如果你要看instruction的时候比如说当你要看instruction它到底在哪几个clock cycle执行我们要看row比如说我看row的instruction它到底在哪几个clock cycle我就看这个row所以你看row的时候往上对我就知道说它是clock 1到clock 5你看aid

加這個指令我們就看這個row它就是五個stage在這個地方所以我們對上去它是clack3到clack7總共這五個clack cycle它在執行如果說我想知道在某一個特定的clack cycle我的datapath它到底是如何使用它的functional unit這個時候比如說我要看class cycle 4我就是看一个column我看一个column同学就可以知道说在这个memory stage它是load在使用那execution stage它是subtraction在使用那这个是decoding stage它是java aid instruction在使用那这个是fetchfetch就是这个load所以

透過Multi-cycle的Pupline diagram我們可以看橫的、看直的我們可以得到不同的information後面其實在討論這一種什麼Forward Hazard其實我們在看Multi-cycle的Pupline diagram會很清楚知道說instruction它們之間resource競爭的關係還有就是說它是不是有Hazard發生另外一種Multi-cycle的pop-line diagram它就只是一個breakbox它沒有什麼像我們剛剛看到的一些圖它就是一個breakbox然後用這個text來identify說它到底是哪一個stage就是這樣子這個就是我們剛剛看到的這個single-cycle的pop-line diagram我們剛剛只有看一個instruction實際上

Single Cycle的這個Papillonian Diagram我們一般都是就是每一個Stage就列出哪一個Instruction 在這個Stage所以我們可以看到說這個在Fetch 這個在Decode 這個在Execution 這個在Memory 這個在Load所以我們就可以很清楚地透過這個Single Cycle的Papillonian Diagram了解說每一個Stage到底是被哪一個Instruction正在使用它的utilization就看得一清二楚接下來我們這一張

圖我們就是把剛剛就是revised過的這個publine的datapath我們可以再更清楚的看得出來就是說我們如果說再加control然後還有我們剛剛如何去identify它的write register同學可以看到我們多了一個什麼這邊多了一個Multiplexer剛剛前面的這個同學可以發現說這邊只有很簡單的多出了這條線這就是我們剛剛Revise過新多出來的一個這條線是我們剛剛Revise過多出來的

好像只有一條線實際上它不是只有一條線為什麼不是只有一條線呢因為我們知道說這個是WriteRegisterWriteRegister它有哪兩個指令會用到一個是什麼Load就是我們剛剛提到的Load另外一個是什麼另外一個你說Add嗎沒錯,比較general的是，rtype同學，這個不要忘了這個instruction format在這邊很重要，你的instruction format不熟你這邊有時候會覺得怪怪的一定要

如果不是很熟悉一定要再回去再看一下，rtype還有load這兩個rtype跟load這兩個指令它的right destination的位置又不一樣是不一樣的所以同學可以看到說我們realize的時候呢我們realize的時候是它這邊就告訴我們說這邊有兩個source這兩個source實際上就是specify的是這個type還有這個load它的right destination所在的位置是不一

樣那兩個不一樣當然是只能夠選一所以你這邊要有一個multipressor然後再feedback回來根據你的這個instruction的type來決定你要選上面還是下面，所以這個是我們把剛剛revised過的這個database再更詳細的列出來它實際上是長這個樣子，那這邊有一個問題我們就說那為什麼我們要把這個Multipleaser擺在這個Execution Stage呢我們為什麼不把它擺在這邊呢擺這邊可不可以？其實它的理由應該沒有應該沒有很多什麼說一定要擺這邊或者是一定要擺這邊

其實同學可以看得出來就是說我們這邊這個Multipleaser它是需要什麼呢它是需要一個Input SelectionInput Selection是誰產生出來的就是Control對不對就是Control UnitControl基本上它就是在第二個StageDecoding在Decoding Stage它會產生這個 REG DSD當我們的 control 產生出來的時候如果說你把這個 multiplexer你把它 move 到前一個 stage這是 OK 的,沒有什麼不可以，但是它可能會有的一個問題是在什麼地方呢？比如說假設我們的 control circuit，它的 delay 是比較大的所以它的 delay 可能是比較 approach整個 stage

等於是它是相當於接近一個class cycle，那你相當於接近一個class cyclecontrol signal已經產生出來了，實際它整個cycle快要結束了那你還要再去透過一個multipleaser去選一個訊號出來那這樣子就有可能，你整個cycle的cycle time你還要再多加上這個multipleaser的delay那有可能會是這樣子，那如果說你的control花的 delay 其實相對於你的 cycle 而言是不大的，就是說你 control signal

產生出來離你的 cycle 結束還有一段時間，你可以把這個multipressor 搬到這邊來，你把它搬到這邊來，它再加一個multipressor還是一樣不會增加你整個 cycle time 的時間，且有什麼好處呢？你搬到這邊其實你就不用再多一個 signal位到這個 pipeline register也就是說你POP9 register就不需要再多一組資料多一個register來存這兩個input source，你只要存

一個就可以了，你只要存一個，所以其實它擺在這個地方，我想它的考量應該是，在說你這個control的部分，它的delay它可能沒有那麼的小，它可能就是跟你的cycle time差不了多少，你再加一個multiplexer你的cycle time可能就必須要增加所以它把它搬到這邊來，所以這種其實你擺什麼地方，並没有說絕對不行或者是什麼

樣的絕對的這種issue，所以大概都是跟它有相關的考量，然後它在這個圖裡面，它多加了這個control所以同學可以看到，這個其實都是跟我們前面的第一個version的CPU，其實都是一樣的，它沒有多出什麼額外的control signal，因為它沒有多出什麼hardware，所以就是這個regg dst然後lu oplu source然後regg write然後這個branchmemory writememory readmemory to register你的data的source到底是哪一個，所以都一樣，這全部都是我們前面這個

這個Simple CPU第一個version它的control所以有關你publine control的這部分我們在這邊就不再跟同學review一遍同學應該再回去看一下前面的版本就可以了所以他說這邊有九個我們來算一下1 2 3 4 5 6 7 8 91 2 3 4 5 6 7 8 9 这边是两个bit如果是由这个control产生的它由control这边产生的大概就是这几个就是这边有一个control unit它会产生这个它也会产生这个产生这个产生这个产生这个这个跟这个还有这个这个不是control

Circuit产生的,这一个是这两个End出来的这个Zero也不是Control Unit产生的这个Zero是这个Ader算出来的, ALU算出来的所以后面这边我们看到了这个Pipline的Control Value它的Control Value基本上就是我们前面在第四章前面那个第一个version的CPU同學回去看一下這個應該都是一樣的我們這邊就不再review一遍這邊還要了解的就是說

我們知道說我們在decoding這个stage這个control unit它產生了這麼多個control signal這麼多的control signal基本上它並不是所有的control signal全部都要跑過每一個stage因为你只要这个control signal在下一个stage不需要你就不需要再送到下一个stage所以我們這边看到這边有一个control的这个unit它產生出来的sort output全部都写到这个Pipline register那Pipline register上面的这个control signal它把它分类成三个type就根据它的stage来分类成三个不同的type一个是writeback一个是memory一个是execution

所以凡是在ExecutionStage會用到的ControlSignal就全部送到這一邊凡是MemoryStage會用到的ControlSignal就送到這一邊WriteBackStage會用到的ControlSignal就送到這一邊它把它分成三类所以同學可以看到這边訊號送過來之後ExecutionStage它就是送到下一个ExecutionStage用完以後就怎麼樣就丟了 就不要了它后面不會再用到不會再用到就沒有必要再把它往後送所

以這边就把它給丟了這边Memory因為還没有用所以你必須還要繼續再往下一个Stage送到下一个Memory這個Right Back也是一樣這個Memory這個Stage用完以後就丟了就不用再往後送只有這個Right Back Stage這兩個訊號就是，它還要繼續再往後送，是哪两个呢就是一个是，这一个这边要送到这边来control的部分，就送到这边来就一个，而已就送到这边来write enable另外,data的部分还有registerwrite register就是从这边送过来，所以

這邊就是到Right Back所以它的機制一個很重要的觀念就是，長這個樣子，你要把它分類，用完了就不需要再往下面的Stage去做Transfer所以，這個是整個，就是加了Control的這個Pupline，這個Pupline的整個，它的這個Structure就長這個樣子，所以同學不用覺得很複雜，因為這個線應該同學回去trace一下，同學回去，一定要trace，你才會

了解說它這個圖，不會很複雜，不然你剛開始看會覺felt很多線搞不清楚它跑到哪邊去，你會覺得好像是一個新的structure，其實這個structure並不是新的，就是都是以前我們介紹過的，所以我們這邊也不跟同學介紹，因為它沒有什麼特別，它就是，同學你可以看Execution Stage就接過來這邊，還有一個接過來Memory Stage，它就是從這邊出來，一個Branch還有一個Memory Write另外還有一個Memory Read，它就是這樣子WriteBack這邊有一個MemoryToRegister

然後另外這邊有一個register right這邊有兩個所以這個就是我們的這個popline的一個control加control的一個部分接著後面我們後面要跟同學介紹就是有幾個case這個case就是說當我們碰到這個data hazard的時候我們知道說我們可以透過Forwarding來解決這個Hazard的問題重點就是說我們要如何去detect需要做這個Forwarding因為我們要去realize這種Forwarding的機制你首先要先知道說這個Forwarding需要的時間已經出現了

我们的Forwarding的机制才会开始启动把这个讯号往前送然后送到前面让前面去选择正确的这个值所以我们来看一下这个Code Sequence这个Code Sequence就是第一个是减它是1 3加然后存到1跟3 1减2然后再存到这个21减3再存到2接着它就是把这个2拿过来加然後第三個指令它

又把2又拿過來做一個all所以我們看到的data dependency就是這個是被write後面要read的是這一個還有這一個甚至這個指令兩個都是2還有最後一個指令它的base base的地址也是2也是register2所以第一個指令2是Write destinationWrite進去之後後面有四個指令全部都要去讀這個2所以我們就用這個case我們來分析一下說我們的Forwarding要如何來判斷說它需要做Forwarding所以我們用這個Multi-cycle的這個Pup-line Diagram我們就把這個-end or-end store

就是把這幾個指令全部都把他highlight出來我們順便也把每一個popline register的name把它寫出來這樣同學比較了解這個到底是哪一個stage寫在這一邊它的左邊就是fetch右邊就是decoding所以它左邊是decoding右邊是execution這個左邊是execution右邊是memory左邊是memory右邊是writeback所以它就是这样子第二个指令相对的这个是fetch decoding这

个是decoding execution所以是第一个跟第二个指令所以我们来看说我们知道说这个2写进去真正写进去的时间点在哪里是在这个地方写进去的真正写进去是在这个地方写进去所以你如果真的要去register裡面讀出來你要讀到正確的register的值的話我們是必須要在這個clock cycle才能夠去讀它的，所以哪一個指令可以正確地在register裡面讀到它呢就是這一個所以就是這個指令，它可以很正確地讀到從register裡面讀到這個1-3存到2

的这个結果，那當然store當然也不会有什么问题，所以最早就是这个那显然这两个前面这两个我们都必须要怎么样呢我们都必须要透过这个forwarding 那，但是forwarding我们知道说forwarding它的方法是不一样的比如说我们在这个第二个instruction它是做end那它做end它的execution stage是在这个地方所以它Forwarding的機制就是直接在這一邊Forward過來它的DataForward的source是從哪边來是從這個LU的Output直接拉到它自己的Input這個Forward我們從這樣子看的話就是直接把它的LU的Output直接拉到

它自己的input這就是所謂的forward这个forward第三個指令的execution stage在第五個clock cycle就是clock cycle 5CC5第五個clock cycle它是在這邊要執行要使用到的它的source就是從這边來的source從這邊來同學你不能說我source要從這邊來為什麼source不能從這邊來因為time不一樣time 時間點不一樣我的這個值它的時間點是在這個地方那你不能夠把過去的東西就是說你不能假設說過去跟現在

是同時發生的過去跟現在是同時發生除非是所謂什麼平行宇宙過去跟現在同時發生這邊為什麼會Forward它的時間點是一樣它是同一個時間點在CC4這個時間點它的LU的output值在這個地方我們就直接拿過來用所以我們是把Clark 4的data在Clark 4這個時間點使用也就是說我在

Clark 4這個時間點使用Clark 4現有的data所以這是對的這就是Forwarding的機制就是這樣子這個我在Clark 5這個時間點我去使用Clark 5現在所有的data我現在有的data就是在這個地方所以它的source是從哪邊來呢它的source其實也是從man write back register這邊過來的它要從這邊過來所以你不可以

說我要從這裡拉過來拉過來過去已經不存在了我現在是clock 5這個時間點這一個是clock 4過去已經消失不見了你不可以在5的時候去拿4的這個值拿過來所以這是Forwarding所以我在這裡我就要用現在的時間點所available的這個data所以同學記得這個關係我們等一下就是要把這個關係式

把它寫出來因為我們要去realize我要去realize說Forwarding什麼時候要Forwarding要如何Forwarding我們就是在找這個關係式我們在找這個關係式所以同學可以看到說這個就是它的後面的instruction的idexstage的某一個source跟它的instruction跟它前面的instruction它的exmestage的rd是一樣的rd就是right destination它要寫到2這個就是要寫到2這個它要去讀2你要去讀2讀就是RT就是它的一個sourceRS或者是RT它的sourceRS或者是RT你要寫要寫就是什麼就是RD就是它的RDdestination所以在這個時間點

在同一個時間點就是比較早subissue的指令的ESMAN的RD等於它後面的指令的IDEX stage的RS或者是RT這兩個一樣就表示它有Hazard就表示你必須要用Forward機制來解決所以这个是描述这样子的一个case这是描述这样子的一个case这个case它是要描述什么呢它是描述說ME write back这个POP9 register它的RD它的 RD就是指这一个instruction的RD就是2它的RD是等于这个指令这个指令

它也是一樣 它是idex這個指令在這個stage這個stage是什麼呢這個stage就是ides這個register它的rs或者是rt它的source這兩個source兩個其中的一個跟它的destination如果是一樣的話它也表示有什麼呢它也表示有所謂的hazard它有dependency它也必須要透過Forwarding來解決它的Hazard所以我們這個例子裡面我們就已經把等一下後面的投影片它的Forwarding它的式子就已經把它解釋清楚了同學這邊有沒有問題我們先看後面的

後面的就是要開始就是比較formal的把我們剛描述口語的描述把它列出來我們說我們要去detect我們是不是需要做這個forwarding的這個動作所以首先我們要了解說我們在式子裡面的一個表示它的這個意義我們前面已經提到過了我們前面提到過說我們說同學要注意這個nameidex這個publine register這個publine register它就是介於decoding stage跟execution stage中間的這個publine register當我指的就是說ide x.

registerrs這指什麼呢這指說我的instruction目前停在這個register這個 instruction 它的 RS 到底是多少這個 instruction 它的 RS 是多少所以它這邊就講說其實它指的就是指這個 register number for RS sitting in IDES pipeline register就是指現在落在這個 register 裡面的 instruction那個 instruction 裡面的 RS 它的 number同理,这个是什么呢?就是idex. registerrs,这代表什么意思呢?它的意思就是代表说,目前落在idex.

register的instruction,这个instruction里面,它所使用到的rs跟rt到底是多少?到底是哪一个register?它的rs是谁?它的rt是谁?就是这样子所以这个notation了解了以后我们就可以看到data hazard我们要知道说什么时候它有发生了这个data hazard首先第一个它有两个situation每一个situation它有分成两种其实这就是刚刚提到的第一个就是execution还有memory它的register rd等於idex.

registerrs這是什麼呢，這個是不是就是我們剛剛提到的這個case，大家可以記得這是exman的RD等於idex的rs，是不是就是我們剛剛提到的這個case對不對，這個caseexman的RD,YESMAN的RD,RD就是它，等於IDEX，IDS指的是指誰呢？ IDS，就指這一個，它的IDEX是什麼呢? RS第二個其實就是它也可以是source是這個跟它一樣，比如說你把這個2調到5跟2對調你把5、

2對調，它就會變成是下面這一個2到後面 5到前面，它的source因為它有兩個source，你任一個source跟它的destination一樣都有data hazard，所以你不一定要2要在前面2在後面也可以，所以如果是在後面的話，它指的就是指這一個同理我們剛剛看到的第二個case就是這個我們把這個destination的stage由memory這個stage往後延延到right back那個stage我們把它往後延一個stage往後延一個stage就是這個case，subtraction跟or

兩個指令的case，第一個case就是表示兩個rtype兩個相鄰的rtype，它們之間兩個相鄰的rtype的instruction第一個的rd等於第二個的rs或者是rt，現在看到的第二2a 2b這個case這個case就是指rtype兩個rtype的指令，但是它們不是相鄰，它們中間隔一個instruction中間隔一個instruction中間隔一個instruction，它的rd前面的rd等於後面的rs或者是rt，它指的是指這個case，這個case就是我們剛剛提到的就是指這條線就是這個case，所以它的main right back，它的rd

等於它的 ID 跟 EX 的 RS 或者是 RT，只要是這兩種相等的話，它們兩個是 R-type 的指令，它們就是中間隔一個指令所以這個就是我們看到的第二個 case到這裡同學有沒有問題，

你只要覺得怪怪的就趕快舉手我們可以再看一看，因為後面都是圍繞的這個在那邊在那邊夾東西的同學不要客氣聽不懂趕快問都沒有，那我們繼續再往下，

但是我們剛剛提到的這個就是1a 1b 2a 2b這四個condition其實它並沒有辦法全部說明，因為你只要滿足那四個裡面的其中一個，實它就已經是什麼，它就已經是這個data hazard，你必須要透過這個forward去解決這個hazard，你沒有辦法做這個決定，因為你還必須要確定什麼我們剛剛提到的它那個是兩個R-type指令

相鄰或者是兩個R-type指令中間隔一個指令1a1b的是相鄰2a2b的是兩個R-type instruction，它們中間隔一個instruction，所以我必須要確定什麼？它是這一類的指令，所以同學可以看到，說首先我們要確定，說它是要做register right就是說這個forward instruction，它是要寫到一個register，所以它是要register write，它的確是要寫它。如果register write是0的話，其實它就

不是這種R-type指令對不對？ R-type指令，它的register write一定是1。它如果不是R-type，例如說它是一個BEQ或者是其他的指令，它的register write就會是0，所以for 1a1b的呢，這兩個case你必須搭配這一個2a2b的呢，你必須搭配這一個2a2b要搭配這一個，這個都是在make sure，說它是一個要寫資料到register的一個instruction，这是第一個第二個，它也

說我們的這個destination，我們知道，說我們的register有一個叫0的這個0，你怎麼寫都沒有用，它always都是0，所以說你沒有辦法把這個非0的值，把它寫到裡面去，它always都是0搞不好你的instruction寫錯了，就是你還是把它寫到這個0那邊去也說不定所以它這邊講說它的這個0你的RD不可以是這個0因為這個

0本來就不是我們可以寫進去的所以它這邊EAEB還要搭配一個ESMAN的register RD是不等於0然後還有EAEB要搭配這個memory writeback register它的RD也是不等於0所以我們要搭配這兩個我們先休息再回過頭來再把這個例子來看一下我們來看一下這個Forwarding Paste的一個例子透過這個例子我們可以了解說這個Forwarding如何來realize這邊是一個t1加t2存到t0後面的指令是把前面加的這個結果t0再加t2然後再存到t3所以我們知道說

T0跟前面的這個T0它基本上有一個Hazard的一個關係所以我們在這裡面看到的就是說當這個指令當這個指令從ExecutionStageMove到MemoryStage的時候我們可以看到的就是說這個LU它的Output這個值實際上它已經包含了T1加T2所以這邊就是我們有把它Highlight出來的就是說它是t1再加t2它的後面的一個指令從decoding move

到execution stage它這個時候它這個t0它要的是t1加t2而不是從這個register文件裡面讀出來的T0，所以我們從這裡面就必須要把這一個值把它這樣子的一個動作就是所謂的forward，所以同學可以看到他就是加了這一條線他就是加了這一條線，T1加T2，把它feedback回LU的兩個input的這個source所以它的multiplier，這个时候

就已经不是2选1了，它的multiplier，這个时候变成是变成是3选1这边3选1，同学可以看它就是假设上面是0 0 0，第二个就是0 1，第三个就是1 0，所以当你的这个forward a，这个input selection是00的时候，它会挑这一个，当你forward a，这是01的时候，它会挑这一个，forward a是10的时候，它会挑这一个，它会挑这一个，

这一個又是从哪边来的呢，我们来看一下，这是一个是从这边来，所以很明显这个是什么呢，就是E0Multiplexer，它的source E0的这个来源，它是从memory stage，feedback回来的这个data，这个forwarding的这个source，如果是01的话，01就是从right back stage这边forward回来的，它是从这边forward回来，所以我們等一下后面就是follow这样子的一个机制，所以这边也是一样，这是一个00，这是一个01，这个是10我写这个000110同学应该知道我在写什么吗？就是multiplexer2选1 4选1

假设是4个1假设是4选1的话我们不是会给它一个number吗？ 0 1 2 3、 1 2 3。它会有两个input selection。当我是00的时候它就让这个通过，当我是01的时候它就让这个通过，10就第三第三个通过，11的时候就第四个通过，就是这样子所以，我这边写的这个000110，就指这个意思。所以等一下，同学，如果发现说你的forward A等于10的时候，代表什么呢？就是代表它第一个input source是从memory stage feedback回去的。如果你

forward A等于01的时候，就代表你的LU的第一个input source，它是从writeback stagefeedback回去了。如果說它是鈴鈴的話，就代表它是一般的pace，就是從左邊傳過來的，它不是從右邊feedback回來，所以它就是有這樣子三個基本的分類。所以我們看了這個之後，我們再看我們已經了解了這一塊了，這一塊，这一塊就是從原本它的Input

Source都是從左邊來的，我们把它Extend成，它有的是从左邊送过来了，有的是从右邊透過Forward把它Feedback回来，所以它有两条路透過Forward Feed back回來所以這邊兩個情況都一樣上面第一個Input Source它的控制多出來的這個控制我們就是叫Forward A它的Input Selection叫ForwardA第二個MultipleSource第二個InputSource它的MultipleSource它的InputSelection叫ForwardB ForwardA跟ForwardB都是由Forwarding這個ForwardingUnit你也可以把它看成它是一個Control它也是一個ControlUnit這個ControlUnit是專門去製造生產這個Forward相關的控制訊號

所以這是Forward Input所以我們看到的Forward Input就是像這樣子同學要注意的就是說同學不要覺得他的Input Output好像很複雜其實這個都可以理解的因為根據我們剛剛的這個式子這邊有兩個Input就是來自於Execution Stage這邊有兩個Input一個是來自於Memory一個來自於Write Back它的Output其實就只有兩組一組是控制第一個Input Source

第二个是控制第二个input source的input selection就是这样子所以这边我们都是前面介绍过的一个，所以我们这边有一个把它highlight出来这个例子就是直接透过Forward机制由Forward A来选择，然后直接位到LU的第一个Input Source，第二個Input Source它是來自於T2所以是从左邊這边過來，它没有任何的Data Dependency，所以我們看到的Forwarding的Condition就是如果是Ex Hazard，如果是Ex Hazard我们提到的就是说Ex Man，

这个指令就是前面issue的指令，它是落在memory stage，从ex进到memory stage这个指令它是落在memory stage從ex進到memory stage這個指令它要做register write，所以它要写数据写到register而且它write的destination不是0而且它的write的destination是等於目前Execution它的这个RS，它的第一个Source，所以这是第一个Source，这个唯一的差别就是它是第二个Source，你可以是第一个Source也可以等于第二个Source，这个差别都一样，就是除了这个差别以外其他都一样，这case它的Forward A就要设为10，Forward设为10，如果说

是memory 来自於 memory，那它就是把這個ex-main改成memory writeback的register write等於1，它要寫到register而且它的rd不等於0，且它的destination是等於它的下兩個指令的rs的第一個source或者是第二個source；那這種情況就是它這邊要等於01，这边一个是Forward A，一个是Forward B实指的是我们这边看到的Forward A或者是Forward B因为这个是RS是第一个，这是RT这是第二个，第一个是A，第二个是B，这个第一个Source，第二个Source；第一个Source是Forward A，

所以它是從這邊過，如果是RT的話，它是第二個source，第二個source在這裡，它是透過这个Forward B來控制從這边進來所以就是分成第一個sourceInput source跟第二個Input source；然後分別由Forward A跟Forward B來控制，這也是一樣，這是第一個source，所以這边Forward A，它是等於01这是第二个input source，所以是forward b等于01所以这个就是我们到

目前为止一个完整的forwarding condition，而且这个condition它就告诉我们说我们的forwarding unit它的output它的output值是这一个这一个还有这一个还有这一个它的input值就是这里面看到的这些variable這些signal 這是它的input好 同學到這裡有沒有問題沒有 我們就繼續再往下看所以同學就是掌握住他判斷的精神就是有三個第一個判斷 他的確

就是前面的指令的確是要寫指寫到register然後它寫到register的目標不是0然後它寫到register的目標是等於它後面的指令的source這個是它寫進去寫到register的目標是等於後兩個指令的source所以這是它們兩個之間的差異接著我們再來看另外一個case它叫double data hazard什麼是double data hazard呢我們來看一下這個code sequence這個code sequence也非常簡單首先把1跟2相加然後再存到11跟3相加也存到11跟4相加又存到1所以它這邊三個指令它的destination

全部都是1全部都是1跟前面的case有什麼不一樣呢其實跟前面的case不一樣的地方就是在前面的case只有第一個指令它的destination是1後面比如說它後面可能是3 4 5 6反正它就不會是1它是不一樣的所以也就是說前面的case它的後面的e這個input source是由誰決定的它的值由誰決定是由第一個指令決定的可是這個case我們可以很清楚知道說第二個指令它的e是由第一個指令來決定第三個指令它的input sourcee不是由第一個

決定它是由第二個所以我們這邊它的data dependency就跟前面不一样之前是这样子現在就不是了现在是这个样子现在它的data dependency是这个样子所以现在的data dependency很明显跟前面的data dependency是不一样我們前面介紹的condition它都是由第一個instruction做forwarding只是它有時候是在memory stage forward有時候是在writeback stage forward它在不同的stage forward但是它都是由同一個指令來做forward這個case必須要由兩個指令來做forward所以我們這邊列出來的圖就是

這個forward沒有問題 這很明顯這一個是這樣子嗎 還是這樣子我們知道根據我們剛剛的說明我們已經知道說不是這一個 這個是錯的如果還用這一個的話我抓到的值就錯了所以這個register1會抓到舊的值我要抓的應該是要抓這一個所以所谓的double数据 hazard在讲的就是在讲这件事情，所以我们要

revise我们前面的所谓的MEM hazard condition要怎么去revise呢，我们要revise的指的是说我们不能很随意的就是把第一个直接forward到第三个不可以随意的做这样子的一个决定我要把第一个forward到第三个，它的前提是什么，它的前提是第二个跟第三个之间没有hazard，第二、第三之间没有hazard，我才能够把第一forward到第三。如果第二跟第三有hazard，就是表示说我第三个指令要用的资料不是第一个指令产生的是，它前一个

是第二個指令產生的，所以就是多加了這樣子的一個判斷，這邊就寫說它的main hazard只有在ex hazard不存在的時候。所以原本的forwarding condition如何做reverse呢，這個reverse其實看起來好像很複雜，但是基本上它並沒有那麼複雜黑色的部分就是我們原本的condition黑色的部分，我們原本的condition跟結果就是顏色比較淡的這個就是我們剛剛提到的我們必須要確保它没有發生execution hazard所以execution hazard是什麼呢，就是ex-main，它的我們來看這個跨幅跨起來，這個就是ex ecution-main.

register-write它要做write而且ex-main. register-rd它的destination不等於0然後再加上ex-main的destination是等於id execution register的第一個source它要前面的指令要寫的目的地是等於後面的下一個指令的它要讀的這個source兩個是一樣這個刮伏刮起來這個就是什麼呢就是我們所謂的exhazard condition所以我們說這個condition不能成立就是什麼呢就前面加一個nup就這樣子所以看起來好像變很長

其實它沒有變複雜它只是加了一個notexhazard的conditionexhazard的condition不可以發生就這樣子後面也是一樣第二個input就是第二個input source把rs改成rtrs把它改成rt它的condition就出來了就是把rs改rt所以這個是我們ReviseScore的ForwardingCondition這邊有沒有問題所以我們來看一下我們加了Forwarding機制的DataPath

我們加了這個 forwarding 機制的 database這個就是我們剛提到的就是這邊它的 source它的 source 有來自於 register number黑色的部分黑色的 input 就是 register number這個 number 有的是 RS 有的是 RT有的是 RD比如說這兩個就是 RS 跟 RT這個就是 RD這個也是rd這個是write register這個是rd這個也是rd比較淡的呢比較淡的這個就是所謂的register

writeRegister write就是說它這個指令是不是要去寫資料寫到register所以這個比較淡的所以同學可以看到它的source不一樣它的source這邊就是從哪裡來的呢就是從controlregister write它是一個control signal它是control unit產生出來的所以它從這邊位過來這就是registered write這個也是registered write它的output跟剛剛是一樣的它就是一個forward A然後這個是一個forward B所以這個就是我們一個有forward機制的一個datapath

同學看這個Dataplace當你看到第一個Dataplace的時候你就一定要把它的每一條線都trace一遍你如果很容易的說這看起來很眼熟你就跳過去你就會發現說整張看起來都很眼熟但是你在進去trace的時候你就好像沒有那麼的熟其實跟它沒有很熟你應該第一個datapath version出來的時候你就

要它的每一個signal你要去trace一遍你要知道說它這個線這樣子拉的目的在什麼地方你都了解以後像它這個一個一個東西一直加進來的時候你就很容易就可以把它trace過所以同學這邊這個複習的時候一定要用這樣子的一個方式接著我們再跟同學介紹這個所謂的 load use 的 data hazard

我們前面提到的 hazard都是可以用 forwarding 的機制來解它可以用 forward 的機制來解我們現在跟同學介紹的 load use 的 data hazard它是沒有辦法用 forward 的機制來解所以我們來看一下這個例子它第一個是 load它把某一個 addressmemory address的dataload到register2接著做一個endend是register2跟register5兩個做end再把它save到register4所以這是第二個指令所以我們可以看到的就是說end這個指令它要做運算的時候是在這個時間點這是clock4clockcycle4第四個clockcycle

可是我们说我们从memory里面读出来的资料它是在这边它才读出来memory stage之后它就读出来就save到memory writeback register这个就是memory writeback register所以它把它读出来save到这边所以它available是在clock cycle 5它在第五个clock cycle这边第五个cut cycle所以我们知道说我们这边没有办法这样子这好像是到未来去

把以后会赚的钱先把它拿回来用所以它没办法到未来去把以后的钱先拿回来用所以这个是不可能的所以我们说这个是没办法这样子forward你的forward不可以这个线随便乱画劃過去就算forward所以我們這邊就必須要store one cycle把這個stage把它store延後到clock cycle 5它既然原本clock cycle 4沒有辦法所以你就把它延後到clock cycle 5你這樣就是delay一個clock cycle所以同學可以看到這個stage當你被放到延後到clock cycle 5它就可以做一個forward它就解掉了

對不對 它就解掉了所以我們這邊就是要討論load use的one cycle的一個store我們要如何去判斷load use的hazard它的detection首先，我們也是一樣，就是說我們要知道，像這個IF ID，它的register，這就指說這個instruction，它目前是跑到IFID的publine register，其實它就是從fetch instruction move到decoding stage，它從fetch的stage move到decoding的一個stage。它的rs另外一個rs或者是rt，就是指令的rs或者是rt。它的source，它的兩個source

會跟誰一樣？它的兩個source基本上就是跟load/load它的destination可是，load的destination不是rd同學還記得嗎？ load的destination，它的register destination不是rd，它是誰呢？它是rt，它是rt同學，如果又忘了就回去再查一下第二章就可以看到，load，它的register destination不是存在rd，因為rd那部分已經被拿去做什麼用，被拿去做這個offset的constant，它已經被拿去做offset的constant所以它的destination是放在rt，所以我們說，load use hazard，它就是什麼呢？

首先，我們要確定，在 ID execution 裡面的instruction，它是要做 memory read它如果要做 memory read就表示說它是一個 load 的 instruction它要去 memory 讀一筆資料所以它要 read而且它 read 完之後它寫進去要寫到哪一個 register 的 destination跟它下一個指令下一個指令就在前一個stage叫IFID它的下一個指令的第一個source或者是第二個source是一樣的它就表示它有一個load use hazard就是我們這邊提到的我們這邊同學可以看到它們兩個之間就差一個stage

这边要注意的就是说它为什么是在idex这边要detect这个东西呢而不是我们这边画出来的这一个而不是我们这边画出来的这个stage这个stage是多少这个stage是man right backidex 对不对这个是main writeback它的. rt等于idex的. rs或者是. rt我们这边看到的情况是这个样子可是我们这边它不是main writeback它是idex.

rt等于ifid的rs它的rs最主要就是因為它要 store所以它希望在可以判斷出來的時候判斷出來它是一個 load use hazard它當然就可以馬上判斷它不需要等到這麼後面的時候再判斷這麼後面其實早就已經知道了它還沒有判斷出來所以我們應該是在前面的時候就可以判斷出來我们在前面的

时候就可以判断出来前面的就是我们这边的idex然后ifid这边我们就必须要store而且要加一个bubble就是说你如何去store这个publine如何去加一个bubble其实它的方法就是这几个第一个看到说它必须要强迫在id ex register全部在下一个clock cycle全部都是0因为我们现在它必须store它必须store所以它原本是在if id它下一个stage会move到id ex你如果不让它move到id ex唯一的方法就是什么

下一个time move到idx的时候让它所有的子全部都是0它所有的子全部都是0就表示它什么事情都不做它什么事情都不做所以就是加一个no operation就是bubble所以你加了一个0进去之后不是只有idx喔idx然后接着再move到下一个stagememory writememory write back那个也是一个0所以它等于就是一个bubble从这个idx这边开始往下送它都不会再做operation所以这个是第一件事情

第一件事情你要让它的control value全部都是0第二个呢第二个要记得的就是说这个不是br anchbranch是说我发现我进来的instruction不是我要的instruction所以我就把我已经进到Pipeline的instruction怎么样把它清掉可是这个不是Branding这个是我要执行的指令读进Pipeline里面的指令是我要执行的只是说它进来的时间点太早我希望它晚一点进来我要它晚一点进来所以这个时候你必须要make sure你的Program Counter还有IFID这两个register

必須要怎麼樣keep and change你要保證這兩個register keep and change就讓它都保持都不動不會被改變你保持不會被改變其實你就等於去把這個instruction把它delay一個cycle我們等一下透過這個datapath我們可以更容易看到說它是如何透過這樣子的一個機制來來做一個加一個cycle的一個bubble所以同學可以

看到這個load它是load到2然後這個它原本是end下一個指定是end2跟5做一個end然後再save到4所以這裡面很明顯它的2讀出來是要讀前一個load的結果把它寫到2可是它寫到er它是在這邊才寫進去這個結束以後才寫進去但是這個er的值available的時間點是在這裡就available所以我們就是必須要在這邊做一個forward的機制如果說這個instructionend的instruction是在第二個clack cycle就把它issue到popline

把它丟進來假設是在cluck cycle 2把它丟進來 同學可以看當它要執行的時候是在cluck cycle 4它在這個地方要執行可是它 earth available是在cluck cycle 5所以它沒辦法把5拿到4這邊來使用所以它必須要怎麼樣它必須要把它delay一個cycle等於說end是在這邊出現原本在这里原本在cluck cycle 2你就变成说它是在cluck cycle 3才出现就等于是delay一个cycle你delay一个cycle我们就可以

发现说它要做执行的时候execution stage就是在cluck cycle 5所以这边available也是在cluck cycle 5所以你就直接forward因为两个都是发生在cluck cycle 5在同一個時間所以你資料就可以把它拿過來用所以這個就是所謂的Forward就是這個Store加Bubble這一邊我們看到的這個這個就是所謂的Bubble它Bub

ble如何控制呢所以它就是當它在這一邊的時候呢，它就把這一些control control value全部都設成什麼，全部都設成0，全部都設成0。它在要從這一邊進到這一邊要從這邊進到這邊的時候呢，它把這邊的control value全部設為0。所以同學可以看到設為0，呢它進到下一個cut cycle的時候，這個Stage control signal全部都是0，所以就是no operation.

then在下一个时间点这边又是0，在下一个时间点又是0同学这边要不要confuse的不要说好多0好多bubble可是我們如果就时间走来看我們如果就时间走来看同一个时间只有一个Stage是bubble，比如說class cycle 4/class cycle 4class cycle 4的時候是execution stage bubble,no operation就是由這一邊送過來的。所以它no operation當我從class cycle 4再往前進到class cycle 5的時候，這個時候,class cycle 5我們要看的是這個地方，所以它的execution stage已經在使用了，它這個時候bubble是從execution stage變成什麼，變成

memory stage所以memory stage这边是一个no operation当你又从class cycle 5进到class cycle 6的时候bubble是变成是在ride back stage的时候bubble然后memory也有在动作execution也有在动作所以同一个时间点只有一个stage是bubble因为我们只有加了一个bubble我們只加了一個bubble除非你連續加了兩個bubble我們這樣子來看的時候

你才會看到兩個bubble不會說你加了一個bubble結果你看在同一個class cycle裡面結果popline裡面有兩個stage有bubble這個一定是有問題所以同學要记得就是当我们在看这个Multi-cycle的publine的data diagram同学要记得直的看 横的看它有不同的意义直的看是看同一个时间点在这个publine里面它的使用的情况这个就是idle然后cut cycle 6的时候是这个idle不同的stage idol这个idle

它都是起源於在這個時間點我們偵測到它有load use hazard所以我們在這邊塞了一個bubble然後它開始從clock cycle 4開始出現每一個clock cycle就出現一個bubble在不同的stage出現一個 bubble就是這樣子這邊同學有沒有問題

那我们再往下看我们再往下看就是说以我们刚刚的例子同学可能会觉得说这个or这个指令是不是对它一点影响都没有其实在我们的这个store bubble的这个operation里面这个or它其实也是有受到影响它并不是说它就很順利的就直接進到popline同學可以看到說第一個時間點cycle1就是這個load進來第二個時間第二個時間呢這個是什麼呢是load進到這個decoding stagefetch的這個stage已經把end讀進來已經把end讀進來

可是这一边我们还不知道说在这里我们还不知道说它是一个load use的一个hazard是我们当进到clock cycle 3的时候进到clock cycle 3根据我们刚刚的一个判断我们刚刚的一个判断发现说这一边它是一个loadload的这个destination是等于我们这一边的什么它的rs或者是rt所以我们就知道说这里面已经

发生了一个load use hazard可是同学可以看在Cut cycle 3的时候第一个指令是在Execution stage第二个指令是在Decoding stage第三个指令是谁就是ALLALL这个时候在哪里ALL这个时候其实它已经进来了它已经进到instruction. fetch這個時間點它已經進到這一邊了所以實際上我們前面那一頁的圖並沒有很精確地描述Pupline裡面發生的事情。真正Pupline裡面發生的事情在Clark Cycle 3的時候Clark Cycle 3這個all第三個指令已經進到Pupline。

我們從3再往前move到class cycle 4的時候我們可以發現因為我們在這裡面detect到hazard而且必須要做store所以我們加了一個bubble。因此同學可以看到在class cycle 4我們這邊execution stage就出現了bubble出現bubble因為我們剛剛前面講說我們的store除了把control signal都設為0之外我們還必須把Program Counter還有Instruction Fetch Decoding這個Publine Register這個也把它Keep and Change。因此這兩個東西當你Keep and Change的時候我們進到Clack Cycle 4的時候這個Register跟這個Register的值是一樣的。同學注意我們把這一個

keep and change在clock cycle 3的時候把它keep and change所以你進到clock cycle 4的時候這兩個是一樣的。那一樣的話就表示這個stage是誰這個stage就是這個end因為在這個clock cycle 3這個stage是誰呢就是這個end。這两个end是一样的只是说他发现他要store他后面就加bubble实际上这个end就是这个end所以我们把它keep and change这个就

一样。另外我們再来看class cycle 3跟class cycle 4我们说把谁keep and change呢？第一个是program counter第二个是IFID，IFID就是我們剛剛指的這一個Program Counter也是没有變所以我們來看Clark Cycle 3Program Counter是指到誰？ Program Counter是會讀到誰？ Program Counter在這邊我們說它是讀到or讀到or 這個是讀到or。因此當你move到Clark Cycle 4的時候Program Counter也是沒有變所以

我們來看Clark Cycle 3Program Counter是指到誰Program Counter是會讀到誰Program Counter在這邊我們說它是讀到or讀到or 這個是讀到or所以當你move到Clark Cycle 4的時候Program Counter也是沒有變所以它再讀一遍它還是讀到誰？它还是读到all。因此同学可以看到它的store跟bubble听起来好像很简单但是你如果要把它深入去观察它的popline里面发生的事情，重点就是两个一个是program counter第二个是IFID这两个register它是keep and change它是没有变

沒有變的話我們就是只要知道說這個register它是保留了誰在clock cycle 3的時候是保留誰我們就知道說clock cycle 4這個stage還是一樣還是一樣是它這個stage它保留誰呢它是保留這個and所以在這裡面它還是一樣是一個and在clock cycle 3它的program counter是指到or所以在這一邊它是讀到一個or進到class cycle 4再讀一遍Program counter也沒有變所以它要讀到all所以它等於是把第二個

指令跟第三個指令等於就是把它封在就是好像把它冰凍把它封了一個class cycle讓它白白過了一個class cycle那個class cycle就是我們加了一個bubble去做一個delay所以同學要注意的重點就是在這個地方他把第二跟第三他把它冰凍起來第二那個時候剛好是落在這個stage第二個stage第三個指令剛好是落在第一個stage你要把第二個stage的指令冰凍起來就是要把IFID register keep and change你要把第一個stage的指令冰凍起來就是要把Program counter

把它keep和 change就是透過這樣的機制同學就可以了解說這個是它DataPath裡面實際上發生比較detail的一個情況所以這邊同學有沒有問題我們就假設真的沒有問題再繼續往下看。根據我們剛剛的描述我們就要來加了一個hazard detection因為為什麼要加hazard detection因為我們剛剛不是講說我們必須要做什麼我們要做store加一個bubblestore加一個bubble就是做三件事第一個就是把下一個stage的control

訊号全部都设为0让它变成一个no operation bubble一路传过去这是第一件第二件事情要保留第一个stage的指令所以你要reserve这个program counter第三件事情你要保留第二个stage的指令你就是要reserve ifid这个register。我们看到说Hazard Detection Unit根据我们这个conditionIDex它必须要做Memory Read所以这边有个input接着IDex它的register destinationRT所以它必须要从这边这个stage

这边是RT,IDX stage的RT从这边拉回来。拉到这边它的另外一个input它的IFID的第一个source或者是IFID的第二个source就是从这边过来第一个source或者是第二个source这是它的input所以我们看到它的input 1,2,3, 4这四个input就是都出現在這個condition裡面都出現在這個condition所以這個線也不難接你就看到說它的

input就是在這裡所以就是這一個就是這條線拉過來然後這一個跟這一個就是這條線拉過來這個rs跟rt呢就是這一個這兩條線拉過來就是它的input那output呢hop-up就是我們剛剛講的要做的那三件事第一件事情是什麼呢第一件事情就是把所有的control signal全部設為0所以這邊control unit它的control signal必須要跟all 0這邊就是 這不是指一個0這邊就是指你每一個control signal都要跟0做一個selection

如果说它侦测到hazard必须要做store它会选择这个0把它写过来如果说它侦测没有hazard不需要store或者是它的hazard可以透过forward来解决的话它就会把这个control unit产生的讯号从这边透过multiplier送到这边就是这样子另外它还有什么呢同学可以看到这个IFID的WriteEnable跟ProgramCounter

的WriteEnable它也是由这个HazardDetectionUnit来产生当它发现要Store它要保护这个Stage的资料它就把它WriteDisable掉它要保护第一个Stage的Instruction它也把ProgramCounterWriteDisable掉它就是透过一个WriteDisable它就Reserve這一個register跟這個register這兩個字所以這樣子就可以達到我們剛剛提到的這個hazard所產生出來的這個effect所以前面的觀念了解以後我們就是兩邊對照我們加了這個structure的圖相對的就很簡單接著我們把時間交給

同學好就是又是LAB4了然後就是這個LAB是Single Cycle Processor那其實如果你們LAB3有就是有做得不錯的話應該要改成LAB4應該蠻容易的啦因為LAB4主要就是差別就是主要Single Cycle就是你們要在一個Cycle裡面就是做完一個運算一個指令這樣然後這邊就大概講一下你們的Spec的部分就是Program Counter是32bit然後Instruction Memory就是8x32對，

這樣上面看然後這是Test Case，我們到時候會有隱藏測支然後這支這支Lab會有Demo，然後你們可能，我們目前計畫是說你們來Demo的時候，然後我們就是現場讓你改你的Test Bench，然後測你的隱藏測支看會不會walk這樣，那這個表上的這個test bench當然是一定要過啊，那其他要求都跟之前lab都一樣，那demo的時

間就是應該就是dayline之後，然後我們應該會再找個禮拜一或禮拜二，然後可能不只一天因為就是現在助教課比較沒有一致所以可能一天day不完，那就是可能會持續兩三天這樣，不過因為就是有dayline嘛，所以反正就是以dayline的時間就是為扣分的基準，這樣，然後到時候demo再看你們的狀況給分這樣，這支大概就是這樣， 你們有什麼問題嗎都沒問題就下課吧.