undefined
接著我們來跟同學介紹就是這個Branch Delay Slot這個觀念這個Branch Delay Slot基本上它就是指在Branch指令的下一個位置就是譬如說我們的這個VEQVEQ它後面VEQ它後面原本是有某一個指令但是因為緊接著VEQ後面的那個指令它不見得是VEQ執行完之後會輪到它執行所以我們

就是把它假設在這個VEQ跟它後面的這個指令中間的這個position我們就是把它稱作這個BranchDelay Slot那這個我們就是希望說可以在這個位置裡面可以填上一個指令那這個指令可以幫助我們來解决就是说就是我们前面提到的就是说你如果说有Branch的话我们必须要这个Store Publine那

就会有一些浪费几个Clack Cycle的时间在Publine的结束段那边看不到有指令就是被执行完整的出现所以我们就要避免这种情况的话前面我们有提到就是所谓就是说你可以去猜什么样的这个指令进来那当然这个其实这个观念基本上就是蛮类似前面的就是说它这边有三个一个是

说我们在Branch Delay Slot这边呢我们就是可以填入填入什么样的指令呢填入这边有三个机制第一个呢就是说From Before那From Before的意思呢就是说我们就从这个 VEQ的指令的前面它的前面原本这个指令是在VEQ還沒執行的時候它就應該執行但是這個指令你不管放在BEQ的前面或者是BE

Q的後面來執行基本上結果都是一樣並不會影響到整個程式執行的結果所以既然它擺在前面執行也一樣擺到後面執行也一樣所以就是把這個指令把它搬到這個BEQ的後面這樣子的話因為這個指令原本就是一定要執行的它并不是因为说VEQ的taken或者是not taken它有时候执行有

时候不执行这个指令是一定要执行所以我们就把它搬到VEQ的后面所以这样子的话我们就保证说整个publine里面都不会有所谓的bubble因为它一定要执行的指令而且不会影响整个城市执行的结果就简介在VEQ后面所以我们这样子的话根本就完全不用猜说这个VEQ到底是t

aken或者是not taken这样子保证我们可以避免store pipeline的这种情况发生所以这个就是所谓第一个from before第二个其实就是我们前面提到的就是说我们的这个VEQ假设它要跳的话那它到底是要跳到就是说要跳到某一个地方那我们就把它的这个targettarget的address呢就是说它说是taken的话它的tar

get address我们就把它放到这个就是这个后面的这个指令那这样子的话呢就是就直接把它放到beq紧接着beq进到这个popline那这个呢就放from for through从 for through指的就是指说就是说你如果说比如说像我们这边如果说假设这个S1等于0的话它就会做这个没有的话它就会做它如果是不等于0它就不会执行这个它就会来执行这个指令

这个时候其实你就等于是把这个放到这个branch的instruction的后面所以这样子其实这两个基本上就是类似我们前面提到的就是说你到底是让它这个taken或者是not taken就直接把它摆到这个pipeline里面来那两种不同的情况你总是会有一个结果是对的一个结果是错的那如果是第一种结果这个是最好的第一种就是from before这个表示说它不管到底是taken或者是not taken它一定不会有错因为它这个指令是一定要

执行的所以这个就是branch delay slot另外我们这边在提到就是说要算这个branch的target算branch的target的话基本上就是我们前面提到的我们的第一个指令一定是已经是就是PC加4然后再去加这个offset如果说我们必须要做这个加的这个动作的话就是你还是会浪费一些这个时间除非就是说我们必须要就是像前面一样加了一个这个adder，那你adder你必须要把它摆在适当的这个stage，

所以这样子我们在算这个target address的时候呢，就是说你可以在尽早在这个decoding的stage就把这个target address就把它算出来；那另外一种方式呢，就是说我们可以使用这个所谓的branch target buffer，那这个branch target buffer这个意思就是说针对每一个这个veq，我们会算它的target address，那这个target address呢我们把它的结果就把它存起来存到

什么地方呢，就存到一个Buffer里面，这个既然是Buffer，我们这边还没有跟同学介绍所谓的Cache，因为我们知道说一个程式里面，它的VEQ的指定的数目可能非常的多，它可能有数百个上千个，每一个VEQ它的target都不一样，所以我们如果说要针对每一个VEQ的instruction都去存它的targets的话，那你就要有相同数目的这

个memory，你有1,000个你就要有1,000个location，你有2,000个就要有2,000个location，让它去存它的targets，但是我们一般这种cache它可能没有那么的大，它的数目可能没有像be q的instruction的number这么多所以基本上它就会有所谓的就是说我们可以存targets它的这个size是小于veq instruction的数目这样子就是我们就把最常用

的最近常常被access到的veq指令它的target address把它放到所谓的branch target buffer里面所以就好像说我的buffer里面只能够存10个target address我假设有100个veq instruction所以我这100个就是拿最常用最近最常用的這十個它的 address把它放到 buffer 裡面假設有第十一個我們要執行第十一個 BEQ它的 target address 算出來這第十一個它當然沒有存在 buffer

裡面所以這個時候我們就要把第十一個把它丟到 target buffer因為它只有十個你存了十一個所以你就要從裡面再拿一個出來就把它清掉那要拿谁呢一般我们大概就是拿那个就是最少用的假设你可以很简单的去估计说到底谁比较少被用到你就把那个最少被用到的那一个targeted把它从

buffer拿掉然后再把新的那个再把它丢进去所以整个cache它的运作的机制基本上大概就是类似这样子就是100个一直在竞争那10个但是我们如何知道说我的这个BEQ我的这个target address到底有没有存在buffer里面呢那通常因为它是一个它是一小部分的一个memory的location当然你memory

你就是必须要透过某一些它的这个address去找说这个location这个buffer在哪里这个buffer在哪里那我们基本上就是透过的这个BEQ这个instruction它的某一个部分或者是全部的 address 去定指 buffer所以就是用這樣子的一個機制我們後面有一張專門在講 memory我們會跟同學來介紹說你如何用 memory 的 address然後來就是它有所謂的 tag 的部分然後來定指 cache到底這筆資料存在 cache 裡面的哪一個 location

所以他这边就写说当你要知道一个BEQ它的targeted到底要不要算你要做两件事情第一个就是说你要知道说这个BEQ它的targeted有没有在buffer里面如果有的话我们就是叫hit如果说这个BEQ它的targeted没有存在这个buffer里面这个就叫miss你miss的话你就要去算它的targeted

算出来以后再把它存到这个buffer里面所以你第一个你check它如果说是hit已经算好而且已经放在buffer所以你就是可以透过你的这个address到这个buffer里面去定值到底在buffer的哪一个位置把它抓出来而且当然就是说而且是这个instruction它是要是branch print就是它是predict taken就是我们有猜测我们是猜它是要taken所以它是hit然后是taken我们就可以

直接马上抓到这个targeted就是这两种情况的话你就可以直接把它的targeted把它抓出来你只要是predict taken然后你又miss你就要去算所以大概就是这种情况这个的话就可以减少我们的targeted computation后面我们要跟同学介绍一个机制就是我们前面的publine的design里面还没有处理这种exception还有所谓的interrupt就是在传统我们如果说我们的computer有接一些仪器的话或者是你有接周边设备的话

其实他要跟他们做一些沟通的话其实常常会有需要这种exception或者是interrupt什么是exception 什么是interrupt同学如果看不同的testbook不同的community organization或者是architecture的书它的定义可能不太一样在我们这一本课本里面它有它的定义我们在这边是follow它的定义我们在这里面我们所谓的exception指的就

是指说有一些event它是发生在CPU里面发生在CPU里面使得这是基本上就是不正常所谓是我们没有预期会发生的一个事件发生了所以我们让我们的程式没有办法再顺利的再往下执行这种情况的话我们就是所谓的exception或者是interrupt在我们的课本里面exception是发生在CPU内部的e

ventinterrupt是external的一个event所以它这边interrupt它会讲说from an external IO controller所以这边要分清楚一个是CPU内部的一个是CPU外部这种分类法是在我们这本书里面它的分类的方式不管是exception或者是interrupt我们都必须要终止目前的程式的执行让要去处理没有一起发生的事件要把它很顺利地排除掉之后才能够再继续执行或者是重新再restart我们这边有列出几个

比如说IO device的request这个很明显是external是external to CPU所以在我们这边就是所谓的interrupt如果说是invokeOS from user program这种很明显是来自于你这个CPU内部或者你user program内部的request，所以internal这个是所谓的exception，另外rismatic overflow我们程式在硬算的时候也是内部出了问题，就是超过我们能够表示的范围，这很明顯

是exception，另外就是说就是使用了一个undefined的一个instruction，这也不知道是从哪边跑出来的一个程式，它根本不是在我们的这个我们的这个IC里面有定义的一个code，所以这个也是属于Internal， 所以這也是Exception。那如果是Hardware More Function呢，它指的就是指說你的硬體出現了不正常的這個情況，那它可能只是一個瞬間的一

個錯誤，它可能也是一個就是一個永久的一個Fail。那這種Hardware More Function因為它有可能是內部的，它有可能是外部 來自於外部，所以這種它有可能是Exception也有可能是Interrupt。其实不管是exception interrupt我们要处理的东西都是一样的只是event的source是不一样碰到这种exception跟interrupt不可避免整个system的performance它一定会degrade因为我们前

面所谓的hazard不管是哪一种hazard，我们都想尽各种办法、reordering、forwarding用一些机制尽量把这个hazard的这个伤害把它降低，让我们的popline每一个cycle都可以issue这个instruction。但是，一旦碰到interrupt或者是exception，那这个就没救了，它一定是就是它有的可能就是直接就停下来那它可能就是会在等那个，就是interrupt或者是exception的那一个指

令的前面、前面那些指令都是很顺利的在执行，只是他还没有执行完，他还没有执行完那他可能就等那些指令，就顺利的执行完之后呢，他就把整个popline全部都清掉，然后再重新、再把就是去invoke那些要去解决这个排除这个interrupt或者是exception的这种event所以这个就一定会有损失，就是已经进到publine里面的

那些instruction全部都会被清掉。所以我们来看一下说，我们要如何处理这个exception在MIPS里面，它说exception，它是有一个叫system control的一个coprocessor，它叫cp0叫coprocessor，会把这个program counter就是说出现Exception或者是Interrupt的這個指令就使得我們整個系統中斷執行、中斷的這個指令。我們把它存在什麼地方呢？在Maps裡面，我們叫ExceptionProgramCounterEPC為什麼要存這個EPC呢？因為我們中斷了整個這個程式的執行。接著，我們會就是我們剛剛講說會把這個Publine把它Flash掉，

那这个时候你Publine要重新执行什么呢？重新执行去Serve这个Event突然发生的Event。我们要排除这个Event所以我们要去Serve这个Event那这些Routine接着就从这个Publine就从这边Instruction Fetch那边开始进来那你整个都排除完之后你可能希望说它再重新再执行，所以你必须要到这个EPC這EPC就刚刚存下来的这个interrupt的地方，

你再把它load到publine里面来再重新执行。所以这边就是要记住发生问题的地方之后才能够再把它restore到这个指令然后再继续执行。要处理这种不可预期的Event，我们知道说OS它必须要有一些方式来做一些communication，就是跟发生问题的不管是你的source或者是你原因，你要知道什么原因所以在我们这边，我们有两个方式就是说对OS而言，它有两个方式来解决、认得。说到底出现了什么样的一个情况那在第一种方式就是在MIPS里面采用的。

它就是有一个所谓的Course Register，顾名思义Course Register，它储存的是储存什么东西呢？应该就是储存一个值这个值其实它就是描述说我到底发生了什么样的一个事件，使得说我们这整个程式的执行会被中断。所以就存在这个Register。所以你不同的EventCodesRegister，它裡面就會被存入不同的這個Value。所以這個是一個方式。所以我們假設說假設它只有一個bit如果是只有一個bit的話我們就是只能夠存兩種狀態在我們這一邊假設是說只有一個bit那0是存UndefinedOP Code就是

这个指令根本不是我们认得的指令，它不是我们在instruction set architecture里面有定义的instruction。所以没有办法执行。所以如果是方状情况那你就会把这个顶写到cost register。如果是发生overflow的话，我们就会把1写到cost register。所以这个是我们在MIPS里面采用的一个方法叫Cost Register。第二个叫Victor Interrupt。什么是Victor Interrupt呢？其实这两个它得到

的效果当然都是一样什么效果呢这个效果就是说我们发生比如说是undefined OP call但你就必须要去call一个routine去处理这种情况如果是overflow你就要去call另外一个routine你要去code另外一个routine去处理这样子的一个情况那你把这些情况都排除完之后呢你可以决定你要接下来要怎么做比

如说再把刚刚interrupt的instruction漏了进来再继续执行或者是再restart什么之类的那所以也就是说你不同的case呢你是不同的处理的case那这个第一种叫cost register呢它就是什么就是你只要发生interrupt的话它系统自然就会植入个别的不同的value到cost register然后就会进到一个single entry进到一个地方这个single entry不管你是哪一种interrupt它就进到同一个single entry其实等于就是想象把它去code它就是固定都code同样的一个routine你去code它之后

好像他就开始执行执行什么呢他就开始解读这个cost register他开始解读说这个到底是0还是1那0的话他要怎么做1的话他要怎么做所以他是用这样子的一个方式那第二个呢vector的inter rupt呢他指的是指什么呢就是当你发生interrupt的时候呢他可能就是透过这个hardware不同的这个event它就直接去

扣不同的routine所以比如说这个0它如果是0这种undefined的OP扣它就会自动去扣某一个address的routine它如果是碰到overflow这种情况它要去扣另外一个地址就routineA routineB所以routineA它有一个addressroutineB它有另外一个address所以它好像等於是定义的一個tableVector表裡面就會描述說你如果是overflow它是a這個address如果是undefined opcode那它就是另外一個b address所以你事件發生了它就自動跳到某一個entry

然后跳到另外一个Entry所以你根据不同的Event它会跳到不同的Entry所以这种就是所谓的Victor的一个Interrupt所以它最后的情况是一样的就是你根据不同的Event然后它要做适当的处理差别只是差别在说它这个做法是它把事件的区分的这种情况它把它写入一个叫Course Register然后不管是哪一种Event它都有

一个Single Entry进到Single Entry之后，它才去判读这一个到底是哪一种Event，然后再做不同的处理。这一种是事先就已经定义好这Event A，它有Event A的一个Address的RoutineEvent V有一个Event B的它的Address的Routine所以你这个Event发生的时候，就看你是哪一种Event，它自动就会去进到不同的这个Entry然后执行不同的code做不同的service所以，

这就是这两种不同的机制在MIPS我们是采用第一种，它的single entry就是这一个，我们就说我们这里MIPS jumps to handler就在这个位置，它的single entry统一就在这里，不管是哪一种type的exception或者是interrupt我们先休息一下。我们的剛提到的就是interrupt的處理機制有兩種情況，这兩種情況就是你去認其實差別就是一個single entry還

有一個multiple entry，所以它的multiple entry基本上就是根據我們定義好的這個vector，比如說undefined opcode，它的entry point overflow，它的entry point然後，每一個不同的interrupt type，它有它的不同的entry所以根据这样子的话最后我们都可以去扣到适当的handler然后提供适当的solution帮我们排除这样子的一个情况所以在这边同学就是要了解这两个不同的机制所以有关于exception interrupt同学要了解第一个那两种任不同type的机制

第二个要了解整个flow这整个flow同学要了解第三个我们等一下会看就是会看管理publine它的design要如何去加了一些东西然后来处理这种exception的case所以我们来看说在exception发生的时候或者是interrupt发生的时候首先我们必须要把这个就发生这个interrupt的指令把它save到这个EPC里面来同学要记得的是什么呢要记得就是说当我们执行的时候

比如说假设它是在execution stage发生interrupt跟随这个指令来到execution stage它的program counter这个时候是多少这个时候其实它已经加4了它已经加过4所以你如果要把它存到这个EPC里面我们如果是要存发生interrupt的那个指令的话当然就是你必须要把这个PC加4的这个就是再减4这个值它才是真正值到值到发生interrupt的这个inst ruction所以这边要注意的一点是这里

存起來之後接著我們當然就是要把Ctrl我們要把整個CPU的Ctrl控制權就是把它Transfer到OS然后要做適當的處理適當的處理不外乎這兩種一種就是進入Single Entry然後根據Cost Register然後做適當的處理第二種就是發生的時候我們根據Vector它interrupt所对应的这个vector我们可以知道说它的entry point在什么地方然后

可以去扣它然后去做适当的这个service那整个排除之后呢接着你有可能就terminate整个program因为你觉得你大概没有办法再执行的话那就是一种就是terminate你的programeither或者是就是再把这个EPC再把它restore到你的这个program counter然后接着再去执行我们的这个程式所以这个就是我们在exception它的一个大致的流程就是

这样子如果是publine的话就是说我们在publine里面因为它发生exception它可能发生在不同的stage所以比如说我们刚提到的这个undefined的OP code它就是发生在这个decoding的stage如果说我们是发生overflow的话它是发生在execution stage所以它是有可能在不同的stage发生这样子的一个情况所以这边提到的就是说我们说假设在execution stage执行一个加那就register2跟register1两个相加然后存到register1相加以后就发生了一个overflow这个时候overflow的话

我们可能要排除这样子的一个情况所以我们第一个要避免什么呢避免我们产生出来的不正确的结果就是write到这个register1里面去另外呢我们也必须要把前面就是在这个加这个指令的它的previous instruction在它前面进到pipeline在这个指令的前面进到pipeline的那些指令它都是还正常的在执

行所以我们要complete previous instruction要让它顺利的把它执行完还有我们要去flush就是这个第一个这个就不能再执行了因为它已经overflow了所以就第一个把它flush然后还有在A的后面已经进到popline的这些instruction全部都要把它flush掉然后set cost register还有EPC register然後接著就是TransferControlToHandler基本上

在PupLine的話我們就是要再多做這樣子的一個動作所以根據我們剛提到的這些Operation這些Action我們可以來看之前我們認得的一個PupLine的一個Design它的Datapath我們可以發現說多了哪一些東西呢首先這邊多了一個All这个同学应该还记得就是我们之前我们如果说要store要store这个instruction我们就是要怎么样

呢我们就是要把这个instruction它decode完所产生的所有的control signal全部都disable掉我们要选择这个0进到下一个stage所以这样子的话呢留在就是目前在decoding stage的这个指令呢它后面就不会被执行了因为它所有的control signal全部都被设为0所以你后面的operation都是没有效都是没有效果的它不会产生任何

效果目前这边就是多加了一个all这个all其实就是什么呢就是它all谁呢第一个就是我们这边是原本的hazardhazard detection unit它已经侦测到hazard发生你必须要store所以这是一个另外一个是什么呢另外一个这边叫id. flush指的就是指什么呢就是undefined opcode我们在第二个stagecontrol unit它一直在解码这个instruction它一解完之后发现说这个指令根本不是我能够执行的指令它根本不认得所以它就会enable它就会enable这个id.

flush所以你either是它是一个undefined OB code或者是发生了这个hazard那你就要选择这个0把目前在ID stage的这个instruction把它hold得住不要让它继续再往下执行那等到再过一个class cycle这个指令再让它再启动再继续执行所以这个是我们在这边有看到加了一个我们刚刚提到说它exception有可能在

RecordingStage也有可能在ExecutionStage如果是在ExecutionStage的话我们就是多加了这一个所以同学可以看到说这边第一个它是把所有的ControlSignal全部都设为0它是在这边它把所有的包括WriteBackMemoryStageExecutionStage这三个Stage的所有的ControlSignal它在这里就全部都设为0可是当

你是发生在execution stage你没有办法在这边设因为你的instruction出问题的instruction是在这个stage所以我们要从这个stage下手把它的control signal把它清为0所以在这个stage它有哪一些control signal呢第一个是write back第二个是memory这个会往后传的这两个会往后传所以我们就是把这两个这边都加一个0然后multiplacer这边也是用一个0multiplacer这个是什么呢这个input selection就是ex.

flushex. flush什么时候会被enable呢就是在我们这个case里面是overflow发生的时候你overflow发生的时候我们这边的circuit就会activate这个ex. flash如何去做这个事情，我们这边就忽略了所以同学不用说它好像在第二个stage它是在第三个stage其实这个东西是有一些connection我们在这边没有把它就是说作者他没有去介绍这边之间的connection我们就把它忽略掉但是基本上

它这个讯号并不是说你在错误这个地方它自己就有办法根据你的instruction什么什么什么然后它就根据你的这边读出来的instruction它就能够侦测它是overflow它是这边执行完产生overflow的时候然后这边就会activate这个讯号然后它就会把选择这个顶进到下一个stage选择这个顶进到下一个stage所以它也是等于把

目前位在execution stage的这个指令把它怎么样flash掉它只有执行到execution stage它后面就没有再执行了因为后面control signal全部都被设为0所以都没有效用它的effect就是no effect就是这样子所以在这边多加出来的其实就是这一个 这一个再加这一个要了解的观念就是这个是针对undefined opcode所以它是instruction读出来以后就解码解码解不出来它就有一个id.

flush然后就把这个0全部都填进去所以这个指令就被flush掉另外一种这两个是针对发生在execution stage这个execution stage就是它产生的overflow产生overflow之后这边会activate ex. flash所以它就会把这两个0送到后面的stage这个instruction就被flash掉，所以这边的重点就是在这，所以在这边我们就不再介绍了，因为这个detail我们刚刚都已经跟同学解释过了，所以同学可以看一下这部分的描述

那我们在这边有一个例子，我们会根据这个popline的这个datapath来看这个case，那这个case呢就是说它的exception发生在执行这个aid这个指令，它是在4C的地方，所以当我们执行4C的时候呢伴随它的这个program counter其实它已经变成50那它的handler呢就是比如说我们就是跳到这个地方来所以同学可以看到，在exception它是

发生在execution stage，execution stage就是在这个stage，就是这个指令在这个stage使得它发生overflow，以我们前面的例子，在这里，我们目前介绍的架构只有两个，一個是undefined or p-code，在这里，一個是overflow，在这里，所以同学可以看到，它执行这个的时候set less than，在decoding，然后load是在fetch，所以后面的两个指令都已经进来，这两个指令进来其实这些都是正确的指令，所以它不会有什么id。

flush就是说它不是说认不出来然后把它flush掉，它在这边它是怎么样呢，它是在这里发生了一个overflow，所以它发生了overflow之后，同学可以看到这边，它的program counter送过来的是50，因为已经加过4，它发生了overflow之后，我们就是把这边，这边加了一个bubble，这边也加了一个bubble，加了bubble之后，这个bubble就会跑到这边来，然后这边的bubble跑到这边来，

这边进来的，它也不让它过来，所以这边等于也是一个bubble所以实际上，这两个bubble是相对于你谁呢，这两个bubble是相对于这一个跟这一个，这一个就进到这里，这一个就进到这里，这一个bubble就是原本在execution stage发生overflow的那个加的指令，所以它也是透过这边的0把这边都设为0所以下一个cut cycle，这边就

会变bubble这个是来自于加这个是来自于setLessThan这个是来自于load后面fetch的这个instruction就是我们的handler真正要来救它的handler就在这边就出现了这个时候我们的这个EPC，它应该就是存入我们的这个aid，它的这个address就存入这个EPC，所以这个就是我们一个exception的一个范例前面提到的是一个一个single的一个exception有没有可能发生这个multiple exception因为我们刚的例子其实就已经有可能发生这个multiple exception，因为一个是在哪里呢一个是在decoding一个是在execution stage

所以它就有可能是发生两个如果你的Popline Stage有超过十个以上的话，那更有可能在很多地方都会发生这个multiple exception，所以当你发生这种multiple exception的时候其实是比较复杂的一种机制，所以他这边提到就是说我们这种simple的approach，它就是处理什么呢？它就是处理这个哪一种exception呢？它是来自于最早的这个instruction什

么是earliest的instruction呢？就是你最早issue到Publine里面去的，就是你在最后面那个Stage发生exception的那个，我们就是从那边把它处理，然后接着就把后面的全部都把它给flash掉另外就是说，如果是在Publine的这种，这是一比较复杂的pipeline，它基本上，它的执行是out of order指的是，就是说我们在执行，我们在丢这个指令进来的时候，它不是像我们这个一次丢一个指令，一次丢一个指令，它丢指令，它有可能一次是丢两个，一次丢四个，那你丢的时候其实你

一次丢那么多个指令或者是另外一种情况是说，你有可能是sequential的照着你的code sequence一直丢指令可是你在执行的时候，它的order并不是照你的code sequence不是照它的code sequence方式去执行它的指令，它有可能是12345；它的code sequence是一样子的，但是执行的时候有可能是13、42；它有可能是13425，或者是另外一种不同的order；针对这种不同的order的话，这种你如果又有发生exception的话，这个就非常的复杂，非常的

复杂所以你要maintain这种precise exception就非常困难，我们这边大概没有讨论到那么的detail所以同学这边只要知道说有类似像这样子的一个机制就可以，所以类似像这种precise或者是imprecise exception我想我们这边我们就把它跳过去，我们进到后面这边有比较详细的介绍也蛮重要的这个单元就是instruction level parallelism，就是ILP这个

ILP不是Integer Linear Programming，这个是Instruction Level Parallelism；我们前面提到的这个POPLINE，它可以同时执行不同的指令，但是它是因为把它切成不同的stage，每一个stage都是执行单一的一个指令，所以我们如果要去increase这个ILP，就是inst ruction level的parallelism意思就是你要让同时有不同的指令可以同时执行，有超过一个以上的指令可以同时去执行。一种情况就是什么呢，就是你增加你的pup line，它的depth5个stage变成10个stage或者是变成15个stage所以你的stage的数目越多的话，我们就可以让

越多的指令同时执行。所以，这是一个所谓的deeper pipeline。但是，你如果你的 pipeline可是你如果你的pipeline越深的话，它的问题就是你如果，比如说你有20个stage那你如果是在中间第四个stage有发生exception或者是什么hazard你没办法解的话或者是branch什么之类的，那你就必须可能你后面的全部都要把它flush掉。所以，这个是

一个很大的一个问题。另外一种方式呢，就是所谓的multiple issue那，multiple issue是指什么呢就是我们刚刚提到的，它一次丢两个指令或者是丢四个指令那类似像这种情况的话呢，你就一定要必须要去怎么样去duplicate你的hardware。这边，我们就提到说你的publine的stage你必须要把它把它做一个copy。那么，你copy完之后呢，你就有机会

去一次丢两个或三个四个的指令，因为我们你如果说同一个时间你可以丢两个以上的指令的话这个时候基本上我们的CPI大概就已经小于1了小于1所以我们大概就我们如果喜欢整数的话喜欢大于1的这个值的话我们可以用另外一个叫instructions per cycle就等於說你一個cycle丟了幾個

指令完成了幾個指令那這個IPC呢就是所謂的這個instruction per cycle那比如說我們這邊4GHz 4-way的這個multiple issue那它的這個peak的CPI呢是等於0. 25它的peak IPC就等於4因為它一個就是4-way4-way的這個issue它一次可以丟4個指令把它丟出去可是我们知道说这个跟我们

的这个POPLINE是一样的POPLINE你可以每一个clock cycle都丢一个指令到POPLINE所以你POPLINE的depth越长你同时就有越多的指令暂居在POPLINE里面那你这个一次可以丢四个指令就一直丢一直丢那它会有一样会有这个dependencydata dependency的这个问题只要有dependency的话呢它就可能让你没

有办法一次丢四个指令那一次不能丢四个指令怎么办呢你可能可以一次丢三个或者是一次丢两个或者是最惨就是一次就丢一个那有人说那我一次丢一个那其他三个怎么办三个就是有一种指令叫NOPNOP就是什么就是No Operation就是好像一个Bubble一样所以就是等于一个指令配三

个bubble就是空炮弹所以它是没有用的这种效果是最差的所以我们后面就会有一些简单的介绍简单的介绍说我们要如何让我们的Parrot的一个机制可以得到更好的效果我们后面剩下的这些内容都是非常非常重要的内容但是作者他只有介绍一些基本的观念但是还是很重要我

们就透过一些例子来了解说基本的这个问题还有解决的方法那同学如果对它更深入的这个讨论有兴趣的话呢同学应该要去show这个研究所有一门课叫Computer ArchitectureComputer Architecture那门课呢它的课本也是用这个作者写的整本书都在讲这个parallel的东西所以它等于是用第四章的后面的一小段来当个引言吸引同学对这个issue很有兴趣就可以

去修研究所那门课那门课本更厚那门课好厚一本这个也是目前很重要的一个topic不管是research或者是industry都是很重要的一个issue所以我们来看Multiple Issue我们今天会再多一些时间把这个进度稍微改一下Multiple Issue我们说Multiple Issue有两种，很多都是所谓的Static跟Dynamic。顾名思义Static，它就是静态的。 Multiple Issue，就是大家都是有用同样的一种Style方式，它用什么方式呢？它是透过Compiler去Group

去group这个instruction，所以你如果是double issue，它就是compiler会把两个instruction，把它group在一起，然后就两个两个两个都是两两配对呢，这个就是所谓的issue slot，那配对完之后呢，它就开始，就一次丢两个，一次丢两个，一次举两个，就是这样子那这个丢，当然不可以随便乱配，你不可以随便乱点的，你跟你就配一对它，如果有hazard，

那就问题就来了，所以compiler，它必须要detect必须要侦测有没有hazard，可不可以解你要避免hazard所以compiler，它配出来的基本上，这都是已经有解掉这些问题，所以你就是照着这个这样子去丢所谓dynamic multiple issue，它是什么呢？就是说这个CPU，它会去exam你的instruction的一个stream，然后它会去选择这个instruction，它每一个cycle都会选择这个

instruction去丢，所以你CPU，你必须要去解决所谓的这个haz ard你在run time的时候你就必须要去解决这个hazard我们后面会有一张图就是让同学看说它这个机制就比较复杂它的机制就比较复杂它不是说一个很简单的一个就是好像像我们前面加了两三个黑盒子或者是加了一个Multipleaser就可

以把这些东西把它解决掉了所以这种是Dynamic就是你Run Time的时候它就决定说到底要怎么去丢这样子当然Compiler它还是有用到的地方Compiler你还是可以先把你的这个Instruction做适当的ReorderingCompiler它可以解的它就先把它Reordering解决掉reordering完表示说它程式执行的结果不会变而且

某一些hazard又可以被解掉这样子的话它后面在run time的时候它就比较不会说要处理这么多的情况所以这个是dynamic的一个issue的情况另外我们还要提到的就是所谓的speculationSpeculation其实我们在前面提到说这个BEQ我们都会去猜我们会用1 bit或者是2 bit我们会去猜说这个BEQ这个instruction到底是taken或者是not taken什么之类的其实你要猜还有更多的猜法我们这边叫speculation这个 speculation_it的这个

它的觀念就不是像說前面不是像處理前面這樣子一個很簡單的一個BEQ taken not taken這樣子的一個情況它最主要的是說就是說這個指令它跟它到底有沒有hazard有一些有hazard它是很容易就可以判斷出來可是有一些有時候它的hazard它並沒有很容易的可以判斷的出來比如說我们的这个memory你要去memory里面去抓资料那你抓之前其实你并不知道它这个东西到底是不是

一样你的store你store跟你的load它到底是不是同样同样的一个指到同样的一个memory address比如说你store你是把某一个指你把它存到memory的某一个location那你load你是到memory里面的某一个location去把子读出来可是你store你必须要怎么样你必须要runtime的时候你才能够算出你的memory的这个address对不对所以你没有办法说你instruction读出来你马上就证测说它有一个这个hazard存在就是类似像这种情况它们到底有沒有hazard那如果有hazard的时候它就必须要store那如果没有hazard的话

实际上它这个load可以跟store是没有关系它们是可以同时执行或者是甚至把load搬到store前面去都没有关系所以我们这种speculation，它就有很多的效应所以我们这边就说你可以start一个operationas soon as possible，as soon as possible就是说你只要目前手上有的信息你知道说它跟别人没有关系没有卡到能执行就先执行执

行其实这就是说你是猜它可以让它执行你就让它去执行如果你猜对了你后来证实说这个指令真的跟任何人都没有关系因为前面的就是我们的CPU很忙同时执行很多个指令我要知道说instruction A到底跟别人有没有hazard他可能是要等到BCD执行完以后他才会知道这个时候BCD其实他还在执行

我们就把A也就把它丢进去就做那A丢进去做做完以后我们先不要把A的结果比如说A如果要做一个write我们A就不要先write先把A做出来的结果先hold得住先不要write因为你write的话你就改变了CPU的状态但是你执行出来你不做write这个没有问题你就先把那个子先keep在某一个地方那等到BCD它执行完以后呢我们就知道说BCD它的东西跟A都没有关联所以我们就可以

确定说A它没有dependency它跟其他人没有 dependency所以A实际上我们刚刚的执行的结果是对的这个时候你就把A的结果把它write进去所以我们现在在谈的这些机制都是后面的做法就是像这个样子所以就是说你先猜猜说就让它做那做了以后呢你不要去completecomplete就是说如果要write你就hold write那等到你知道说你是猜对了你就complete那你如果是猜错的话呢比如说我们刚刚A已经自行

结果都已经出来了结果BCD执行完以后我们发现说结果A是错的因为A它跟C有dependency所以现在C执行完了我们的A怎么办呢你不能说那我A已经做完了我就直接write这是错的因为你跟C有dependency那C现在执行完你A在执行你的A的结果才会是对所以要怎么办呢你就是roll back这边

讲roll backdo the right thing指的就是说你那个A执行完的结果你就不能write你就把A重新再fetchdecode execution你要再把它roll back让它再重跑一遍因为它跟C有关系C的结果它已经update了所以你这个时候A要重新再执行所以最坏的情况就是什么呢最坏的情况就是你的A要执行两遍最好的情况呢就是你A

提早执行然后BCD执行完你A的结果就直接写进去所以这个就是所谓的speculation那你不管是static或者是dynamic的multiple issue其实都一样都是适用这种speculation所以这边提到的一个就是speculate on branch outcome其实就我们前面提到的taken, not taken这两种这个condition你到底是要taken或者是not taken你可以

反正是让它做做完以后发现说结果我是做taken结果它最后结果是not taken那个结果就不要write你就再把not taken的instruction再拿出来执行这一个就是我刚提到的speculate on load这种情况就是前面是store后面是load如果你Store寫到Memory Location A然後你Load呢你是到Memory Location A去Read那你這個Store加

Load它們之間就有Dependency這個就有Dependency所以你的Load就必須要等到你的Store都做完了之後或者是你可以透過Forward機制你才能夠去做這個Load不然的话你的结果会是错的你的结果会是错的所以这个就是我刚提到你就可以猜你就不管你就load先做等到你的store执行到一半你发现

说你的store的memory location跟你load的memory location是different我们就可以确定说我的这个猜是猜对了你如果发现说他们是一样的那就表示我猜错了你这个load做完的结果就没有用你要再重做你要重做你要等这个store的资料已经存进去了之后你的load再重做就是这样子所以这个就是我们的speculation所以这边提到的也是一样就compiler hardware的speculation那compiler它可以reorder instruction

就是你可以把一个指令move across a branch或者是load across a store这边指的就是指我们刚提到的你的branch你到底你可以先把一些不确定要不要执行的先把它拿过来执行你也可以把一个紧跟在store后面的load把它搬到前面去执行你不要等这个store做完再做load你也一样就把它丢出去做这一种都是OK

的反正你等做完以后它自然会有机制去判断说到底有没有dependency要不要rollback那hardware它也是一样它就是你在hardware这边你必须要buffer你的result你必须要buffer你的result是什么是buffer你的result就是我们刚刚提到我们刚刚提到说你load可以先执行但是你到你的memory location读出来的这个值你先不要write到

register所以这个就是buffer result把你读出来的或者是你算出来的就是ALU算出来的或者是读出来的那些值全部都buffer起来全部都先存起来存起来直到它能够确定它是对的那你再把它complete它最后的结果所以这边都是观念这边我们不跟同学讲说他如何realize这边都是观念同学要了解这个观念就可以

如果说他已经知道了结果说他是错的他不可以这么早就执行所以这个时候怎么办呢你就把纯刚刚执行结果的这个buffer你把它flush掉你就必须要把它flush掉那flush掉当然你就要重新再initiate这个instruction的execution所以这个是我们这样子的一个观念所以这边我们这边提到的这个speculation还有这个exception这个是比较复杂的就是你要猜然后又碰到这个exception

它里面就有提到static dynamic它跟exception的关系这一部分我想同学有兴趣可以先参考一下这个课本我们把它挑过去，我们把重点放在后面的static multiple issue跟dynamic multiple issue这两个单元前面有提到static multiple issue packet，它的在一个group里面的instruction，它代表什么意思呢，在一个group里面的instruction，它代表的就是说，它可以在一个single cycle里面，可以同时被丢出去，丢到popline里面去。假设它是一个group是for instruction，它就是一个for way

的一个instruction，你一次就四个指令，就出口当然你可不可以丢它，有没有hazard，这边你必须要先确定说它是OK的，你不会说这样丢出去以后，它是没有办法执行这个，你必须要确定有时候，在以前刚开始有这样子的一个观念的设计的时候，有时候我们会把这样子的一个东西叫做叫Vv l i w，它是什么缩写呢，very long instruction word，它是一个very long instruction word。为什么

叫very long instruction word呢，我们知道说，在我们这一个教科书里面的example，它是32 bit，它是32 bit那实际上MIPS他们arm MIPS他们都有64 bit，所以它是32 bit所以我们说它的一个instruction一个instruction word就是32 bit就是这样子。如果说在我们的这个一个enhanced的一个version，它虽然是32 bit但是我们一次可以是double issue double issue就是你把两个指令

一次就丢出去。所以这个时候你看到的是什么呢，它是64 bit。你可以把它看成它好像是一个很长的一个指令，它是64bit实际上它是两个32bit的instruction构成一个packet，所以你如果把它看成它就是一个instruction word所以它就好长好长。如果是四个instruction就是128所以这个就是very long instruction word。所以有人把它称作这样子的一个名词。它的原因就是在这个地方并不是说它真的是从32 bit CPU变成64

变128并不是这个意思，所以我们这边就提到说你compiler必须要remove所有的hazard。你有可能会reorder instruction在你的issue packet里面，因为在一个 packet里面你是同一个class cycle要把它丢出去，所以它们之间不能有data dependency那你 packet之间可能可以有这个dependency。如果说你没有办法一次丢，那么多个instruction出去的话，你就必须要塞那个bubble就是塞no operation所以你有可能是instruction1、no operation它是配对的instruction2、instruction3它是配一对的instruction4、

no operation要配一对，所以它可能是类似像这样子的一个情况，所以我们这边有一个例子，这边课本提到的一个例子就是一个to issue的一个packet，那它为什么能够一次丢两个指令呢所以它一定是它的 pipeline 的这个 datapath它一定有做过不一样的这个 enhance 所以，它是一个是专门执行它一条path，是专门执行 LU还有

branch 的instruction另外一个，它是专门执行load跟store的instruction一个是执行load跟store，所以同学可以想像它的packing，它可以有两个指令，一個是要做 LU operation的或者是 branch 的，另外一个就是要做load跟store，所以它这两个指令可以同时执行既然同时执行的话，它当然就是怎么样呢必须要有两个data这个datapath必须要有两条路，一条

是给这个instruction走的另外一条路是给这个instruction走的所以就是这样子，所以我们在这边看到的，我们假设说它的被reordering完之后，它的instruction是长这个样子，所以我们就是第一个cycle就把这个丢进去，这个也丢进去，第二个class cycle就丢这两个指令，第三个class cycle就丢这两个指令，所以我们看到的，就不是只有一个，我们会有看到两个row，两个row这是同一个cycle丢了两个row.