undefined
我們再往下看之前我們先把上一次下課之前的這個除法很快的再go through讓大家再有一點這個記憶。我們再來看第一個版本的這個division的hardware。我們上一次有提到就是說我們根據我們以前的這個除法的這個方法。我们就是把這個倍除數還有這個除數然後是由左往右開始去做比較比如說這邊這個除數呢它是4個bit那我們

當然就會一次先check一下說前面這4個bit那check的話電腦它就是先做減那減完之後餘數如果是正的我們這邊sum就會填這個1那如果是負的話呢我們就必須要把剛剛減的再把它加回來還原成1001那在這個例子裡面呢因為它的餘數是正的所以它就餘一個1那餘一個1之後我們接著再往右看下一個bit所以就是這個是第一個

看的bit這個是下一個看的bit所以就把這個0把它移下來所以這邊就變10那10的話在電腦裡面我們就是把這個10減掉1000那減完以後我們知道10減掉1000它是負的所以是負的話我們這邊就填0我們就再把這個負的這個餘數再加上1000我們就會還原成這個10還原成10之後我們再看下一個bit 101同樣的一個步驟這個一減餘數又是負的所以這邊填0然後再把這個1000加回來還原成101最後再把這個bit 0再把它放進。來就變成10.

1然後減掉1000我們就會得到的是一個正的一個餘數這正的話呢我們在這個quotient這邊呢我們就必須要填一個1就填一個1那填一個1呢這個就是最後的reminder然後這個是最後的quotient這個就是我們知道說我們以前在做除法的時候我們就是用這樣子的一個方式來算那在這裡面同學可以看到的就是說

我們在這裡面一個是被除數同學可以發現說這個被除數它是怎麼樣呢它是從最左邊的bit開始被使用來跟這個除數來做一個比較使用過的就是使用過的像這些100這三個已經被用過的它自然就會不見了它就會就是下一個iteration的時候它這邊就不會再考慮它就是考慮餘數再加上右邊剩下的這個部分所以它就是用這樣子

的一個方式sequentially把這個quotient的bit產生出來所以這個是我們這邊看到的這個電腦處法它的一個方式根據我們剛剛的一個觀念我們來看一個division的一個hardware這個division的hardware我们可以看到就是说我们刚刚有两个一个是dividend一个是被除数一个是divisor另外一个是除数根据我们刚刚来看的话同学可以看到这个divisor其实它是一直在移动它原本是在这边做减然后下一个它移到这边来做一个减

那在这个case里面这边都是负的都是负的所以这边bit它就没有动所以基本上它就是用这样子的方式它devisor它实际上它是一直在它一直在怎么样呢它一直在往右shift它一直在往右shift所以我们的这个hardware我们的devisor一开始是摆在一个64bit的一个devisor的register摆在哪一边摆在它的左半部因为我们这

边是32、 32我们原始的divisor是摆在它的左半部记住记住就是initially的dividend我们被除数原本一开始把它摆在remember所以从这样子的一个摆置方式我们就可以大大略可以看得出来说基本上它就是用remember去减掉什么呢减掉这个divisor因为remain的裡面它原本是擺什麼呢它就是擺這個dividend它擺這個被除數擺在這個地方然後接著我們就是把這一个減掉這个divisor減掉這个divisor就是我們剛剛提到的我們在這邊提到的就是說

我們要比較它比较大還是它比较大如果它比较大的話这个一减之后我們的餘數会是正的餘數是正的我們這邊quotient就會擺一個1所以這邊就是在remember的register這個就是在remember的register那這個呢這個在哪裡呢這個就是在divisor的register所以是這個減掉這個所以我們根據這個架構來看的話這邊要64

这边也是64bit这边也是64bit所以我们就是这一个减掉这一个之后我们就是会根据它的结果来判定说这个余数是负的还是正的如果是负的话这个control test它就会把quotient填入一个如果是余数是负的它就会填一个0如果余数是正的它就会把quotient填入一个1填入一個e因為我們是

填在quotient register的LSB所以顯而易見的我們這邊是需要做一個shift left所以你第一次看完以後如果假設是填一個e就填在LSB接著我們會往左shift一個bit就會shift一個bit在check下一個bit的時候當它如果是要填0的話我們就是再填一個0或者是要再填一個e在這個LSB那邊然後再把它shift進去所以我們如果是以這個例子來看的話我們這個quotient是1001所以這個e它會第一個

被產生出來然後填在quotient register這個e是第一個填到quotient register的LSB接著我們再接下去填的是填這一個所以它填一個它就會shift left所以填兩個它就會shift left然後再shift left所以最後最早被填進去的1它就是在這個位置它就會產生一個1001這樣子的一個結果所以這個是我們搭配我們看的這個例子我們來了解說quotient register

它的一個運作的一個方式那這個Ctrl的一個Test它除了Ctrl每一個Iteration它必須要去Shift這個QuotientRegisterToLeft然後它還要Shift什麼DevicesToRight因為我們剛看到我們那個除法那個Devices它是一直在往右移它一直在往右移所以這個Devices它是要ShiftRight那這個Remain的就是说在这个例子里面这边所谓的write它指的应该就是指说我的remember减掉devices减完以后如果是负的话它必须要怎么样

它必须要再加上一个devices再把remember再还原它必须要还原所以当你每次要写remember register的时候你必须要给它write enable就是让他允许他可以把它写进来所以这样子来看的话我们就可以很清楚的了解说这一个Hardware这个除法器它的这个运作的一个方式它每一条线我们大家都知道它在做什么所以这边注意就是说一开始这个Devices它是放在Devices Register的左半，然后这个被除数Dividend就是放在这个Remember Register，所以根据我们刚

刚了解的话，我们再看这个就很简单了。我们来看这个division的这个flow，它说第一个，它就是先减掉，就是从remember registercode跟什么相减？减掉这个devisor的register，结果放在remember的register减完之后接着它就去测试一下说你如果说这个余数是大于0的话，如果是大于0的话，它就会shift quotient register to the left，那你shift這個quotient register往左shift一

個bit，那你也會在它最右邊填一個1進去，因為它remember大一點，那如果remember是小一點的話呢那它就必須要把剛剛剪過的remember再restore還原成原本的值，那怎麼還原呢，它就是再把這個devisor register再把它加回去，就是再加回去，所以它等於就是先剪一次，再加一次，就是這樣子。接着它也是一樣Shift Quoting Register往左Shift然後

接著在它的LSB那邊要填一個0進去，所以這是兩個之間的差別這個Iteration結束之前必須要記得再把Devices的RegisterShift Right就是往右Shift一個Bit接著就是看看Iteration結束了沒有還沒有結束就是一直Iterate然後結束的時候我们的quotient就会在quotient registerremember就会在remember register所以这个就是我们第一个版本的division包括它的flow跟hardware这个例子这边我们列了一个例子这个例子就是我们在这边可以看到就是说它一开始 devisor是00十

一开始這個divide它是0一十一所以我們可以看到說它一開始是擺在divisor的左半然後這邊就擺在remember接著它就是用減的所以一減這一個減這一個它就會得到這個數這個數它是負的負的所以再把這個數再把它加到這边再加回來它就会还原成这个数就把这个还原成这个就变成这个接着

它就是把这一个DeviceShift Right这边是Shift Right所以00十变0001QuartierShift Left然后LSB点0所以这边都没有动所以就是用这样子的一个方式大家回去可以trace一下这样子最后结果出来这个Quartier这边就是一个EE然後remember就是於1就是這樣子它的這個operation的flow就是像我們剛刚講的這個描述大家應該可以自己回去trace就

可以了。接著我們再來看一下我就用之前的flow然後再剪貼一下貼一下然後勉強貼一個optimizedivider。它相對應的這個flow同學可以看到就是說我們前面這一頁我們前面這一頁的這個divider的hardware它的register都是64個bit這是64 ALU也是64然後這边remember它也是64所以它這边都是64根據我們前面乘法器的設計觀念我們知道說我們應該有機會

可以把這个64怎麼樣呢可以把它再簡化成32那如何把它簡化成32呢同學可以看就是我們之前的Devices是怎麼樣呢是64 bit那64 bit我們一開始是把Devices放在左半部然後接著每一個Iteration都必須要把Devices往右shift往右shift一個bit根据我们在乘法里面的这个纪念其实我们如果不要把device往右shift一个bit

其实我们就是把什么呢我们就是把dividend shift left往左shift left by one bit它们的效果实际上是一样的根据我们乘法的optimize的这个纪念其实我们的quotient我们也可以不用了就是我們quotient基本上因為你的dividend既然是往左shift所以每一次你的LSB基本上它已經不用了你的remember register的LSB bit它都不用既然不用的話其實我們就可以來squentially來儲存什麼呢儲存quotient我們可以來儲存quotient既然可以這樣子的話所以同學可以發現這一邊

這個quotient register也不見然後我們這邊32 bit ALU ALU也變成32 bit因為它已經變成是左半部的這個什麼呢32 bit剪掉remember左半部32 bit剪掉divisor32 bit然後你往左shift的時候呢這邊就填quotient就是這樣那你最後結束的時候呢你的remember呢你的餘數就是在rememberRegister的左半部那你的quotient

呢就是在你的rememberRegister的右半部所以这个就是我们根据我们乘法得来的这个经验我们可以去shift这个rememberRegister to left就是这样子所以根据这样子来看我们就知道说在这里面它的flow大概需要变得就是這邊說remember如果是大於0的話我們就是必須就是要把這個remember register shift to left by one bit而且在這個remember register LSB要insert 1'quotion'quotion的這個bit相對應是1如果你的remember是0的話就是說你除了先把remember先restore回來之後接著

再把remember register shift left by 1 bit然後加一個領再填一個領填到它的LSB就是把這邊從領這邊填進來那這樣子的話呢它就不需要這邊原本它還有一個shift divisor register to right這邊就不需要所以它少掉了一個這個然後我們這邊就'quotion'就填到這個部分來所以这个就是我们optimize过后的division它的一个hardware structure跟它的flow到这边同学有没有问题所以我们为什么要设计这样子的optimize的一个divider因为在这边他有提到就是说他提到说我们当然不希望说我们在设计我们的

就是说我们的这个computer的hardware的时候就是multiplier是一份然后divider是一份同学可以发现说这样子的一个架构跟我们前面的mult iplier它的架构实际上它是可以共用的它可以共用就是说当它要做乘法的时候它可以用同样的一个架构用不同的flow就可以完成乘法你要做除法的时候你只是用不同的

一个flow它一样可以完成出法所以这边我们可以看到就是说它的remember register它可以shift right它也可以shift left我们做出法的时候它是要shift left你如果说需要另外的运算需要往右shift的话这个remember register它一样是可以做shift right的一个动作所以这两边的shift都可以这样子的一个架构就又精简然后又省掉这

个hardware的一个cost接着我们要来跟同学提到的就是我们根据刚刚的这个flow我们是不是有可能可以improve我们前面有提到说比如说我们在做这个做乘法的时候我们有提过一个好像是可以加速乘法的一个boost algorithm当然不见得说你所有的pattern你两个operand去相乘它都可以得到一个speed up

但是假设它的连续的e比较多的话我们就知道说它可以省掉一些加法它可以透过减法省掉一些加法我们在这里面我们前面的方法里面有没有可能也可以做这样子的一个节省省略掉一些加法或者是減法的operation所以我們就是要來探討一下我們前面的這個演算法它就是叫Restoring Algorithm什麼是叫Restoring Algorithm呢我們同學回憶前面的flow就是當你的reminder是負數的時候

你必須要把它把這個device把它加回去讓reminder還原還原成正數那這種方式它就是叫叫Restoring Algorithm那我们来看说这一个加回去的这个动作是不是一定都需要那我们当然就是要先来推导一下说有加跟没有加它到底有什么差别首先我们来看这边之前就是说我们假设这个Iteration直

接做了一个R-D的一个动作如果说这个余数是大于0呢quotient它就会设为1设为1然后就结束这个iteration就结束当然它也会做shift的动作如果说quotient是填0的话呢实际上我们是把D再加回去所以这个时候remember它是等于多少它是等于2R对不对就是说原本是R-D那我们这边就分了两条路一条呢这个是quotient填1一条是quotient填0那quotient填1的时候呢这个D是不需要加回去的所以当你shift当你shift left的时候呢它是怎么样呢

2的R-D就是我们在下一个iteration里面在remember里面看到的数是不是这个数所以我们说这个是这个是第I个iteration这个是第I加1个iteration那你就是说你不用把D加回去然后你往左shift往左shift就等于乘以2所以它是等于两倍的R-D如果说它quotient是填0的话我们是把d加回去d

加回去把它还原成r还原成r之后再shift left所以这个时候下一个iteration它看到的是多少是2r对不对这是下一个iteration就iteration i跟iteration i加1它看到的这个remember里面的值是不一样的就是quotient填1跟quotient填0的时候下一个iteration在remember里面看到的值是不一样不管是第一个case或者是第二个case他的要判断他要判断说在iteration i你的quotient要填0还是要填1他还是一样还要再做一个减的动作他还要再做什么呢

它还要再做一个减的动作对不对它要再做一个减的动作这个减D减完之后我们这个时候就可以再来判断remember它到底是大于0还是小于0大于0这个iteration i加1就要填1如果是小于0的话那这个quotient它就要填0所以我们在iter ation i加1要判断quotient 填一填零的時候呢兩個case

兩種不同的case它的值一個是這個值另外一個值呢它是這個值它是這樣子所以我們假設我們假設說在第一個iteration我們不做restore就是我們不做restore不做restore的話呢這個case我們就不用考慮了因為这个case它本来就不用做restore所以这个case的话它一定是对的我们现在来看这个case如果是这个case的话我们不做restore我们在第一个iteration我们应该怎么办呢就是2r-2d假设是第二个case第二个case它的remain原本的数是2r-2d

我們現在要產生一個2r-d來判斷quotient要填1還是填0所以這個數要再做什麼樣的處理才會跟這個值是一樣的加d 對不對就是再加一個d就是再加一個d2r-2d再加一個d它的數就會跟這個數是一樣所以从这边我们就可以得到一个初步的结论这个结论是什么呢就

是说实际上我们可以改良这个Restoring的Algorithm怎么改良呢就是我们不要做Restore不管它的Quotient填0还是填1我们都就是Quotient填0我们也不需要做RestoreQuotient填1本来就不需要RestoreQuotient填1的时候它的Flow都是一模一样的，但是quotient填0的時候我們在下一個iteration在這個iteration的時候我

們要知道說前一個iteration它的quotient如果是填0我們在這個iteration我們的減就要變成加減低要變成加低這減低變成加低。如果前一个iteration它的quotient是填1的话前一个iteration它的quotient是填1这个 iteration它还是用减的就是这样子我们就可以保证说我们在下一个iteration当我们要判断就是说下一个iteration的quotient要填1填0的时候

它的remember的值就是我们要的那个数所以我们这样子我们就可以来看一下我们的这个flow就不一样了这个flow它当然有分第一个iteration还有不是第一个iteration因为当你是第一个iteration的时候你没有前一個iteration的基準來做判断所以你第一個iteration一定是做減第一個iteration一定是做減所以我們第一個iteration這边一

定是做減所以它的flow就是從這邊過來減減完之後它就判斷remember是大於等於0如果是大於等於0的話我們這個remember它就shift left而且它的lsb就填一個1進來如果說remember是小於0的話同學這邊可以看到它如果小_than0它這邊也不做restore它這邊小_than0它就是shift remember to left一樣但是它是填一個0進來所以差別就是這邊填一個1這邊填一個0這邊填一個0之後接著就看iteration結束了沒有沒有的話就回到這裡這邊就回到這裡不是回到

第一个iteration它就回到等於就是回到这一边其实你也可以到这边来因为这边有个yes or no所以你回到这边来你就判断说它的LSB到底是remember的LSB到底是1还是0为什么要判断remember的LSB是1还是0就是我们刚提到的如果remember的LSB是1的话表示是这个case表示是这个case这个case我们就必须要怎么

样呢就必须要做减的动作就是跟之前的flow是完全一样所以我们这边它就必须要做减如果等於1它就必须要做减如果说remember的lsb它是0的话就是要加就是这个case因为它之前它没有restore所以这个时候其实也就是说这个时候remember它的值是多少它这边的值是2r-2d这个时候它的值是2r-2d它的值是2r-2d如果说是这个case你必须要把它变成2r-d所以你就是加一个d如果是

這個case當然就是2i-2d再減一個d就是這樣子所以這個就是non-restoring的除法它的演算法這樣子可以省掉一個restore的程序這邊同學有沒有問題這個shift left

Shift leftShift left是SL还是SHL这个要查一下第二章的instruction

你說哪一個步驟你說clock cycle還是clock cycle要幾個clock cycle基本上基本上你说要花几个clock cycle应该是看你的iteration这一边比如说首先第一个就是说我们在这边一定要做一个加或减假设加减就是一个clock cycle它就是1这边它要做一个shiftshift的话它也是需要一个cycle所以它iteration的话它在一个iteration里面它可能是需要两个clock cycle

以前的话呢以前我看一下以前应该是这边因为前面那个多需要一个operation这边先做一个减的动作然后减了一个动作之后这边是需要restore 需要做一个加然后这边再做一个shift所以这边等于是一个 两个你做加 做shift你如果說加完之後如果說你的加法加完之後你一定要做shift你的確是可以在一個clock cycle之內做完可是問題是你這邊的hardware你的加完之後你不見得一定都是做shift你有時候是加完以後就不需要做shift就是說

這個shift就是說你shift你如果是跟加法綁在一起在同一個cycle你是用wiring的方式去完成的就是用這個拉線就是把線往左對一個bit去做一個connection這樣子自動就是一個shifter這個是不需要額外再多一個cycle沒有錯但是你傳統的你的shifter如果說它就是就是一個register的一個shifter那是需要一個cycle的那這一邊的話呢

這邊因為你的這個Shifter你不是說綁死什麼綁死就是說你在每次做加法加完之後它一定是做Shifter它有時候加完它並不需要做Shifter有時候加完它需要做Shifter所以你這邊的Shifter你沒有辦法用Wiring的方式去完成所以你這邊一定是一個Shifter真正的一個Hardware的一個Shifter而不是用Connection的一個Shifter我們在第四章的话我们会有一个图让同学看到这位同学提到的Shift说你需不需要一个 Cut CycleShift你如果说它是D4用这种Hardwire的方式它不需要一个Cycle它可以跟这个绑在一起但是这边它不是用Hardwire的方式做的同学这个问题很好

这边还有没有问题如果没有问题的话我们就继续再往下看这边我们就跳过了因为这边这个内容并没有很多后面的这个MIPS division它就是介绍的这个MIPS它的就是high跟low它的兩個這個我們在Multiply的時候就看過然後這邊有一個除法就是它的instruction就是DIV這個同學參考一下課本所以我們關於這個加減然後乘除它的演算法一些簡單的演算法還有它的hardware structure我們大概就介紹到這裡

我們在最後一個單元我們就是介紹這個14 point我們期中考我們就是我們下禮拜四的期中考我們就是考到這個第三章結束我們今天應該會把整個第三章就是上完然後再上第四章我們這個單元我們是要跟同學介紹這個14 point因為我們知道如果做一些科學的運算的話它都是就是說都

是用浮點運算浮點運算基本上就是在看看你的表示的範圍有多大你的精準你的Precision你的精準度有多少你的精準度越多的話當然我們算出來的這個值就越精確所以我們這边看到的一個常見的幾個這種14-point的notation比如說-2. 34乘以10的56次方然后正的0. 002乘以10的-4次方然后还有正的987.

02乘以10的9次方这三个数有什么不一样呢我们这边已经有highlight出来说这三个数的差异一个是normalize这个是normalize就是说我们的这个significant它就是这边整数只有一位而且它是非0它不是0.多少它是一个非0的一个数这个它就不是Normalize因为它这边这个整数它是0这987当然也

不是Normalize因为它的整数的部分它不是只有在个位数它10跟百这边987都有所以这两个数都不是Normalize再考虑到这个14 point我们大概因为它的表示的方式就是说你可以有很多种的这种方式來表示它所以我們在電腦裡面總是需要一個Standard所以我們等一下後面會看到會有一個ITRI.

254的Standard它就是在定義14Point大家都需要用什麼樣的格式來表示如果是Binary的話這邊就是正負這個是Nominize過後的14Point就1點多少然後再乘以2的幾次方所以這邊Base是2在C裡面C++我們知道說我們就是可以用float跟double我相信同學現在應該很少人就是在寫程式的時候float跟double還有integer是用得很好的什麼叫用得很好呢我就只要小數點我就用float我如果擔心它overflow就爆掉我就用double

我double就不会错了再多我也没办法反正它最大就是double所以我干脆每个都宣告用double好了这样子是最准的就保证不会爆掉当然如果你所有的variable全部都是用double大概不会有任何的问题可是你光是要一个for什么i等于多少你的i也是用double吗当然不会是用double你一定里面至少一定会有integer

有一些你就用double有一些有的人会确定说我这个数没那么大我就用float可以省一点你就会发现程式里面有float有double有integer然后这个i等于这个double你可能宣告一个dd然后float宣告ff然后你就什么i等于ff或者是ff等于i然后在那边assign去就用得很快乐实际上这种都是错误的用法因为

在我们的programming language里面data conversiondata type conversion是一个很重要的一个issue如果说你们的程式里面你们的这种data type conversion没做好的话你们的程式就很容易就错掉这种错也是常常会让你不知道是错在什么地方你觉得说奇怪我trace了我的equationtrace n变了equation没有错大家都錯在什麼地方呢大家全部都是錯在這種Data type conversion所以同學要記得你要先讀懂這個language裡面的spec他要講說他們的Data type conversion的rule到底是怎麼樣

你要把那個搞清楚你不要說隨便算一算之後然後再去做這個Data type conversion所以這個我相信同學應該大部分的應該幾乎都沒有注意到這種事情等到以后写比较大的程式比较复杂的程式的时候就会有一大堆奇奇怪怪的bug然后就会花很多时间去学到这个教训接着我们再来看我们刚刚提到的HTTPoS standard 754它是在1985年这边提出来的其实就是我们刚刚提到的就是说你这个14 point

有自己不同的用法format都不一樣這個就會有一個很大的confuse你唯一的辦法就是制定這個standard這個standard它提供了兩種format一個是single precision一个是double precision就是一个是32 bit另外一个是64 bit它的差別就只有在bit的number是不一樣其他的format都是一樣所以我们就要这个学习还蛮神奇的这个PowerPoint好像还没有当过以前是每一次上课都要当一次不知道

是发生什么事情我们来看一下这个Single Precision我们现在看这个Format我们说14 Point的Format就是需要三个一个是Sine一个是Exponent一个是fraction就是这三个部分这三个部分我们都知道这个sin是sinbit这是一个负1负1的s次方你如果是0的话它就变正了你如果是1的话它就变负了这个fraction它是1加fraction这个是我们的significant这是我们的significant我们等一下再来看说那为什么我们会

significant為什麼會變成一個e加fraction這邊是exponentexponent同學可能會以為說這是2的十次方所以這個10就是填在exponent的地方實際上不是這個樣子我們是把這個10再減掉一個bias再減掉一個bias我們等一下會來看說為什麼要減掉一個bias就是说这个exponent应该不是减掉bias应该是加

上一个bias所以10加一个bias是存在这个地方存在这个exponent所以真正的数因为我们存在电脑里面的exponent是加过一个bias的一个值比如说这个bias是127就是一个10加127它就变137这个exponent就变137你要把它还原成一个真正的数的时候你就必須要把exponent減掉bias就是137

減掉127就會等於10這邊就等於2的10次方所以這個是真正的值你的true value x就是在這個地方它真正的值是在這裡所以就1加fraction乘以2的exponent減bias次方就這樣single precision它的exponent是8個bit然后fraction是23个bit所以23加8加1总共是32那你如果是double的话exponent是11个bitfraction是52个bit所以这边加起来是64所以我们来看一下为什么这边是1加fraction首先我们这边的说明就是说因为我们的

這一個754這個standard它儲存的14 point我們需要是一個normalizenormalize過後的一個significant既然是normalize過後的significant它的值是多少呢它的值就是大於等於1. 0小於2. 0所以它就是1. XXX那個XXX可以是0到111就是這樣子所以它的值就是1點多少那这边就来了就是说那你这边为什么不存1点

多少我可以反问说那既然每个数都是1点多少我那个1为什么要存呢对不对我们可以省掉一个bit因为我们可以少存一个bit我们就多一个bit可以使用我们就多一个bit可以使用我们的这边fraction的精确度又多了一个bit它的精确度又多一个bit所以也就是说我們的significant再減掉1就是0. 11所以那個1. 11就是存在fraction的地方我們也不是存0.

11因為0.這個東西你可以把它看作它是一個implicit它是一個沒有明確的表示但是我們實際上已經把小數點點在這個地方了它是implicit它不是explicit它這種表示方法是implicit的一個方式所以我們就是說如果我們剛剛提到的如果是1. 11的話在這個fraction裡面它就是1 1就是兩個1它真正轉換出來它就會轉換成1. 11就會轉換成1.

11就是這樣子所以這個是我們第一個說fraction的部分那第二個呢第二個我們就說我們的這個exponent我們exponent我們為什麼要減掉這個bias呢為什麼要加上bias就是當你要存到電腦裡面去的時候為什麼要加上bias这个最主要的目的就是说我们的exponent我们的floating point number在做运算的时候

我们常常需要做一个动作什么动作呢就是比较它的两个数两个伏点数它的指数的大小对不对比如说我们如果要做A加Bfloating point number A加B我们不可能就是直接把a加b兩個數直接相加因為它的這個2的幾次方這個指數的部分它可能不一樣一個是2的二次方一個2的四次方所

以你必須要把這個指數的部分全部都先統一都先變成2的二次方或者先都變成2的四次方你那個significant才能夠相加所以我們在做比較的時候就是說在14 point的這個operation常常需要比較它的exponent的部分exponent的部分你如果是做比較我們希望說它是一個unsigned number它的comparison它是一個比較

簡單的方法如果它是一個unsigned number比較的話基本上你就是一個bit一個bit去compare它就是一個compare你根本不需要去做一個加減法然後來判斷說它的就是加完的结果到底是正还是负数就是用这种方法它直接可以用一个就是用一个ensign的方式所以因为这样子的关系它才需要把exponent加上127，它加127之后我们可以来看一个例子，它加127之后它的exponent跟

这个是reserve，这两个保留不用，我们后面会看说为什么它的exponent 0 0 0跟1 1全部都是 0，全体都是1 时，它把它保留起来，因为14点它必须还要表示其他的一些比较奇怪的case，比如说如果有的数，它不是normalize它是denormalizedenormalize就是说它不是它的整数的那个bit，它不是1而是 0，如果说是这种didnominze没有被nominze过的

数，你可不可以表示它，可以表示另外一种就是说14点不管它single还是double，它可以表示的数已经非常非常大或非常非常小可是总是有更大的数更小的数就是正无穷大跟负无穷大，那你的faulting point可不可以表示正負穷跟負負穷所以它就是保留，就是保留這個000跟111去來做一些特殊情況的一些判斷就是說在某一些情況它是正負穷大，在某一些情況它是denormalize所以我們把這兩個case把它保留起来保留起来以後，所以它的case

这个exponent加过bias之后的exponent它有意义的值呢就是从1开始1 2 3 4 5到多少呢到11 111110就是到最大的是10这是最大然后最小呢就是0101它exponent有效的值呢就是这几个所以我们来看就是说看一个例子比如说这边是三个bit这边三个bit那三个bit我们知道说这个tooth complement我们可以表示什么呢0 1 2 3

负1 负2 负3 负4它可以表示这一个那如果说我们加上11的话呢加1这个数呢就变这个这个数就变这一个然后这个数就变这一个那这个数呢就是会变010所以它的数基本上就是变成这样子所以我们真正在exponent交过bias的数它的最小的值就是001这个001相对应的就是-2然后010一直到最大110110对应的就是-3这是我们以三个bit来看如果是八个bit

就是我们这边最大的数就是到127然后这边最小的数就是到-128加127之后这边就变2就是说这边就变255这边变0这边变1所以我们真正有意义的exponent的数就是在这个范围1到254这是1到254所以同学可以看到这1到254整个全部都是一个signensign它follow一个sequence

这个sequence就是什么呢这个的确是数目越小它的exponent就越小这个越大它的exponent就越大所以你看原本的exponent是127一直到-126这是非常小的这是非常大的然后在最后bias过后的数它是一个ensign的一个number它就254到1所以这个是bias127的一个目的至于这两个保留我们刚刚有提到它保留我们等一下后面会看到所以我们如果说一个数的exponent它是1就是说在我们的在我们的I3.

754它的format它的exponent的那个field它是1的话真正的exponent的数是多少1-127就是-126就是这样子如果说它的fraction是0的话它的significant就是1. 0所以这个数它真正的数是多少就是1. 0乘以2的-126这个数其实就是我们可以表示最小的一个数就是2的-126次方然后significant它的fraction都是0所以是1.

0乘以2的-126这相对于实境位是1. 2乘以10的-38次方大概是一个约略这样子的一个值我们先休息一下我们再看single precision的range我们刚刚看到是它的这个最小就是指数最小的这个值接着我们再来看这个指数最大的值我们知道说最大是11. 11110这个是2,542,254减掉127就是正的127正的127它的fraction的部分是全部都是1所以它的这个significant就是1.

1就一堆1这个数significant它是趋近于22. 0所以我们说这个exponent最大的数它是2. 0再正负2. 0再乘以2的127次方相当于正负3. 4乘以10的38次方所以它是从10的38次方到10的负38次方这个数其实已经相当大如果是double precision的话这个计算的过程同学大家自己看一下它是从10的-308次方一直到10的正308次方这个数也是已经很大它实际上我们的double precision的一个range就是已经到10的308次方这样子的一个数

所以我們在這边看到的呢我們就說它的這个精准度呢就是说它的精准度大概有多少那我們當然就是用這個就是说它的2的负23次方這边来估那你要知道说2的负23次方大概相对於我們的這个实境位大概是小數點下脊位的話我們就把它取這个log那取log大概是大概是略等於大概approximately23乘以0.

3差不多约略等於66個decimal所以它大概是实境位小數點下10的6就是10的這個小數點後面的大概6個digit那如果是double的话呢2的這個-12次方它大概是小數點下16個16個decimal的digit所以這是我們的precision这里面我们来看一个简单的例子这个例子就是负的0. 75负0. 75因为是负的所以负1这个x大的就是1大的这不是小的这个0.

75我们说它是，就是说0. 75实际上它是等於0. 11它是等於它是等於0點就是二进位二进位来看的话是0. 110. 11因为我们要把它做一个normalize所以必须要乘以1. 10. 11变成1. 1乘以2的负1次方所以这个是我们把0. 75变成这一个数这个数我们就知道说这个significant我们抓小數點的这个值我们就知道它是多少

一 它是一 零零零零最左边这个是一 然后零零零因为它要兜这个significant它就是一点一零零零零 justo这样子兜的它兜真正的数就是一点一零零零零所以就是这个一就填在这个地方exponent就是负一加一二七就等於一二六我们就看single就好我们不要看double所以它的 IEEE754的一个single precision的format-0. 75它的数就是1011 11110就是这样，然后后面这边是1，后面全部接0，全部接0，这是我们single那double的话，就同学自己看另外的一个算法，

所以另外一种例子，这边另外一个例子是说，如果我给你一个754，它说是一个single precision，如何把它转换成真正的一个数，那真正数是多少其实这个也是你就要了解format就没有问题首先就把这个大S取出来sin，它是一个负的接着我们接着再把exponent，我们先看这个fraction好了，fraction就是蓝色的部分，它是01 0110全部都是0，那fraction 01 01 0基本上它就是什么呢，它就是1.

011. 01然后再乘以2的几次方呢，2的几次方，它是exponent，就是10101它是等于129那1297其实它是加过127得到129，所以它是要129减掉127，所以这是2的二次方，然后这个是1. 01实际上就是1. 25，那乘以2的二次方然后这个是1. 01实际上就是1. 25那乘以2的二次方所以它是等于负的是乘以4所以得出来就是一个负5.

0，负5。 0就是这个14 point那在这里面呢我们再来看一下这个最后的这个754 encoding的这个table那这个table呢其实就是我们要看的就是右边最后边这个column它描述的这个754的standard它所能够表示它能够表示的这个资讯全部都在这里第一个它可以表示0第二个它可以表示denormalized number然后第三个就是正常的正负的floating point number这正常的就表示它是normalized的一个floating point number

还有它也可以表示正负无穷大正负的infinity然后这一个就是未定的反正它是什么数不重要反正它这边就是总共就是有比较明确的值就是1 2 3这三个值这个正负无穷大其实它没有一个value的意义但是它有算术上面的意义算术上面的意义就是说比如说你某一个数除以无穷大它

要等于什么数呢我们大概说它会趋近于0之类的这样子的一个意义那这个呢就是基本上你可以把它看成就是说这不是它所能够表示的东西那我们来看说这个0呢single跟double precision都一样必须要你的exponent是0你的fraction也是0如果说你的这个754的一个numberexponent跟fraction都是0就表示

说这个14 point它是0那第二个呢就是说exponent如果是0fraction如果是0的话呢就表示它是一个denominize它是一个denominize它也是一个数但是它不是normalize的这个number也就是说它不会是1. 1001之类的这种数，它一定是什么呢。它一定是0点多少，那你只要是0点多少这种就是所谓的denominize。所以这个数也是可以表示的，所以我们等一下回头看这个exponent 0搭配non-zero的fraction，不管是single double都一样。

至于你的exponent，如果是1到254这边也是任何一个数，这就是我们正常Normal score的14点。如果是exponent是255搭配fraction是0，255搭配0，这个数其实就是infinity，它就是infinity或者是double是exponent20. 47搭配fraction是0，那这个就是代表说这个数是infinity那，如果是255搭配non-zero的fraction，那这个就不在它表示的这个范围之内。所以我们可以从这边，我们就可以看到，我们说这个最小的，我们说最小的一个positive single precisionNormalized number是等于多少

我们不是要问说它的数字，它的值是多少我们要问的是说它的IEEE format怎么写你只要同学要试着回答一下说用IEEE的format，同学也不要去说001你去那边算几个0，你只要说后面全部都0或者是前面全部都0什么之类的。同学觉得这个最小的positive的single precisionnormalized number，它是等于多少它的fraction是多少它的fraction是多

少最小所以fraction应该要多少全部都0你多一个1不行你多一个1就比那个0还要大了你如果最后一个0101那它就比010还要大所以必须要全部都是0fraction的部分全部都是0exponent的部分exponent當然就是11-127其實就是2的-126次方2的-126次方乘以1. 01. 0乘以2的-126次方這個就是我們說normalize最小的positivesingle precision nominous number如果说是smallestpositive single precision.

nominous number它的在这边它的exponent是固定的我没记错好像是-126次方所以是0 0 0 0 0 0 0然后最后bit是1这个是最小的这个就是最小所以这个就是我们说如果它是一个denominize的一个number然后这边提到说这个无穷大你必须要follow这个mathematical的convention比如说某一个数加正无穷大它就是正无穷大某一个数除以无穷大它就是0大概就是这样子

所以我们可以来看一下就是说这个14点的这个edition它的表示式我们大概知道以后我们就来看它是怎么做加法这个同学会说这个很简单没有错 这个很简单我们只跟同学提醒几个key point第一个key point就是说我们以这个来看这边是一个9. 99乘以10的一次方加1. 61乘以10的负一次方我们

知道说这样子的一个算法我们没办法直接相加我们要把这个10的指数要把它统一为1或者是统一为-1我们在这里面它就是说第一步要align decimal point它是shift number with smaller exponent它就是说你必须要把这个比较小的数指数比较小的那个数去做一个shift的动作你要做shift的动作其实就是要把这个比较小的

数把它align成比较大的数所以你就把-1次方变成1次方-1次方变1次方你的significant就是要怎么样你的指数已经乘以10的2次方所以你的significant就要除以10的2次方所以你这边1. 61就会变成0. 016就会变成0. 16你这样align完之后它接着就可以相加了相加就直接叫significant相加加完之后接着就必须要做normalize因为比如说你这边9. 999加0. 016它会变成10.

01510. 015这个就不是这个就是一个denormalize number所以你要变成1。 0015再乘以10的二次方做完之后你就做roundingrounding就是看看说你的这个精确度到这个小数点下几位比如说这边如果说到下三位所以你这个5呢你必须要把它round掉那你round就要看你的方法比如说45入或者是进位或者是舍去那比如说这边是45入它就是把这个round了之后这边进位就变1.

002再乘以10的二次方那你rounding完之后呢你还是一样要check一下说它是不是一个normalize的一个number所以这边要check的有两个地方第一个呢你的significant加完之后你这边有可能会变成是一个denormalize number所以你就必须要把它normalize那你normalize完之后呢做一个roundingrounding完它有可能会进位它可能就是一直进位一直进位假设

假设这边都是9这边都是9所以你一定会它要加一直加一直加一直加就一直往前加所以你rounding完之后它又可能变成是一个是一个什么是一个denominize的number所以你必须要再做一个check它是不是要再做nominization就是这样子这边它的flow就是这样子我们在这边问同学一个问题就是说为什

么我们要shiftexponent比较小的而不是要shiftexponent比较大的为什么我们是要以exponent比较大的这个为主要align它而不是要align它同学要不要猜猜看为什么要align这个而不是这个同学有什么想法吗我们用另外一个方向来看我们如果是alignalign這一個我們假設是align這一個好了那我們假設一個case

我们假设一个case10的40次方那你把它align成-1那这个数会变什么这个数会变什么可能已经超出你的范围了超出你的significant那边可以表示的一个range对不对反过来讲假设是40次方你这边是-1那你这边-1你把它变成四次方这个表示什么呢这个会变成0. 001很多0然后后面

出现了一个161那你会说这个也是我没有办法表示的那没有办法表示你就run得掉对不对就是run得掉而已因为我们在最后加法最后我们也是没有办法去表示那么多0010. 00、10、161也是没有办法表示我们一样是要做rounding对不对，所以从这个case，我们就可以看得出来，说这里就是为什么我们要align这一个，以它为主去align，而不是要align这个比较小的，这一个，所以因为我们在align的过程里面，它后续的动作可以顺利地进行，

它超过了这个precision，它本身就是可以把它run掉，这边有个case，它是这个二进位，它这个是二进位的，就是我们说是1. 0乘以2的-1，然后加上-1. 11乘以2的-2次方，这实际上是0. 5加上-0. 4375，所以它得出来的结果是0. 0625，它的做法就是根据我们刚的描述，我们第一个要align这个-1，所以这个2的-2次方变成2的-1次方，所以1. 11会变成0.

111，结果相加之后变成，这个是正的， 这个是负的，所以它会变成0. 00、10、001乘以2的-1次方，这是一个denominance number，所以你要把它变成1. 000乘以2的-4次方，所以这个就没有什么rounding的问题，所以它实际上就是一个0。 0625所以这个是一个乘法加法14 point的一个加法的动作14 point的Adder hardware它跟我们的integer的Adder相比的话它相对的是比较复杂就是说

你如果說要讓它在一個clock cycle一個clock cycle之內要把它做完你的clock cycle可能要很長所以它通常大概就會需要比較多的clock cycle才能夠完成所以我們來看一下這個14-point ADER的這個Hardware這個Hardware乍看之下它的线连来连去好像还蛮复杂的我们以这个例子然后由上往下来trace一下说在这个加法的过程里面在这个hardware它的flow它的data到底是怎么走的我们只要trace一遍我们就可以

把所有的线全部都画过一遍全部的线都trace过一遍我们就知道说這個架構到底是做什麼用首先我們先來看右邊它這邊分成四個StepStep 1它就是在做ExponentExponent的AlignAlignment它要去AlignExponent要Align之前它當然要先做Compare所以它這邊有個CompareCompare完之後它就知道說以誰為基底然後誰要做Shift

align完之后第二步就是做加所以加的部分大概就是这个LUbigLU第三个step它就是做nominization它就怕你significant加完之后它变成denominize number所以它必须要做一个nominization这边就是做nominization用的最后再做roundinground完我们刚刚说它有可能又变成是一个denominize的一个number所以它rounding完之后它

要再回到normalize的这个stage再回到这边然后再做一个normalize大概就是这个样子所以这是它的三个步骤，所以我们来看这个例子是exponent是2，exponent是4，然后fraction是1。 10，然后，这边fraction是1。 01首先我们要知道说以谁为基底就是要比大小对不对，所以同学可以看到这边就比大小，small LU比看看谁比较大所以你这边一算完以后这个值出来，我们就知道说谁大谁小，比如说是2-4我们假设是2-4我们假设是左边减右边，

我们假设是左边减二边，就是二减四，所以你二减四的话，它当然就是负二负二的话就是表示这个比较大它就表示这个比较大，而且它是差负二负二它知道说它是差二所以我们可以来看这边进来的是什么呢，这边还有这个是2这个是4然后这边是2那这边这个结果它会进到control control，就知

道说负2是后面比较大，所以你要让后面的进来，我们是以后面的为基底，所以是base是2的四次方就2的四次方就2的四次方就进来了，那它这边因为是负的所以它知道说这个fraction它就不需要做shift的一个动作，因为这个fraction这个数左边这个数它是exponent，从2要变成4所以它的fraction它必须要乘以2的负2次方，所以它必须要什么shift right它知道说这边是负2所以它知道shift right

by 2 bit，如果是-3它就是by 3 bit-4就是by 4 bit juste用这种方式它就可以知道说就是所以同学可以看到这边就有什么呢multiplexor它都是从这个-2这边来做判断的，所以它这个数呢就是从这边下来，这边就是这边就是1点1. 101. 10然后这边是1. 011. 10我们先不要管说它只有存fraction，我们假设是整个significant在运算这样子比较简单所以这边是1. 10这边是1.

01这边它告诉我们说要shift几次呢要shift两次这个data有过来不过它不是选择这一条，所以它过来之后shift right它会变什么0. 011对不对然后这个是1. 01然后这个就是选择4因为它是-2所以它知道这边要选择4过来，所以同学可以看到这个control它这么多个它这么多的control signal全部都是由这个-2判断出来要选择谁所以到这里东西有没有问题到这里就是它只是做alignment它alignment就做完做完之后呢就big ALU相加，这边是0.

011加上1. 01它变成多少呢，它变成11. 101对不对它变1. 101那1. 101呢，因为這邊是Big ALU算完所以這邊Ctrl它會選擇讓Big ALU下來，它就把這個1. 101的這個值就把它送到這邊來，然後呢它也會把1. 101這個值往Ctrl這邊送它往Ctrl這邊送要做什麼呢，它就是要讓這個Ctrl來判斷說1. 101到底是不是一個Normalize的一個Number，它讓這個Big ALU的運算的結果送到Ctrl來判斷1. 101是不是一個Normalize Number，那control circuit判断完之后呢，它就可以決定什么呢，它就可以決定说这个1. 101要不要shiftshift rightshift left要不要shift它就知道了那它也知道什么呢，有

还有这个control它会控制它会控制由这个4进来，这第一个iteration的时候它是从上面下来的这个1. 101它是称以2的四次方这边是这个4所以你必须要让exponent就是从4这边过来，那4这边是4这边是1. 101，所以这边是第一次的时候这边是4然后这边是1. 101然后1. 101这边control它也判断说它要不要

normalize它判断说这个不需要normalize所以它这边control它就怎么样呢它就不会做加也不会做减然后它也不会做shift left它也不会shift right都不会它都不会所以这边下来它的值还是多少还是4这边下来它的值是多少还是1. 101还是1. 101这个加完的这个数它是正数还是负数如果就可以把它的sin bit直接assign到它的sin bit如果这个加big ALU加完以后是负数这sin bit就是1如果这个big ALU加完是正数它这个sin bit

就是直接把它抓過來就是這樣子所以同學可以看到就是說它這樣子Normalize完之後接著它要來讓它做一個RoundingControl就是根據它剛剛1. 101它知道它有幾個bit它知道說我們可以存幾個bit要不要做Round如果說這個時候它必須要做Rounding的話它就會在這個地方做一個RoundingRounding的Hardware

它就把它做Round那Round我們假設它是可以存假設它是可以存多少它是可以存小數點下兩位而已假設它只能夠存小數點下兩位那這邊也是45入所以你是1的話它就會Round它就會進位所以你這邊Round完了它就會變1. 11然後這邊rounding這邊它還是4它的exponent都沒有變所以1. 11這個時候它就會從這邊feedback回來然後它也順便沿著這一條線再送給誰呢再送給這個control讓control去判斷說1.

11是否需要进行 normalization 让它判断这件事情就是等於它都做同樣的事情它再repeat一次所以这个时候下一个iteration的时候它就会从这边进来它就不是从这一条这一条是Big LU刚加完的右边这一条是rounding过rounding过后它会feedback回来check它要不要做normalization;rounding过后是从右边这一条这里面也是一样同学可以发现这边是fraction这边是significant然后这边呢

是Exponent所以Exponent如果说一开始是Big ALU的结果它会从这一条进来如果你是Rounding过后的值你的Exponent就是一个Feedback从这边下来所以它的Input Source是不一样但是它这边要做的事情是一样都是要做Normalize;所以同学可以看这整个Hardware的一个Structure就都complete它的做法就是这样子我们刚刚的描述其实都follow我们前面介绍这个14点加法的这个精神第一个alignment第二个就是做一个addition就是做那个significant的addition加完之后就要做normalization;normalize完之后要做rounding;

那你rounding完之後還要check說你round的過有進位是不是由它變成是一個非normalize的一個number所以還要再回去再normalize一遍所以這就是它的一個flow這邊同學有沒有問題同學你只要回去就是照我剛剛這樣子你就從上面開始做運算就開始自言自語開始畫線 然後解釋 畫線解釋你從上面做到這邊 結果出來的時候你的線全部都畫完了

都合理解釋完了那就證明同學完全了解這一張圖你如果畫完以後發現還有一條線不見了沒有畫出來 沒有把它highlight起來那就表示說同學還不了解這一條線到底要做什麼用所以同学应该复习的时候要用这种方式复习一次就可以彻底了解这个flow有问题可以再讨论没有关系好 那我们就再往下看后面是这个14 point的乘法这个乘法我们在这边来看说这边是四个digit decimal它是1.

11乘以10的十次方乘以9. 2乘以10的負五次方這個乘法感覺就比較簡單它不需要alignment所以我們就說它就是exponent做加這個exponent做加我們就說10加負5它就等於負5如果說10跟負5假設10跟負5它都是bias過後我們可不可以把這10跟負5相加呢 可不可以n這10加-5加出来并不是我们要的数为什么

因为10里面就是10里面它已经有加了一个bias然后-5里面它也加了一个bias你把10跟-5两个相加你等于加了两个bias你等于是加了两个bias所以你把10跟-5相加没关系你还要再减掉一个bias不然的话你十加负你会多加你的bias会多加一次所以这个是我们要了解的地方就是说你如果是bias的一个numberexponent你不可以直接相加加完之后还要再减接着我们就是做significant的一个乘法乘法一样就是做nominize然后check有没有overflow underflow然后接着再做roundingrounding之后再做nominize

大概就是接着再决定它的sin bit所以这个是乘法它的14 point它的乘法大概就是这样子这边有一个4个digit binary的一个example它是一个0. 5乘以负的0. 4375这个就是我们刚刚提到的这边说它是一个负1它是一个负2我们假设这个负1负2我们这个负1负2它就是说你看我們把它它是要做一個BIAS的話它是-1加127-2再加上127所以你不能把這個就是說你加完之後它是-3再加上254你必須還要再怎麼樣還要再減掉一個127接著它是相乘然後後面的動作都是一樣這個同學自己看一下就可以這個是乘法的部分

有关于14-point arithmetic的hardware如果是仿造我们前面看的这样子的一个结果就是说multiplier它大概跟Ader有类似的complexity也就是说它的multiplier基本上并不会因为它做一个乘法它需要多出多少的这种hardware的一个resource当然前提就是说这样子的一个乘法器可能不見得它的效能不見得是我們所預期需要的你如果需要更快速的話大概就是必須要有特殊設計的這種Multiplier一般這個14-point arithmetic hardware它會做加減

乘除然後開根號還有這個integer conversion之類的反正你只要牽涉到14-point大概它的所需要的clock cycle大概都不可能是one clock cycle因為它牽涉到的operation比較複雜我們在這邊介紹它的MIPS裡面提供的14 point的instruction之前我們要先了解就是這個以前跟同學提過了就是說我們以前這種14 point的這個Hardware基本上它不是跟CPU擺在同一顆chip在早期的半導體製程還沒有那麼先進的時候

它没有办法塞那么多东西所以它是这个CPU是一颗，然后它可能必须要搭配另外一个Floating Point的一个Code Processor，它是另外一颗Processor，	it是你在主机板上面可以看到两颗，就对了一颗是Code Processor。现在可能自成，它很先进，可以把它整在一起，它可能就不需要说你还需要一个Code Processor。所以这种我们把它认作，它也是

Coprocessor 1。因此，同学可以看到的Load C1C1是什么呢？ C1就是Coprocessor1的一个意思，这是Coprocessor 1的一个意思，我们在这个MIPS里面，我们有另外独立的Faulting Point Register，我们有Faulting Point Register，就是有F0,F1,F2,F3,F4到F31，总共有32个，这32个都是32bit。所以基本上，它是for single precision。同学说，我如果是做double precision64bit，基本上就是它D4,D4，就是认定F0,F2，这是一个，这是一个，这是一个。所以，你F0，它是32，它就是搭配

這可能内部都已经hardwired都已经把它 group 在一起，这搭配 F0,F1，它就是一组 64 个 bit。所以，它就是它就可以存这个 double precision那你如果是 F 2 呢你在 double precision mode 之下指的就是指 F2 加上 F3你不用去 specify 說你是 F2 加 F3反正它 default 就是一定是 F2 搭配 F3这是它D4的一个搭配的方式所以我们的14-

point instruction它就是作用在什么呢14-point的register这个在早期来讲这个当然是本来就理所当然同学可以想想看早期他们的14-point它的hardware是跟CPU是不同chip那你既然不通chip你怎麼可能說你14-point用的register你必須還要跑到另外一顆chip去用人家的register這個是不可能的因為你這樣速

度整個就慢得不得了非常非常慢所以它一定是independent跟我們CPU的那些instruction是不一樣即使你現在都已經把14-point跟我們的CPU其實都整載同一顆chip同学问说那我是不是可以共用就可以了是不是可以共用其实一般现在的design它不可能把它一样还是会把14 point的部分把它独立成一区你可以很明显地看得出来这一区它这一区就是14 point你在layout上面看它这一区就是这一块就是14 point它不会说把14 point把它打散掉

散到一般的C PU裡面全部都跟它合在一起，它這是獨立的一區所以就這個上面來看的話它還是有必要是使用自己的register就instruction來看的話，instruction它們是完全不同種類的operation，一個是integer一個是faulting它們之間是完全不同種類的datatype，它們的運算方式也是有明顯的差異所以其實你沒有必要一定要使用integer的就是一般我們前面提到的那些register來做運算，所以他們都會提供這種特殊的register然後14-point的instruction就是operate only on 14-point register，就是這樣子

所以這邊可以看到的就是像load word、load double、sep store word、 store double就是类似这样子，这是他们的这个instruction，这边如果是single precision的话，我们可以看到的就是说add single、sub single、multiply single、divide single，如果是double的话就是用这样子搭配，同学可以看到，你如果是single的话，你F0到F31偶数、奇数都可以出现，因为它是个别使用，但是你如果是double的

话，它都是偶数0搭配12搭配3这是default的所以我们就是用这样子来做一个double precision的一个加减乘除另外有这种comparison它说single or double precision的comparison它说c dotC dot比如说EQ LT LE这一种然后点S single或者是double它当然就是什么呢就是一个compare就是说我做single precision的一个compare然后看看它是比如说看看它是F3是不是小于F4F3如果小于F4的话它会怎么样它其实就是会set就是set把某一个

14 point它的一个condition code bit同学可以把它看作它是一个特殊的flag就是14 point的一个flag这个flag它就会把它set turn on或者是clear turn off它就是一个flag这个flag要做什么呢当然就是你branch要用的就是你这边set跟integer那边的观念是类似的是一样的所以我们这边就是如果说它F3小于F

4的话它就会把这一个特殊的condition code bitrun bit flag把它set 1接着你就可以再用这一个指令叫branch就是这个就是branch true或者是branch false就是branch code processor 1 truebranch code processor 1 falseCode Processor 1当然就是指14 point所以它那个flag如果是true的话它就跳到这一个label如果是BC1F25就是如果是force的话它就会跳到这个label所以它就是提供这一类的指令接着这个课本就用了一个例子

我們說溫度就是這種華式跟色式的一個conversion這個轉換我們這邊就不跟同學介紹了因為它裡面應用到的觀念前面都已經介紹過它就是都是在處理這個array它只是多加了就是做這種14 point的這個number所以同學自己看一下這一段code

这里面同学如果有不了解的同学就必须要回去复习一下你的C就是复习一下你的C就是说我们知道说我们C里面比较常用的就是C比较熟的人很多人都会喜欢这种用法它就是在LOK一个array的时候它不直接宣告一个array它就是用自己去Code Memory Allocate然后它就是去Allocate一个R

ow BaseColumn Base的一个Array就是用这种方式那你就必须要知道说在Array里面它的Index成长的方式它是用Row Base去做成长还是Column Base去做成长那这种不同的方式的话在你存在记忆体里面的Sequential的位置是不一样的所以这个同学自己看一下接着我们再跟同学介绍我们要如何提高这个14-point operation它的accuracy

它的精确度我们前面提到的就是说你小数点下几位那你就要做rounding超过了就要做rounding在这边他提出了有三个一般我们比较常见的也叫garbid roundbid另外还有一个叫sticky bit什么叫Garbit什么叫Runbit它的观念是这个样子就是说比如说我们精确度只有到这个小数点下两位这个小数点下两位我们如何去存这个第三位或者是第四位它是不是就被Run了出去被Shift了出去以后就不见了呢

那你不见的话你如何能够做rounding呢你如果只能够存两位你在你的hardware里面也是只能够存小数点下两位那你如何去做rounding你就ship出去以后就不见了对不对所以你要能够做rounding你一定是必须要把那些被ship到外面去的把它存起来所以这一种就是第一个 比如说我们小数点下两位它

的下一个bin我们一般这个就叫Garbin再下一个这个就叫Wrongbin就是Garbin跟 Wrongbin它的一个差别所以同学可以看我们如果precision只有到这里的话你如果要提高你的精确度的话而不是说这个056它自动就消失你如果没有got bit wrong bit的话你就是只能够存0. 02那个56就不见了那你2. 34那后面0也就不见了所以我们说如果它可以存got bit wrong bit它就是这个56全部都有所以你可以加加完以后就是什么呢2.

3656它的结果就是2. 3656这个56这两个就是Garbit, Roundbit都出来的这个时候我们如果说你要做45入你就可以根据你的Garbit跟Roundbit去判断说你要把这个56去掉呢还是要进位变成2. 37比如说45入的话这个56就去掉它就会变成2. 37这个就叫Rounding Rounding就是这样来的所以我们必须要support这种机制那它就可以说加完会变成2. 37如果说我们没有gabit run bit的话它就是0. 02这56就不见了2. 34就是这样它两个相加变2. 36它就变2. 36所以同学可以看说一个是2. 36一个是2. 37哪一个比较准

哪一个比较准这比较准还是这比较准没有错我们一般如果说用两个数跟它应该要有的这个值来做比较看看谁的difference比较小如果是用这样来判断的话是2. 371是比较准因为我们可以看到它是差多少呢它是差44 对不对这37减掉36 56就是差这边 这边就是44那你如果是56减掉36是差5656跟44当然是44比较少

当然就是差四次比较少像这种它有一个课本有一个名词叫ULP叫Unit in the Last Place它的定义是什么呢它的定义就是说我们使用我们的这种我们有自己的方式然后有这个rounding的一个机制我们最后算出来的这个数跟它原本应该要有的数的差异到底差多少然后它的基准点是看哪里呢它的基准点就是看你的你的精确度的最后一位的这个digit比如说我们差是差在它的精准度最后一位是这个digit我们就要来看

它跟它的差别是差多少是差0. 00440. 0044这个digit是1所以它的下面下一个它的digit就是多少它的ULP就是0. 44ULP原本头影片上面的那个请同学update成0. 44 ULP所以你如果说是差1的话它就是叫1 ULP如果是差2的话就是2 ULP像它这边它是差0. 44我们的这个pointfraction是在这个地方fraction就是在就是在精准度的最后一个digit那个地方fraction所以它就是变成0.

44 ULP所以这个就是我们这边看如果是这一格的话这个差的它就是差0. 56 ULP就差0. 56 ULP因为它是差了56然后friction在这个地方所以它差0. 56 ULP到这里有没有问题接着我们再来看什么是sticky bit这个Gar bit跟Round bit它已经帮我们解决了就是说精准度的问题它可以提高这个精准度的问题可是有时候呢之后就是说比如说如果是我们的rounding的一个机制是说假设是这个5就是说0.

5以下的如果是0. 5以下的然后你就把它round掉0. 5以上的你就把它做近位就是就是说像我们说四舍五入就是四舍掉五入那你如果说是五以下包含五的把它舍掉然后五以上五以上的敬畏那有一个情况很难判断什么情况呢你说五就是这个例子五00000然后这个是五0000001因为这个1是

出现在很右边的一个位置如果我们只有Garbit跟Roundbit的话它只会存这两个所以就它来看的话这个5是要Round掉还是近位要Troncate掉还是近位就直接把它舍掉你如果说有考虑到这个1的话那它怎么办呢它就要禁位所以这个就是你只有Gabit跟Roundbit跟实际的情况它还是有这个差异那这个东西我们

要如何来保存这个1呢因为它里面中间的这个0可能里面有差了10个015个0都有可能那你后面才出现一个1那这个时候怎么办它有一个机制叫sticky bit这个sticky bit就是就一个bit这个一个bit是表示什么呢是表示说在我们的gabic round bit之外它被shift out出去的bit有没有曾经是1有没有曾经出现过1如果有曾经出现过1的话这个sticky bit它就必须要设为1如果所有曾经被shift out

出去的bit都是0那這個sticky bit它就必須要是0所以這個sticky bit它的implementation其實很簡單就是什麼呢你每一次只要有一個bit被shift出去你就是做一個all就跟sticky bit做一個all你的sticky bit initially設為0之後每一次有一個bitshift out出去之後就跟它做一個all所以你只要中間曾經出現過一個1的話這個sticky bit它就會是1所以我就可以很容易地判斷說這個例子sticky bit是0這個例子它的sticky bit是1我就知道說這個例子是2.

354 0 0 0不管多少個0它都是0但是這邊是2. 35 345 2. 345然后，010中间会有一个1或者是有好几个1，反正它就是大于0既然大于0的话，它自然就是大于等于这个5大于等于5所以它就必须要进位，这一个它是等于5，所以它就是要把它去掉，就不进位，就直接去掉，所以这个sticky beat，它的作用就是，在

这个地方，这边同学了解steep beat，要做什么吗，所以就是把这些全部都做一个all，全部都做all当然，它不是一次做all，它是sequential一次一个beat出来，就oh，一次就oh，一次oh，一次，那裡面只要中間有一個e呢，它這個state bit就會被設為e，就是這樣所以，我們到這裡第三章，大概就全部都介紹完了，我們大概就是，在看一下這邊，他說interpretation of data，它實這邊是在描述一些很簡單的觀念，大家都知道的，

它只是告诉我們说，在电脑里面存在记忆体里面data，我们都知道它都是01010…1010你每次去抓32或者每次抓64个bit出来的时候，我怎么知道说32个bit，每次都抓32个bit，这是什么资料，它资料有固定的，它的format不是format就是说，有固定说这个一定是instruction，这一定是data或者是这个一定是initial这个一定是14点

吗，它没有，它没有固定的说这一笔这样01 01的形式的资料，它就一定是instruction它就一定是什么这个资讯当然，是我们必须要去specify我们设定说这一区是code我们就知道说这一区抓出来的资料32个每一个word都是一个instruction这是我们继续specify你在执行code的时候它会到memory里面的某一个地方去

抓一笔资料这笔资料到底是什么东西这个也不是说它天生就是initial天生就是14 point你同样的一个number你不同的instruction去抓它它解读出来的意义可能不一样它在这边这个指令是initial operation它去抓过来它就把它认作是一个initial去做运算这边是一个14 point的一个instruction它去把它抓过来它

就把它认定是一个32 single precision的这个14 point number所以其实这边要讲的就是在讲这件事情同学可以看一下课本那个big picture里面的一个描述这个大家都知道所以就是用这样子的一个方式来对一个data一笔data来判定说它到底是instruction datasign and signinteger14 point就是这样子最后一个这边同学要注意的地方就是说我们知道说我们在做平行处理的时候我们常常会把很多的一个equation把它拆出来拆掉以后

分別丟到不同的 thread 去做做完之後就好像一顆 tree 一樣就一直可以 merge 上來這個方式同學要注意到一個地方就是說我們 sequential execution它有這種 associativity 的一個特性A 加 B 再加 C是等於 A 先加 B 加 C 之後再去加 A它有這種特性就是 S 加 Y 再加 Z它其實是等於Y加Z之後再去加X它等於這種特性可是如果這種14 point同學可以看說S Y Z是這三個數這三個數我先加X Y那加完以後會變什麼會變0然後再加ZZ是多少 是1那結果變什麼

變1它就變1那你如果是Y加Z呢Y加Z这个数太大了你加了一个1不见了结果呢然后你再加这个X一加1就变0你说1跟0好像你这个14 point感觉好像1跟你好像差不了多少可是当你用阴历学去看它1跟0其实上它就是不同的故事的结局这是完全不一样的同時要了解就是

說當我們是看類似這種14尤其是做14 point operation它都常常會有這種情況尤其是你再把這種14 point然後float就是single double把它混著用然後再去做data type conversion那個又會更亂七八糟所以這個一定要小心所以我们大概第三章就跟同学介绍到今天没办法介绍第四章我们今天就上到这里.