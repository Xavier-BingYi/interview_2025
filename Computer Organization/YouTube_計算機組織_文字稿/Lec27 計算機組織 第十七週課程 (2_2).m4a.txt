undefined
上一次就是下課以後有幾位同學來跟我討論一些問題，我想在這邊做一些補充或者是更正其中有一位同學他提到第五章Block size我們第五章在提到cache的時候Block size的時候我們那時候有提到就是我們說Cache的block它的block size如果增加的話我們可以提高這個heat rate，但是Block size如果說大到超過了某一個程度的話比如說跟整個case size相比的話它相對佔了蠻大的比例這個時候我們的mix rate會增加反而它的heat rate並不會增加它的mix rate會增加

那時候我們上課的時候大概就是有提到就是有提到說我們的Block size 增加的時候因為基本上我們的Cache 的數目Cache 的 size 是固定的所以你 Block size 增加那我們在 cache 裡面的這個 block number它就會相對的減少所以我們說那時候上課有提到說這個在競爭同一個Block 的 number競爭同一個Block Cache裡面還有Block的精準程度會增加這位同學他的問題非常好就是說之前跟各位同學的解釋其中的這部分應該是過度解讀同學的問題他是提到說我們的

Memory Size跟Cache Size都是固定的我們的Block Size= lock Size增加的話當然你的Cache裡面的Block Number是增加的，那麼 memory 因為 memory size 它還是固定的所以你 block 增加的話，你 memory partition 出來的 block number它當然也一樣是減少，所以你在 cache 跟 memory 裡面其實它是等比例的減少，所以你如果要用我們之前上課跟同學提到的那部分的話，那部分的說明應該是過度解釋應該不是說你有

更多的東西在競爭同一個cache的這個number不過之前提到的另外一個這個理由它一樣是存在的就是說我們之前上課的時候也有提到說就是說因為你block你cache裡面的block的number數目減少那你block number數目減少的話自然而然你進來你進來以後然後再被踢出去的時間它可能就會縮短你待在 cache 裡面的時間就會縮短舉一個很簡單的例子而言不管是一個小的一個 function code或者是我們在一個 loop 裡面就是這一段 code

並沒有很大在一個小 loop 裡面如果假設我們在這個 loop或者是這一個小的 function code 裡面我們總共 access 到四個 block假設我們 access 到四個 block那麼這個 4 只是一個例子這個數目可以改變你如果是access到四個block當我們Cache裡面的block number如果是五個四個以上的話至少在這一段call它一直iterative在run或者是這個小的function call每次去call這個function的時候它就是這四個block讀進來之後它就不會再miss它就可以一直在那邊hit hit hit當然如果說我們的block

這個size增加的話那我們block number減少假設減少到4個以下3個或2個那你會用到這4個block所以你進來了2個3個第4個進來另外一個就要出去在excess下一個又要進來又要出去所以它等於就是一直在那邊輪所以你進來再出去待在cache裡面的時間本來就會減少那這個當然也會降低這個heat rate

另外有一個例子其實跟我們剛剛提到的這個例子是蠻類似的它只是另外一個應用而已我們只是說我們剛剛只是一個general的一個描述另外一個特定的例子是說譬如說我們知道說我們在做這個array的乘法譬如說如果你是一個很大的一個array譬如說是一個512512乘512這樣子一個大的array

電腦去做Array乘法的話當然也是相當耗時有一些方法它可能是可以把一個大的Array做一個Part ition譬如說我們取中間的一個16乘16這樣子出來做一個運算以這樣子的一個例子的話因為它是一個Array512乘512所以它的每一個Row或者是RowBase或者是ColumnBase它儲存的Data它是一個連續的如果說我們的Block

一個block size假設我們說它是512所以你不管是一個row一個column你一次抓一個block就抓進來它是連續的資料它可能一次就把一個row或者是一個block它就把它抓進來這樣子的一個block size的話我們相對的在cache裡面它的block number數目就減少所以你block數目減少你可能沒有辦法一次抓16x16你抓

了一個block進來你只是包含了這16就是你一個block裡面只是包含了這16x16裡面的某一個row或某一個column的一個部分那其他的資料都不在這16x16都是在另外512x512裡面的其他的data裡面所以這樣子相對你一個block進來你就抓了很多redundant的data所以當你要去算那個16x

16的時候你就會有block一直在那邊swap新的進來舊的就要出去那你如果block size比較少比如說你就是16個所以你一次抓的時候就抓一個 row或者是一個column所以你16x16全部都可以抓進來所以這個是另外一種Education的一個應用所以我們在這邊跟同學更正一下這部分就是之前那部分可能過度解釋所以同學可能要注意一下非常感謝這位同學另外還有幾位同學他們有問到的問題就是跟Polling Interrupt跟DMA的部分

就是這一頁的內容相關當初這一頁可能講得太快所以可能有一些中間的connection並沒有很清楚我在這邊也是跟同學稍微再補充一下我想Polling這個機制大概都沒有什麼問題Interrupt driven的IO我們之前有提到過Polling跟Interrupt它都是由CPU在負責當然它的機制不一樣Polling它當然是周期性的去Check說它到底是不

是有需要做這個IO如果是Interrupt的話我們舉一個例子我們舉一個例子我們舉一個譬如說就是要這個CPU它要去讀一個資料譬如說它要去讀鍵盤它要去讀一個它要去做一個IN的資料的話這個CPU它一剛開始它當然就會送一個它要讀的Request它要去讀某一個設備什麼樣的資料當CPU送了這個Request之後CPU當然它可以去

做它要做的事情它不需要說等在那個地方因為它的IoDevice它不見得就是ready在那邊等CPU去call它所以這個IoDevice它如果說ready的話它當然馬上可以response它如果說沒有辦法馬上ready的話反正CPU它不會等它就做它的Io等到它ready的時候它大概就會送一個interrupt這個CPU它就是在每一個指令的cycle結束的時候它會去check說是不是有這樣子的一個interrupt如果有的話這個interrupt假設是它要的IO就是說它已經ready了這個時候CPU它就會開始去做IO的transfer在這裡面

不管是Polling或者是Interrupt driven的IO就是課本裡面其實它有提到一個名詞叫Master那這個Master其實最主要的指的就是說在這個Operation裡面它到底是誰在主宰這一個動作那以這個IO Operation這個Polling跟Interrupt driven的IO的話CPU它就是Master所以CPU它會負責去處理這些IO的operation所以從我們這邊的描述我們當然就知道說即使

這個IO它到底能夠多快它能夠多快的來完成比如說它的這個IO operation的IO rate到底有多高完全dependent就是說這個CPU它可以去處理它處理這個IO所花的時間跟速度，所以這個是Polling跟Interrupt的一個機制，在這裡面當然我們前面已經有提過說這個機制不好的地方就是說我們CPU它必須要進來來take care這個IO的operation，DMA的話，它是不用的。 DMA基本上它並不需要說要透過這個CPU來處理它的方法就是說，在課本裡面它有稍微提到，就是說它對CPU而言

DMA這個Operation就是只有在一開始跟結束的時候CPU它才會介入，它怎麼介入呢？其實就是CPU它要做IO的時候它就會送一個資訊給DMA的Controller，這個資訊當然包含說它是要哪一個IO Device要做IN還是OUT的Operation它要多少資料它的Memory它的starting address到底在什麼地方就是類似的當它送給DMA controller之後，CPU它當然就可以

繼續去進行它的工作，它就不用管它不用管說IO到底什麼時候會Ready Ready這個部分的話，在DMA的機制，CPU它不用管，因為DMA controller它自然就會主宰這一些，所以以DMA這個機制MASTER就是DMA controller，因為它已經主宰了這整個IO operation所以DMA它就會說等到這個IO device ready的時候DMA它就開始去送送完以後它就給一個interrupt給這個CPU說它已經complete或者是有error所以在很明顯在

这个DMA跟我们前面提到的Interrupt Driven的IO它们共同的一个特征如果同学要说它有什么Command它的Command就是说它基本上Interrupt Driven的IO跟这个DMA它都有用到InterruptDMA Controller它结束了或者是Arrow它就是给一个Interrupt那这个就是不一样的就是说这个CPU它必须要在Interrupt Driven的IO去take care它

的IoOperation它是一個Master那如果是DMA的話Master是這個DMA Controller所以這個中間當然是非常不一樣那課本裡面這裡其實沒有提到的就是有一個地方它沒有提到就是說我們在做IoOperation的時候其實它有它當然也要用到這個Bus System Bus那CPU它在run的時候它在執行的時候它有可能會

用到這個System Bus那既然都要用System Bus所以是不是我們剛剛講起來好像ideal case是CPU它一直工作DMA controller它也在做它的IO操作那实际上並沒有用到System Bus的時候，那他才去用它去做這個Data的Transfer，另外一種情況呢，那一種情況就是所謂的這個課本裡面沒有提到的叫Cycle Stealing Cycle Stealing也就是說它可能會去偷那個CPU的Cycle，意思並不是偷啦意思就是說它CPU Run Run之後它就叫CPU Suspend就叫它先Hot一下然後讓這個DMA用一下System Bus那用完然後再

讓這個CPU繼續Run它的工作當然它不能夠隨時叫CPU Hand Suspend它有一個固定的時間點，一般而言比如說以Intel他們的機制它是在每次CPU要用到System Bus之前它就會叫這個CPU先停下來依照我們這個架構的話他會使用的 System Bus 大概是在第一個就是 Instruction Page他要去讀這個 Memory Instruction Memory第二個呢 他要去 Read, Write Data Memory所以大概就是在這兩個 Stage他會去 tow CPU 的 Cycle這個是另外比較 detail 的細節我想最主要的同學應該了解剛剛提到的 Interrupt

還有DMA它們之間兩個最主要的差異就是在CPU它的角色所以同學有問題來跟我討論或者是課堂上發問的話我想同學應該也會有收穫因為有時候講太快某一些東西就漏掉了接下來我們上一次好像是提到這個我也提一下好了就是說覺得到底是哪一邊有問題這個其實他要強調

的他要強調的其實就是我們跟同學提的RAID3跟RAID4他們的一個差異他們的差異最大的差異就是在說RAID4它如果是一個small write的時候它只要去access一個disk就可以因為我們知道說這個RED4跟RED3它最大的差異是它是以Byte跟Block為這個Partition的這個Unit所以RED4

的話它是一個Block它一個Block就放在一個Disk然後它連續的Block就放在下一個Disk所以我們在Access HD的時候我們知道說我們要的是一個Word可是我們讀一個Word會到 disk 通常都是因為 miss就是因為兩次 miss 之後我們才需要到 disk 裡面去讀到 disk 裡面去讀的時候我們知道說它抓的時候基本上它就是抓一個 block當然在以 disk 我們介紹 disk 的時候它不叫 block

它是叫 page它就是一次抓一個 page所以它抓的時候它當然都是抓一個比較大容量的一個 data所以以 RAID 4 而言的話partition unit就是一個大容量的單位一個 block 一個 page所以它 access 一個它如果只是讀一個 word它當然就是只有落在一個 block 或者是一個 page它抓的時候當然就是只有抓一個 disk它去 write 去 read 當然就是只有一個 disk那至於 read3 的話我們知道說因為它是比如說它是 byte level 的一個 strip

Bite-level的一个strip的话它一个word它可能会distribute在这边的data disk里面所以它read的时候它也是read multiple disk那它write的话它当然也是write multiple disk所以它write它怎么可能就只有write在一个HD而已除非它这边的read3它虽然说它是Bite-level但是实际上它是以word为单位来当strip你如果是以 Word 為單位當 Strip 的話它可能就是只要 write 這一個可是問題是我們去 HD

去 update 的時候我們不可能就要 update 一個 Word 對不對我們不是你進出都是一整塊的你從 HD 搬出來也是搬一個 page然後你把它寫進去也是寫一個 page所以即使你是用 Word 的話大概你說要單獨寫一個hard disk這個大概是有困難除非說你的small write指的就是指一個single word的一個write而不是multiple word的一個write因為你只要是multiple word的write你有可能是跨兩個不同的page所以你絕對

不可能說就只有去write一個disk所以這張圖是有問題就會讓人家confuse會讓人家confuse的原因是說明明你介紹的時候你是一個byte level的一個interleavebyte level interleave然後你這邊write只write一個single disk所以你到底你的strip到底是byte level還是word level還是其實它已經是到page level所以我覺得這個是會讓人家confuse所以我們才說這邊

就不用介紹這邊讓同學知道說confused的原因到底在什麼地方我們上一次介紹到這個地方我們大概剩下內容並沒有很多我想我們等一下就不要下課我們就直接把這一章的進度全部結束這樣子我們今天可以提早下課我們來看一下就是這邊有提到這個IO System的一個Des ign他有提到就是

說我們前面提到IO的這個Performance有相關於這個Latency還有這個Throughput那 Latency 的話通常一般會講到Latency大概都是一些Timing Critical的一些Operation那對於這一類Timing Critical的這種Operation的話他當然很注重就是說你的Latency到底是多少我們不希望說它要在那邊等很久雖然它的Throughput很高但是它卻要等很久的一段時間類似像這樣子的一個情況我們如果要分析說它的一種time critical的Operation 的話他的Latency是多少大概我們碰到的情況一般有兩種一種就是說它的Loading並沒有非常的

重什麼是Loading沒有非常重呢大概就是說你一個Request進來大概並没有其他的Request在那邊搶然後很多在那邊搶然後在那邊等你如果碰到這種情況的話它會比較複雜所以基本上大概就是一個Request進來然後它大概每一個Io需要多少什麼時間每一個Component需要多少時間加總起來大概就是可以算出它的Latency如果說

它是一個Load 很重的情況的話那這個可能你就沒有辦法從單純的這一種 Component它個別的 latency 去做一個加總然後就可以算出它的一個 individual operation它的 latency那這種情況通常我們就需要引入curing model或者是用一些 simulation 的方式來模擬因為有很多request然後你必須在那邊等候所以大概就是需要一些simulation或者

是導入這個curry model的方式才能夠去估計出它的latency如果是這個throughput的話我們等一下會有一個例子會有一個實際的例子我們來分析一般我們大概就是針對個別的component我們可以來分析一下它個別的throughput大概是多少我們可以找出說在這一整串的operation裡面每一個它的效能高低把它列

出來我們就會很清楚看出來說它的bottleneck到底是在哪一個device或者是在哪一個component你如果說要做improve的話大概就會有比較這一類的依據我們等一下的例子就是這個server這是一個SUM的Server這個SUM現在已經變成Oracle我們這邊大概就先簡單看一下這個Server Computer其實我們現在台灣也有一些公司開始在做這個Server所以只要我們台灣開始做這個Server我們大概就知道這個單價可能要慢慢開始掉

不過對我們消費者是一大好處就是可以買到更便宜的這個Server。這個Server基本上就是說在以前當然沒有那麼多的Application，但是現在這邊列出來Web Search Office的這個Application還有比如說這個Virtual Work，不管是即使是以後即使現在的像很多的這種工作不是工作就是遊戲伺服器很多都已經是建在這個Server上面各式各樣的Application。這個Server通常就是有我們以前跟我們同學提到的類似像那個Workstation，它可以就是一年365天你就是Always都是Turn on

都開機它的擴充性能也不錯譬如說我們等一下會看到它的這個Main Memory動不動就是幾十G不是像我們的這個PC大家都幾G幾G它那個並不是為了玩Game而要擴充到幾十G的純粹是因為它在工作上面的這個Computing的需求所以它有這個Multiprocessor Network Connection還有它的容量非常的大通常它也不會是就是單純的HD它還有類似像我們前面提到這種RAID它們大概都是綁在一起的，

所以我們這邊有幾個名詞就是RAC。我們一般的這個server它大概有一個 standard就是說它的寬度大概是19inch然後它的高度的話大概是1. 75inch的倍數這個倍數1. 75inch這1. 75它就是一個單位叫1u所以同學如果常常看到1u 2u 3u 4u，它指的就是指我們的server。這個Rack Mounted Server有人把它翻作好像是叫機架伺服器之類的，這個名詞當然可能不一定就是一定叫機架伺服器，可能同學會看到其他的名詞。它的意思就是說

通常這一類的伺服器，它不像我們這個PC或者是以前早期的工作站，它就是有一台主機，這個主機就是Standalone，就是擺在我們的這個桌子上面或者是這個地上然後再搭配一台螢幕就是這樣子這樣子的話好像是個人型的工作站。當然你其他人可以透過網路連到你的這台Workstation通常這種主機這種Workstation或者是這一種不是這種機架的，

它的主機比較大，它的擴充的能力更強。如果是這種機架伺服器的話，它的擴充能力相對的比較少，就沒有辦法擴充性那麼強。可是它有個優點，同學可以看到左邊這張圖，同學可以去我們系上的硬體實驗室裡面，就是以前硬體實驗室裡面以前我申請那個教改熱塞的教改計畫經費買了很多server全部都是用這種方式把它架上去的，所以在一個空間裡面你買一個這種機架，比如說，它如果是42U等於說你可以

放42台EU的server在以前的話我們說一個Wall Station Room，你要擺42台大概你的空間要還蠻大的，大概你每一台大概要保留一個位置然後讓一個人坐然後放螢幕、 大螢幕然後空間不能夠太擠要考慮到散熱的問題所以你42台的話空間很大。現在這個同學可以看就高高的，就把它往上疊就會疊出42台不過一般42U的計價大概沒有辦法擺到42台

理想，好像說可以擺四色彩但是它有一些空間會擠壓到所以沒有辦法而且通常他們還會再擺像Router還有像RAID之類的全部都會擺在這一邊，所以這樣子就是容易統一管理，這個是一個Sunfire就是X4-150EU的一個Server。我們等一下要分析它的效能，就是用這一個來分析同學可以看到它這邊有两个Intel Xeon 5-100 5-300，它是四个扣，它是跨扣，所以你有两颤的话就是八个扣然后它透过front-side buffer接到北桥晶片，這边它有接到12、34每一个12、34四个插槽

所以你如果說是全部插滿的話，16乘以4G大概是64GB的主記憶體同學會說主記憶體這麼大幹嘛都可以拿來當小硬碟可以使用其實64GB的Memory其實一點都不夠大同學以後你們做一些研究就會知道64GB其實不夠大，這不是因為程式寫得不好所以記憶體使用很多。通常很多這種業界的test case一讀

進來它就是幾G所以你幾G再加上你的data structure再把它expand再放大以後大概就是都要將近一二十G以上。通常你的raw data進來你的data structure存起來不可能比它更小。你如果有辦法說你的raw data讀進來你的data structure存得比它更小又更有效率，那這個是還太厲害了。所以這個64G實際上在研究上面來用有時候真的還是不夠用。

接著這邊是PCI PCI這邊接到南橋，所以我們等一下看的一些規格就是有關於這些DRAM然後這個HD HD就在這邊大概就是這樣子

的一個架構。

我們以這個例子來分析我們的这个IoSystem，它的IoRate它說給定一個sumfile X4 150 system它的這個workload，它是每一個disk read就是transfer64 KB每一個IoOperation在這邊我們說一個IoOperation就是一個假設就是一個disk read每一個IoOperation它需要執行就是各時百千萬、十萬、二十萬個user的instruction還有十萬個os的instruction因為不是只有user的program在

run通常你user program你去run IO operation，我們知道說很多那些它都是supervisor mode所以你必須要透過os的幫助你才能夠完成你的IO instruction所以user還有os的instruction是二十萬加十萬總共這麼多我們每一個CPU每一個Core這邊是指每一個Core我們有8個Core每一個Core它每秒可以執行10的九次方格instruction Francise Bus它的Pig Rate是每秒10. 6GBDRAM DDR2它的Calc Rate是667MHz是5.

33MHz6GB每秒然後PCI它有8個LAN它每一個LAN是每秒250MB8個LAN的話乘以8所以是每秒2GB這邊都是指它的Transfer RateDisk它的Rotation是15,000 RPM然後Average的Sick Time是2。 9 ms另外它的Transfer Rate是每秒112MB這邊提醒同學的就是說我們一般在講File Size我們在講File Size我們說EM 1K 1K是多少1K是2的十字方 對不對1K是2的十字方所以它的Base是2 適合進位我們在講IO的時候同學要記得我們在講IO Rate

我們的K是十進位所以K的話是十的三次方大M的話是十的六次方大G是十的九次方所以同學要知道我們這邊講的這邊都是Io rate我們這邊Io rate都是以十進位為基底所以這是十的三次方9次方 這是10的 6次方所以同學知道這樣子的話等一下再算的話才不會算了老半天 算

了好幾次都算不出投影片裡面的結果所以要記得這件事情這個例子我們就要開始根據每一個component我們要開始一個一個去做分析說它的IoR rate到底是多高Bottle内到底在哪一个Component我们要做这个分析所以首先我们来看我们说这个Disk就是它有这个Random Read还有这个Sequential Read我们也会根据这两个来做不同的计算首先我们来看CPUCPU当然它也有它的Read因为我们说你每执行一个IO的Operation必须

執行10萬加20萬個instruction所以total是30萬個instruction就一個IO operation我們每秒可以執行10的九次方個instruction所以我們就可以算得出來說10的九次方除以30萬我們就可以算出你平均一秒可以一個core平均一秒可以完成幾個IO operation所以這樣一除的話33 3個IO operation那你有8個code乘以8，所以它就有26,

000多個每秒可以執行這麼多個IO的operation接著我們來看這個disk我們首先來算一下這個random read，random read我們就是假設因為它是每一個位置都不一樣，每一個位置不一樣的話我們每一個IO operation，每一個read它就必須要rotate然後要sick time，我們這些都是每一個operation都要把這些東西算進來所以這種random rate算出來，

它的Io rate當然就會相對的非常低，所以我們來看一下這邊大概是怎麼算的我們這邊先假設他說我們實際上的sick time是我們average的sick time的四分之一，所以我們前面的sick time是2。 9ms除以4這是給定的接著我們要算Latency Latency我們一樣是假設說它是轉二分之一圈所以這邊二分之一圈就是這邊除以

2就是二分之一圈這4ms是怎麼來的呢這個就是我們之前有個case已經算過了同學應該還記得我們轉一圈要花多少時間呢轉一圈要花多少時間就是這個15,000。同学记得这个是每分钟你把它转换成每秒的时候是要除以60然后再取导数我们就可以算出来说你转一圈要花多少时间我们这边平均是转二分之一圈接着我们这边说Transfer Rate我们的Transfer Rate一个IO Operation是需要传送64KB这样子的一个资料

那我們的這個disk它的transfer rate是112 MB那你這樣子傳送資料大概要花多少時間所以就是sig time 讀寫頭的移動然後這個rotate latency然後接著 transfer 真正定值了以後開始傳資料 transfer這邊加總起來是3. 3 ms所以我們一個一個IO operation需要3. 3個MS你每秒可以做幾個IO operation取導數就可以得出來，所以每秒可以得

到303個operation可以完成303個read我們有8個disk這邊有8個disk所以你有8個disk的話，303再乘以8就是2424這個就是random read就是這樣子，每一個都要seq rotate然後transfer那sequential read的話，我們這邊就忽略了，我們就是說sequential，我們就是說它是所有的資料就是形序這樣子全部把它讀出來，那這個當然是，就是說如果真的

是大量的資料全部都是這樣子，這是最好的，那我們這邊就是假設，就把這些sigchime latency我們這些都把它ignore掉，所以我們就是12除以64你平均一個disk可能每秒可以完成1750個，你有8個disk就是乘以8所以這是sequential，它的ideal case是這樣後面這些就很簡單了，後面這些就是一個PCIe的Io rate，每一個LAN是254MB，8個LAN就是2GB，再除以64，這是每一個IO read，每一個Disk read需要這麼多的資料，所以你這樣子

一除的話，你就是每秒它每秒可以傳送這麼多，那你一個IO的operation要這麼多的資料所以你每秒可以做幾個IO operation這樣一儲的話就得到31250DRAM也是一樣5. 336GB除以64KB會得到83375FRONT SIDE BUS，我們假設，因為5. 3GB是它的Pick Rate，我們假設在課本這邊假設說我們當然不可能OS都是Pick Rate，它就是平均，就是一個Pick Rate的一半，所以就是這邊原本是多少pick rate是10.

6GB除以2它就是5. 3所以5. 3再除以64就得到8,1540，但是同學可以看到我們的front side bus，它是接到兩個這個chip就是這邊四個code，這邊四個code，所以它是兩個所以要乘以2，它是要兩個這邊一個兩個我們剛剛算的是算一個所以一個算出來以後因為它兩個可以同時送，所以你要乘以2，所以算出來以後這個frontside bus它是16,3080每秒可以完成這麼多個operation這樣子我們分析下來以後，實我們就知道說bottleneck在哪裡了，這個是個10、

百、千、萬、十萬、十六萬然後這是83,000、311,000這14,000然後這是2,000然後這個是26,000，所以很明顯最大的bottleneck在什麼地方呢，我們當然本來就知道是在這裡，因為這個hard disk一定是最大的bottleneck，所以這個例子就是用這樣子來分析我們可以知道說這個就是在hard disk要improve的話，我們要想辦法去improve這個hard disk，它的問題接下來我們最後面的內容大概就是剩下這一章的phoracy還有PIT4，那有幾個也還蠻不錯蠻有趣的觀念介紹給同學跟同學討論一下第一個

討論的phoracy就是說disk的dependability，同學如果去看HDD的spec， 它的規格去它的原廠的網站上面去查他們的規格，同學大家都可以查到它的meantime to failure，這是我們前面有介紹過的時間，這個時間當然是一個很重要的參考依據，我們知道說如果說這個數值很高的時候，我們就可以確定說這個HDD它這個product應該是

還蠻穩定的我們應該還可以蠻放心的就是可以用這麼多的時間平均可以用這麼多時間它不會壞。可是一般譬如說我們看到一個製造商他說他的MTTF大概是這個要算一下個十百千萬 十萬 百萬120萬小時也就是說你買來以後然後你大概要過了140年它才會壞掉，那意思就是什麼呢？意思就是我們只要容量買得夠大我們就這一輩子就買一顆就好了我們就買一顆硬碟。其實就等於以後就是那個那個什麼呢？就是小孩生下來去

戶政事務所報戶口政府就送一顆硬碟然後這顆硬碟就是跟著你一輩子，因為我們壽命不可能超過140年，所以你就一個人就是有一顆硬碟就跟著他就跟一輩子這樣子就OK了那同學相信嗎？我相信的舉手那不相信的舉手

當然大部分同學我相信應該是不相信因為它不可能時間這麼久可是這個廠商資料不會造假。它的實驗是怎麼做的？它的實驗大概就是這樣做的，因為我們知道說我們這個commercial product有一個很重要的因素叫time to markettime to market就是說你如果是找鳥的話那个market就是只有你是unique的一个product你的price要怎么

定就是随你定所以你的毛利可能就是非常非常的高你如果是玩鸟的话这个时候市场已经到处都是同类型的product所以你要跟人家竞争你就要去杀你的price所以你的毛利率就非常的低这大家都知道的一件事情所以我们不可能为了去deliver一个product我們雖然為了要提高它的 Reliability Dependability我們就必須要做一些測試然後得到一些數據我就測個一年、兩年、三年、

四年測完以後然後再Deliver這個Product這是不可能所以通常他們就是說用大量的Disk在一個房間裡面比如說它就1000台它就1000台的Disk然後就讓它一直Run一直Run大概是24小時就一直Run不斷的Run那run多久呢可能run一個月 run兩個月之類的所以你一個月 這還好吧你就run一個月大量的1000台run完以後就開始了你就說你這1000台run了一個月你總共run了幾小時然後你大概有幾個disk壞掉那你就可以

算出你的min time to failure結果一算當然是 140年實驗的盲點在什麼地方呢有沒有同學要質疑一下說這個實驗的盲點在哪裡我已經寫在上面了它的盲點是什麼呢它的盲點當然就是說它沒有考慮到這個failuredisc failure的distribution我們很多事情都有就是你把它統計下來它都有這個distribution對不對那

我們知道說一個新的一個product除非它說它這個product在生產的過程本身它就是壞的它本身就壞了所以你run當然就壞掉或者是它有瑕疵所以它的使用率就一下子然後可能很快就壞掉不然一般產品應該都是你用了第一年第二年它大概都是正值這個青壯年所以它很耐用很耐操它很不容

易壞掉所以它根本沒有考慮到這個failure的distribution那你用1000台量夠大然後run一個月好像也蠻長的不過實際上真正它的lifetime並不是一個月裡面能夠從一個月裡面去擴大你幾年數十年甚至上百年它的failure的一個distribution所以这种统计数字基本上是没有意义的所以你说140年看起来就非常的

放心所以这个应该是没有用所以我们说我们是不是可以去看另外一个数据我们不要看说这一看就140年这实在是我们可不可以看另外一个数据我们说annual failure rate我们就算说你的你每年大概有多少个failure你如果用这个数据来换算的话用这个数据来看的话或许你会看到比较不是那么惊人的一个资料可能有它的参考价值所以我们说我们的annual failure rate它就是什么呢假设我们有1000台我们现在有1000台我们每一个disk

在我們這個實驗裡面我們總共run了多少小時，就是總共run了多少小時或者是說你run了一年好了，你就是說你這個disk你run了一年，那你一年有多少個小時所以你這樣子一乘你的分母，這是什麼就是說你這邊就是你每年每一個disk run 了多少小時然後乘以 total disk所以你說你總共你一年到底你

的disc到底run了多少個小時你一年裡面disc到底run了多少個小時就是這一邊你下面就拿我們的 mean time to failure就是你平均一個 failure大概要多少個小時它才會發生要過多少個小時會發生一個 failure你這樣一儲的話大概就會得到說你平均一年大概會有幾個 failure 的 Failure rate Failure rate這樣一儰的話就是 0。 73%所以我們就是用mean time to failure然後得到這樣子

的一個數據，所以這個好像比較有參考價值可是這個數據算出來之後我們馬上有另外一組實驗，這個實驗當然絕對不會是廠商做的，應該都是比較有想要追求事實真相的這個researcher就學校的這個學者，他們就做了一些實驗呢，他們實驗當然就不是用那個mean time to failure去把它給推出來的譬如說，他們知道說failure distribution所以他可以去算說你第一年的annual failure rate是多少，那你第三年第二年的annual failure rate是多少，第三年的

Annual failure rate到底是多少兩組人算出來，他們平均差不多大概是2%到4%，你看這個第一年，它是1. 7%，然後第三年是8. 6%我們可以發現說，這一邊的數據有一個共同的特徵，它都比0. 73還要來得高，對不對為什麼它都會比0. 73還要來得高呢，那問題還是出在這個地方，它用什麼東西來算它用這

個數字來算，這個數字本身它就本身就並沒有考慮到Failure distribution所推出來的一個數據，那你再用這個數據再去推一個AFR那當然還是會有問題所以你這樣子推出來的還是0。 73相對的，又比較低這當然是越低越好所以不管是反正你當然不是說廠商的數字沒有那個意義而是說你可以拿他們的

數字去互相比對一下因為假設他們的實驗的樣本他們實驗的方式都是一樣的，那他們推出來的數據你可以互相比較，雖然在實際的應用上面並不是那麼的精準，但是我們可以做一個reference不同廠商之間可以比較一下，說誰的這個FR 到底比較高所以FR 到底比較低或許會有一些參考的價值，這個就是我們剛剛跟同學提到的在 IO rate

這邊我們的 1GB 是 10 9次方，你不要把它當作是 2 30次方這樣子來算，它會有誤差的，它差到大概有 7% 的誤差這邊要提到的就是說我們前面提到有一些IoController我們要讓它比較Smart一點，讓它的功能要比較強大可能會把它變成是一個IoProcessor，IoProcessor感覺好像它就是一個很強的Processor，它跟我們的CPU一樣都是叫Processor只是其中

這個前面又冠上再加一個IO，好像你只要有IO Processor的系統，它的效能一定會比較好實際上不盡然如此，因為我們的這個IO Processor，它不見得因為你如果要讓它效能很高的話，你付出的代價一定是什麼一定是Cost一定是CostDesign的CostPrice的Cost，所以這些的Cost一定會讓你，所以你如果說你這個系統真的這麼需要

High Performance的Io Processor，那它的價位一定非常高那你如果買到一個號稱有Io Processor結果價位跟其他人差不多跟那個沒有Io Processor的沒有差多少，那你大概就要小心你的Io雖然是叫Processor，但是它可能是一個Low End Processor，它的效能可能很差，它雖然是Processor，但是Processor要High End Low End所以它可能效能很差，它的效能如果很差的

話你的整個Overall Performance可能會甚至比沒有IoProcessor的效能還要差為什麼因為我們的IoProcessor，它如果效能差的時候萬一你的某一些Task它必須要執行很多的IoDepression你的IoProcessor會浪費很多的時間在那邊執行Io那這些很多的時間去執行Io你的CPU可能會被這些Io沒有未完成的Io的operation給拖累然後在那邊等以其這樣子倒不如我們CPU是非常快就CPU就親自下來做它也比較快CPU可能搞不好是它的1,000倍、10,000倍的一個速度

搞不好更高所以你CPU雖然說它執行IO它其他事情不能做但是總比你要等很多時間在那邊等IO complete那你CPU就其他事情先擺著你就進來它可能就一秒就結束就把它做完那你IoProcessor你做個一分鐘五分鐘那你CPU才花一秒你其他還有三分五十九秒你還可以做很多事情所以這個是一個極端的一個比例但是

的一個例子，但是它的觀念這邊要傳遞的一個訊息就是說我們把東西都丟到IO Processor不見得是一件好事情因為IO Processor它的Design也不見得說它就是一個High Performance可以搭配搭配你的CPU，如果說它沒有辦法搭配你的CPU與其，這樣子在那邊Wait for你的IO的Completion，你倒不如就CPU就自己進來做反而來得比較快。 比有IoProcessor所以這個就是我們提到的這個我們前面有提到說傳統我們在backup的時候

都是backup到tab現在已經很少看到backup還是用這個tab原因當然有很多我們說這個tab的technology現在其實已經都落伍了。如果說要這樣講也是沒錯，這只是描述現在的一件事實就是說我們目前的TAP的Technology的確是比Disk的Technology還要來得弱。但是其實在產業界很多事情有一些已經退了流行的東西不見得是說它的Technology有多差很多都是一些商業的因素

它才被取代TAP因為就是說跟DISC而言它的帶來的毛利或者是利率可能沒有DISK那麼的高公司願意花金額在TAP去做Research的意願相對的就低沒有人願意在這個東西做Research它的Technology就不太可能一直持續的進步當有很多公司一直花錢去做這個研發的時候這個科技它一定會進展得非常的快。所以

這種東西都是相對的所以說這個TAP現在應該它的技術因為大家花了很多錢在研究這個DISC所以DISC的技術一直在進步，所以它已經DISC，它已經差不多就取代了這個TAP當然用Disk也不見得是那麼的就是說，你即使用RAID也不見得是那麼的安全我們提到萬一這家銀行燒掉，那怎麼辦？公司燒了， 銀行又同時燒了， 什麼都沒了，所以我們有Remote Miro，大概你就是要透過網路，在不同的Location去備份重要的資料，這個才是最重要的

另外，這邊有一個很重要的disk scheduling，我們說disk scheduling，就是說，我們有很多disk read write這些disk access的一個request，這一類的request，我們不是應該都給OS來讓它做scheduling比較好，因為我們會覺得說，OS是那個等級最高的，它是最聰明的，讓OS來做scheduling這樣子會得到比較好的效果實際上就是說，這個想法應該是不對的，因為，我們讓OS來scheduling這個Disk的access，並不會比較好。我們這邊列了一張圖，可能看得不是很清楚，但是這邊的觀念最主要，就是在說，Disk controller，它會知道

Logical的這個Block address，Logical的這個Page address，它到底是對應到我們Disk裡面的哪一個 Track的哪一個Sector這個Disk controller它知道這些事情但是OS它不知道當然你OS要知道的話你可能要想辦法去Query或者是什麼之類但是基本上本質上面來講Disk Controller它知道這些Information但是OS它沒有這些Information所以你OS如果說要

去schedule你的這個Disk Access的話它大概大不了就是按照什麼呢就是按照比如說我們這邊有一個例子就是它就按照它的這個number比如說這邊有一個724100269987它就按照這個26先再來是100再來是724再來是9987它就按照這個number按照這個number去access實際上會不會比較好不會為什麼呢同學可以看我們假設這個讀寫頭的位置在這個地方我們第一個access是2626的位置在哪裡呢我們把它畫出來

26的位置在這裡所以他第一次rotate要轉到這裡來他才能夠讀到2626讀完結束就在這裡結束他這邊就結束了這邊就讀讀讀讀讀完以後就結束接著他要讀100下一個100incremental100他要從這邊轉 轉到什麼地方呢轉到這裡轉到100這已經轉超過一圈了它已經轉超過一圈了轉到100100這邊讀完了接著它要讀7,24724，它就要從這邊開始轉，怎麼轉呢？它要轉到這邊來，

他要轉到這邊來， 又轉得快一圈了724；他讀完以後，在這邊，他要讀99,87。 他要從這邊轉，就是724，在這邊結束； 他要從這邊轉轉到99,87，99,87在這裡轉到這裡，所以同學，這樣看， 他已經轉了好幾圈了，我們這邊畫得太亂了同學自己看一下，這邊的這個箭頭，它的意思大概就是像我們剛剛畫的，它是這樣

子；先轉到這邊讀完以後，再轉到100,100，讀完以後，再轉到7,24724，讀完以後，再轉到99,87；它轉了好幾圈，但是如果給Disk Controller去schedule的話，它知道不應該這樣子去access，因為他知道他有一個sequenceoptimal sequence讓他可以rotate最少怎麼access呢他第一個先從這裡轉到這裡，就轉到724，讀讀讀 讀到這一邊，再轉這個距離就讀到100；然後100這邊讀完，他再轉到這一邊，就讀到26,26；讀讀讀 讀到這一邊，他又轉到這裡，

就讀到99,87所以同學，你可以看到discontroller它所轉的圈數，就是這一圈就是這一部分加這一部分加這一部分再加這一小部分，這個加起來可能連一半都沒有連半圈都沒有，所以它要轉的圈數就非常的少；所以這邊就告訴我們說，我們如果要去scheduling去schedule这个disk的access的话我们就是要有这个disk

controller因为它知道logical的这个pace number它对应的这个track跟sector所以它可以从这样子的资讯它从它的location来判断它的access的先后顺序它的rotate的这个number可以是最少所以这边要跟同学传达的信息最主要就在这里這一個應該是最後一個Pick Performance這個同學應該都知道了我們在講說我們的Dev

ice它的Pick IO Rate到底是多少多少實際上基本上它是非常難達成的當然它的原因有很多它的原因包含譬如說我們這邊講的就是說它可能基本上並有時候並不是因為CPUIo的一個Request它才會去做Io的Operation比如說這邊有提到的CollisionCollision是什麼Collision呢當它要做IoOperation的時候DRAM我們知道DRAM都需要Refresh它如果沒有Refresh的話它存在Memory Cell裡面的紙會慢慢的DecayDecay到一個程度

它的值就不見了原本要讀一個1讀出來可能就變成0所以它必須要refresh你derain refresh的時候當然它就不能夠被讀所以這樣子的一個collision你就必須要wait你必須要等它refresh完之後你才能夠讀所以這樣子當然我們就沒有辦法達到我們的所謂的peak rate你的peak rate你是假設說你在讀的時候你的derain

完全不會Refresh你都不會跟這個Refresh這個衝到這個的話就實際上的情況都會常常碰到這種事情所以以這個PCI Bus你說Pick Bandwidth他說是133MB每秒每秒這個MB而實際上大概PCI Bus我們最大大概可能就是到80MB每秒同學一看之後幾乎打了五折所以這個pick rate跟我們實際上運作的速度基本上是差非常多的所以我們大概這一張第六張我們大概就跟同學介紹到這個地方我們回顧一下就是這一張的重點我們不跟同學做這個review

因為我想同學應該回去自己抓一下重點這個重點就是我是覺得同學你如果沒有試著學習自己去抓讀書的重點的話應該要試著去做這件事情其實你如果有自己的方法當然是最好你如果沒有自己的方法的話其實最簡單的方法就是什麼呢最簡單的方法你就把你的test book拿出來看一

下作者他的章節的分類到底是什麼你大概就知道你這個章節最主要有哪幾章的內容我會建議同學你每一章讀完以後應該試著要把每一個章節的 key point把它抓出來，它最主要有哪幾個架構它在說明這幾個架構的重點要抓出來，抓出來之後你要知道說哪幾個架構它們之間有connection，它們之

間的interaction到底是什麼這樣子的話我相信這一整張的重點你大概就都知道所以我們通常做重點就是這樣子抓你幾個main structure它們之間的relationship這樣子幾乎可以cover整張其他的一些大概都是一些比較細節detail的東西細節detail的東西大家就看一下描述裡面有一些有重點有一些沒有重點同學這樣試著去做的話我相信應該每一個內容應該都會很容易就知道說大概要注意哪一些同學如果在準備研究所考試的話你更是要用這個方法

你如果是在準備研究所考試的話你一定必須要把我剛剛講的那些你自己要把它列出來你如果列不出來就表示你沒有讀得很熟你如果讀得很熟你一定有辦法列出說這個章節最主要幾個structure它們之間的關係你一定列得出來所以你一定要試著去做這件事情所以我們這一個章節我們大概就是跟同學討論了這個Io performance我們的measurement

我們知道說一般的throughput response time還有我們討論到dependability後面我們有介紹了一些Flash接著我們就跟同學介紹Bus有幾種Bus。我们透過BusIO跟CPUMemory，它們之間的transfer大概有哪幾種機制每種機制它大概需要哪一些內容來幫它完成這個機制。所以我們大概學過的polling、interrupt driven 還有DMA這每一個機制裡面，它都有不同要搭配的還有後面有一些 benchmark這邊有一些內容。我们跳過後來最重要的一個重點就是 rate juste rate

它的分類就是有哪幾種還有它們之間的 difference所以我們大概就跟同學介紹到這個地方這個期末考我們大概跟期中考的方式是一樣True和 false的部分同學一定要把這個寫一下你的point有同學會說它都已經是對的那我要寫什麼如果說它都已經是對的你覺得說這個問題裡面你覺得這個對的statement裡面，它的key point是什麼你就簡單一句話寫出來

你覺得它的key point在哪裡它要傳遞的觀念或訊息是什麼你可以把它再稍微描述一下這樣子就可以了至於其他的問答題的部分的話我們大概會有一題是Memory一題是Memory的例子就是Virtual Memory還有Cache它們之間的一個串聯所以这边会有实际的read write的一些 access希望讓同學們去了解他們之間的一个connection其他的当然就是一些没有cover在true和 false里面的一些重要的观念我們會用問答題的方式讓同學做答所以同學尽量寫只要同學有写

不是太離譜的话應該都可以拿到分數我們大概課程大概就跟同學進行到這裡要同學有沒有什麼問題我想分數的部分同學不用擔心你們只要有讀有寫的話分數應該都會滿不錯的同學有沒有什麼建議或者是什麼問題都沒有我們在把時間交給助教以前因為同學都是大三， 少部分是大四的我們整學期大部分都是在上技組大概也没有时间跟同學

閒扯其他的事情我們就是利用剩餘的時間提醒同學我在上課的過程裡面都有跟同學提到說你們在讀這個書的時候不要把它當作它是好像數學或者是物理它是一個serum它就是應該是這樣子存在的基本上我們很多engineering的東西都是没有一個標準的solution所以這也是為什麼同學找我要標準

答案我不太喜歡給的原因因為同學從小時候包括我也是這樣子上來的我們都是從小一路就一直考試一直考試然後考到現在還在考以前我們那時候從來沒有想過說進大學以後還有一個研究所考試因為以前研究所考試不是很多人在考的後來才變多了所以大家都習慣考試所以你

在讀課本的時候你就會覺得說把它當作Bible一樣在讀你習慣這樣子的話沒有關係但是你要了解說這個是不對的因為這個會影響到各位同學以後在職場上面的發展我們畢業以後不外乎是做研究或者是到業界裡面去做Product你不管是業界不管是学术界的研究或者是业界做一些有

innovative的一些product其实你的一些idea是非常重要我们以前的教育都一直灌输我们就是一直K书考试然后把它当做一个东西去理解然后把它背下来我们的应用头脑的应用都应用在什么地方呢都应用在我们把这些东西理解之后去解体的这个应用这个解体的应用实际上這個限制了

很多你的一些發明的一些發展新的一些idea這個就是我們跟西方人差最多的一個地方所以我一直跟同學講說同學在讀這個你理解是一定要但是你不要認為說這個就是對的你如果有想到比較好的你要有去質疑他的這個心態你要去質疑說這個這樣子做一定是對的嗎他為什麼一定要這樣子做

你如果學會質疑的話以後同學在一年進研究所要做研究的話我相信同學應該會做得很好因為我看到的研究生大部分當然就是最主要研究做得好做不好所在的原因就是說我拿同樣的一篇paper給不同的研究生來讀但是有的研究生他讀完以後他知道說這個作者他用了這個方法去解這個問題他會說他為什麼這裡要這樣子

做好像不一定需要這樣子做他為什麼要這樣子做有的人會去質疑他有的人他就是把他當作教科書一樣在讀他雖然讀懂了但是你問他說你對這一篇的作法你有沒有什麼想法沒有因為他把它當作test book他要想法一定要怎麼樣一定要你要給他一個就好像說你讀了這本課本你給他一個習題然後你這樣去解題他才會試著去解他試著去解基本上他的思路就會被侷限在一個框架裡面如果說你沒有把你的思考的

就是說你沒有把你的思路侷限在一個框架裡面你就會去質疑說這樣子到底好不好這樣子到底對不对為什麼一定要這樣子其實要做研究的話就會比較容易也會比較有一些新的idea你新的idea你不是說只有做研究實際上歐美他們很多公司他們的high end product都是研究的成果他們不是像我

們現在台灣大部分的公司就在那邊做那個血汗錢他Hire了一大堆Master然後在那邊做他們都說那個學校的研究跟我們這個沒有太大的關係就是如果那個產業講這種話你要小心一點那大概就是你進去做大概就是賣勞力不是賣基本上就是你需要用你的工時來換你的production如果說他需要用工時來換你的production這種產品的價值一定非常的

低可是我們台灣現在大部分的那些大老闆他們習慣就是用這樣子的模式，his就是用這樣因為台灣便宜、 台灣人工很便宜。你在美國矽谷，你Hire一個Master，你在台灣大概可以Hire四個貴一點，大概三個，你三個打一個，你打不贏人家嗎？我們Quality不錯的對不對，怎麼可能三個打不贏人家，所以他們做的Product一定是做High-end的Product，他們High-end的Product就是他們的Innovation，他們就是著重他們的Innovation，

這個文化上面的差異最主要就是在這個地方，所以同學要了解這一點，說以後，不管是做research或者是你要創業幹什麼，其實最重要的就是一個idea，這是一個idea，有一些idea需要一些非常solid的一些background，有一些idea是需要貼近生活面，你貼近了群眾的生活，它的experience，你才會有一些idea，像Steve Jobs基本上他就是靠貼近民眾的生活的experience，他有很多很好的idea，但是有些idea不是天馬行空，所以有一些同學就是現在鼓勵創業趕快去創業創業是很辛苦的一件事情，

創業不是說你完全不需要任何的一些基礎的知識，你就能夠創業，你說好像有基礎的知識你就會受到這個框架的局限，其實不是這樣子有一些新的ide a是需要你有一些很solid的一些background的knowledge還有training，那麼based on那些基礎，你才有辦法再去建構更innovative的一些product所以這種東西是不太一樣。你要知道說你的那個行業到底是需要哪一種，你就要把那些東西準備好，大概是這樣子。.