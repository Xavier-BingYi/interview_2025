undefined
我們來看一下就是我們上一次跟同學介紹到這個1-bit的LU我們上一次的1-bit的LU它具有的功能就是基本的NO還有加減法我們現在要再把LU再把它加入setless LAN的功能這個setless LAN的話我們知道說這個指令基本上它就是比較兩個operand看看說看它是不是a小於b如果是

a小於b的話它會把某一個register的值把它設為1所以我們這邊要做的實際上就是第一個要比較這個a跟b它的大小第二個是要output這個0或者是1就是說如果說它是大於等於的話它是output 0如果說它是小於的話它就output1所以我們從這邊基本可以看得出來說我們的output值它的差異一個是output0 另外一個是output1所以它的差異就只有差在LSB這個bit其他全部都一樣其他全部都是0所以我們在這邊就知道說

我們在setless LAN它的output的產生我們只要去控制LSB這個bit它的差別就是一個是0一個是1這個差別在什麼地方呢我們當然要先找出這兩個的差別我們才能夠知道第一個如何偵測它的差別已經發生到底要輸出0還是輸出1因為如果說它是小於A如果是小於B的話它是輸出1

我們知道說在這邊我們不會有一個comparator去做AB的比較，我們AB的比較，我們一定是用A減B所以我們在這裡面第一個，我們知道說我們是用A減B去做AB的比較，所以既然是用減法做比較的話，你如果說A小於B的話，A減B，它是什麼？ 它是負數，如果說a大於等於b的話，a-b，它就是一個

非負數，是0或者是大於0的一個數，所以我們就從這一邊，我們就可以了解說我們做了一個a-b然後要做setless length，它們最主要的差別就是在a-b的結果，如果是大於等於0的時候它就是輸出0，包含LSB這邊要0，如果是A小於B的話，A減B，它會小於0，它小於0的時候，它的LSB這個bit要設為1，大於等於0跟小於0的差別在什麼地方呢？它的差別當然就是在A減B那個結果，它的sine bit對不對差別就只有差sine bit

當你a小於b的時候，它的結果是小於0，所以它的sin bit會是1，它的sin bit會是1，sin bit會是1，它的output要是1，所以剛剛好，我們從這一邊，這個巧合，我們就可以知道說我們可以利用a-b，它的結果的sin bit來當作這個output lsb，它的value就是這樣子，我們從剛剛的這個討論，我們就可以得到一個結論，就是

說我們這個setLessThan，它的output，它的output第一個bit到31個bit，這些全部都是0，那第32個bit第0個bit就是LSB那個bit就是我們就直接拿a-b這個結果它的sine bitsine bit來output來設定這個LSB這個bit所以根據我們剛剛的一個結論的話我們就可以來看它的結果就是長這個樣子那這一個cell呢這

個cell是非MSB的這個每一個bit的cell大概都是長這個樣子就除了MSB那個bit之外每一個bit都是長這個樣子其實就是我們剛剛之前的那個結果只加了一個什麼呢加了一個less同學可以回憶一下 之前它的 output 有三個選擇一個做 am 一個做 or 一個做加我們現在除了 am or 還有 java 之外我們又多設了一個 set less thanset less than 我們就多加了一個選擇你如果是 set less than 的話它的 output 就是從這邊進來 然後從這邊出去所以這是非 MSB 的 bit

它就是長這個樣子就多了這個less所以我們根據剛剛的結論我們知道說這個從第一個bit到第31個bit的這個less都要設多少都要設0全部都是0除了這個LSBLSB這個bit它的less呢它的less是從哪邊來呢MSB的sine bit其實就是這一個這個是MSB它的cell長得比較不一樣差別在什麼地方

呢因為它是MSB所以它要去 check第一個，它要check有沒有overflow這個MSB這個bit其實也就是sine bit所以同學可以看到它要check有沒有overflow這個overflow detection它需要知道就是說需要知道AA的sine bit它也需要知道B的sine bit它也需要知道說這個A加B這個cell MSB這個cell它負二A的加完以後它的carry out然後還有它的sum就是透過這樣子來判斷它有沒有overflow有沒有overflow我們等一下會跟同學介紹它一個簡單的判斷機制這個set

我們就是直接把這個sin bit直接sin bit拉到什麼地方呢拉到LSB的這個LAS拉到LSB的這個LAS所以我們如果來看整個32個bit同學可以發現這個是MSB 這個是LSB所以這個是它這個A-B之後它的sin bit在這個地方sin bit出來它就直接拉到這邊LAS所以這是LSB的List其他的BitCell它的List全部都是0透過這樣子的設定如果說A小於B的話這邊就會輸出一個1因為A減B是負數所以Sidebit是1所以這個Set它會是1所以這個1就出來所以它就會變成

如果是a小於b這邊就會輸出e所以這邊就是e其他全部都是0所以我們可以看到它的output是多少呢全部都是0只有LSB是e所以它就會輸出一個e如果說a大於等於b的話它的sin就會大於等於0所以它的sin是0sin是0的話這邊就會寫入一個0所以它的output就全部都是0就是這樣子所以這就是我們再加了一個setless length的這個功能最主要就是我們這邊看到的這邊同學有沒有什麼問題那我們繼續再往下

我們在這邊看到一個簡單的32bit ALU它的final version其實就是我們剛剛的這個然後再加上這個這個我們知道說我們在CPU裡面常有一些frag這邊有一個frag detection這個frag就是0frag0frag我們知道說如果這次的運算它的結果是0的話那我們的0 fret它就會是1所以如果說它是0每

一個bit都是0所以你這個0這個0 0 0 all之後它就是0然後再加一個not它就會是1有一些CPU早期的CPU比較多所以各家的規格都不太一樣現在CPU剩下少數幾種有一些它如果是寫一個0bar0bar大概就表示它如果是0的時候它這邊輸出是0所以它這邊又加一個bar所以你要看一下它的規格看它這邊到底是怎麼寫的所以這裡沒有就是最後的版本跟剛剛的version是一樣只加了一個 0frag就是這樣子

我們在第三章前面先讓同學了解一下一個簡單的32 bit的LU它的設計後面我們就要跟同學介紹在CPU裡面它的加法、減法、乘法、除法還有14 point的number它的表示方式我們會介紹一個ITPoE的standout這個同學大家都知道了就是我們在做加法的時候我們這邊是一個Binary然後就是從LSB

開始加然後它會有一個這個Bit會有一個Carry out所以這邊它就是一個Full A的那當然這邊如果有一個Carry in它也是一個Full A的所以它就是每一個Level這樣一直加一直加然後它的Carry就一直Propagate從LSB往這個MSB就往左往MSB這個方向去做propagate這種加法的方式我們都很清楚其實我們這邊要討論的其實就是說

通常我們比較concern的是說我們在做加法的時候我們怎麼知道說這個加完之後它有沒有overflowoverflow我們知道說基本上就是我們在表示這個數字不管是unsign或者是sign我們都有固定的bit number固定 bit number 你要用一個 format 去表示一個數字總是有它的 range你如果說你運算完之後產生的數字它的大小已經超過你的 format 的表示範圍其實這個就是所謂我們是說它有 overflow 的發生、overflow 的 detection。 其實我們很簡單只要就是說它這邊說加，所以加它把它

分成有很多種、就是說正加正，然後正加負或者是負加負或者是負加正所以它分很多種。 Anyway， 不管分成哪幾種case，其實我們最後，我們都會變成就是一個，我們就是會變成就是同學可以把它想像成兩個number的一個相加，它有它的一個sign，它有它的sign，就是它是正的還是負的同學可以想像、就是說我們要讓一個運算產生overflow，一定是什麼呢？就是正加正或者是負加負對不對你。如果是正加負或者是負加正或者是怎麼樣基本上

它就是都在這個 range 裡面，在那邊跳它不會有 overflow。所以其實我們要 detect、說一個 Java 的 overflow，its實很簡單，我們只要了解說這兩個 operand，它的 sine bit 到底是多少，它的 sine bit，如果是一樣的話，它才有可能有 overflow。如果這兩個 operand它的 sine bit 如果是一樣的話它才有可能有 overflow如果這兩個 operand 它的 sine bit 是不一樣那它絕對

不會有 overflow。所以這是我們第一個得到的一個結論、第二個結論是什麼呢？ overflow就是表示說它運算的結果已經超出我們的format可以表示的這個範圍，那就表示什麼呢？正加正，它產生一個什麼數呢產生一個負數正加正產生一個負數其實就是我們剛剛提到的它的運算結果。正加正應該是正結果，它變成一個負其實就代表什麼？代表說它已經就是overflow發生超過我們可以

表示的這個range那一樣是負加負那如果說負加負它一定是要負如果負加負它得到一個正數所以它也就overflow。所以我們要去探討說你的這個加法跟減法到底有沒有overflow其實我們只要follow我們這一個剛剛討論的方式，那你減法也是一樣。你如果說減法，its實很簡單，我們就是把這個減把它帶到這

個number裡面。最後都是把它變成是一個什麼加什麼叫A加V那你A到底是正那V到底是正還是負最後不管你是加法減法最後都是變成一個A加V的形式然後接著就去探討說A跟V它的sine bit一不一樣就是這樣子所以這個就是在這邊他寫了一些例子在介紹我們的整數的加跟減。你要

去detect它的overflow到底要怎麼去做一個detection我們就根據我們剛剛的討論，我們就是最後都是用一個加的形式來看待這樣子就可以了。所以接著我們這邊他有提到說其實有一些language，它並沒有說你有overflow的時候，你必須要這個exception它一定要去call這個exception做這樣子的一個處理它這邊有提到說比如說像這

個C比如說像C它ignore overflow所以說你如果是在MIPS裡面的instruction跟它相對應的一個機制的話就是在這邊我們就是在MIPS裡面都是把它當作是一個類似是一個insign這樣子的話它就不會去check說它到底有沒有overflow另外的language它這邊提到這個ada或者是4-chain如果說你有 overflow 的話大概是需要 exceptionException 我們都知道就是發生了一個特殊的 event發生了一個特殊的 event我們就根據 event到底是哪一種 event然後去做特殊的處理其實就是去 call

額外的 function然後它來處理 exception 這個 event在 MIPS 裡面大概就是 add它就是有 sign把它看作是有sign的一個數字或者是ADDI就是immediate這邊有提到就是說有overflow的話基本上它就是要去invoke這個exception的handler它就是一個特殊的一個routine當然你要去call一個routine你必須要先把你產生這個exception到底是發生在什麼地方你要把它save起來把它save把這個program counter

就是發生exception的位置把它save到這個叫EPC叫Exception Program Counter Register然后save之後save之後就再jump到在predefine已經定義好的這個handler的一个位置最後再把這個EPC的这个值再透過這個instruction再把它restore到這個PC里面就是你的handler已经处理完之后然后再跳回来所以這個是這邊先做一個簡單的一個介紹所以這個是我們說overflow的一個處理方式在課本裡面它有介紹就是說

我們用這個MIPS裡面我們可以如果說你要寫這個overflow detection針對sign或者是unsign它的這個加法的話這邊有兩個這個procedure上面這個是detect這個sign的這個加法有沒有overflow下面這個是detect這個unsigned的這個加法到底有沒有overflow我們來看一下這個上面的就是有signed的這個edition根據我們剛刚的這個介紹觀念的介紹我們知道說其實我們就是專門去看A跟B還有A加B這个結果它的signed bit所以我們在這裡面我們就

這是根據我們剛刚的簡介介紹的觀念就是t1加t2所以他先判斷說 t1跟t2，它的sin到底是不是一樣，所以我們這邊就把t1跟t2這兩個input做一個excuse all那excuse all，我們這邊當然就只有看什麼呢看sin，如果說是正兩個都是正或者是兩個都是負做excuse all它的結果是多少呢，它的結果就是sin bit會是0。

你如果是一正一負去做excuse all的話，它的sin bit會是1也就是說你如果T1跟T2 excuse all完之後，它得到的結果是一個負數的話，這個鐵定不會有overflow絕對不會有overflow所以他這邊就是告訴我們說，如果他得到的數是一個負數，也就是說A跟B的sine bit是不一樣，他就保證不會overflow。如果A跟B的sine bit是一樣，它不見得會overflow，所以他就還要再把T1 T2加完的結果存到T0。他把結果這個T0跟T1 他們兩個的sin應該要一樣，

他們兩個這邊就是比較T0跟T1他們兩個sin要一樣的話，那這個就產生overflow就是這樣子，所以這個就是這個sin的一個簡單，它的一個procedure。我們先休息十分鐘我們再來看這個unsign加法的overflow detection它的code就是很簡單，因為它的觀念其實就是它的觀念就是這樣子比如說我們說有4個bit，然後這個就是有一個數0. 100，這四個bit我們如果說要加另外一個數，就把0.

100加上另外一個數加完之後不會有overflow，那個數最大是多少我們知道說其實，如果是很散的話，它的最大數就是11. 1對不對它最大數就是11. 1全部都是1所以我們把這個全部都是1，然後說它最大的數就是這樣子你把一個數a要加上某一個數最大不能夠超過11. 1所以它最大能夠加的數是多少就是a bar最大能夠加的數就是10.

11就是這個數所以對於0. 100這個數而言它所能夠加的最大的數就是10. 11你只要是超過10. 11的話，一加就overflow已經超過它能夠表示的範圍就是4個1就是11就是這樣子所以這四行的這四個instruction它要做的就是這件事情所以我們說它做一個NOR T1，它把這個T1做一個根臨做一個NOR那T1根臨做一個NOR得到T3這個T3它就是什麼呢，就是T1 bar所以當然你就要比較這個T3就是T1 bar你就要比較這個T2

大於T3 也就是T2如果大於T1 bar的話它就overflow 就是這樣子所以它的這個觀念就是用如果是很sign的話就用這種方式來偵測我們這個Multimedia的部分我們跳過去因為這邊大概介紹的部分非常少，大概同學可以參考一下這個課本我們接下來再來看乘法乘法的部分。 kitaunter我們首先我們先從我們以前小學的時候開始教乘法。我不知道你們現在乘法是怎麼教，我們以前是這樣教的，好像聽說以前你們有上過什麼有一種新的教學法，不知道是什麼

教學法，那個不知道是不是這樣教法。我們以前是這樣教的，所以就是我們在子上面就是1,000乘以1001，我們就開始，就是這個1對過來就1,000然後這個0就0，然後這個0也是照抄這個1的話，就抄1,000唯一的差別就是我們抄下來，我們說這個乘數被乘數，我們根據這個乘數它的bit的位置去把這個被乘數，把它抄下來1的話，

把它100領超過來，如果是領，就copy領，所以把這個位置要對準對準之後就開始加一個column，一個column一直加由右往左加，然後它的carry out就一直往左做propagation，這就是我們知道的乘法，所以我們可以看到乘法，其實就是用加法把它加出來的當然，我們在computer裡面，我們一般的computer裡面其實它也沒有所謂的懲罰

器，只有那一種有特殊需求，有特殊需求對那種懲罰非常sensitive，它必須要做快速的懲罰的時候，它可能會有這一種Special hardware就是所謂的Multiplier真的是一個Hardware的懲罰器一般我們就是用加法就是用這樣子一直累加所以我們在這裡面看到的我們看到的第一個我們要知道說這個product它的bit number它的product length的sum所以我們如果說4個bit 4個bit我們這邊大概就是要這個product register你就必須要reserve這個8個bit給這個兩個4個bit的乘法它的結果來儲存第二個

我們知道我們在乘法裡面一定會用到 shiftshift 從這個地方就可以看得出來我們可以知道說其實它這個移位移過來 往左移 往左移 往左移這個就是 shift shift left在這個地方同學要了解的就是說我們先跟同學講一下這個觀念這個觀念就是什麼呢我們可以看到說因為等一下乘法出法都是用同樣的觀念我們看上面跟下面它們之間假設是差了一個bit所以我們會很直覺地說什麼呢我們就是把下面這個number往左shift一個bit 對不對

就把它往左shift一個bit往左shift一個bit之後呢就可以做一個相加的動作可是我們反過來我們也可以看說其實我們不是把下面這個number往左shift一個bit我們是把上面這個number往右shift一個bit它們的效果是不是一樣的對不對 效果是一樣的所以我們等一下後面再看的時候我們要對整個multiplier它的howell做這個最佳化其實我們就是用這樣子

的一個觀念。你可以往左shift你也可以往右shift只是看說你要shift的number到底是誰。如果是shift的下面這個它就是往左shift。你shift的上面這個它就是往右shift。它們都是有同樣的效應跟效果。所以我們根據我們剛剛介紹的乘法這個觀念的話我們就可以來看一下我們提出第一個版本要完成這個乘法。它的 hardware 到底要長什麼樣子首先我們這邊有這個就是這個倍乘數它是 64 個 bitLu 它也是 64 個 bitProduct 它也是 64 個 bit另外 Multiplier 這邊是 32 個 bit。

那為什麼它這邊是要64個bit呢？因為其實它是完全因為它的架構的關係。比如說第一個，它的product是64個bit，因為我們是32x32所以是64。 Product 是64，所以這邊product是 64。那我們說這個 product_it 是 Lu寫進來的，所以這邊 LU也是64bit相加那另外這一個這個倍乘數它每次都要跟這個 product register再做一個相加product 就是指這一個這一個 然後再加上這一個這一個的結果再加上這一個然後這三個相加的結果它是存在 product register之後再加上這一個所以它一直在做這個 64

位元兩個 64 位元的 bit number 的 addition所以這三個 register 全部都是 64 個 bit一開始它的這個倍乘數它是存在這個multiple register最右邊所以如果是32 bit它就是32 bit就存在這個地方然後multiplier這個乘數它是有另外一個multiplier register它存在這裡這個multiplier它為什麼要做shift right呢因為根據我們剛剛的 operation 這個過程它是第一次 scan lsb

接著再往左 循序的往左做 scan再來看這個 bit 再來看這個 bit 再來看這個 bit所以我們要 sequentially 從 lsb 到 msb 去看它每一個 bit我們的方式就是 shift right你每一次都看這個 multiplier 這個 register 它的所以你就可以sequentially從LSB到MSBone by one一個接一個然後去看它的值到底是多少看它的值多少要做什麼呢當然就是它如果說這個是1的話你就是要加1000如果這個是0的話你就是加0所以它就是看這個bit

就看這個multiplier 最後變這個bin如果是1的話呢它大概就是會把這個數把它加進來如果這個是0的話它就是加一個0它可能就是加一個0 就是這樣子加一個0其實就是不加的意思加0就是不加的意思所以這個就是它的一個structure我們就是在這邊由最右邊的LSB bit給control的circuit讓它來決定說它要不要把這個數加進來另外control也會控制說它每次加完以後這邊就要往右shift一個bit這邊要做什麼呢同學記得吧

假設我們是1001當你是scan到1的時候它就是直接把這個1000直接把它加進來加進來之後我們scan下一個bit所以它會變成0100這個是0所以它不用加但是呢你必須要把1000往左shift一個bit讓它變成1000這邊多一個0往左shift一個bit這邊不是往左shift一個bit 對不對接著它在這邊往右shift一個bit0010這邊是0所以它也不用加但是這邊它必須要再往左shift一個bit1000

所以這邊填了兩個0最後這邊再往右shift一個bit我們就可以看到說這個是1這個是1這個是1的話這個時候我們就必須要把這個把它加進來我們就必須要把它加進來所以我們在這邊其實總共shift了這邊應該shift了三次所以這邊應該是1 0 0 0因為它這邊有三個bit所以這邊要shift三次一次、

兩次、三次所以shift三次最後才把這個值加到這個product所以我們這邊shift left它的用意就是在這個地方因為當我們看這個bit的時候它不用shift這個倍乘數它不用shift當我們看這個bit的時候這個倍乘數它必須要shift一個bit當我們看這個bit的時候這個倍乘數它必須要被shift兩次當我們看最後一個bit的時候這個倍乘數它必須要被shift三次它必須要shift三次 往左shift三次這樣子的話這整個structure它就可以搭配我們左邊的

這個乘法它的運算的方式所以這個是我們看的第一個版本的乘法器這邊同學有沒有覺得需要討論的如果沒有的話我們就繼續再往下看我們就是把我們剛剛的一個描述我們利用一個flow chart把它這個描述出來就是配合我們剛剛的這個Structure這個乘法記它的硬體的一個架構我們就說我們一開始呢我們就是Test Multipliering這個Test Multipliering就是Test這個Register的LSB所以Test的LSB那它如果是1的話呢你就必須要把這個Multipliering把它加進來把它加到這個Product Register

把它加進來，如果是0的話你就不用加這邊就不用加其實同學可以看到就是說我們在這裡面我們這邊沒有控制它要不要加其實控制的是什麼呢我們是控制這邊到底要不要write它要不要write反正它加不加對它也並沒有差別只是說你加完以後結果你不要寫進來就好所以這邊這個write就

是這個control circuit來根據我目前的這個LSB，它如果是1的話它就會write enable你這邊如果是0的話這邊就write disable它就disable把它disable掉之後這邊的加其實它並不會寫進來其實就是等於它沒有加就等於沒有加就是這樣子接著我們這邊做過一次加法有加沒有加不管他到底有沒有做加法接著他就把這個multiplyer的register往左shift一個bit，他接著也把這個multipliershift right一個bit這樣子就是一個iteration就結束一個iteration他就是處理一個bit

處理一個multiplier一個bit處理完之後就回到這邊然後再test multiplier0一樣是test這個multiplier register的LSB，因為它已經shift right所以實際上你已經0 1 2 3這樣子sequential去Scan這個multiplier的每一個bit所以這一頁我們就是把它formal的用flowchart把它表示出來剛剛的這個版本實際上它可以再最佳化再把它做得再好一點那怎麼做好一點呢基本上我們第一個

想到的當然就是Hardware的這個Resource我們希望說讓這個Hardware的Resource可以讓它不要用到那麼多的Register所以我們可以來看說我們前面這邊都是64, 64, 64只有Multiplier是32個bit其他都是64 bit我們有一個optimized的multiplier同學可以發現說第一個multiple register它受升成功從64變成32 bit multiplier不見了然後LU是從64變32我們也把它精簡cost 就是cost down

這個product在這裡沒辦法精檢它一定是64它就是64 bit所以我們就可以發現說這個optimized過後的multiplier怎麼會長得這麼奇怪呢我們看不到它的multiplier register其實我們同學應該可以猜得出來它不見得一定有地方存那什麼地方可以放呢就只有這個可以放它沒有別的地方可以放從這個架構來看它沒有別

的地方可以放所以只有這裡這裡可以放呢我們應該可以知道說它就是放在右半部因為我們這邊有一個shift right的actionshift right很明顯就是它要去sequentially scan這個multiplier的LSB所以這邊是叫shift right所以我們把這個multiplier放在這個地方既然放在這個地方的話可是我們說product register必須要64個bit那product register現在只剩下32個bit那怎麼辦

怎麼辦呢我們就回到前面去看我們回到前面來看同學可以看看就是說我們再來分析說這個方法第一次加完以後這個就是 product product 4個product 我們假設都是 4個 bit這個 product register 4個 bit第四加完以後呢同學可以來看說我們在加第二次的時候加這一個這兩個數相加的時候這個 bit 會不會變這個 bit 會不會變不會變它已經

它已經固定 它最後的結果已經出來了所以這個0呢你已經不需要再把它放到java裡面去做運算你不需要那你既然不需要的話呢我們可以shift right把它shift right到什麼地方呢shift right到product register的右半部我們等於就是把product register 64 bit把它看成2個32個bit把它看成2個32個bit一開始Initially 一開始就

是它的左半部的 product register左半部的32 bit是設為0右半部是存Multiplier右半部32 bit是存Multiplier當你第一次scan這個Multiplier的LSB來決定要不要加之後第一個bit處理完之後這個bit就沒有用了 它已經固定了固定之後 你要處理第二個 bit 之前我們不是整個 product register64個 bit 全部都會往右 shift 一個 bit所以這個 bit 它就會被 shift 到右半部的 register然後第二個 bit 就是變成這邊當然會填一個 0就是等於這四個 bit 相加相加完之後

這個 bit 的最後結果也固定了當我們處理第三個 bit 的時候呢這個已經固定了所以我們在把整個 product register 往右 shift 的時候呢這個又會 shift 到這個右半部然後接著第三個呢當我們處理第三個 bit 的時候就是這個再跟這邊相加這邊也是填一個 0基本上它的觀念就是這樣子所以我們可以看到它

一開始就是initial這邊會設為0然後這是multiplier然後接著它每一次加完之後它就是往右shift一個bit最後整個加完之後，整個Multiplier全部都清光就是這邊，它會從Shift出去，不見了；然後，整個Product左邊32，右邊32，就是最後的Product結果，是放在這64個bit它的觀念，就這個樣子。我們用一個例子來看，我們用一個例子來看，就是我們假設這邊是1,000；然後，這邊是10,11；

這邊一開始是10,11就是這樣子；然後，一開始這邊左半部就是設為0，第一個bit是1，所以我們就把這個1,000，就把它加到Product裡面，所以Product這邊就會變成從0變成1,000；右半部還是保持它是10,11算完之後Shift它Shift往右Shift 一個bit所以它這邊這個1就不見了，所以這個0跑到右半部，所以它就變成

01,01然後，這邊往右Shift，所以這邊是塞一個0，所以它Shift往右Shift一個bit之後，這邊它的Product就變成這個樣子；接著，它再看這個bit，這個bit是1，所以它也是要加，所以你把1,000再加進來，加上0,100加完之後就變成11,00然後這個值還是不變，所以在這個情況之下，它的Product實際上是長這個樣子；然後，它的

Multiplier剩下3個bit，我們要再往下進行的時候，整個Product register再往右Shift一個bit所以往右Shift一個bit這個時候整個product它的完整的內容是我們圈起來的這個數然後multiplier剩下這兩個bit接著我們再scan lsblsb它是0所以這個時候你就不需要做加所以你這邊它還是維持01 00接著再往右Shift一個bit

Prada就變成這樣子Multiplier就剩下最後一個bit因為它是1所以再把1000再把它加進來它就會變成1011就是把這兩個數相加它就會變成1011最後再把這個Multiplier殘留的最後一個bit MSB把它Shift出去所以它就會變成然後左邊填一個0這邊01011000最後這一個才是完整的product就是4加4是8個bit最後一個完整的product所以我們可以很簡單驗證一下我們說這一個數這個是8然後這一個數是多少3

11所以它是88所以乘起來是88那88呢這是2 4 8 16 32 64所以這是64再加上一個16那就是80再加上一個8就是等於88所以它們的結果是一樣的所以這裡使用的觀念其實就是我們剛剛提到你可以把倍乘數往左shift但是它的代價就是你的這個multiplicate它必須要64個bit你如果不要把它往左shift的話相對的你必須要把product往右shift剛剛好我們從前面這邊的例子，我們看到什麼樣的結果就是它沒處理完一個bit這個product的LSB，

它就已經固定了，所以我們就可以把它shift到右邊去這個bit處理完，就把它shift到右邊剛有這個特色，它有這樣子的一個性質，這樣子我們就可以把整個multiplier optimize成32、32、64然後這邊還可以省掉一個32個bit的register，所以這個是我們第二個版本的Multiplier同學這邊有沒有問題沒有問題就再繼續往下看這個例子同學回去自己trace一下，因為就是用我們剛剛的方式應該可以很順利的把它trace出來，我們就不再

再確實一遍這一個我個人認為它是錯的，我有跟其他老師討論過他們也是覺得這張圖怪怪的，我是認為是錯的，所以就不要管它了，如果同學說認為這是對的可以來跟我討論看看你覺得它為什麼是對的，基本上我們要做這個，我們要做快速的，我們這邊可以回到這邊，這邊忘了跟同學提他這邊就是他這邊有跟同學提到說，我們可以，我們可以把這個，就是說再加做加法跟做shift，我們可以讓他 impera，就可以去進行這樣子

的一個動作，就是讓它平行的去進行加跟這個shift，實際上我們可以看到說，這個operation，它是sequential什麼sequential呢我們是說把這個加我們把這個結果放到這邊來然後做加法加完之後呢結果存到這邊來然後我們再做一個shift的動作這shift完之後下一個iteration它才是feedback回到這一邊然後再做一個加的動作如果說你想要讓它這個加跟shift可以同時進行的話很明顯怎麼樣

呢同學必須要把這一邊feedback回來的時候你必須要做一個位移的動作什麼叫位移的動作呢譬如說這邊 di 個 bit 是接到這邊的 di 個 bit你要往右位移的話你這邊 di 個 bit 你就要接到這邊的 di-1 個 bit這樣子它就可以有 shift 的一個效果它並不是說 shift 完之後再 feedback 回去做一個加的動作你要讓它同時做的話你可以用這樣子的方式就是這邊的結果第二個 bit

接到這邊 i-1個 bit 的 input這樣子它等同就有 shift 的效果這樣子的話我們可以讓這兩個 operation可以 impair 同時去進行這樣子速度可以比較快所以這邊是他這邊提到的就是說我們要讓這個 multiplier 更快速的方式同學如果有興趣可以去查這個multiplier它有很多paper就是要如何設計比較快速的multipl

ier它有很多的方法實際上如果我們不討論那麼advanced的top ic的話，我們可以說我們要讓multiplier更快的方法其實就是你讓加法變快，因為我們剛剛的整個過程其實它就是一直在repeat加法 對不對。他一直在repeat加法。我們只要把加法讓他變快，整個multiplier其實他就變快。所以，我們這邊，我們讓跟同學介紹一個，就是currylookahead的一種觀念實際上，這個加法有更好的加法。其實，我們都可以看得到這個作者，他已經把currylookahead從課本把它拿到，

如果沒記錯，應該是已經放到光碟片裡面去了。但過我們就是用欣賞的角度來看一下說早期，我們在improve這個加法的速度的時候，我們如何把這個carryripple carry來speed up，這是一個很好的一個學習的一個教材。所以，我們還是跟同學介紹這個carrylookahead。我們都知道說，我們在一般傳統在做加法的時候，它會有這個carry out的問題。 carry out的問題，就是說

這個beat加完之後，它的carry out變成下一個beat的carry in然後再一個full header然後，它有這個sound還有carry out，再變成下一個beat的carry in就是這樣子。所以，我們如果要最後這個MSB這個beat，它的加要完成，你必須要等什麼呢你必須要等它的carry outpropagate從最右邊LSB一直propagate到最左邊MSB它的carry in ready之後它才可以做加法加法之後它的sum它的carry out才會出現就是這樣子當然我們知道說Hardware其實它不會等

它會不會等 實際上它是你一turn on之後它就一直做 它就一直做加的動作它只是說每一次output出去的結果都是錯的它只有到這一邊最後這個carry in ready之後它這個output的結果它才是正確的那我們如何去消除這樣子的一個就是說等待前一集的carry in我們就來看我們就必須要介紹兩

個觀念第一個叫generate另外一個叫propagate我們先來看說它的加法大概是怎麼推導我們知道說每一個level每一個bit每一個bit level它的carry out這是什麼呢ci加1這是什麼bi and ci或者是ai and ci或者是ai and bi其實就是說我這一集的-2a的它有三個input就是兩個input再加一個carry in這三個input任兩個只要是任兩個都是1的話我在這一集就會產生一個carry out對不對

就會產生一個carry out就是這樣子我們把它就是把它寫成這樣子的一個形式把這個C把它提出來為什麼要把C提出來呢因為在這個equation裡面我們要把受到前一級影響的關係把它獨立出來前一級是誰呢前一級就是CiAi跟Bi是這一級的input這個Ai跟Bi它的值就是我們的兩個input number所以它不會受到前一級的carry-in影響所以這個是independent of carry-in

我們把carry in提出來就長成這個樣子所以我們說C2它是什麼呢C2就是A1 and B1或者是A1加B1然後and這個其實就是C1C1是前一集的carry out我們就把前一集把它展開來展開來它就是長這個樣子它就是長這個樣子所以我們說C2實際上它就是等於A1 B1 A1 B

1然後這邊A0 B0 A0 B0最後再加上一個C0它這樣子的一個形式這個形式我們先不要管它我們先還是回過頭來看這一個這一個我們就把它定義一個叫generategenerate就是A I and B Ipropagate是A I or B I它的意思是什麼呢它的實際上的意思是說generate就是說我們看這個generate我們就可以知道說它有沒有

產生這個carry out比如說AI跟BI它如果都是1的話我們就可以確定這一集有carry out所以你如果generate是1的話generate是1就確定這一集它的carry out一定是1所以它叫generate它是1就可以決定carry out是1如果說generate是0的話generate是0不見得這一集的carry out是0它還要去看propagate還要看propagatepropagate是什麼呢propagate就是說如果前一集的carry out這一集的carry in是1的話

是1的話那這一集的carry out就是1所以propagate如果等於1再加上這一集的carry in也是1兩個1那你的這一集的carry out自然而然它就是1所以這個propagate它的意思就是你還要看這一集的carry in就是前一集的carry out所以這個是在這一集就可以決定了就可以決定我們這一集的carry out那這個propagand呢我們就是還要看前一集的carry out才能夠決定這一集的carry out到底是多少所以這樣子

同學就很清楚啦所以我們如果要知道我們這一集的carry out到底是不是1第一個看generate它的ab這兩個input都是1那它carry out一定是1那如果說它的generate是0的話呢我們再來看這個prop agandpropagate，它如果是0那就沒有機會了。 propagate，如果是0，它就沒機會了。它這一集的carry out一定是一定是多少，一定是0，因為A跟B都是0，你再加一個carry in是1也沒有用，所以一定要

這一集的propagate，它是1，然後搭配前一集的carry out也是1這兩個genre跟propagate有什麼好處呢？其實我們就是把這個C1寫成這個G0加上P0 and C0就是這個式子。接著，C2我們就是把它展開來，就直接把它展開來同學看，就是這個C1，我們就是把這個把它帶進來展開來就長這個樣子然後，C3呢，我們就是這個式子， 它原始的式子我們把C2用這個結果再把它帶進來展開來整理完之後是這個樣子同學說，你怎麼展

展到最後還是有一個C0可是同學可以看到其他的式子有沒有C1 C2這個variable有沒有C1 C2的存在比如說你在C3裡面你有看到C1跟C2這一個前一集的carry嗎？ 有沒有如果有的話其實就表示什麼呢？你要決定C3，你必須要等到C1 C2都算出來才能夠算C3 對不對就是當你要用這個式子去算的話呢，這個就是所謂的repoator carry是 repo。你要算C3 你要先等C2算出來我們看這個式子是這樣子

可是我們現在看它展開來的式子這個式子裡面有沒有C2 沒有所以你算C3 要不要等C2算出來不用那你算C3 你要不要等C1算出來才能算也不用 因為這個式子裡面你找不到任何C1 C2它只有誰呢C0所以就表示什麼呢就表示其實你要算C3你不需要等前面那一集的carry out算出來你才能算就是說這個全部都可以同時去做運算C1 C2 C3 C4可以同時算

它為什麼可以同時算呢我們就來用白話來解釋這個式子好了我們就白話來解釋說C2它寫成這個樣子它的白話解釋是什麼呢就是說C2呢就是說這一集它的carry out有幾種情況它的carry out會是1呢第一種情況就是我們這一集的兩個input我們這一集的兩個input number都是1G1就是A1、B1A1、B1都是1那

這一集的carry out就是1了如果說你這一集的A1、B1它沒有同時是1的話呢沒關係還有一種情況是什麼呢我這一集的A1跟B1兩個有一個是1兩個有一個是1的話呢P1它就會是1P1它是1的話在搭配什麼搭配它前一集的兩個inputA0跟B0都是1A0 B0都是1其實就是表示A0那一集的carry out是1所以A0的carry out是1就表示我這一集的carry in是1所以carry in是1在搭配其中一個input是1兩個相加

也會產生一個 carry out 事宜的 carry out如果第二種情況不滿足的話那沒關係 它還有第三種情況就是我這一級的 input 要有一個事宜再搭配前一級的 input 也要有一個事宜再搭配前一級的 input carry in 事宜這個情況就好像是這樣子就是說我這一級它的 input 是 0 1它的前一集input是01然後它的前一集的

carry incarry in是1所以我們把這三個一加所以這個1加0加1前一集就會有一個carry out是1前一集有一個carry out是1等於對這一集有一個carry in是1它有一個carry in這個又會產生這一集的carry out是1就是這樣子所以它的一個白話的解釋就是用這樣子去看所以我們也可以解

釋這個C3C3就是我們這一集的兩個input都是1它就會有個career或者是這一集的兩個input有一個是1一定要有一個是1然後再搭配前一集兩個input都是1這樣子你這一集也會有一個carry in失一所以它也會產生一個或者是等於它等於就是說前一集的carry out會失一呢它除了前一集的carry in都失一之外呢也可以

是前一集的carry in有一個失一再搭配它的在前一集，它的carry out失一就是用這樣子的方式一直拆解它就會變成這樣子的一個式子我們有把這個input pattern的一種可能的組合我們把它寫在這邊 同學可以自己參考一下這樣子的一個過程我們就可以清楚了解說C1 C2 C3 C4我們可以同時算出來我們只要based on這個equation

這樣子的equation我們就可以同時把它算出來我們把這個式子列在左邊這裡然後它的這個hardware它的一個logic design我們把它列在這一邊這裡面每一個block它的長相就是長這個這個它是要算什麼呢它每一個bit它都要算它的generate generate是做一個and所以同學你可以發現a跟b ai bi做一個and這個就是g這

個g就是generate然後我們前面講的ai bi做一個or其實我們要做的是一個excuse or就是說a跟b有一個是1a跟b有一個是1所以它這邊是做excuse or所以這邊出來是propagate所以每一個beat level都必須要 generate 它的產生它的 generate 跟 propagate那另外呢 這邊同學還可以看到什麼呢這個還有一個 excuse all這個其實就是做什麼呢就是前一集的 carry in 進來前一集的 carry out然後這一集的 carry in 進來這個就是做什麼 sum 就是做 sum就是 a i b i 跟 c i

他們如果有基數個1的時候它的sum就是1有基數個10加1加0它會是1或者是1加1加1它的sum也會是1就是有sum跟carry所以基本上它這個就是在做一個負2a的只是說一個負2a的我們把它分成它的sum然後還有一個是carry out還有一個carry out就是分成sum跟carry out這一個它就是做一個sumsum的話就是我們剛剛提到的就是ai bi再加上它的carry in ci奇數個e的時候

它的sum就是e如果是要算這一個bit level它的carry out這個式子 用這個式子這個式子它可以同時C1 C2 C3 C4 同時算出來它不是用說C4要等C3算完才能算C4所以我們這邊看到的這個就是我們傳統的repo adder我們傳統的repo adder同學可以看到什麼呢它就是一級一級一級的借過來它要從LSB開始一直算算算算到

這一邊MSB才能夠算得出來所以它的delay就非常的長它的delay從右邊一直往左算一直算算算它的pace的delay就非常的長所以我們說這種repoader就是只能看不能用你用下去的話你就要一直等一直等一直等你bit數目很多的時候那還得了以前8bit還好左邊就有七個右邊就有七個後

來進展到16 bit現在32 bit再64 bit那repoit的速度就很慢我們在這邊看到的這個breakboximplement的就是這四個equation同學來看這個每一個breakbox就是我們上面的這個breakbox它每一個bit level都會產生generate propagategenerate propagate它會產生generate跟propagate所以這邊的G0跟P0就是從這邊來的然後G1 P1 G2 P2就從這邊來那C1呢 C1就是這個式子所以它就是一個end all structure這邊C1就算出來了

這C1就算出來C2是這個式子所以C2是這個NO structure它也是一個NO structure這個式子本身就是一個NO structure然後C3就是這一個那C4呢 這邊沒有畫出來就是類似同樣的就是這邊C4 這邊就出去所以同學可以看到C1 C2 C3跟C4的delay有沒有一樣 都一樣它們的delay都一樣都是一個end note structure這個end note structure在CMOS design它們是可以就是相同的相同style的一個設計就是說幾乎它的delay應該幾乎都是一樣的，所以這個是我們的

就是跟同學介紹第一個version四個beatCarrie Luger的headA的四個bit就是這樣子我們先跟同學介紹一個觀念，因為之後好像我會再公告可能是下下禮拜一就是要去演講所以那一次會停課，所以我們就是先上個十分鐘先上個十分鐘慢慢補回來我們先跟同學講一下就是說這樣子的一個Carrie-Lugar head的架構到底好不好，如果以解決這個repoCarrie的觀念來看的話，這個架構是好的C1 C2 C3 C4它同時就算出來了，它不用去C4不用等C3C3不用等C2

可是我們來想想看說假設說我們是32個bitC32它的架構會長什麼樣子它也是一個anode structure但是同學可以來觀察這幾個anode structure有什麼不同同學看這個anode structure有什麼不同哪一個比較大，這一個比較大沒有錯是誰大是and大還是or大和我們講的大的對象不同不過結論是一樣的這邊and是四個，所以相對or而言

它的 input 的數目是不是也變大了和 的數目變多了你的 all 的 input number 也變多了對不對我們可以看這邊 all 它有幾個 input 兩個這邊 all 有幾個 input 三個那 all 數目越來越多對不對那你 32 bit 那怎麼辦32 bit 怎麼辦你看 all gate 的 input number會變得非常的大這個在 CMOS 的 circuit design 將有什麼作用呢它的副作用就是當一個 gate 它的 input number 數目變多的時候它的 loading 就變大所以它的 transistor 它的 behavior behavior 其實就是 transistor 的 switching它的速度會變慢你的 input number

數目越來越多對那個 GET而言它的Input loading就越來越大它的Delay就越來越大所以這種 Design 32bit用這種 Design好不好?不好 當然不好所以這個就是我們後面要跟同學介紹的就是說這個是要把它變成是一種Multi-Level的 Carry Look Ahead 的一個架構所以我們來看一下什麼叫 Multi-Level我們剛剛看到的是 4-bit Carry Look Ahead Adder我們現在把這邊是 16

個 bit我們把它列出來我們把它列出來我們把 4 個 bit 當作一個 group4 個 bit 當作一個 group同學可以看到這邊就 4 個 bit 4 個 bit 4 個 bit 4 個 bit如果說我們把它看成是 16 bit 的時候其實我們它的carry有repo的effect它就是這樣子一個一個由右往左傳如果說我們把它group成4個beat之後同學可以發現每一個group裡面的4個beat它的carry有repo的效應我們可以用4個beat的carry look ahead來同時產生每4個beat

他們裡面的carry out所以這個可以同時產生這個就是第一個level的carry look ahead可是我們如果看group這個group 這個group 這個group這個group它的carry out是這個group的carry in這個group的carry out是下一個group的carry in 對不對如果以group來看的話這個group的carry out就是下一個group的carry in這個group的carry in它的作用

是什麼呢這個group的carry in如果確定以後它可以讓這個group裡面的這四個beat的carry out同時算出來讓它同時算出來同理這個group的carry in確定以後這幾個它就可以用這個 carry look ahead讓這幾個 bit 的 carry out 同時算出來它的觀念其實就是我們在做這一集的就是最右邊那一集因為最右邊這一集它的 carry in 是 ready 的吸領是已經已知的所以同學可以看我們在看這一集的時候這個吸領是已知的

我們說C0是已知所以這一集的generate propagate都算出來之後我們搭配一個已知的carry in這一集的C1 C2 C3 C4同時都可以算出來所以同樣的觀念我們假設這個group的carry in已知的話這裡面的carry out是不是可以用剛剛的方式同時把他的carry out全部算出來所以它的這個2 level它的idea就是這個樣子它2 level就是這樣子

就是1st level它是在算group裡面的carry那2nd level它是在算group跟group之間的carry它在算group跟group之間的carry所以我們以2 level的觀念來看的話同學記得First level是算group裡面的Second level是算group跟group之間的carry這樣子的觀念有了以後我們就可以來看一下說我們如何改寫它的generate跟propagate因為我們已經把它做grouping所以我們的generate跟propagate它就是一個group generate跟group propagate

group-generate就是指說這個group什麼情況之下它會可以確定它有這個carry out就是G0到G3就是這個group它什麼情況之下會有這個carry out呢就是它完全不看這個C它完全不看前一集的這個C它如何可以決定當然就是什麼呢就是這個level的input都是1的話呢這個carryout就是1對不對右

邊的bit都不用看我們只要看這個bit這兩個是1這個group的carryout就1了如果這兩個不是1的話呢它至少有一個要是1就是它的propagate至少有一個是1再加上它的前一個這個兩個都是1它兩個都是1就會有一個carry in再加上一個是1那這個group就會有一個carry out所以這個就在

描述我們剛講的這個這個就是這個兩個至少有一個是1再加上這個level也是要有一個是1再加上這個level兩個都是1那這個group它也會有一個carry out有一個是e的carry out然後呢 再來就是這個就是這一集 這一集跟這一集它們的input都有一個是e再加上lsb這一集它的兩個input都是e那這樣子也會產生一個這個group也會產生一個carry out所以這個就是透過input oper and就可以決定carry out的general那你如果是

propagate 的話就是我們前面列的P3 and P2 and P1 and P0這個就是propagate光是這個你還沒有辦法決定這個 group 的 carry out你還要再搭配這個 group 的 carry in所以我們產生了 group 的 general 跟 grouppropagate 之後我們就可以導出這個 group C4C4是G03加上P03 and C0這個就是C4這個group的真正的carry outC8就是G47加上P47 and C4你可以把這個C4帶進來最後就可以展出這個式子這個式子同學也可以發現

這個C8它的carry out需不需要等C4也是不用它也都是這個group的generategroup的propagate在搭配最後一個C0所以我們從這邊也可以看得出來它又具備我們前面看到的4-bit carry look ahead的精神就是它的每一個group的carry out都是independent of前一個 group 的 carry out跟前幾集的 group carry out 都沒有關係它就是直接用前幾集的 group generate還有 group propagate然後再搭配一個 C 裡這樣子的話呢我們 2 level 的 16 bit 的 carry look aheadA 的就完成了這個是 first level

這是第二階段我們可以用一個動畫讓同學了解說它的運作是怎麼算的首先它就是剛開始先產生每一個bit level的G領 P領每個bit level的generate跟propagate這個每個bit level的generate跟propagate算出來之後接著它在這一個level 1它會產生group level的generate跟group level的propagategroup level的generate group level的propagategroup level的generate跟group level的propagate算出來之後它會產生什麼

它進到Level 2這個Level 2Level 2它會算出什麼呢它會算出C4 C8 C12C4 C8 C12Second Level它是把這個Group Level的Carry Out把它算出來Group Level的Carry Out算出來之後接著再回到Level 1再把每一個Level 1裡面的這個C5 C6 C7 C9 C10 C11 C13 C14 C15全部都算出來再把它算出來就是這樣子

所以我們根據它的這個flow來看的話就是說同學要了解就是說這一些 Carry我們來看它的Carry它算出來的值的先後順序第一個算出來的是誰呢？正確的值可以算出來的第一個先算出來的C1 C2 C3為什麼C1 C2 C3先算出來呢？因為這個C0本來就是ready的C0本來就是ready所以你的流程第一次下來的時候對1 2 3 4這四個黑二值二元算出了這一個

算出了這一個 算出了這一個 算出了這一個實際上它也算出了這些全部都算出來了但是真正的值是對的只有這三個是對的因為只有C1 C2 C3只有它有正確的C0這個C5 C6 C7 C9 C10 C11這些算出來的值都是錯的； 為什麼？因為他的group carry-in還沒有算出來他的group carry-in這時候還沒有算出來group carry-in是誰算出來的？ 是level 2算出來所以你這邊這個group general group propagate進到level 2以後他的C4算出來 C8 C12同時算出來之後5 6 7 9 10 11 13 14 15接著也就同時算出來

他們的order是這樣子同學如果可以了解這個order應該就表示說已經完全了解這個2 level16個beat的Carrie Lookahead他們的運作方式所以我們再來看一下他的flow就是長這個樣子就是一開始呢beat level的general propagate那之後呢就是進到第二個level進到第二個level它剛剛是產生group level的propagate跟generate這個時候這邊其實都算出來了但是這些值都是錯的因為這些還沒有ready只有這三個是對的接著level 2這邊進來後level 2它把這個level 2接著把

這個C4、C8、C12算出來那4、8、12就是這三個group它的carry-in都ready之後最後也同時都算出來這個就是整個2-level的16-bit carry-look-ahead它的運作的方式我們先介紹到這裡.