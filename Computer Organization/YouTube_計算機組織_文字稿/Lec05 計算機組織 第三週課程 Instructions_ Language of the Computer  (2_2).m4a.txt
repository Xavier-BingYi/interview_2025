undefined
我們第二章要跟同學介紹的是MIPS的instruction set這一部分同學如果有修過assembly language的話可能很多觀念其實都是就是在assembly language那門課裡面應該修過所以我們這邊有一些很快就會跳過去我們今天上課最後上到11點50分然後之後助教他會跟同學介紹第一個就是我們整個CPU Project裡面的第一個子計畫就是我們大概每上到一個單元之後我們就會有一個Subproject做到期末的時候整個兜起來就是一個CPU的Partial Set首先我們來看這個Instruction Set

我們知道說我們computer不同的machine、CPU它都有不同的instruction set實際上這個computer它的instruction基本上就代表了它電腦核心裡面它所能夠support資源的基本指令其他所有的operation當然都是由這些instruction set所兜出來的所以他這邊提到說different的computer它會有不同的instruction set雖然說它有不同的instruction set但是實際上即使有不同的這種ISA

它有不同的instruction set但是很多都會有這一種共通的指令并不是說指它的機器碼是一樣，而是指說這種operation的類別是一樣。比如說我們都會去做register的read跟register的write之類的，所以它都會有很多這一種相同種類那種都是最 primitive 的 instruction而且都是最簡單的。在早期的話， 早期的computer，它的 instruction set 相對的是比較簡單。當然也是因為當時的半導體製程還有 circuit design

上面來講的話，它沒有辦法做到這麼複雜的地步。這邊提到說很多這種現代的 computer，它也是有 simple 的 instruction set這邊指的大概就是指你如果是Risk這種系列的CPU它演化出來的話，它的Design Philosophy大概就是屬於這種希望越簡單越好的這種設計哲學。我们這边介紹的MIPS的Instruction Set我們并没有把Full Set全部都介紹我們大概就是只有比较常用到還有我們會Implement就是我們最後Project裡面會Implement出來的

这些Instruction Set里面我们大概会介绍如果同学要看这个Full Set的话，同学可以看这个课本的附录还有或者是他这边提到的MIPS PS他这家公司他的网页里面应该可以查到他的这个3264bit的Full Set所以同学可以上网到这边来看一下首先我们要介绍这个它的 instruction format 之前我們先跟同學介紹幾個比較常見的 operation根據這幾個 operation我們也可以來看一下說我們在設計 CPU

的時候我們會有哪一些 design principle比如說我們這邊等一下就會看到第一個 design principle我們現在看第一個是最常見的是 arithmetic operation像這種 add a b c它在講說它是把 b 跟 c 相加然後之後把這個結果存到這個A所以這個大家都沒有問題所以幾乎所有的這種 arithmetic operations大概都是這種format就是A加就是B加C把它存到這個A裡面來為什麼它要提供這樣子的一個operation它為什麼不提供B加C加D存到A或者是B加C加D加E再存到A如果說

你要support你要提供B加C加D那你為什麼不support一個array就是A1加到A10或者A1加到A20然後接著再存到某一個結果所以不管怎麼樣我們在使用這種加法的時候你的使用的情況它的便利性非常多如果說我們要去offer各種不同的這種它的變化 使用的變化的話，我們的instruction的

format會變得非常的複雜，所以我們只提供最基本的形態，就是只有兩個相加，然後存到結果存到另外一個register這個就是我們一般都看到的這一種，不管哪一種instruction set都會看到這一種，所以這個就是符合我們第一個design principle，它說什麼呢？ Simplicity favors regularity這個是指什麼東西？它指的就是指說通常，我們如果說，我們

要把這樣子，我們剛提到說它有很多種不同的用法，你要把這麼多不同用法全部都考慮進來，那你的instruction format會變得很複雜複雜的話對設計不是一件好事，所以我們希望說，我們這樣子的一個簡單的format，這簡單的話會顯得說整個這個instruction，它是比較有規則它是比較規則化，有这种规则的话我们在做设计的时候通常这个设计会比较简单，设计比较简单也会让我们设计出来的东西会比较有效，

会比较快，所以这个是连串的因果关系，所以他讲说Regularity，他讲什么呢？他会使得implementation变得比较简单，简单其实就是efficient出来的结果自然就会比较有效通常，我們可以使用比較低的cost來得到更高的performance所以這個就是我們一個instruction簡單的 instruction會帶來後續的這樣子的一個正面的效果，所以這個是我們所要知道的第一個很重要的design principle。所以我們剛剛提到的Java當然不是就

A加B加C然後再存到我們的結果，它可能是G加H再減掉I加J所以它是這兩個相加這兩個相加再做一個減法。所以我們當然也就是只有使用這樣子的一個指令就是J加H存到T0然後I加J存到T1然後再把這兩個相減然後再存到F。所以就是類似這樣子我們的osmetic operation基本上都是兩個input一個output接着Asmetic operation之後我們要了解到的就是說我們剛剛提到的都是I加J G加H可是实际上我們在對CPU而言其实它并不看什麼I、J、

G、H它不看這一類的Symbol。因为這種G、H、I、J是給我們人看的实际上在CPU里面它所有的operand 它都會存在什麼地方呢它都會存在 register我們都知道說它會放在佔領器裡面這 register 就是我們真正的兩個 input它的一個 data source 從這邊來的MIPS 它有 32 個 register每一個 register 是 32 個bit。我们等一下會後面會跟他們解釋為什麼它是 32它為什麼

不要是16為什麼不要是18或者是64或者是50它為什麼不要是這些數字它為什麼要32我們等一下會讓同學來了解說這個是跟它整個instruction format都有連帶關係的它有32個32 bit的register我們把它稱作register fileregister file這個名詞是從risk從risk這種arctecture這邊過來的就是會把最常用的這個data

全部都放在這個register裡面它的編號這32個編號就是從0到31因為CPU裡面它都是number它沒有什麼symbol所以它的每一個register去認就是用這個數字register 0 register到31這樣子總共0到31個這個32 bit就是我們這邊的一個word所以我們這邊一個word是32 bit這是32 bit的一個versionAssembler呢 在Assembler而言我們知道這是一個系統的軟體它對這些register最主要分成兩大組第一大組

第一個set叫temporary values它的naming是T0 T1到T9總共有這十個register這個是temporary的一個value另外一個叫safe variable它是S0、 S1到S7總共8個我們後面會來看說它把分成T跟S series它最主要的用意在什麼地方提到這個register我們剛剛提到說CPU它在operation的時候它的data的source是從register這邊過來為什麼它要從register過來它不要從memory那边過來呢

他这边最主要就是要fit第二个design principle他说smaller is faster他说比较小就是我们size比较小的这种design不管是什么样的东西通常它都是比较快比较快他指的跟我们做一个比较就是register跟main memory来比较的话这个显得意见我们知道main memory它的size是非常的大但是它跟register它的速度相差的話相對的就非常的

慢當然也是跟它的design設計的技術跟方法有關係register它設計的速度設計出來的速度比较快相对的当然它也比较贵它也没有办法像memory一样可以在一个很小的area裡面可以pack高密度的这种记忆体单元所以这种都是它们之間都是有这样子的一個關係它這樣子比較小 比較快剛好符合說我

們CPU的速度通常是最快的所以我們CPU如果說它每一次access data到到Memory的話整個CPU，它的bottleneck就是在等這個data從Memory這邊過來，所以它需要把data放在register來搭配CPU的速度，所以我們前面看到的這個C code，G加H然後I加Z，那我們就是這幾個變數F G H I J這五個變數，它就把它放在S0到S4，S0到S4，總共五個register，所以F在S0然後G在S1，H在S2，I在S3，Z在S4，所以這樣子的話，我們就知道說G加H，它就是S1 S2兩個相加把結果存到這個T0

然後 i 加j，S3 S4 加起來存到 T1然後再把 T0 減掉 T1然後再存到 S0，所以這個就是我們在MIPS 裡面看到的，我們不會看到什麼GRH 這些，我們看到的就是說實際上，我們這邊是使用這種register，它直接是從 register 這邊讀，我們提到register，但是我們知道說register它的size非常小，它只有32個，但我們知道，我們隨便一個array一宣告，我們很少會宣告這種32個element的array，我通常就會宣告很大的一個array，即使不要用這麼多多宣告一點免得overflow掉，這樣子

的使用方式或者是我們用這一種一般的比較compressed的data structure，它當然資料都存在memory，所以我們知道說Mem ory通常都是使用用來儲存比較複雜然後它有綜合資訊整合在一個Structure裡面的這種Data像Array、Structure還有Dynamic、Data這一類的全部都是所有Data都是放在Memory所以我們知道說我們就這邊有一塊很大塊的Memory然後這邊有一個很小塊的Register我們所有CPU要的Data都是從Memory

抓到registerregister只有32個而且你也不能用32個因為它讓你用的只有少部分系統它會保留幾個就是系統它要自己用的所以你只能夠搬幾個到register裡面來所以我們後面在討論的這個章節一個很重要的觀念就是說我們要如何去handlehandle就是說你register你什麼時候要進來什麼時候要出去我們要如何來maintain這樣子

的一個skin其實這個是一個optimization的problem這個不在我們這一堂課的範圍之內我們只是讓同學了解它有這樣子的一個機制因為你要討論optimization那是algorithm的範圍所以我們來看一下就是說它使用這個你要執行resmety operation它就是從memory到register然後再把結果從register再save到Memory在Mips裡面，它的Memory是By address什麼是By address呢？ By address的意思就是說

我們在Memory裡面它一個Address對應到的一筆資料是什麼呢？是一個Byte一個Address對應到的一筆資料是一個Byte，所以它不是一個Address對應到的一筆資料你就可以，它裡面就是存一個Word，一個Word是32個Bit所以我們叫做一個Byte是8個Bit，所以這個意思是什麼呢？意思就是說我們抓到一筆資料，我們要抓一個Word的話，我們要連續抓4個Byte對不對，連續4個Byte48、32我們才會抓到32個Bit這樣子的一個就是所謂的Byte address，

所以同學可以把每一個Address就把它當作就是一個門牌，每一戶都會有一個門牌，每一戶裡面它就是住四個人，就是這樣子，就是住八個人，所以我們這邊提到的就是說，每一個Word， 它就是存在連續的四個Byte這樣子的話，我們就可以知道說，其實因為我們一個Word是32個Bit，我們在談資料的時候，我們都是談一個Word、兩個Word、三個Word、

四個Word，我們很少去談說一個Byte、兩個Byte，我們要去抓哪一個Byte，我們比較少談這種東西，所以我們如果是以Word為最基本的一個單元來看的話我們這個word在memory裡面，它是被align它有這樣子的一個特徵是，words are aligned in memory，它的意思，這個aligned的意思就是說，因為我們一個word，我們會有個起始的位置，例如說

這個word起始位置是0，我們知道說這個0，它其实只抓到一个byte，你要再抓到其他三个byte，就是1 2 3，这总共四个byte兜起来就是一个word真正一個word，下一个word，它的address在哪裡呢？ 就是 4下一個 word 它的 address 就是 4所以就 4 5 6 7那，在下一個 word 呢，它的 address 是多少呢？ 是 8所以它是被align，就是等於，它是一個 4 的倍數， 0 4 8，所以我們如果是談 word address 的話呢，它沒有那個 word 的 address 是 1 2 3 這種，我們都是 0 4 8

這是叫式的倍數，這樣一路上去，這樣子的一個特徵，我們把它稱作words are aligned in memory就是這樣子，因為我們一個word，它不是存在單一的一個address，它是要連續幾個location把它抓出來，它才是一個word，這個要衍生一個不同的方式，叫big endian或者是叫little endianMIPS它是采用Big Endian什麼是Big Endian呢Big Endian的意思就是说我们知

道说一个word它有四个byte就好像说我们去看一个byte里面它有几个bit我们都会说LSB MSBB就是指bit这边这个B就是指byte就是说你的最低的位元组到底存在什么地方最高的位言组到底存在什么地方这个big end点就是most significant byte它是存在什么list address of a word就是像我们这边show出来的就是这样子所以我们如果说要兜一个word的话比如说假设这边有一笔资料这个是MSB 这边是LSB

所以我們要儲存的時候這個2A是放在什麼地方呢2A是擺在這個地方然後4D擺在這裡77擺這裡FE擺這裡FE是LSB所以FE就擺在這個地方這個就是所謂的Big EndianLittle Endian顧名思義它就是反過來反過來的話這邊就是LSB這邊就是MSB所以就是FE 就存在這裡 77然後這裡 4D 這裡是 2A

這種存法就是所謂的 little endian所以這個只是一種他們有兩種這種使用方式那同學記的 MIPS 是屬於這種 big endian提到這個 memory提到 memory 我們就知道說我們剛剛Memory說它可以存structure它可以存array我們在寫這個CC++我們大概第一個會碰到的就是常常會用到這個array這個array 比如說我們說G等於H加大A這個arrayA8A8 我們說它的第一個element我們知道說它是A0 A1 A2 A3就是這樣子

假設我們說這個G它是存在S1然後H是存在S2這個array大約它的base address我們知道說array它是存在一塊連續的位置存在一塊連續的位置這塊連續的位置我們要知道要如何去access這個array的第幾個element我們一般的方法就是我們要知道它的array起始的位置叫base address它的第一個E

lement叫Base Address第一個Element我們已經知道我們就可以抓哪一筆資料呢就可以抓A0 對不對我們就可以抓A0你要抓A1的話你就必須要Base Address再加上Offset這個Offset就是看你是第幾個Element所以譬如說你如果是A1你的offset就是1個你如果是A2的話你的offset就是2個我們這邊1個offset 2個offset指的不是指這邊1 2因為我們指1個2個是指1個element 2個element它每一個element的offset的value是多少是4對不對

我們剛剛講0 1 2 3然後下一個位是多少是4這個開始的這個 word它的下一個 word 的 address 是多少是 8所以它兩個 element 兩個連續的 element它的 offset value 是 4所以是 4所以這邊 32 是什麼呢它是 A8所以它有 8 個 offset每一個 offset 的 unit 是 4所以 4 8 32所以就是我們這邊就告訴我們說它的base address再加上這樣

子的一個offset 4乘以8這個就是A8這個element存在memory的位置這個它就會到S3就是S3它這個register裡面存的這個值存的這個值就是base address再加上offset得到的算出來的這個address就是A8的address它就到memory的address把那笔资料抓过来存到T0里面接着T0再加S2S2是H所以就等于H加A8然后再存到S1所以我们到这里我们就透过register它的operand跟memory的operand还有arithmetic的application

我们知道add它的instruction还有load instructionload是指什么呢它就是从memory的某一个位置去load一个word这边w是指一个wordload一个word把一个word把它load到t0这边来所以这个指令它就是做这件事情所以我们这样就可以了解一个基本它们的operation这个只是前一个范例再多了這個a12它就是把a8加h然

後再存到a12所以我們又要多看到一個指令叫storestore就是把register裡面的一個值把它存到memory某一個location所以這個a8我們這邊就知道說它這邊就是a8是指這一個所以是a8再加上h存到t0這邊呢就是T0把它save到memory的什麼位置呢這個就是base address再加上12乘以4就等於48所以這個就是存到A12它就把這個T0存到A12這個就是我們的store這個指令我們看了基本的register還有memory他們的operation

它這邊就回過頭來比較一下register跟memory它們之間的關係這我們都知道了我們說register它是比memory還要來得快如果我們要使用這個memory的data我們當然就是需要透過load跟store的指令就是把它load到register裡面來這樣子的話它就會需要比較多的instruction可是同學會說它需要比較多的instruction那這樣有什麼好處呢它有什麼好處你把它拆成那麼的細，它的好處是什麼呢？它的好處就是說

當我們在implement這個arithmetic instruction的時候，我們在用硬體去realize這些加減這些指令的時候，因為它的data source來源是固定的都是從register這邊來，所以我們要去用circuit去realize這樣子的指令比較簡單。所以我們做出來的這種circuit，它的速度應該是會比較快。如果說你的家這個指令有時候是從register讀，有時候是從memory讀，你這個指令它執行的cycle time可能就會變動

像我們這種就是非常的簡單當然它的缺點就是要多load跟store的指令，所以這個就是我們剛提到的就是說我們必須要在真正它在CPU裡面執行的時候所有東西其實都是Map到Register裡面來。所以我們就必須要把Register做一個最佳化的使用什麼是最佳化的使用呢？我一筆資料只要把它load到register裡面來的話，它就要待在register裡面待得越久越好為什麼

會說待得越久越好呢？待得越久越好的意思就是說你把它load到register裡面來結果後面的指令它一直在用這一筆資料它一直去access這個register它不需要再怎麼樣，它不需要再到 Memory去load資料進來然後先load再執行先load再執行所以你的Data都在register那這種是最好的那如果說你每次要執行一個指令你就

Data在外面那你要怎麼樣你就要去做一個load你就要做一個load那你load進來之後執行然後再store可是你在load之前呢你還要做什麼事你可能還要先做store漏的之前為什麼要做store有沒有同學猜一下漏的之前為什麼要做可能要做store同學發揮想像力一下隨便猜看看我現在要把一個變數把它抓進來那抓進來我要就是說

他的資料不在register裡面所以他要把它從memoryload到register裡面來一種情況是register很少人在用可能程式剛開始執行所以很少人用所以register裡面可能很多是空的所以我就把它load到空的register裡面去對不對可是如果說已經執行一陣子這register其實都已經被別人佔滿被別的variable給贊助了那你再把一個新的verb把它load到register會怎麼樣會怎麼樣差不多就是你的register因為你裡面都滿了所以你的register其實就是代表代表某一個變數的值那你如果把它蓋掉的話

那一個變數的值就怎麼樣就不見了所以那個值它可能是被運算過可能已經被update了結果你把它蓋掉那你剛剛update過的值就不見了所以你必須要store你必須要先把被update過的這個值從register把它寫到哪裡寫到memory就是寫到memory就是等於說我这边register原本是存variable a然后a的值原

本是1然后经过运算这个register它被改成3所以suppose a应该要等于3结果我又load另外一个register又把它load另外一个variable又把这个值盖到这个register结果我的a它还没有改成3它那3的值就不见了所以这个就不对所以你有可能load进来你要再做store所以load再加一个store那你就要多兩個指令如果說它是空的你就只是做一個load不管怎麼樣

你就是要做這種operation這是最糟糕的所以最好就是register進來以後每次用大部分都是用到存在這個register裡面的data所以我們講說only spears to memoryfor less frequently used variables這個spear的意思就是我們剛剛提到的你新的進來你舊的就要把它 store 回去你必須要做這一種就是要讓它們一致，要讓它們的 data 的值一致，你搬新的進來舊的就要 store

回去所以我們一定是希望我們如果需要把某一個值再替掉的話，我們一定希望把這種最少用的值最少用的變數把它存回 memory 裡面然後最常用常常被用的那個，我們還是把它keep在register裡面這樣子，它才不會常常在那邊辦來辦去所以我們這邊提到register optimization是 important應該是is very important這件事情同學不用擔心這不是我們要做的compiler它必須要去做optimization的這件工作所以compiler裡面其實也是有很多這種optimization的問題

MP的問題必須要解的接著我們再來看一個很重要的一種format我們這邊提到說immediate operand講到這個同學就知道這是指什麼我們說constant data在一個指令裡面我們specify一個constant data這是很常見的一件事比如說我們把S3加4然後再存到S3或者是我們最常見的是什麼宣告一個變數一個loop然後這個i叫i

加1或者是i加2或者是i減1然後等到滿足一個條件它就跳出來就是這樣所以我們在Program裡面其實很多都是需要這種constant如果說我們的指令沒有這個constant的話那就很麻煩我們指令不支持這種constant連這個constant它都怎麼樣這個4都必須要從memory裡面把它抓進來那這個就很頭大了你連加一個1加一個2這樣子

的很常見的constant都要去記憶體裡面搬1搬2那這個速度就很慢所以我們有第三個design principle它說make the common case fast，make the common case最常見的這種常見的我們一定要支持我們一定要提供提供是什麼呢提供的方法就是我們就在我們的instruction裡面直接可以放這個constant直接放constant把這個constant直接放在我們的instruction裡面所以我們的instruction裡面會有一個field會有一個欄位這個欄位就是專門放這些constant用的所以可想而見這些constant不會是32 bit的constant

對不對它不可能是32 bit因為我們一個instruction才32個bit那你光是這個const它就放了32個bit它這個就變data就不是instruction了所以它只是 32 bit裡面的某一個field它可以放這個const，所以我們等一下後面會看說在MIPS裡面它的instruction format在哪幾個 field 是可以篩這個constant。另外就是我們這邊提到說我們這邊提到的immediate operand 就是addi，這個i就是immediate的意思，你只要addi就知道說這一個operand是一個constant。我們沒有提供這種substrate immediate的instruction為什麼呢？

因為我們這邊我們就是放一個-1、-2、-3這樣子的一個數字，因為我們知道說i-1等於是i加-1，所以我們沒有必要為了這樣子就可以做的事情還要額外再提供一個subtract immediate instruction。所以這個是有關於immediate還有no-subtract immediate instruction這樣子的一個instruction，它是滿足我們第三個principle讓比較常用的這種case會變得比較快。所以它講說small constants are common，所以immediate operand可以避免一個load的instruction它不需要到memory去load這個式這個式它已經存在你的instruction裡面為了讓我們的make the common case fast

其實它還有一個MIPS它還有一個叫REST0REST0這個0其實它是一個特殊的一個佔存器這個特殊的佔存器你沒有辦法把它override掉它的這個值它的值always全部都是0所以你沒有辦法去把它改成1 2 3這個就沒有辦法同學會覺得很奇怪說那為什麼我們要做這樣子的一件事情呢我們為什麼要做一個register0我們也可以把 0 放在我們的 instruction 裡面用ADDI 都一樣可以做其實它這邊是為了就是說你加了一個register0它會有一些變化它的變化比如說我們這個

MIPS它沒有提供move它沒有提供move這樣子的一個動作我們說把一個這個A0的data把它move到A3我們沒有move但是它可以怎麼樣它可以用ADDADD就是S1加0然後存到T2這個指令其實就是等於moveT2還有S1你就是把S1 的值把它搬到T2 裡面來所以它是利用這樣子的功能它可以realizeimplement 其他的 instruction前面的就是

這幾個基本的指令我們看過之後我們接著來看unsignedBinary的integer因為我們在operation裡面這種integer扮演的角色非常的重要我們知道說我們在這個在computer裡面我們可以用once-complement, Twice-complement來表示這種signed integer，如果是unsigned的Binary integer，我們說給定一個n bit的number我們都知道說它的range就是從0到2^n-1的n次方-1所以如果是32bit的話，它的range大概就是這樣子。

這個同學大家都知道，如果我們要表示一個sign的一個initial的話，我們假設是一個tooth complement，它的範圍就是nbit它就是負的2^n-1次方正數到2^n-1次方-1它是 Tooth Complement，所以它正數沒有辦法表示像負數這樣子，這麼多。它少掉了它少掉了這個就是把它扣掉就是它少掉了這個數負數可以表示到這個 Scale然後正數的話，它沒有辦法表示這個所以我們可以看到的話，就是說這邊，如果都是 11的話，然後後面是 00的話，它的表示方式

就是類似像這樣子，就是-1，然後乘以2^31次方加上這邊1， 2^31次方一直加一直加加到這邊，然後出來的結果就會等於-4。這個同學應該都已經了解，所以我們說32 bit，它的範圍是從這邊負的然後到正的這樣子的一個範圍Tooth Complement。 Tooth Complement，我們知道說，如果從 bit 0 到 bit 31，bit 31 是 sin bit，我們知道說 1 是 negative number，0

的話是 non-negative number，這個正的 2^n-1 次方在 Tooth Complement 它沒有辦法表示，所以我們說它一些在 Tooth Complement 裡面比較特殊的值一個是0，全體都是0， 全部都是 0全部都是 1 這邊，它是負 1，那它如果是我們說負數最大的就是說我們來看它的絕對值最大的這個負數它其實是10000，這個100000 itu就代表的就是這一個數那正數最大的話呢，就是這個sin是0，然後其他全部都是1這個就是幾個基本Toast Complement的Property，那我們這邊也是很快的看一下

它的tooth complement，我們看一下說它大概是怎麼derive出來的，我們說在tooth complement，我們說sign就是說它可以表示正負數，我們一般，如果把一個binary number，我們把它做一個complement，它tooth complement它基本上就是把它做一個complement然後再做加1的一個動作、complement就是1變0， 0變1，所以你如果是001 它就會變 110然後 110 再加 1這個就是 Tooth Complement 的一個 number我們如果以這個式子來看的話X

再加上 X barX bar 就是對 X 取 Complement我們知道說 X 加 S bar 它會等於多少它會等於 11111這等於這麼多 1這麼多 1 在 Tooth Complement 裡面它其實是等於負 1的一個值所以我們如果把這個式子把它把這個-1把它搬過來的話然後把這個搬過來這個搬到右邊這個搬到左邊我們就知道說Xbar加1會等於-X所以這個就是我們Tooth Complement就是採用這種方式所以這邊有個例子同學可以自己看一下

你可以就是取Complement加1或者是從右邊往左scan然後碰到第一個1保留下來之後每一個bit都是0變1 1變0這樣也可以得到Tooth Complement提到這個Tooth Complement其實最主要是要來介紹這個部分這個部分在我們CPU裡面的運算也是一個很重要但是是一個簡單的觀念叫Sine ExtensionSine Extension指的是指什麼呢它指的就是指說我們要

如何把同一個數然後在不同的bit number裡面做一個轉換比如說我一個負2我負2可以表示在4個bit裡面我也可以表示在8個bit裡面我也可以表示在32個bit你這個負2如果說當初你是表示在8個bit的一個number你如果從8 bit把它extend成32 bit這個過程我們就稱作Sine extension其實這個過程都是跟這個Sine有關係因為你不能夠說在8 bit裡面是負2然後變成32 bit結果它變成是正2或者是正多少或者是負多少它已經不是負2這樣子

一個轉換它就錯掉了為什麼會有這樣子的一個轉換呢同學可以想想看我們剛剛提到的ADDIADDI比如說我們要把A加8或者是A加-2A加-2我們說這個-2是存在什麼地方呢它是存在instruction裡面instruction裡面它那個-2當初存的這個bit number它是用少於32個bit但是實際上我們CPU內部在做運算的時候A加-2它會怎麼

樣它是變成兩個32 bit number做運算因為它的那個加法器它就是32 bit的加法器所以你如果原本是8 bit你就要轉成32 bit你原本是16 bit你也要轉成32 bit那你才能夠做兩個32 bit的這個number的這個加法所以就是需要做所謂的sign extension這個sign extension就是我們這邊提到的ADDI需要然後還有另外叫load byte然後

還有叫load health wordload byte就是我們雖然說我們剛剛前面看到的指令叫LW叫load word實際上它有提供load byte你可以把特定的某一個byte把它load進來或者是你可以把特定的某一個health word這是16個bit Healthware把它load進來這個都可以但是你load進來是load到什麼地方去呢你是load到registerregister是32 bit所以你就必須做這個轉換你從8 bit轉成32從16 bit轉成32另外一個我們等一下會看到的BEQ BNE這個叫Branch equalBranch not equal如果相等它就跳

如果不相等的話它就跳 就跳到某一個地方去執行這一類的它也是需要做一個offset的轉換它的做法是怎麼做呢就是replicate the sine bit to the left就這麼簡單我們說原本負2是這個數字 它是8個bit那我現在要把它轉成這個16個bit那你負2怎麼變成8個bit如果變成16個bit的負2它就是把這個sine bit一直往左copycopy到最左邊就是這樣這個也是這樣 正二它也是從把這個sine bit一直copy到最左邊全部都用sine bit去做copy這個就是所謂的sine extension，它可以在不同bit number之間做這個transfer。

接下來我們要看的這個部分，我們要看說我們要如何表示一個指令前面他先把一些這個instruction裡面幾個比較常見的一些觀念介紹完之後，我們要開始來看這個指令，這個指令其實就要看他的這個instruction的這個format。我們可以來看一下說他這邊提到的instruction，他是用這種binary來做這種encoding。接著它都是Binary的這些Number，它透過這些Binary的Number 0 101，它的Binary的這些01的值，它接著就直接會去控制Circuit，直接控制Circuit比如說，如果是Multipleaser的Selection Input，它的這個Instruction某一個部位

某幾個bit它可能就控制這個Multipleaser，它的source input到底要選哪一個source進來之類的，它就是用這樣子的方式去控制它的hardware的一個運作。 MIPS instruction我們在這邊討論的是32-bit instruction world，實際上它們已經有64-bit，這邊只提供small number of formats encoding operation code就是所謂的OP code就是operation code然後還有small number of registerregister number也不多 32個就是這樣反正什麼

都不多什麼都不會很複雜其實它的一個特徵就是regularity所以這個也是為什麼因為它的regularity也是為什麼說它是一個很好的一種CPU的architecture可以讓我們做一個新手入門來認識透過這個來認識整個CPU裡面的運作方式跟它的架構首先我們來看register number我們知道說32比較常見我們會使用到的這邊T0就是T0到T7它是register 8到15然後T8到T9它是24、25S0到S7這八個它是16到23

這個就指說你在你的Machine Code裡面你在你的Machine Instruction裡面你如果是指S0的時候你如果是指S0其實它的值就是16你如果是指T7它的值是15同學不要去查ArcCode T是多少 7是多少它如果是T7它的Number就是15他就知道15就是對應到T7他就是有這樣子的MappingMaps的instruction format我們看第一個就是叫R-format instruction什麼是R呢？這個R是register的縮寫，它就是指說我這個instruction，它是在做register的operation，

所以我們可以來看它的這個整個32 bit它被切成1 2 3 4 5 6這六個field，那為什麼要從這個R format開始呢？因為其他format的instruction全部都是由這個R format所演變出去了，它不會說有什麼instruction跟這個是完全都沒有共通的，完全都不一樣那這個就不regular，其他的format它可能就從這邊比如說這邊把它merge在一起，它會變成一個新的 field，它只是做一個 merge 的一個變化，所以我們可以看到它是 op,

rs, rt, rd這個 op 就是我們剛剛提到的 op coders 就是第一個 first source register numberrt 呢 second source register numberrd 是 destination register number同學會發現說跟我們剛剛看的那個順序不太一樣它machine code裡面的順序我們是把兩個source搬到前面然後destination放到後面然後這個shift amount顧名思義是什麼呢你要做shift operation的時候你要shift幾次shift amount它是放在這個地方然後還有function code這個OP code主要是分種類每種類它還有不同的operation

它不同的 operation它的 functionality不同的 function它就是由 function code 來區分的所以我們會看到這邊 function code會分出很多不同的 function我們休息十分鐘我們來看這個 rformat我們剛剛只是大概看了一下它有分成六個 field我們現在來看一下為什麼是 6 5 5 5 5 6我們先問一個問題好了就是說為什麼當初要 allocate 32 個 register它可不可以給 33 個 34 個

可不可以當然它可以給34個、35個或者是64個都可以可是它如果要allocate這麼多個register的話我們知道說這個rsrtrd它的field它每一個field它就不止5個bit對不對那它要幾個bit它只要超過32個它要6個bit因為我們5個bit只能夠identify32個那你要identify超過32個你要6個bit那你6個bit的話呢只有這個fee也是6個bit嗎當然不會這個是6 這也是6 這也是6所以我們原本register

原本是15個bit它變成是18個bit你多用了3個bit，多用了3個bit，我们一个instruction就是32bit，所以表示其他的field要扣掉3個bit，那你可以扣這一邊，你扣這一邊的結果是表示什麼呢表示你可以shift你可以shift的數目就會減少，对不對那你如果扣这边就表示什么呢你可以表示你如果扣OP function就表示什么就表示说你可以提供的instruction set你instruction set里面可以提供的instruction数目种类就变少所以这个数字其实是综合整个overall的考量之后一种妥协的结果这个是

應該是他們整個CPU的Architect他們討論之後他們覺得這樣子的一個搭配其實對他們整個系統是最好的他認為說OP6 bit function 6 bit這樣子的搭配已經可以把他們認為基本應該要有的這些指令都放進來他們已經該有的都已經放進來他不需要再更多的bit來放這些OP跟Function你要更多的Instruction Type進來的話它就越來越脫離我們前面講的這個SimpleRegular這樣子

的一個Design Principle它會變得太複雜所以这个六个Bit差不多是這樣你又減少的話就勢必要把一些Instruction TypeInst struction的Function把它剔掉那可能對這個CPU的Performance而言它又會變差所以這整個即使這個數字 即使它們都是你可以把它看成它們都是整個調教過的它們不是說隨便16個bit 32個bit就是這樣它們是一種互相需求的一種妥協之後的一個結果所以它就是6 5 5 5然後5 6 就是這個

所以我們這邊第一個例子是說S1 S2相加然後存到T0所以我們就是S1存這一邊 S2存這一邊然後兩個相加然後存到T0 S1是18 S2是18 T0對應的是8然後因為我們不是做shift所以這個是0我們是加不是做shift所以這是0A的指令在MIPS裡面它的OP code是0它是透過這個function來區分的區分這個加跟其他的rismatic operation所以這是32它的這個function是32所以整個ADD T0 S1 S2它的instruction就是長這個樣子所以你把它都乘一個都乘一個32bit的0101就是這個值

那你把它轉成16進位就是每4個bit group乘一個digit4個bit group乘一個digit那就是16進位變成這個樣子所以這個就是所謂的這個A我們這邊看到的一個instruction對應它的一個machine的instruction我們在剛剛投影片前一頁的最後一個我們就看到16進位這個應該同學都了解。我們就不用再介紹第二個我們要跟同學介紹的第一個

是R format，第二個是什麼呢是I format，這個I當然就是我們前面提到的immediate，就immediate I format的這個instruction，所以同學可以發現說我們剛剛是6 5 5 5，然後是5 6，所以他把後面三個5 5 6 這三個把它合成一個，合成一個， 這個是什麼呢是一個constant或者是address反正不管是constant address，它就是一個value，它是一個value這個就是

我們所謂的immediate arithmetic或者是load跟store的這個instruction，load跟store instruction這個immediate addi同學應該沒有問題，它就是把一個register加上一個constant再存到另外一個register，load跟store同學回想一下我們第一次看到load跟store它是什麼呢，它是把memory的某一個位置裡面的值把它load到register或者是把register的值把它寫到memory裡面的某一個location，那個location是怎麼算的呢那個location是不是一個base

address再加上一个offsetbase加offset那个offset 抱歉这个offset就是base加offset我们就是放在这个地方它也算是一个value constant value所以我们这边就是16 bit16 bit因为它是所谓的tooth complementTooth Complement所以16-bit Tooth Complement它的constant的範圍就是負2的15次方到正2的15次方減1就是這樣子所以這個就是我們的iFormat這個iFormat同學可以發現說已經跟我們前面提到的我們前面有稍微強調就是說Risk它強調的就是Simple Regular

要有規則然後要簡單結果我們發現說R format之後又出現了一個I formatI format之後會不會又出現另外一個formatformat好像越來越多這樣好像又違背了這個risk它的架構實際上我們前面看到的三個design principle這邊第四個design principle是一定要的什麼呢它說good design demands good compromise我們一個好的設計不是說我這個

好的設計多厲害多厲害他還是需要什麼？他還是需要一些妥協，這個妥協指的是說我們不能夠所有的指令全部都是R-format，因為我們前面提到說I-format這種是common case，所以我們需要把那些constant直接放在instruction裡面，我們不需要說把constant放在memory然後再用load把它讀進來然後再做加減乘除我們不要這樣，我們就

直接在instruction裡面所以你把這個instruction讀進來之後，你直接從這個field就可以把你的其中一個input data直接把它抓出來就把這16 bit直接用sine extension16轉成32然後接著再跟另外一個register兩個相加馬上就可以做完。所以這樣子的一個妥協實際上對我們整個CPU，它的效能是有幫助的，所以這是一個很重要的一

種設計的一個Design Principle，但是這種妥協不能太多，因為你每次都妥協，每次都妥協妥協到最後，實你就會變成現在的這個X86的Format，它的Format一大堆很多很多很多，就非常的複雜那就是每一次都要妥協所以這個當然要怎麼樣才是比較好見仁見智，所以他這邊提到說不同的這個format就是會讓你的coding會變得更複雜，但是你有必要的像這種com mon case你還是必須要提供所以我們希望我們的這個format的種類是越少越好

越像， 長得越像越好。所以我們剛剛提到的是什麼呢？它的format的變化基本上就是從我們的R format這最後三個把它整合在一起變成一個新的format，這種叫I format。所以這邊我們就同學就是要再回想一下我們到這裡為止，我們前面提到的總共有四個design principle那四個design principle，它都會有對應它的一個例子就是它有個例子就要來說明說為什麼

這個Design Principle是需要的呢？都會有個例子這四個Design Principle同學這個觀念要清楚。如果有問題的話可以隨時來討論。接著我們再來看就是這個同學也了解，就是我們現在的這個Computer，它就是所謂的Store Program，store program就是把你的program跟data全部都是存在memory裡面，所以你的instruction跟data看起來都一樣，它都是binary它沒有長得什麼不一樣。還有另外一個就是binary的compatibility，它可以允許你被compile過的program可以在不同的computer裡面

同样去做执行的动作，比如說你在HP的PC上面compile过之后你也可以在其他的现在没有IBM比如说你可以在联想或者是在Acer或者是Acer或者是其他任何一种厂牌像以前日本的PC也做得不错比如说像福奇组現在好像都比較少見了所以你在任何一種廠牌上面可以來run只要它們是同一種instruction set architecture這樣子就可以接著我們後面要跟同學介紹一些比較常見的operation這邊我們可以比較快的跳過去因為這個在同學學過

assembly language 的話這邊應該都看過像 shift left它的符號大概是像這樣子那就是 sll 叫 shift leftshift right srl 往右 shift然後 bitwise end它不是 large co-end它是 bitwise end就是 bit to bit 做一個 end所以它是 end或者是這種 immediate format 的 endend ibitwise all 或者是 all ibitwise not我們這邊沒有 not 我們是用 not也就是說在 MAPS 裡面它還是一樣有一些地方就是我們剛剛提到它的哲學設計哲學就是越少越好所以它不是說 not

它是提供一個 not我們等一下後面會看到說它的 not 是如何用 not 來 implement所以這個是Logical operation這個shift呢shift就是我們提到的就是R format這邊就必須要specify你的shift amount到底是多少這邊有描述說shift left它就是等於這個乘以2這個大家都知道shift right等於就是除以2shift left的話它就是右邊填領shift right它的左邊如果是unsigned的話就是

如果是nsine它是等同1它是除以2如果是sine的話那就不一定了因為你shift right它這邊是除以就是左邊填0你往右shift左邊那些空出來的它全部都是填0所以這邊只是一個例子它這個and operation就是t1 t2做and所以and的話同學可以看到這邊11其他全部都是零這些一零的 零零的全部都

是零就這個一一它才是一all只要是有一個一一它全部都會保留一所以同學修過Assembly Language應該就知道說我們在做這些處理其實都是很多它都是在做那個bit operation它就是你能夠針對一個word裡面的某幾個bit某一個範圍內容去做這些處理幾乎全部都在做這種然後NOT呢NOT就是零變一變

零我們在MIPS裡面它是怎麼做呢它就是你如果要對T1做一個NOT它就是T1跟0這個register做一個NORNOR是什麼呢NOR就是做一個OR再加NOTNOR就是做一個OR再加一個NOTT1跟0 OR起來是多少就是T1T1跟0 OR起來就是T1然後在NOT就是T1 bar所以T0就是T1 bar所以我們如果對這一邊做這樣子的一個operation這邊就會0變1 1變0 0變1就會變成這個樣子所以這個就是我們的NOR operation

接著我們再來看conditional operation它說是branch to a level instructionif a condition is true如果一個condition它是滿足的話它就會branch到某一個被level過的instruction的那個位置如果不滿足的話如果是force它就會繼續執行比如說branch equal它說rs跟rt相等的話它就branch到L1branch not equal不相等它就branch到L1或者是就直接jump直

接用jump就jump到L1所以我們這邊很快地看一下這個C code這個C code它的就是如果i等於j它就g加h存到f如果i不等於j它就g減h存到ffgF G H I J它是存在S0 S1 S2就是這樣子所以它這邊就是說I跟J如果是不是相等它就是I跟J S3 S2兩個比較是不是相等它如果不相等的話它就跳到else不相等不相等就執行這一個執行這一個它就是把這兩個相減存到G減H存到F

那如果相等的話呢它就是把g加h然後存到f那加完之後呢這邊就記得就是在跳到exit大概是這樣這是一個基本的code那這邊有一個這個loop這個while loopsave i如果是等於k的話呢i就等於i加1所以我們這邊說s3i存在s3然後k存在s5然後就是說這個adress base address這個save

base address它存在s6它是這樣子所以我們說它比較這個fire loop的話首先你必須要先把這個save把它抓出來save抓出來你要先把這個indexindex乘以多少呢index乘以4對不對所以它這邊就是index i它存在s3s3乘以4就往左shift兩個bit就乘以4然后这个是offsetoffset再加上save base addressbase

address加上offset这就是save i它在memory的location它把save i抓出来存到t它把save i这个location它的内容抓出来存到t0接着它就把t0跟k比较相等就是这样子所以这个是一个其实它应用的最主要就是这个array它的一个关系接着有一个很重要的一个观念它叫block它这边定义的就是说我们知道说我们在写这个C C++这种heightable language我们都有block的这个观念那你的这个variable的definition其实它的lifetime到底是多少它除了你特定

是宣告它是一个 static 之外呢其实根据你的这个 variable它所宣告的位置 location你的 block 的范围其实就定义了你的这个 variable它的 lifetime它的就是什么时候开始这个 variable 有效什么时候这个 variable 它就不见了在我们的这个 assembly 里面呢assembly language 里面其实很少有类似像就是说就是你看不到就是说像我们在C++里面我

们有这种block的符号可以定义说这是一个block我们这边它有提供我们说一个basic block它就是一个sequence of instruction它不是一个这种sequence of instruction太模糊了它必须要有boundary这个boundary它的定义就是在no embedded branches except at n除了在你block的結束的地方以外呢，你不可以有branch你不可以有branch所以你branch只能出現在block結束的地方然後no branch target就是那個level except at beginning你除了在block的開頭的地方之外你不可以有level所以就是像你這樣子看到

一个sequence的instruction這邊假設有一个level然后這邊有一个branch其实这一段它就定義了一個block它就定義了一個block這就是一個basic block它的一个 definition這個basic block definition它定義要來做什麼呢這其实是以compiler的眼光而言我們前面有提到說compiler它必须要做很多optimization那Compiler它如何來認就是說我們在Compile我們High Level Language其實它可以一個Block一個Block去抓它可以透過你Block的這個Symbol你可以

定義出來說這個是一個Block它們是有一個關係的它們是有一個關係存在的那你在這一種這個Assembly Language的話它就是透過這樣子的一個方式來來把一大個assembly program把它拆成很多個 block這樣子，它要做optimization它可以針對這個block裡面而這個block裡面，它的variable的使用情況到底是怎麼樣這個block裡面，它的variable，就針對這個block去做optimization所以，它講說這個compiler identify basic blocks for optimization最主要就是，在做我們前面講的

Register Speeding同學還記得Register Speeding就是你從Memory讀Register讀值讀到Register那，如果後面又有人要進來，你這邊就有人要出去那，到底誰要出口呢，那這個Compiler他必須要去Allocate，他這個關係Compiler Allocate關係，Allocate完之後呢，他在執行的時候，他就Follow Compiler Allocate的這一種Sequence誰進來進到什麼地方那，它進來誰要出去就是這樣子這樣子，如果Compiler它的Optimization做得好，它只要這個只load到register它就可以待在register裡面待很久不用說進來又出去

進來又出去在那邊做這個swap除了我們剛剛提到的這個VEQ BND之外還有其他的cond itional的operation這邊一個比較特殊的是就是叫 set less than slt它叫 set result to 1 if a condition is true它講得很清楚這個condition是 true 的時候它就把這個結果設為 1把某一個結果 把某一個 register 設為 1如果不是的話如果condition不是 true它就把它設為 0比如說我們說 set less than rd rs rt

它就是比較RS是不是小於RTless than 小於 沒有等於RS是不是小於RT如果是的話這condition成立 RD它就等於0不然的話 RD就等於1不然的話 RD就等於0就是這樣它當然也有提供immediate的modeset less than immediate就是如果rs是小於某一個constantrt就設為1如果是大於等於的話rt就是設為0同學

會說這個less than到底要做什麼用呢其實就是要做比較比較大小比較大小之後再決定要做什麼事情我們這邊舉一個例子當然它不一定就是一定要做這種事情但是再举一个例子说我们先比较大小S1 S2 S1是不是小于S2S1如果是小于S2的话T0就会变1如果T0变1的话我们看它branch not equal如果T0变11当然不等于0所以它就not equal它就会branch到L

Branch到L所以其實這個就是什麼指令呢其實這個就是S1小於S2的話它就Branch到L它就是有所謂的Branch less than對不對那你就會說有Branch less than有沒有Branch less than and equal有沒有Branch greater than有沒有BranchGreater than and equal你就可以举很多例子你要一种它就要提供一种你要一种它就要提供一种所

以在这个MIPS它的design philosophy它觉得说没有必要做这种事情它认为做这种事情可能不见得有帮助所以它就提供什么Branch not equalBranch equal它不提供那个Branch less than所以他这边讲说为什么呢他为什么不提供branch less thanbranch greater than或者是greater than or equal这样子他告诉我们说how wellfor comparison就是比大小比大小的comparison它是slower than那种equality的comparisoncomparison你可以

比說是不是相等你也可以比大小你只要是要比大小的關係的話它這種電路這種硬體它通常都比較複雜比較複雜當然它的delay大概就會比較大所以如果說你要讓你的這種Branch的operation都很快我的每一次Branch都很快你就不要Branch equalBranch not equal再搭配Branch less than 這種比大小所以這個就是

它最主要的原因為什麼它會比較慢呢同學回去翻一下那個數位系統那本書同學去翻一下comparator那個circuit還有應該同學應該就知道說你如何去比它們到底是不是一樣這是它的equality的comparison跟这种less than larger than的comparator那个电路比较一下就知道说他为什么讲这个是比较慢的所以

这就是我们的原因我们只用VEQ VNE这是最常见的case所以这个呢就是他这个Architect他认为这是一个good designcompromise我们不会要什么就提供什么这样子不见得是好事另外我們如果說要做比較的話就是比較你到底是比較sine還是unsine比如說sine comparisonset less thanset less thanimmediate如果是unsine的話這邊就要再加一個uu表示是uns ineso它是unsine comparison然後這個是set less than的unsine immediate

這個有什麼不一樣我想同學應該都很了解比如說我們舉這邊一個例子這個S0它是全部都是1然後S1它是全部都是0然後LSBList Significant Bit 是1這個如果是比較Sine的話我們知道說這Sine Bit 是1所以這是負所以這負 你負的再多大都沒有用所以它一定是比這正數還小如果說你是比ensign的話 這一定是最大沒有人比它大

因為它全部都是1你找不到一個比它大你要比它大就要overflow 對不對所以這個是最大的如果是ensign的話 這個就比較大如果是sign的話 這個就比較小所以這個是sign跟ensign的差別所以我們到這裡我們大概就把比較常見的MIMS的instruction我們大概都介紹完了到這裡同學有沒有問題前面應該大部分的觀念同學應該都知道只是一些小地方不一樣接著我們跟同學介紹也是同學知道的觀念但是我們應該會介紹一些跟同學以前比較沒有注意到

的這個小地方就是Procedure Code Procedure Code呢我們都知道說Procedure Code它的Step大概就是可以分成這幾個Step第一個呢這個也是這個章節裡面一個重要的觀念。第一個就是我們要把這個Parameter，我們要去扣別人對不對，扣別人。你要把這個Parameter把它放到你的Register裡面去接著，你要Transfer Control to Procedure你要叫別人呼叫總是要把控制權給別人，不要抓著不放要給別人，他才能夠執行。然後接著他必須要怎麼樣呢？就是說

這個系統必須要allocate一塊storage給這個procedure，因為procedure他可能需要一些temporary的一些variable所以他要allocate一塊memory給他。接著，就是執行執行完之後再把這個結果，如果要傳回caller的話，你要把結果放到register，傳回去caller才能夠到register裡面去讀這個結果，它要回傳的這個值都做好了。 事情都做完了，你就把它直接就return控制權，再還給caller就是這樣子。 它的過程，這個大家都知道

我們後面要跟同學介紹的是什麼呢？介紹的就是說我們在MIPS，我們在MIPS裡面，我們如果要寫這一種callcall一個procedure絕對不是說就是一個jump到某一個地方然後再return回來這樣子就沒事了。實際上我們現在要做什麼事呢？我們現在就是要做剛剛跟同學提到的提到什麼呢？ Register你的值是不是會被人家

蓋掉 Register你的值會不會被蓋掉，那你的值如果被蓋掉的話你必須要把你的值把它保留起來所以這個一個重要的觀念就是說我們可以想像成什麼呢？想像成說我們CPU的一個State最主要就是由它CPU裡面的Register來定義定義說這個register它的狀態到底是什麼，所以我們只要看一下這個CPU它的register的內

容，我們可以把它想像成這個就是它目前的狀態，目前是A這個procedure它在執行所以它的register裡面的值，它都代表著這個procedure A在執行過程裡面的一個狀態的值，那我現在我要把procedure A把它變成是一個procedure B在執行的時候這個CPU裡面的register是不是就變成是要代表procedure B在執行過程裡面它的值的變化，所以這時候register就代表procedure B，這個時候同學就要知道說這個樣子，我執行B的時候A的那些register值要怎麼辦？ Procedure A的register值要怎麼辦？

就是我們前面提過的要怎麼樣要把它 store就是要把它存起來，當你 procedure B 執行完回到 procedure A 的時候，你必須要再到 memory 裡面去把我們剛存到 memory 的那一些procedure A 它的 variable它 register 的這些值再把它 load 回 register 裡面我們就是要做這些事情做這些事情它後面有一個機制可以比較有效率就是不用寫很多code可以省掉一些load跟store的動作我們後面的觀念最主要就是要傳遞這樣子

的一個觀念所以我們先來看我們的register它使用的方式這邊A0到A3它是存這個argument就是你要傳這個呼叫另外一个procedure的时候把参数放在这个地方你要return回去的时候你把这个结果放在v0跟v1就是这两个registert0到t9這十个register我們前面說過它叫temporary的这个variable它這邊講說它可以被override by coli呼叫者可以去 override 這十個 register而且你不需要 save 它 你就可以 override我們等一下會來講說為什麼 Kodi

它可以 override 這十個 register而不去 save 這個 register我們等一下再來看 S0 跟 S7 它叫 save register這邊講說 Kodi 你必須要去 save 跟 restore這八個register這個是什麼意思呢？意思就是說，在COLI裡面，你在被呼叫者的程式裡面，如果你要把紙存到S0跟S7的時候，你一定要把S0 S7先把它save，然後你就可以用、看你愛怎麼用就怎麼用。當你用完你的COLI要return回COLA的時候，

你必須要把剛剛的 S0 S7 save 起來的值再 restore 回去。所以你coli 必須要做、 maintain 負責 maintain S0 到 S7它的 data 的一致性。但是，如果 coli 要使用T0 跟T9 的時候，你不用 save 你也不用restore。你想用你就用。所以這個是它在這邊的一個機制就是這樣子，這個我們等一下會跟同學提說為什麼你coli可以想用就用為什麼同學應

該可以猜得到因為有別人幫你maintain對不對誰幫你maintain呢？當然是COLA就是COLA所以在這個地方它就分成兩邊就是COLA，你就去maintain這個T0到T9它的data的一致性。如果說caller要呼叫別人、caller覺得說T0、caller知道說T0裡面有他要的值存在T0那你、caller你就要把T0 save起來、caller你必須要call別人之前你必須要把T0 save起

來。如果說T0沒有你要的值，那你就不用save，你有需要的值在T0你就 ave它因為你呼叫別人的時候，可能會把T0 override掉，所以要不要決定前再 cola 這個 coli S0跟S7，它就是你要用它， 那你就要save它，你不用它，你就不用save它，就是這樣子，所以這樣子的一個機制就是分成兩邊 cola負責這一個 coli負責這一個，這樣子的話， 他們就會比較 efficient。

你如果不把它分成兩邊的話，你每一個都要Save跟Load都要Save跟Restore，你要Save Restore所以這個是很麻煩的一件事情。舉個例來講就是說， 假設我們在COLI，我們使用到T0，我們在COLI使用到T0，因為我們沒有剛剛這種分工合作的機制，所以你 coli 是不是一定要把 T 領 save 起來對不對，因為 cola 不知道說那個 coli 它要不要用 T 領它不知道，它也是 suppose 說那個 coli 它沒有把 T 領 save 起來所以 cola 它只要用到 T 領它就一定要 save然後 cola return

回去 cola 的時候它就要趕快再把 T 領 restore 回去可是實際上 cola 它並沒有有用的值存在 T 領裡面，這個值有沒有被改他根本不 care所以這個時候你 coli 去 save t0 跟 restore t0這個就是 redundant work，你就等於執行了兩個 redundant instruction那兩個 instruction 是不需要執行的你就等於多執行這兩個 instruction所以這邊最主要的一個觀念就是在這個地方所以同學先回去先把這個觀念先

先把它弄清楚我們下一次上課的時候在go through的時候就會比較順如果有問題我們下一次上課的時候同學可以再提出來討論接下來時間我們就交給助教他跟同學講第一個sub project我順便跟同學提一下因為我10月底禮拜一剛好有一天要去演講所以那一次沒辦法上課我到時候會把日期

公布出來所以等於10月底會停禮拜一會停一堂課所以我們之後我們會利用就是今天大概12點我們大概就是一次多上10分鐘一次多上10分鐘我們把這50分鐘的課把它補回來我在11月 接近11月中的時候本來是有一個禮拜要到國外去開會發表論文剛好我的session是在禮拜二所以我就

禮拜一開幕那天就不要去所以我禮拜一還可以上一次課但是禮拜四我趕不回來所以禮拜四兩次要停課所以那兩次我也會另外再找時間再把那兩小時的課再補回來所以先讓同學知道一下好 那個我現在開始介紹我們第一個Lab這個學期總共有六次Lab目的是要實作一個CPU出來這一次第一個Lab只要做簡單的Memory跟Register的存取就可以了然後我們 Memory總共有八個然後每一個都是32bit的大小位置是從

0到7為方便解說我們現在就是m0到m7那我們指令總共有兩個而已一個是load一個是store那個指令上面你看那個上面有寫opcode是1，然後後面是一串0，然後store是01，然後後面是一串0。那前面8個bit就是opcode，那後面8個是Memory的位置，那在後面8個就是Register位置，那最後8個那個目前還用不到所以現在都是0。那我們漏的是將Memory就是XX那8bit的位置Memory的位置裡面的值存到Register，那個RT的位置，那Store的話呢，就是將

register裡面的值存回memory。我們這次lab只要通過下面這一串指令就可以了一開始初始值memory的初始值是0，1，2，3，4，5，6 7就這八個register的初始值都是0我希望你們跑出來的結果就是要符合這樣的結果我們作業的使用環境就是Linux大家應該都有修過數位電路實驗吧都有吧有嗎 有沒有嗎如果沒有的話我們在E3上有放一些有關Verilog的教學跟介紹很多人應該是沒有用

就是自己電腦上沒有裝Zilinx所以我們也有放一份投影片是專門講說你們怎麼去抓Zilinx好然後我們跑那幾個測試資料結果對那這次Lab就過了就這樣沒有額外的測試測試就是上面那幾就是那一串測試那我们要的就是波形图 程式码程式码最好是有註解那不註解的话助教看不懂我們可能会就是增值或扣分那新的话就是写说你是怎么做这是lab的这样就可以

了对那如果有问题的话下面都是我们助教的联络资料然后教教的方式的话呢就是将波形图程式码与心得就是压缩成一个档案档名就是叫你的学号然后作业的编号跟版本这样然后Due Date就是在10月13号也就是两个礼拜后的今天对你们有两个礼拜可以写那持交的话持交的那个规则就在这边持交七天是还可以再交只是会打六折啦你們要注意一下時間那我們用的 Xilinx 版本是 13.

2那如果你們想要用系統中 Xilinx 寫的話你要注意一下系統中的版本是 10. 1那希望你們就是確認 13. 2 版本可以過再叫過來就上傳 E3 這樣那 E3 上就是我剛有講就是你怎麼取得那個Xilinx跟安裝然後Xilinx的一些就是你要run project的setting然後我還有就是寫一個小的範例程式你可以拿那個範例程式下去改然後寫這次的project那還有一些Vlog的補充資料Vlog就是我找一個網頁給你們就是看一下怎麼寫讓你們複習一下

這個投影片都會放在E3上面然後還有如果說你們在今天早上就下載投影片的話就是你們要再去下載一次因為我們剛有再更新過一次你要注意對還有關於13. 2版本要記得裝的是那個Webpack，那就是不用license的對，那功能就是足以應付我們這堂課，就是了就不用license然後我要講一下example code，這次lab不太需要用什麼技巧啦，那老師要求就是我們可以寫一個example code，然後就是

看這次lab會用到什麼技巧，那我們就是寫個example code，然後用到這些技巧，但是跟這次project就是不太一樣的東西，這樣那你們就是我就稍微講一下，然後我這個example code是input也是32bit的一串數字，那OP code只有前面兩個bit，然後總共有四個Operation，就是AND, OR, EXOR, LEFT SHIFT，後面15個bit，15個bit分別就是兩個Operant做的，就是Operant1 AND Operant2或者是OR, EXOR, LEFT SHIFT，就是這樣，就是把結果存到一個32bit的register，這些是一些Test Instructions，第一個Instruction就是一串0 AND 一串1，

然後第二個Instruction是一串0 or一串1，那第三個Instruction就是010，然後去Excel一串1這樣，那最後一個就是Left Shooter那這個都是這個Code我都有放在E3上面，你們就是直接可以拿下來，然後就是裝好，然後就是看跑步型什麼的，那個教學都有，那你們要記得下來去看，這是Top Module啦，就是宣告一些變數，然後Clock然後Reset

那這個Operation 1 Operation 2就是去抓取後面那兩個15bit的數字出來，那抓完之後就是看訊號我的訊號是設定在Clock Positive Edge的時候，就是就去看Input後面那兩個15bit，然後再看他的OP code是什麼，然後再去做AND OR EXALT 或者是LEFT SHIFT，然後testband你們也要自己寫，那你可以也是可以拿我的code下去改testband沒有很難寫，就是大概只要動中間那一塊數字就可以了，然後就是看看有多少instruction你就多加幾行，然後這個就是跑出來的波形圖，那我希望報告可以

可以看到，就是這樣的波形圖，你可以解說哪一塊波形，然後是哪一個 instruction，然後可以指出說我的 result 在哪裡，然後 input 在哪裡，這樣訊號要拉清楚，然後 code 就是這樣很簡單，然後有任何問題嗎沒有嗎？那沒有就下課囉.