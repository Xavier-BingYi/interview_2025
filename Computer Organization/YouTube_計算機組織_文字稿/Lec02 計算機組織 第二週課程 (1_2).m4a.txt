undefined
我們上一次跟同學介紹到我們說要評斷一個國家的半導體的科技水平我們一般是看Memory跟CPU它們的技術我們上一次有提到在CPU方面而言我們都知道美國它是趨於領導的地位。 Memory的話Memory其實早期是日本日本早期在Memory裡面它是居於領導的地位。我們知道說現在其實Memory有一家公司佔著舉止輕重的角色就是Samsung韓國之前Memory是一無所有它根本跟Memory這個技術是完全沒有關係。它是如何從無到有可以變成在短短的

這時間之內變成是一個記憶體的強國。其實它不只記憶體強國它現在也是半導體的強國。其實這個就是說先說明一下我等一下講的這個故事純粹是日本人的觀點因為這個故事大部分的內容是因為我看NHK他們製作的NHK他會製作很多那種影片然後介紹一些歷史典故什麼之類然後他其中有一個專輯是在探討記憶體的歷史。所以這個算是日本的觀點。所以實際上是不是

如此的話可能還要再細究首先韓國其實他們在決定要發展記憶體的時候他們當初就派了一個就派了一個小組到美國去跟那個Micron我們知道說美國的這個Micron他也是記憶體公司他以前也是一家很重要的公司。他們那個團隊學完之後回去回到韓國就算是韓國的一個SID團隊是一個種子隊伍當然他們當初聽說他們從美國回去的時候，那時候在美國的這個團隊裡面有幾個關鍵人物

也是韓國人不知道有沒有把那幾個key person也一起挖回韓國這個就不是很清楚，但是我們知道說要從無到有光是靠一個SIT team是不太可能的當然，因為跟其他的記憶體槍口他們差了很多個世代，所以他們必須要用盡各種辦法來增進他們的技術所以，那時候日本其實很多Memory的發明者其實是

Toshiba裡面的工程師，在早期Toshiba，它是一家當然它不是只有做記憶體但是它在記憶體上面是一個非常有名的一家公司，所以很多有名的記憶體的發明都是從Toshiba這邊過來當初他們就是Toshiba他們發現說奇怪怎麼韓國的Samsung記憶體的科技進步得非常的快他們也聽說有耳聞過說韓國從Toshiba這邊借一些學一些技術他們學技術是怎麼學法，因為我們知道說這種科技是跟商業相關的跟商業相關的科技

一定是機密他不可能說隨便交給敵對的國家後來他們發現說好像有一些工程師他們就是利用週末的時候去韓國度假我們就是禮拜二禮拜天到韓國度假然後度假其實不是真的去度假就是到神宋那邊去度假然後順便做技術交流這樣子，所以後來他們Toshiba他們就就是把那個公司全公司的員工的護照全部收起來查看看到底是有哪一些人就是每到週末就到韓國去度假，順便做技術交流。所以聽說據日本人的說法，就是說

韓國他們曾經用過這樣子的方式讓他們的記憶體design的這個technology就是很快速的提升另外還有一個故事，這個也是日本人的說法當時即使韓國的記憶體Samsung的記憶體技術已經提升很多，但是它差日本還是差了可能一到兩個世代吧我們知道說差一到兩個世代其實就幾乎沒有什麼競爭力所

以說那時候Samsung他們邀請日本Toshiba到Samsung去訪問，Toshiba他們去了然後Samsung他們也邀請他們去看他們最先進的這個廠房，這個Toshiba也看了，因為Samsung最先進的對Toshiba而言根本不是任何對他們不會引起任何的興趣不過他們還是參觀，參觀後來想說就沒事結果參觀回來之後Samsung他們就寄了一封信來說我們邀

請你們參觀我們最先進的廠房，我們也希望說去參觀你們最先進的這個廠房那時候Toshibaพวกเข剛好在建一個新世代的一個廠房，Toshiba他們高層他們就想說反正他們只是來看工廠反正也看不到裡面有什麼技術所以就想說沒關係就讓他們來看反正他們也是走馬看的話結果就帶Samsung的那些人去參觀他們最先進的正在興建的下一世代的廠房結果其實當然大家不會笨到說要去那邊看人家的技術。其實Samsung

日本人說神送就是透過那一次去他們的廠房參觀的時候就認識了那個廠長，是認識了建那個廠的廠長之後就把那個廠長挖過去，所以就是透過種種的方法然後神送他們的記憶體。後來就起來所以現在打的日本現在不是都一直說什麼台日聯手抗衡什麼之類的。所以現在這個神聖他們

其實不是只有記憶體很強，他們整個半導體都非常的強當然韓國他們是因為整個政府全國之力都在資助一個公司，所以這種競爭其實並不太對等。但是至於這個CPU的話，我們知道說CPU的設計到目前為止都是美國居於領先的地位。談到這個CPU其實我們另外一個在看一個國家的科技。我們知道說這個Supercomputer非常的重要。我們前面有秀過一個Roadrunner那個是去年九月的時候是世界最快的這個Supercomputer之前其實Supercomputer他們的這個競賽只有

美國跟日本就是美國日本兩個國家在那邊一直爭誰第一誰第一。我記得好像是去年年底還是今年年初的時候好像曾經就是中國大陸他們曾經拿過這個最快的他們Super Computer他們的這個設計的科技就急起直追，所以讓這個美國跟日本也是嚇出一身冷汗。好像聽說這個美國跟日本他們要設計下一世代的超級電腦又會比中國大陸他們還要更快反正這種競爭就是一直在那邊有時候他領先， 有時候他領先這樣子

就是算是一個良性競爭對人類的科技而言算是好事一件所以我們看到這個road map我們要跟同學提一件事情就是說我們從這邊看到2011原本它的roadmap是可以到CPU可以到10GHz我們上次有葉烈跟同學提過說我們目前已經沒有辦法做那麼快前一陣子AMD他們才announce說他們最快的是8.多GHz跟10GHz還是有一定的落差，這個純粹都是散熱的問題我們後面會有一些簡介所以這個很重要。 MORE SLOW

我們同學以後看到這種curve這個road map它就是在predict，就是這個半導體它的技術的一個演進根據一些科技人士他們的預測這個Moslow就是說， 至少我們這個製程的shrinking製程的shrinking可能會在6到10年之內可能會中止中止的意思就是說，以目前我們所使用的半導體技術的方法，大概在十年之內沒有辦法再把半導體的原件再把它縮、萎縮，它沒有辦法再萎縮當然就是要再想另外一個辦法，可能就是有沒有

新的技術就好像當初的真空管到這個transistor，這是一個很大的進步，但是現在有很多新的技術都想要取代目前的Transistor，但是現在還不知道說到底誰會勝出，但是大家不要擔心說十年之後是不是科技就會停止當然沒有半導體科技當然不可能會停止，因為它在生活上面的需求是那麼的重要，所以它不會去 shrink dimension 的時候，它可能會用另外一個方式

去發展什麼方式呢，那可能就是開始，因為我們都知道說，我們Shrink就是在單位面積可以塞更多的電晶體，但是現在沒有辦法在單位面積塞更多的電晶体的時候，下一個方法是什麼呢，就是以前一個晶片就是我們看到的那個有包裝過的晶片，你把那個包裝把它拆開來，大家回去我如果而上一個 homework

要大家回去拆這個可能大家回去都要報廢一台電腦，大家把這個晶片可以把你不要的電腦隨便拿一個晶片，把那個包裝把它拆開來，你那個封裝的硬盒子拆開來之後，同學會看到一個，就是類似長得像譬如說，這個是它外面的硬殼包裝，它有這個接角傳統的就是長在兩邊現在的大概就是長在底下，

就是有很多Array Pin就長在底下，它中間同學會看到一個，我們上一次就稱作這個東西叫帶，中間有一個帶，這是很脆弱的東西，它很容易被損毀，所以需要這個硬殼子來保護這個帶會有很多黃金線接到邊邊的這個角，同學可以看到它裡面一定是只有一個帶，就是你把那個硬把包裝拆開之後，它

就有一個袋，所以之後的發展它一定是朝什麼呢既然它沒有辦法再塞更多電競體所以我們同樣的面積可以怎麼樣堆疊。 我們把它堆高，這個就是叫3D IC這個也是目前全世界有花很多effort在這方面的研究叫3D IC那就是要把這個袋之前袋就是一個是平面的。我們現在要把它堆疊把它堆起

來實際上3DIC並不是僅止於這個research的topic同學的這個smartphone裡面它裡面的這個memory其實它都已經用到這個記憶體堆疊它有很多代的一個堆疊已經用到3DIC的這個技術同學也可以把那個舊的smartphone我不知道新的smartphone它現在都是用3DIC的技術同學如果要換手機可以把新的這個SmartPhone把它拆開來去看看它

是不是用這種3D IC的堆疊方式所以我們從這一邊其實我們可以看到很多半導體它發展的趨勢半導體發展的趨勢它也影響到我們整個電腦CPU還有電腦系統它的發展硬體的發展其實也牽涉到軟體的進展所以這其實都是都是息息相關的所以這個也是建議同學說除了你的興趣之外在大師畢業之前多修一些硬體的課讓你多增加一些 domain knowledge或許你以後不是靠這個吃飯但是你可以有這些 knowledge

之後可以知道很多一些趨勢的發展我們下面這張圖就是看到一個 processor 的 market這個 market我們可以看到，說這個數目是 cell phone 的數目，最多。但是我們，如果論單價而言的話當然是 cell phone 它的 processor 相對的是非常便宜，我們的 PC 它的 processor 單價相對的高。如果 server 的話， 它的 processor 單價又更高，所以我們可以看到，之前的這種成長是一直呈現爆炸性的成長。 數目越來越多，

其實這個還沒有到頂，這也是剛開始而已，因為很多世界上大部分的國家其實都還没有手機的普及力還是非常的低，所以我們到前面，我們就大概簡單的跟同學簡介了整個半導體還有Processor CPU電腦它的歷史的發展這一頁裡面，我們列出了其實前面有跟同學有提過就是說，我們這堂課裡面同

學會學到的，我們這邊有看到，有幾個，就是當然是你的 Program，如果 translate成這個 Machine Language，這個不是重點，因為同學如果有修過這個系統程式應該這個都已經知道了另外還有就是說，你的 Hardware Software 的 Interface 還有就是，如何去要決定一個 Program 的 Performance，我們再來比這個 Performance當然就是同一台電腦兩個程式去 Run，看誰跑得比較

快我們就說誰的 Performance比較好，如果是要做一個比較一個就是一個理論的分析的話，我們可以從一些數據這個也是在我們第一章後面一個重要的單元，就是如何決定Performance，如何決定Performance之後，我們當然要知道說Hardware designer要如何去improve Performance，還有最後一個什麼是Paraprocessing為什麼要Paraprocessing？當然也是因為希望提高Performance，所以同學可以看到我們這堂課其實在談的都在談什麼，這是一個很重要的議題，就是Performance，我們就是在談這個Performance

那我们要了解这个performance，我们其实可以从几个level就从我们这个CS我们知道说这门课非常的重要，algorithm不管我们是在哪一个field我們基本上CS的每一个field都是在解algorithm都是在解optimization的problem，所以我们在比较我们的algorithm当然就是在比较我们algorithm的complexity我们如果說有人是n log n那前面提出來的 n²那種complexity的algorithm當然就會略訊一籌所以我們的

algorithm，我們在決定什麼呢，就是number執行的number of operation所以其實我們就在算說誰的演算法需要執行比較多的operation誰執行需要執行比較少的operation就是在比這個那algorithm出來之後呢我們需要coding對不對那coding呢 想說Avizion有啦那coding出來應該都一樣啊所以我們就說我們使用哪一種Programming Language呢

然後使用哪一個Compiler那我們要把它Compile這個Machine Code要在哪一個Architecture上面執行呢它的目標執行的目標是哪一個Architecture所以你的Compiler要產生這個Architecture的Machine Code這件事情重不重要 當然也是重要的首先我們就這個Programming Language我們知道說你用現在應該很少很少人在用

但實際上在美國一些商業的公司他們很多人還是在用就是用BASIC所以我想同學現在大部分人應該都沒有寫過BASIC大概是二三十年前或者是更早的時候年代流行的一個Programming Language你如果用BASIC寫你用 C 寫 C++ 寫當然是 C++它出來的 performance 應該會比較好假設是同一個人然後不要用什麼特殊的skiier當然你可以說那我用什麼我用 assembly 寫最好當然是最好只是看說你可以寫多大的assembly 的 program還有 compiler這個同學應該

大家都有這個概念我們這邊就不再贅述另外我們談到一個議題說同樣的 algorithm我們不同人寫出一個 programperformance 會一樣嗎也不一樣當然不一樣 對不對當然不一樣當然不是 comment 的位置不一樣comment 寫的不一樣因為我們知道 program 就是 algorithm 加 data structure所以你的 data structure 有沒有善用正確的Data Structure這個當然也是很重要所以你同樣一個Algorithm不同的人去Coding出來的效能也是有可能會差非常的多再來我們再來看Processor跟Memory的System Processor跟Memory System其實我們在這邊可能就要跟同學提到一個兩個名詞這個在早期大家比較會提的

就是說我們在不同的Architecture執行這個Program它是不是會有同樣的效能當然不一樣我們舉一個例子我們說不同Architecture 的這個Processor我們知道說早期Processor的設計有分兩大陣營，一個是RISC，另一個是CISC的代表就是ARM跟MIPS，就是這兩個，這個大家都知道了什麼是RISC呢？就是Reduce Instruction Set，它是一個精簡指令集，顧名思義就

是它的設計的哲學是什麼呢？它不希望說它的這個Processor所提供的Instruction Set是很複雜的指令，它希望說它的設計哲學是認為說我們提供越簡單的指令集，這樣子我們要去implement這些指令集的時候，我們在做Hardware設計，我們會讓我們的Hardware更有效率所以它的第一個精神一定是首先你只要是出現在指令集

裡面的指令一定是經常被使用到的絕對不會是那種偶爾才使用它，如果是偶爾才使用的指令，它一定是用它基本的指令集再去兜那一個偶爾才會使用到的指令，它的目的就是減少指令的數目，這樣子它在做Hardware Design然後要去Implement每一個指令的時候，它的 hardware 才會有效率才會執行得快，所以這個是RISC， 它的設計的哲學，那CISC呢？ 當然就是所謂的complicate，就是複雜指令，那這個 complex 就是複雜指令集，複雜指令集它的代表當然就是 AMD

跟Intel，AMD 跟Intel， 我們知道說你去看這個X86 它的 instruction set一大堆， 就是真的是你要全部都很熟的話，那個真的要耗費一番心力他的設計哲學就是他認為說有什麼需要的指令，他覺得說只要雖然它不是非常常常被使用，但是他覺得使用頻率大概超過一個程度，他認為大概就需要幫他弄一個指令，那個指令它可能實際上是一個很複雜的operation。你如果是用這一個

這個type的processor來implement一個複雜的instruction，這個type的複雜instruction你可能等於幾乎是寫一個subroutine，它才能夠implement這樣子複雜的一個指令所以這兩種不同的設計哲學基本上是不一樣的所以在不同的這種architecture實際上再搭配這個memory system，那你就是會執行出不同的performance，所以這個level它是決定什麼呢，決定你這個指令可以多快的被執行什麼是多快的被執行呢同學可以想想看像這樣子

的一個processor我們一定可以預期什麼呢，它的calculate rate是比較高還是比較低同學猜一下我們投個票好了我們說risk的calculate一般我們不是說一定一般我們照這個原理上面來看的話我們可以預期risk的calculate比較高的舉手大膽一點沒關係啊，打錯又不會怎樣。雖然答對沒有獎品，結果有滿多同學答對了，那risk因為我們說，因為它簡單，所以它

電路設計、 hardware設計可以比較有效率。自然而然，它的時脈當然就會比較高，所以它的calculate rate一般是比較高。這個CISC，它的calculate rate一般是比較低，但是它執行完一個指令，它可能這邊需要執行好幾個指令才能夠完成一樣的operation，所以到底誰比較好，這個其實在不同的場合不同的application可能會有不一樣的結果。

在下一層我們看到的叫IO system，IO system就是我們知道說，我們的computer system都要透過IO做一些operation，所以就是有這麼多不同的label。我們要可以來決定整個program的performance。所以，如果我們來看一個一個電腦軟硬體，它們之間的架構關係，一個大概的示意圖，這是一個很簡單的示意圖這個同學可能在計算機概論裡面

可能都學過了。我們可以看到說，在核心裡面這個就是一個Hardware，這是Hardware，我們知道Hardware，它不會動。我們還要再綁一個System Software，System Software當然就是包含我們的OS還有，就是說你的Program你要把它編譯成這個Machine code的時候所需要的那些System softwareCompiler還有Assembler這些接下來才是這個Application software現在大家都知道說這個當紅的就是什麼叫AP我們在談的AP大概就在談這個只是說AP在這個PC上面已經紅不是紅這麼久已經存在這麼久現在突然在手機這邊突然紅起來

所以我們知道說我們一般寫application不會用assembly去寫我們一定是用這個high level language那system software的話呢就是我們剛刚提到的compiler這個operating system這個我們就不再跟同學介紹這都是記概裡面的觀念那hardware就是我們提到的processor memory還有controller所以其實我們大概會越列的談到就是說這邊他們之間的這個關係 hardware software 的一個 interface我們也會知道說我們在 design 一個新的 processor一個 computer system

的時候hardware 跟 software 的 design 是如何來進行這個在我們後面會跟同學提到一個就是一個所謂的 instruction set architecture所以這一頁就是課本這邊就是 highlight 出來說我們一般所所理解的high level language這邊是C那變成assembly language的時候呢大概就便利成這樣子然後這個assemble大概就是變成這個樣子那我問一下同學現在還有人在寫這個的舉手有沒有不要客氣不要說都沒有人舉手我好像不好意思舉

你如果舉手的話 對 不要不好意思有沒有同學在寫這個這個一定有的嘛因為你修assembly就一定要寫嘛 對不對那這個現在大概沒有人在寫在早期的時候 城市沒有那麼大的時候就是這個programmer大概或多或少都會寫到這個東西那當然是在二三十年前所以那時候程式還沒有很大沒有像現

在程式也都這麼大所以現在程式隨便寫你說我寫了一千多行聽了就覺得實在是太小了因為以後出去工作自己寫的程式都多到已經不知道那個就是我們公司一個product一個程式要make就是一個程式要把它make出來用用最快的server大概至少要make三四個小時以上所以那個程式的code是非常非常的多接著我們再來看就是說

我們看到一個前面就是硬體軟體的一個大概的他們的構造圖我們接著來看這個computer的component我們知道說我們現在其實這一堂課最主要的focus就是在這個地方，這個地方這個地方就是整個Processor Processor包含了Control Processor包含了Control跟Datapath。我們知道說我們的電腦除了Processor之外還需要Memory就是記憶體的存取，所以這個Control這邊畫一張圖很明顯，它就是指

它只有出一張嘴巴，就是喊1 2 1 2 1 2，就是要大家同步，因為我們現在的電路，我們這邊都是synchronous的circuit。我們現在很少是asynchronous就非同步電路的話，它就需要一個時序需要一個clockclock就是1 2 1 2，大家都要同步，同步1 2 1 2 1 2，同步這邊也簡單讓同學了解這樣子的一個問題，同步它會有什麼

問題呢，因為現在同學大一進來都沒有上成功嶺，所以大家沒有成功嶺的經驗以前我們早期就是進大一之前都會先上成功嶺，然後成功嶺就是在那邊算是步兵的訓練、 基本的訓練，如果你站在適應台看到這麼大的一個部隊向右轉， 你這樣喊下去向右轉，那你就會看到這個部隊非常整齊馬上就向右轉，可是呢， 這個很奇怪，就是這邊的你就會發現它不是這樣一下就想要轉你就會發現轉轉轉轉轉好像這樣子

是前面看後面、後面看前面然後再更後面的又看前面這樣一路看它才會轉過去那會有這樣子的一個delay的原因大家都知道是因為聲音傳遞的速度所以後面的人他聽到響油轉他會有一個delay跟前面的人會有一個delay如果是更大的一個部隊的話就會有人跟他們講說你不要聽聲音你看最前面的動作因為我們知道光的速度是比聲音的速度還快所以你不要去聽響油轉你就看前面響油轉你就趕快響油轉就是這樣子

這個也是有這樣子的問題我們在電路設計裡面同樣是會有這樣子的問題譬如說我們假設這個是一顆chipchip它當然有它的範圍 對不對我們一個訊號從這邊進來假設這個訊號就是clockclock是什麼呢就是我們跟同學提到的它就是長這個樣子不好意思 這個畫面會動所以在寫的時候它會晃來

晃去所以寫的字跟畫出來的都長得很奇怪我們知道說譬如說我們是positive edge triggering我們知道說就是在這個往上的時候同步存取大家都follow這樣子的instruction可是同學可以想想看當你clock你從這邊一直傳你訊號這樣走走走走走走到這個地方訊號走走走走走到這個地方距離是一樣的嗎也不一樣 當

然不一樣所以這個delay也就不一樣所以在這個IC的設計裡面他們在設計這種Clock的訊號他們就會要求有這種所謂的Zero Delay skew它不允許說你從這個進來的input source到每一個端點我要接收到那個Clock的訊號運算的時候它們之間是有落差的，就好像我們剛剛提到的一個大部隊裡面聽到的想有賺

的時間點不一樣，如果大家聽到的都不一樣，那全部就都亂掉，所以在設計上面就有這樣子的一個optimization的問題我要想辦法讓它們之間到的時間點的落差是0，最嚴實的要求是0；現在的要求可能是會有一個torrent，它容許有一點誤差，但是這個誤差不能太大，只要是在這個容許的誤差範圍之內所有的電路的元件還是可以同步運作，所以這個是讓大家知道的一個common knowledge所以它這樣子

來運作的話我們知道說我們compile完之後這一邊就有很多這個program它就會存在這個memory裡面然後inputData進來然後它從這邊讀取這個程式或者是資料然後算完之後然後output，大概就是這個樣子所以這邊同學大概都知道了我們這邊就不用再詳細介紹了；至於後面的這個我們就可以很快的看過去，因為這個同學每天都在用的東西，這個是

Sun這個就是我跟同學提過這個在之前是非常有名的一個Workstation的一個vendor，他們的老闆是出了名的是反微軟的陣營的頭號大將逮到機會一定損一下只要請他發言他一定就有事沒事就損一下這個微軟不過他們已經先掛了這個是光學滑鼠因為我們早期的滑鼠都是滾軸它是用滾軸去偵測它的shift

它位移的大小現在這個光學的話這邊就有提到它有一個這個LED它會發射光源它有一個低解析度的這個camera所以它會去感知說它兩個瞬間它的這個offset也是這個時候它們的這個offset到底是左右上下多少然後來決定這個mouse可以這樣子來一來一去這個大概同學都知道這個的話這個早期

我們以前有玩過我不知道同學現在有沒有玩過因為以前好像之前問好像同學都沒有玩過但是不知道現在有沒有新的潮流大家又開始在玩這個東西這個就是在存什麼呢在存這個不是存 就是在Display我們如何在我們的Monitor上面Display Text或者是Graphics同學應該都已經知道說即使我們就是用一個

就是所謂的frame buffer就是我們的螢幕裡面比如說我們這邊這個螢幕它的解析度所以它有很多點每一點其實它就對應在這個記憶體的某一個位置這個點它如果說它顯示它如果是像早期只有黑白它是黑白螢幕所以黑白它只有兩種狀態兩種狀態的話它就是兩個顏色所以你如果是兩個

顏色的話大概就只要一個bit大概就可以表示說它是亮還是不亮當然你亮還可以是亮的比較多亮的比較少之類的，如果是彩色的話當然就要看說你提供多少種顏色所以一個pixel 一點就看你offer多少個color你就必須要有多少個bit的memory去記錄那個顏色，所以你要這一點讓它亮不亮， 呈現什麼

顏色其實你就要去fear它這個點所相對應到的framebuffer裡面的location你去寫入一個適當的值你去refresh這邊，它自然就會把你這裡面的純的值把它顯示在你的screen上面，這個就是從早期一直到現在都一直在使用我們要如何去display它的畫面像早期程式比較小的時候在做動畫或者是什麼之類的，其實你就

是有一種方法就是你就直接去控制這種framebuffer，它的這個update，因為尤其是動畫它很多都只是在partial的image它有做一些改變，所以你大概只要去update一些部分的location它的color你一直去refresh它就會呈現那種動畫的效果，這個就是我們把這個主機盒把它打開之後我們看到的它的內部，所以這個同學應該回去自己對照一下應該也都知道像這一個，它就是這個Memory 插Memory像這種插Memory就是現在的Memory好像比較不耐用，我記得以前Memory都還滿耐用

Any way其實不是只有Memory不耐用，我不知道為什麼現在的電腦都不耐用。我們以前電腦用至少大概六七年，那算是很短的。現在好像聽我實驗室的學生好像他們只要用三四年，他們就覺得好像應該該換了碰到我就覺得說奇怪不是還沒有六七年嗎？不過現在電腦很容易就壞掉不知道為什麼，所

以我們看到整個這個computer它的一些圖片的簡介我們來看說這個就是我們剛剛有提過的，在CPU在Processor之內我們就剛剛提到它有兩個，一個是DataPath一個是ControlDataPath，就是你CPU裡面在執行真正執行運算的單元，就是叫DataPathControl的話，就是你要去它講說SequenceDataPathMemory就是哪一個大聲工在那邊出嘴巴在那邊喊的，所以這是Control然

後裡面當然還有CacheMemory，早期大概只有Cache就有Level1現在有Level1 Level2所以這是Cache我們在後面有一個章節會專門講這個Memory這邊是一個示意圖，這個是AMD這個Barcelona四個Processor的一個code，所以看到它這邊有四個code這一張圖看起來其實我們就是它有一個專有名詞這叫Layout，Layout是什麼我們在第一章的後面會簡單跟同學介紹Layout就是實際上電路最後的

它的正面目，你要白話這麼解釋就是這樣子 Layout就是電路，它最後長的樣子，那個東西就是叫Layout，所以有人把它翻作這個叫實體，就是電路的實體，它的英文其實就是Physical Design那為什麼叫Layout的真正的面目或者是它的實體呢，因為我們知道說我們以前在在修這個數位電路設計的時候，我們那時候上

的好高興因為我們都是上這一種，我們都是上這種設計，对不对，這種設計看起來非常的friendly這個，不管你要做什麼設計，我都可以用這種東西把它就只要是數位電路，我都可以把它design出來，一套systematic的方法可是實際上我們知道說真正的電路，它並不是長這個樣子真正的電路我們在數位電路的

這門課裡面，我們也有介紹過所謂的電晶體，電晶體，我們看到的大概就是類似像這種符號畫得實在有夠醜，不過大概就長這個符號，我們知道說這個電晶體怎麼兜一兜，它會變一個InverterNAND GET, AND GET, ALL GET, NO,get這個電晶體我們看起來就不喜歡了，因為它的特性比較複雜不是我們大部分CS的同學也

不會喜歡它，但是它還不是真正的電路的面貌也就是說同學如果把那個包裝盒把它打開，你把那個Package把它打開之後，你把那個帶你把它放到這個顯微鏡下面去看，你去找找看，你如果可以找到這個東西的話輸你一頓飯，但是如果有Designer故意刻這個東西上去，那我就沒話講了。你如果可以找到這個東西，你如果可以在省異境下面看到這個符號，那實際上那個是沒有用的，那個是Designer他故意刻上去的，那個是要秀什麼東西的，我不知道

秀什麼圖騰，你也絕對找不到這個東西就是Layer、Layer它實際上就是一大堆Geometry，就是一大堆幾何圖形，所以你就看到一大堆幾何圖形，所以這個就是Layer另外接著我們就是說CPU之外，我們知道說還有所謂的Memory、Memory這邊也是有兩個名詞， 同學應該大家都聽過，一個叫volatile，一個叫non-volatile，就是你關機，turn off power之後，

它裡面的資料都不見，你turn off之後，它還在，所以這些都是那network，這個也不用介紹，所以這邊只是把這個跟computer它相關周圍的這些都讓同學review一下這邊接下來我們要談這個Performance之前，我們讓同學介紹一個很重要的觀念，讓同學了解說，我們在設計一個新的Computer，它到底是如何分工合作的，在進行首先，我們來看說任何的一個Design都有所謂的Extraction什麼是Extraction

例子其實就我們software的design而言，同學可以把它看成說我們一個program，它的實體存在電腦裡面是什麼，是010101對不對？現在大家都不會去寫010101，除了誰呢我每次提這個人就是，就是幾年前同學就已經沒有反應，所以像這部電影現在的同學大部分都沒看過，就那個Matrix裡面的那個Neo主角Neo。如果他寫成的

是的話，他可能就直接寫那個01 01 01，因為那個對他最Nature對我們最Nature是什麼，我們是寫C++這個對我們最Nature，所以Programming Language它分那么多Level，這個就是一種Exception。我們在 C++ 上面做 Design 的時候，我們可以寫很大的一個程式，我們可以看到 High-Level 的 Scope所以我們可以寫一個很大 Scale 的程式，這個就是 High-Level 的一個在分 Abstraction 之下，最 High-Level最 Low-Level 就是 Machine Instruction這是就我們 Software 而已，如果就 Hardware就好像說

你要做一個Processor的一個Design，我們可以從Architecture Level開始去描述，所以這個也算是一個Level算是一個Design Level那你Architecture Design完之後你可以再把它Dump到Dump到Behavior所以你是一層一層不同的Level由Top往下一直Dump，然後Dump到你的Gate Level Dump到Switch Level再Dump到什麼呢最後是layout最後設計完之後layout就出現了，所以這樣子的level我們知道說它的優點就是high level design scale可以做很大，但是在高 level你如果要做simulation的時候通常會比較不準，因為它可以看到的真正每一個元件它的property

都是黑核子那個黑核子是不精準的一些參數，所以你既然是不精準的話你的Simulation做出來也就比較沒有那麼準確，但是它的優點是什麼呢就是速度很快，所以它可以做一個scale很大的系統的Simulation，那你如果是在當到這個circuit level你要去run some spice，那個速度相對的就很慢，但是它出來的Simulation結果那告訴你

說它的delay是多少，那它的實名類型的結果就會非常的準，所以這種obsession幫助我們去第一個可以了解整個系統我們不需要說第一次就去看那個最detail的東西我們先從最high level的開始來拆解然後high level拆解完之後再down到下一個level所以其實就我們剛剛提到的就我們的這個software而言你要把整個Absorption Level 全部跑過一遍同時要修過很多課你要修從大一的程式演的設計然後你要開始去修系統程式 作業系統Compiler慢慢你的整個 overall 的 scope

才會出現那 hardware 也是一樣 hardware 你必須要從最 top level 的課程開始修當然目前分工分等性你並不需要全部都很了解你只要專精某一個FIR就可以另外還有一個名詞叫Instruction Set Architecture什麼是Instruction Set Architecture呢它就是HardwareSoftware的Interface這個ISA它的重要性有多重要呢就是說我們在設計一個新的CPU的時候會不會是說這個新的CPU

實體它已經做出來了那做出來之後呢我們這個軟體公司它趕快去發展什麼Compiler然後OS做這個Porting然後它的OS Compiler做完之後AP趕快去做什麼Application趕快去寫它的Tool是不是這樣，如果是這樣子的話，它等於是什麼？ Sequential Hardware做完然後做System System做完再做AP，所以你的整個cycle會拉得很長，所以我們當然一定是

同步進行就是說，你design hardware然後你design system甚至你可以做你的AP的設計，你要這樣子同時進行怎麼辦呢？你就必須要把不同的group之間的interface要把它定得很清楚最底層的那個hardware，它的interface就是這個instruction set architecture這個東西，它就是告訴我們說將來我這個Processor，它會offer哪一些instruction，它的instruction set裡面到底包含了哪一些instruction，它的這些instruction，它的這個fear到底是怎麼定然後它的這些machine call到底是怎麼定這些都非常的清楚，instruction set architecture，所以你這個已經定好之後就可以怎麼辦呢？

另外我們先看一下我們再去看那張圖Application Binary的Interface什麼是Application Binary Interface顧名思義這個就是你要寫Applic ation當你一個系統都還沒有出現的時候，你Application如果要同時去進行的話，它需要有這種Application Binary Interface，它需要ISA加上System Software Interface下課嗎？我們把這張圖看完，

ISA就是這一層，所以你Hardware的 interface訂好之後，你要寫System Software它就知道說它之後的OS還有Compiler、Assembler它產生的Machine code，它的format到底是什麼？它的format就是這個東西，就是你到底有哪一些instruction你的instruction長什麼樣子？它的內容是多少？它的content是多少？ 這個都定義好，所以你的system你也可以跟著去發展，那你的hardware designer就會根據你的ISA去設計你的硬體，你的硬體就是要去implementISA裡面的每一個instruction就是這樣子，所以這個可不可以同步進行可以，

它們可以同步進行因為都有一個共同的interface那ystem它如果也有offer它一個system的interface對application而言，它全部都具備了，因為application它有system software的interface又有ISA，所以它不管要這一層， 要這一層，它都知道說它之後到底是怎麼樣的一個，就是說它最後的長相到底是什麼，他都知道得很清楚，所以就這三者而言，他們的design應該是不會受質疑。我必須要這個先做完之後再做這一個，所以就整個team的發展而言，他們是可以impairment進行，所以這就是ISA它的一個重要的觀念

所以這個就是我們今天就先跟同學介紹到abstraction這個觀念.