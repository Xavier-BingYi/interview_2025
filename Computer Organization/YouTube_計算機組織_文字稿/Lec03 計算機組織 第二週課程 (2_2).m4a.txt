undefined
我們上幾堂課就是跟同學提到除了介紹歷史之外還有提到這個Performance在這門課裡面扮演一個重要的觀念我們首先透過一個例子課本上面的一個例子來看一下這個Performance的一個定義我們在這個例子裡面它其實就是要來探討說我們有這個四試駕這個飛機我們要來看看說到底哪

一架飛機它的 performance 是最好的我們這邊有四張圖表第一個這張圖表是 passenger 的 capacity它告訴我們說每一個飛機它所能夠它就是一趟它最多能夠載運多少的乘客第二個它這邊第二個圖表它是 cruising range它指它的這個就是他航行 就是巡弋的範圍大概有多遠他一趟加滿一次油之後大概可以跑多遠第三個圖表是cruising speed就是他巡弋的速度 飛行的速度最後一個是passenger乘以mph就是每小時可以跑多少mile所以基本上就是

就是指我們的速度同學可以發現說這四台飛機在這四個數據裡面它的優異程度不一樣舉例而言它存在的人數最多是這個波音747如果說我們要看它交往一次大概可以航行多遠最遠的是這個就是Docker DC850如果說我們說最快的話是另外這個conquer它的時速是最快的但是我們

如果說passenger乘以mph的話最高的這個值是這個波音77那這四個數據到底有什麼不同的意義呢？同學可能會說那這個一定是最大的巨無霸，它可以載最多的乘客，所以我們一次可以載最多人從AD載到BD。如果我們用這個觀念來看的話，我們會說同樣有1,000人要從A載到B，所以我們用這

一台來載的話，它可以怎麼樣呢？它可以用飛最少次的次數然後可以把1,000人從A載到B，感覺好像是這個最好。如果說是這個的話，我們說這一台Doggers DC850，它的Range它可以跑最遠，所以你說如果說這個A跟B非常遠的話，這個可能就一次加滿油，它就直飛其他，它可能還要再落地再加油然後再飛。

如果說看到這個速度的話，這一個是最快的，它就是一趟A到B，它花的時間是最少，所以是不是這一個會比較好。我們在討論Performance，我們到底是要看說它飛最快呢？還是他載最多呢？還是他的這個巡弋的範圍是最遠的？到底哪一個是最好？其實我們如果看1 2 3單獨看這三個，實是不準的，因為我們知道說我們在討論就是說，

並不是說他載的次數越少越好或者是說他飛得越快越好的話，我們應該派什麼？我們應該是派那個戰鬥機戰鬥機的這個，這個速度是最快的，可是我們知道說戰鬥機一台就是駕駛，如果雙人坐的話，就是後面再坐一個，所以大概就沒地方坐了這邊至少可以載100多個，所以這很明顯如果說要比這個時速的話應該不會是這樣子的一個比法到底怎麼比呢我們來看一個式子這邊課本它有提到說其實我們可以考慮說

總共有多少個乘客就好像我們剛剛講的假設我們要從A到B總共有1,000個，所以有total有多少個number of passengers然後除以這個passenger capacity我們就知道說用哪一型的飛機它需要幾趟的航行次數才能夠把這1,000人把它從A載到B所以我們會乘以所謂的passenger capacity所以它總共需要幾次，一次需要花多少時間

呢，一次要花多少時間呢我們知道說 distance就是A到B的距離A到B的距離到底是多少我們現在這邊假設我們不考慮說它的cruising range到底是多少我們假設都是加滿一次一定能從A飛到B它不需要說還要停下來加油說這個要加油然後這個不用加油所以加油還要減速加油加速它還要多花

一些時間我們就不考慮這些這些factor所以我們就是說它的距離是多少然後它的cruising speed就是這一個cruising speed到底是多少所以這個就是飛一趟需要花多少的時間然後這個是總共要飛幾趟這個是飛一趟要花多少時間那乘出來就是total我們用每一行的飛機它把1,000人從A載到B BD它總共要花多少時間，在這個例子裡面，這個式子才是我們所謂的performance，在這個例子裡面，它的capacity也不是performance，它的speed

也不是performance就是它total要把這一千人從A載到B需要花多少時間，在這個式子裡面，我們知道說number of passenger跟distance between A and B這兩個數字是固定的它是constant所以variable就是這一個variable是什麼呢！第一個是passenger capacity第二個variable是什麼呢是cursing speed我們要這個數字是越小越好那既然要越小越好的話，我們是要怎麼樣呢！我們當然需要說這個相乘是越大越好對不對所以這個數字分母的這個數字其實就是我們第四個table它的passenger的capacity再乘以它的speed

因為這個數字越大的話，我們這個performance，它的數字就會越小所以最好的是這一個所以我們透過這個例子，第一個例子，我們大概就可以稍微體會出來說，我們在討論這個performance的時候其實我們就是看說它完成這件事情要花多少時間其他的一些factor它會影響到花多少時間的這個factor我們並沒有

辦法單獨考慮單一的Factor就來決定最後的這個Performance因為它是由兩個以上的Factor來共同影響最後的這個Performance透過我們剛剛的這個例子我們就來看這個第一章裡面就是說這個很重要的觀念其實這個觀念也還滿簡單的只是一般就是不會大家不會仔細想這些問題我們同學應該都聽過response time跟這個throughput那response time是什麼

呢response time我們知道說它其實就是它這邊告訴我們說它就是說我們要完成一件工作所需要花的時間這個就是response time那throughput呢throughput是說我們在單位的時間之內我們可以完成多少件工作所以它說有這麼多的工作可以在單位時間之內被完成你這個單位時間我們可以說我們平均每個

小時他大概可以完成幾件工作在一般的這個在一般的這個商業活動裡面其實他們的這個系統他們是還滿注重這個throughput比如說他每秒可以每小時可以或者是每分鐘可以完成幾筆交易或者是說它每分鐘它可以完成多少個query的operation這一類的都是屬於這個throughput有關於這個response time跟throughput我們同學來問一下同學就是說如果是以你個人而言你個人在用電腦你會比較concernresponse time還是比較在乎這個throughput它的這個

好壞你是希望這個比較好還是這個比較好這兩個其實沒有什麼對跟錯的問題這純粹是個人觀點的問題如果說是以我們個人使用的話個人使用我們一般比較會在乎的是這個response time為什麼 因為我們當然都希望說我們在移這個mouse我們在double click這個item的時候它多久時間會反應出來這個就是response time

那Srp是什么呢Srp是以系统的观点来看以这个电脑系统的观点来看比如说我加了一个Server那我加了一个Server不管你是哪一种ServerFile、FileServer或者是专门提供人家Query的各式各样的就是你的Server的Application不一样但是你在乎的应该是说你的这个系统你到底每小时或者是每分钟你可以服务多少人

或者是完成多少工作所以這個觀點會不一樣我們就會比較關注這個throughput它的值會比較高所以這個是基本上response time跟throughput兩個它們的這個些微的差異所以純粹是這個觀點的不同在這個地方，我們來看一個改變就是說，這個是我們一般在最近幾年比較沒有，但是在之前的二三十年來所有的電腦的買賣大家都

被同樣的一個觀念牽著走，那個什麼觀念呢？就是每當有電腦公司，它推出，不管是AMD或者是Intel，它推出比較High-end的Processor，然後它 announce，說這個電腦是裡面搭載最新的Intel最新的AMD，怎麼樣，它的價格就會很貴，它就是因為它提高了calculate rate。我們這邊就講說，我們有兩個選擇，第一個選擇，就是說，我們把我們的電

腦裡面的processor用一個比較快的version，就從2GHz把它換成3GHz，這是換成比較快的version第二種，我們加比較多的processor，比如說，我原本是2GHzSingle-Core的CPU，我現在把它換成，也是2GHz或者甚至是1. 8GHz但是，它是Dual-Core或者是Quad-Core，所以它是Multi-Core的電腦。如果說我們用這兩種機制的話，它對Response time跟Surface到底會造成什麼樣的影響。 kita來探討一下。說第一個方案，第一個方案

當然我們要討論的就是說它的 response time 它的 throughput其實在這樣子的討論也是稍嫌籠統的一點。可能還要再稍微再劃分一下劃分什麼呢？我們說我們的這個電腦，我們到底是 single user 還是 multi user就是說都是我一個人在用呢？還是說其實我這個是加了一個站然後很多人他都可以 login 進來使用這台電腦。這

種情況其實也會有一點點不太一樣。所以我們來看，假設我們是使用比較快的Processor然後我們如果是針對這個single user來看的話，這個response time它會不會變得比較好。它當然一定會變得比較好clock rate你從2GHz變成3GHz，它一定會變得比較好。但是，我們後面都會講說其實你不要被那個比較高的clock rate所騙好像3GHz一定跑得多快多快。其實我們並不是說它3GHz跑得比較快是騙人的，而是說3GHz跟2GHz我們說它快了1.

5倍。實際上，它的performance真的會好1. 5嗎實際上並不一定，它的performance的increasing rate不見得就是跟你的clock rate成同樣的一個 rate， increasing rate但是它的 response time 它一定會變好，那 throughput 呢 throughput 其實它當然會變好，因為假設我們是一直灌你一直灌很多 program 進去sequentially 一個一個灌就 single user 灌 program 進去你的 response time 減少了當然你的單位時間完成的 work當然也會增加所以對 single user 而言這個都是一樣的，

如果說Multi-User的話，Multi-User其實我們這邊我們是假設安德一種同樣的一種這個假設是什麼就是我們都是假設說Multi-User的使用環境當中，其實都很多使用者都在那邊Waiting大家都在那邊等待而不是說雖然是Multi-User但是好像都沒有人上到這個站來用我們不考慮這種情況我們考慮的情況是Multi-User很多人都在用

很多人都在等這種情況之下你增加你的calculate你的response time會不會減少當然也會減少因為A-User很快就把它解決掉馬上換B-User它也很快就把它解決掉，所以in average來看的話這個Multi-User它一樣會減少同理這個throughput當然也一樣會減少所以對這種Multi-user而言這个都是一樣會減少，如果說我們是考慮這個Multi-processor如果是Multi-processor的話我們換成Dual-code Multi-code用Single-code變成Dual-code Multi-code那你如果是Single-user你的response time會不會減少目前不會因為我們目前沒有

那樣子的Compiler的技術把一個Program就是一個Parallel Compiler然後把它Compile成然後自動把它Distribute到這個Dual CodeMulticode然後去讓它Run然後變得更快然後在目前沒有這種General Purpose的這種Parallel Compiler這個也是可以跟同學提一下就是說這個技術是就是說我們目前來看硬體跑太快了Software是遠遠落在硬體的後面所以說在比如說Microsoft還有Intel其實他們很希望說這樣子

的這種general的paracomputing的environment可以早日成熟所以他們其實砸了很多錢在美國那邊資助很多美國大學的研究單位然後進行這一方面的研究這方面的研究就是希望我們develop一個general purpose的paracompiler這種意思也就是說你designer不需要去那邊想說我要把這個程式把它平行化我要怎麼做 怎麼做 怎麼做其實現在很多不同的領域它有很多這種research topic它譬如說是dedicated到這個Maticode的這種framework或者是dedicated to這種

Many-code GPU的Architecture我把某一種Application的Algorithm我想辦法把它Paralyze我如果能夠得到很高的Performance它的Speed up很大的話這個就是一個Excellent的Research的Work目前很多Research都在做這方面他們要做的是說我們一般General User根本不用管那麼多其實你就是寫完之後這種Paracompiler就可以來完成幫你Take care所有的事情目前没有这种环境了所以

我们说你增加更多的Processor有没有办法Single User有没有办法去reduce你的response time目前是没有或许明年就有也说不定有没有办法去增加你的SrewputSrewput当然就是你如果有办法把Job A丢到Code 1然后Job B丢到Code 2那你的Srewput当然会增加所以這個是Single User Multi User的話你如果是增加Core的話Multi User是PostTime應該是ResponseTime會減少因為你可以把JobA Code1 JobB Code2你可以這樣子Submit同樣的你的這個Throughput同樣會有這樣子

的一個Game所以這個是以前可能大家比較沒有想到其實但是一個蠻簡單的觀念就是response time跟throughput透過這樣子的一個改變它會造成什麼樣的影響所以其實在這一邊呢就是我們剛剛提到的就是說我們的viewpoint不一樣會希望去decrease這個或者是increase這個但是我們在講在比較我們底下的一些example comparison其實我們的

比較基本上我們是 based on這個 execution time因為一般我們如果說要比較說你到底是電腦A比較好還是電腦B比較好in general我們大概就是會比較它的這種 execution time所以我們說 performance就是 execution time 分之一如果說 x 是比 y 還要快然後快了 n 倍的話基本上我們會說那 X 比 Y 還要快了 N 倍那這個 N 當然就是 performance 的 X是 Y 的 performance 的 N 倍那 N

倍的話當然就是 X 的 execution time是 Y 的 execution time 的 N 分之一所以導數就會變成這個 N這樣子的一個比較其實你不用去考慮其他的那些其他的 factor其實你就用這個很簡單的一個 matrix就可以很明確很仔細的說明說Performance其實就是執行時間你花越多的執行時間它的效能就是越差就是這樣子所以

我們這邊有一個例子我們說我們要去跑一個Program所花的時間我們說在A上面10個second在B上面是15個second所以我們就當然知道說A一定是比較快B是比較慢那快多少呢10分之15就是快1. 5倍這是一個很簡單的Performance的metric可是關於這個ExecutionTime同學如果有去扣這個PC或者是Workstation你們有去算過說你的Program到底需要花多少時間來執行的話同學應該都已經有看過就是我們可以扣的API裡面你要去

去retrieve的那個data其實不是只有單一筆data它會告訴你說有CPU time有elapsed time你可能會覺得說什麼是elapsed time什麼是CPU time這一邊它就告訴我們說什麼是elapsed time什麼是CPU time通常我們在做research的時候我們在比較我們在比較說我們的work比較好呢還是它的work比較好呢通常我們不會去比較elapsed time我們比較的

是CPU Time原因在什麼地方呢我們來看它的定義Eleth Time它告訴我們說它是Total Response TimeTotal Response Time就是我們前面看到的Response Time跟Throughput的比較所以它是一個反應的時間這個Response Time它已經告訴我們說它包含了所有的Detail的任何事情所需要花的時間全部都要Count進來包含什麼呢包含說這一個它CPU所需要執行的

時間我們知道說我們技蓋有上過這一方面的我們說這個Multitasking我們是把那個Time把它切成很細很細的slot每一個Task進来然後CPU就Dedicate去Serve這個Job然後之後它沒做完的話它就出去下一個再進來就是這樣子因為它速度非常的短讓我們以為說就是Multi-user大家都在用裡面只有一個CPU讓大家覺得說

這台電腦都在幫我做事情其實它是在那邊Time sharing所以它需要花什麼時間呢它要進到CPU裡面去然後它要出來它要再進去它還要再出來進去出來需要做什麼呢我們都知道說你要進去你要換這個job執行的時候你必須要把跟這個task所相關的state它的狀態全部狀態是什麼就包含你CPU裡面的register對不對

就是那些資料把它 copy到你的CPU裡面去執行完之後你要退出來換另外一個task進去你必須要把你目前這個task執行到目前結果目前的狀態也要存起來然後它要把它save起來所以這些都需要花時間這些時間它全部都算在in less time裡面所以他說Processing, IOS, OS overhead, idle time這些全部都算出來所以這個實際上它是在算我們System的Performance另外一個CPU time它完全就是說你時間是花在處理這個Job

上面的時間所以它不包含你的IoTime不包含其他的這些需要做Time Sharing方面的這些工作所以它就不做這種事情所以我們在研究工作我們在比較說我們的比較還是他們的比較好我們通常是比較這個CPU Time在那邊換來換去這個電腦它的狀態都不太一樣所以這個很難比我們就比說我們真正在CPU裡面花多少時間

就是在比這一個所以我們說不同的Program就是說它會被CPU我們說我們來考慮CPU或者是System的Performance CPU我們只有考慮CPUCPU Time或者是我們考慮整個System的Performance我們用這兩種Metrics來看這個Program的時候其實這個不同的Program它會有不同的變化它並不見得說都會呈現一致的改變都變好 都變壞 不一定因為有的Program

它的IO可能會需要比較多所以這種不同的Program之間的關係是不太一樣的接著我們再來跟同學介紹一個CPU的Clarking為什麼要介紹Clarking呢這個Clarking因為Clarking就是跟Performance有相關我們前面就說Performance就是什麼就是Execution Time我們在前面我們再跟同學說Execution Time你可以考慮你的System的Performance你也可以考慮單純的CPU的Time可

是我們都在講這個時間但是時間到底要怎麼算所以我們後面會有比較detail說真正的Programs需要花的時間要怎麼算所以首先我們要先知道這個ClarkingClarking我們上次跟同學提過cluck就是synchronous circuit都會有這樣子的cluck就是一個固定的週期就是on off on off這個on off on off我們說cluck period指的就是指一個週期這個叫cluck period所以說我們一個cluck period或者是cycle time就指說這一個長度到底是多少時間比如說它是250 picosecond它其實也是等於0.

25 nanosecond其實我們在談到clock的時候同學都知道其實它是clock frequencyclock period其實就是clock frequency的導數clock frequency就是我們的錢都是砸在這個數字上面我們的錢都砸在這個數字上面這個數字越高它就越貴其實就是說這個CPU它的clock每秒到底有幾個cycle它每秒有幾個cycle所以你每秒到底有幾個cycle就是這樣所以你每秒你的cycle的數目越多的話表示它震盪的次數就越多震盪的次數越多其實為什麼會說是這個電路會比較快呢或許同學已經知道我們這邊很快的讓同學了解一下這樣子的一個觀念

我們一般所謂的synchronous circuit它的基本的型態大概就是這個同學都知道的就是Digital System裡面大概都學過的這個FF是什麼呢它是Free FlopCC是Combination Circuit這個Free Flop跟Combination Circuit我們知道這個其實你如果把它展開來的話這個我們是把它濃縮在一起你展開來它等於就是說這個是一層的 free-flop它會透過一些 combination circuit然後再位到下一層的 free-flop然後它的 output

可能會進到這個 combination circuit這是不同的 time frame你可以這樣把它展開來是類似像這個樣子這個 synchronous circuit 是這個樣子我們說它的 clock是在控制什么东西呢它的clock当然就是说我们假设是positive edge triggering在这个地方发生它会把所有的data全部都load进这个free flop那free flop的dataload进来之后它output出现之后它就会进到它就

会位到这个combinational circuit這個combinational circuit就要算出去決定下一個state它的state是什麼這個combinational circuit它的delay到底是多少呢我們這邊是一個示意圖實際上在真正的電路裡面同學可以想像說從這一端進來跟這一端出來它有很多條pace比如說這边有一條pace這边有一條pace它的pace的數目是非常非常的多pace number非常的多我們說這個combinational circuit它的速度就是取決於這combinational circuit裡面的每一條pace的delaydelay是什麼

呢我這邊訊號進來到這邊出來需要花多少時間delay就是我訊號從這邊進來然後從這邊出現需要花多少時間我們假設說這個delay需要一個neural second这个delay需要两个neural second它total只有两个pace同学请问一下这个case它只有两个pace一个是1 neural second一个是2 neural second我们的这个clock cycleclock period要射程多少射程1 neural second还是2 neural second

我們要2我們都要等什麼我們要等比較慢的這跟什麼我們假設說我們就全班去跑1萬公尺我們就算說這一班要花多少時間跑完是什麼呢 是最後一個跑道你最快一下子就跑完了沒有用你要看最後一個跑道終點就是算這一班他花多少時間才跑完這1萬公尺所以你要等最慢的所

以這就是2 ms我們會選這個 我們不會選這個因為你如果是選1 ms的話有的會過 有的不會過這個sec就錯掉了所以我們要等最慢的 就是這個2這個就是我們所謂的clock它的cycle的目的就是要讓所有的人都同步要同步的話就是要等最慢所以同學可以看就是說這個clock rate越高的話就

表示clock cycle越小clock cycle越小就是表示這一部分的combinational circuit它的delay就越小所以當然它overall circuit速度就越快所以它完全就是在這個地方它的clock rate的觀念基本上大概就是這個樣子我們知道clock其实并不是要让同学知道剛刚的那个观念其实我们是要告诉同学说我们的CPU time其实它就是CPU clock cycle就是number of clock cycle就是你run这个program总共需要多少个CPU的clock cycle你每一个clock cycle它的cycle time是多少这样一乘之后就是我们这个job这个program

它需要多少 CPU time所以這個都是很 straightforward 的一個式子因為我們說這個 clock 的 cycle time它的導數是什麼呢就是 clock rate所以你也可以把這個式子變成就是分母變成是 clock rate你這個分子還是你所需要的CPU clock cycle的 number所以到這裡我們就很高興了我们就很高兴说我终于知道我的CPU time是由这两个factor或者是

这两个factor来dominate所以我们要让它变快怎么办呢我们要improve我们的performance当然是要去reduce the number of clock cycles这是第一个第二个我可以increase我的clock rate或者是decrease我的clock cycle time所以我就说我終於知道要如何去improve performance不過天下的事情通常都沒這麼簡單很多時候你好了這個factor另外一個factor它可能就會走樣我要去increase我的clock rate結果我的clock cycle會增加是沒有錯但是如果說這個它會減少

就是你的calc rate如果是把它變多的話你所需要的這個calc cycle的這個number會增加那你增加這一個然後這一個也增加好像會抵消但是如果說這個增加比較多這一個增加比較少那你一層的話你最後就是說你最後的那一個數字這個不是一層就是這一個除以這一個這個增加比較多這個增加比較少

兩個相處之後它還是會減少但是問題難就難在說你很難控制說我這個到底要增加多少然後這個它會相對應的變化量會在我的控制範圍之內讓這個會變好這個地方就比較難去judge說要怎麼做所以他這邊就講說Hardware designer他通常必須要trade off就是在你的cycle count你的所需要的clock cycle的

number跟你的clock rate中間你必須要做一個取捨同學在這裡可能會聽得好像怪怪的說怎麼會說我增加了這個東西這個東西它的變化會影響到我的CPU time呢我們後面來舉一個例子這個例子可以讓同學了解我們前面在講的這件事情這個例子我們來看這個就是我們假設一個現有我們使用

的clock它就是這樣有這麼多個cycle我們這邊有五個instruction每一個instruction它所需要的時間不一樣這邊它要講說舉例乘法一定是比加法還要來得慢然後floating point的運算一定是比integer的就是整數的這個運算還要來得慢那既然比較慢的話我們 suppose 它會需要整數倍的整數倍的 cut cycle 的 number舉例而言 我們這個指令是什麼 我們不管它很快 一個 cycle 就做完了那這個指令它需要兩個 cycle這個指令一個

一個 這邊兩個所以我們說這五個指令total 需要幾個 cycle呢1 2 3 4 5 6 7它需要七個 cycle才能夠把這五個指令做完所以這個是我們知道的一件事情我們現在來看說我們就看兩個指令一個指令 兩個指令這兩個指令我們用兩種不同的clock rate來執行看它需要幾個cycle或者它需要多少時間我們說這是第一個第一種clock rate這是第二種clock rate

第一種clock rate很明顯它是優於第二種clock rate因為它的週期時間比較短對不對它週期時間比較長所以感覺這個是比較好這個是比較不好我們來看這兩個指令如果用第一種clock rate來執行的時候它會碰到什麼情況同學可以看它所需要花的時間就是這麼長對不對這麼長這麼長的話你在這一種clocking strategy的

情況之下它需要幾個cycle一個可不可以 一個不行 一個不夠它需要兩個 對不對所以它需要兩個這個指令我們把它貼在因為它前面需要兩個所以我們這個就在第三個cycle開始執行這個指令它需要三個其實還沒有滿三個 多一點點這個少一點點但是它需要三個Cycle所以同學我們來看

說這兩個指令它在這一種Clarking Strategy它需要1 2 3 4 5那它需要花多少時間它需要花的時間就是從這一邊到這一邊這邊開始到這邊結束它有沒有浪費 有沒有浪費了第一個指令它這裡就執行完了它這邊要IdleCPU必須Idleidol等第三个clock上来的时候它才会执行第二个指令第二

个指令它也是这边就执行完它还有一点点的idol time所以这种clocking strategy我們會浪費了這麼一点時間如果說是這種clocking strategy我們說我們就取這一個是它的clocking period就這樣長這個剛剛好也是它的兩倍第一個指令需要一個cycle第二個指令需要兩個cycle它需要三個cycle它的time是從這邊開始在這邊結束

所以很明顯它可以減少多少時間我們不要算cycle的number我們算時間它很明顯它可以減少這段時間對不對它可以減少這段時間這個就是我們剛剛講的就是說你的clock rate你把它提高沒有用你要看你的instruction instruction set裡面每一個指令它到底是需要花多少時間你花多少時間然後你要取一個最佳的值大部分的大概都是在同樣的一個cycle其他的它剛好就是這個cycle time的整數倍

整數倍它也不會去浪費絕大部分的instruction都不會去浪費這種idle time你如果可以做成這樣子的clocking strategy的話這樣子的clocking才是一個好的clocking所以並不是說你要把它拉很高然後就表示說它很好所以我們從這邊就知道說前面提到的你的clocking的數字越高並不見得越好當然你也沒有辦法說要想多高就要多高因為從前面的這個例子我們可以知道說你的Clocking要拉很高的話你必須要把這一個它的Worst Delay，你把每一個Pace其中裡面Delay最差的那一個你要把它做到最好你要做得非常好你才有辦法把你的Clock把它調很高不然你會被這個Dominant。

那我們剛剛的例子呢剛剛那個例子是一個很重要的觀念所以同學一定要把這個觀念把它確立下來。那我們來看接下來這個例子CPU time的一個例子，它告訴我們， 這個是很簡單的例子，它說這個CPU Computer A，它是2GHz， itu就是說它執行一件程式需要10s的CPU time。現在我們要design一個computer B，我們希望CPU time是6s。我們可以有比較快的clocking其實它就是要問說

我們的這個computer B，它的clocking到底要多快要多快才會怎麼樣呢。他說多快才會讓我們的CPU time是6個second。但是我們需要我們的clock cycle的數目大概是這個computer A的1. 2倍，也就是說computer A，它如果需要M個clock cycle執行這個program的話，computer B它需要1. 2M個clock cycle來執行這個program所以它就只是在問這件事情這件事情當然就很簡單，因為我們前面的式子，我們知道說我們的clock cycle的number所需要的clock cycle的number是什麼呢？我們如果知道說我們需要花多少個CPU time，

我們需要花多少時間，我也知道clock rate，因為clock rate是你每秒它有多少個clock cycle，你有這么多秒一乘就會知道說你要花多少個clock cycle。我們這個式子 背上這個式子Computer B，它的clock rate其實我們要知道Computer B的clock rate就是把這個除過來除過來，所以CPU time再分母然後Compute B的clock cycle在這邊Compute B的clock cycle是多少，就是我們剛剛提到的A的1。

2倍A是多少呢？ A就是我們就把這兩個A的兩個數字相乘一個是A它需要10個second然後A它的clock rate是2GHz這樣一乘就會得到什麼呢？ A所需要花的clock cycle的number就是20乘以10的9次方所以你把它代進來我們就會得到V的clock rate14 GHz就是這樣子所以這是一個簡單的代換接著我們要再更深入一點就是我們剛剛前面就只是講說我們的clock cycle就是我們的CPU time然後再乘以我們的clock rate其實我們可以來看說

我們所需要的cluck cycle可以用另外一個觀點來看另外一個觀點是什麼呢？這個觀點就是說我們這個程式總共有多少個instruction count然後每一個instruction它需要多少個cycle我們假設每一個instruction都需要兩個cycle那我這個程式我們這個程式有5個instruction所以5乘以2就知道說total它是需要10個clock cycle就是這樣子所以

這個就是我們的clock cycle的數目可以用這樣子的觀點來看既然是clock cycle可以用這樣子來看我們就知道說CPU time這個公式可以再稍微換一下我們就把這個CPU time我們就把這個clock cycle替換成這個替換成這個所以這個就把它導進來instruction count是在這裡CPI就是這個縮寫cycles per instruction就是平均每一個instruction它需要多少個cycle才能夠把它執行完所以你這樣子一乘的話就是你這個程式需要多少個clock cycle然後再乘以cycle time就會得到這個CPU time

所以當然這個式子也可以把它導成就是把這個cycle time換成clock rate就變成這個分母所以我們為什麼要導這個呢我們就知道說我們要reduce我們的CPU time我們可以做哪些事情呢我們可以做reduce instruction count我們可以reduce CPI我們可以去increase clock rate我們會發現說我們知道的比前面一個公式還要再多一點所以這

個就是我們這個公式最主要的用意這個用意當然我們就要知道說在什麼地方可以reduce CPU time它這邊就告訴我們說instruction count它是一個program總共需要多少個instruction才能夠執行這個是由誰來決定的呢它這邊告訴我們說可以determine by program instruction set architecture還有compiler這三個全部都可以決定這個instruction count所以這個同學應該沒有問題因為你的program寫得非常非常非常長當然你的instruction count你要希望它很短這個好像很難除非你有一個非常好的compiler

當然你也要對應到什麼呢不同的instruction set architecture這邊的例子就是我們前面跟同學提到的RISC跟CISC如果說我們把一個program，把它map到RISC，另外再把同樣的program，把它compiler在這個CISC的machine上面去compile。我們說哪一個instruction count會比較少？ Risk還是Sysk？我們把同樣的program，在Sysk跟Risk上面去compile，在哪一個平台上面，它的instruction count會比較少沒錯。 Sysk為什麼？ 因為我們前面提過的Sysk，它的instruction比較複雜，一個指令它可以解決比較多的事情，

那Risk的話它可能必須要用比較多比較簡單但是比較快的指令去兜一個比較compressed的instruction，所以我們就說，如果是要單純討論instruction count的話，你要比較少的instruction count大概就是Sisk。可是這樣是不是代表Sisk一定比Risk還要優呢？還要好呢？不一定，這depend on你的computing的situation，這個的確是不一定。在早期CISC跟RISC他們競爭很激

烈的時候，你會發現說什麼這兩大陣營用的benchmark的matrix好像不太一樣，因為大家都是用對自己有利的matrix還有就是其實，如果談到這個RISCSysc的話其實現在已經沒有這個東西了。現在已經沒有所謂的真正的Risk或者是Sysc，因為同學你可以在目前的SyscSysc的代表就是我們說這個Intel的架構AMD的架構。同學可以在Intel的架構裡面發現很多以前Risk他們裡面的架構，因為他們覺得說Risk他們有這麼多優點，那為什麼不拿來用呢？

所以它其實不是純CISC。它裡面有很多那種Architecture的Design都是從RISC那邊把它移植過來的。所以現在已經沒有所謂的什麼Pure RISC跟CISC的這種戰爭。我們繼續來看這個一個Program的Instruction Count。我們剛剛提到說這個Instruction Count它會，它會被這個一個Program、Program的這個多寡。 如何寫法決定也會被ISA所影響另外一個Compiler其实也是會

受到影響实际上，在Compiler里面，它有很多这种optimization的問題，它里面其实一定会产生这样子的code sequence嗎？实它是不一定的。所以各家的Compiler他们都有不同的方法去產生optimized過後的code sequence。所以這些很多optimization的問題需要解決。所以compiler好的compiler好的comp iler，它可以做得比較好不好的compiler，它當然就做得比較差。如果是說每一個instruction，它到底需要多少個cycle，每一個instruction需要多少cycle，這個純粹就是什麼呢？就是由CPU的hardware來決定，所以完全看

這個 hardware 的 designer circuit 的 designer，他到底有多厲害，有辦法去完成這個 instruction 的 operation然後可以花多少個 delay然後這樣子來設計跟規劃所以這純粽是 CPU 的 hardware 在決定的。所以我們知道其實我們前面就知道說不同的這個 instruction，它需要的 cycle 的 number 是不一樣我們如果說不同的instruction，它有不同的CPI實際上是有實際上不同的instruction，

它本來就是有不同的它所需要的cycle的number，就不一樣，所以這樣子我們在討論average的CPI的時候，我們當然就是不能夠單看什麼，就是說都是單看最簡單的instruction你必須要把不同種類的instruction set裡面的instruction都要把它放進來考慮所以真正的average的CPI，它是會受到你到底使用的時候到底使用了哪幾類的inst ruction

這樣子的MIPS它會影響到你average的CPI如果說你這個program都是用到那種就是說它的CPI值很高的那一個type的instruction那你這個program最後你的CPI大概就會比較高所以這樣子我们来看后面这边有一个例子后面这个例子它其实只是要让同学知道说这个CPI然后跟它的performance我们说这边它有两个computer一个是computer A它的cycle time是250个pecosecond它的average的CPI是2.

0那computer B它的cycle time是500个pecosecond它的CPI是1. 2他們說這兩個computer，它是使用相同的instruction set architecture。他說使用相同的instruction set architecture，這表示什麼呢？這個東西，它當然就是表示說它既然是使用同樣的instruction set architecture，所以它的instruction count是一樣的。它的instruction count是一樣，所以我們在這裡面，在算CPU timeA跟B的CPU time B的CPU time，這兩個computer的CPU time相同可以發現，instruction count，它是一模一樣，因為他們是使用相同的instruction set architecture當然我們必須要強調的就是說，你一定是在

同樣的instruction set architecture然後，用同樣的compiler拿去compile出來你的instruction count是一模一樣，一模一樣的話，它的CPU time是多少，在A裡面，就是instruction count 乘以它的CPI再乘以它的cycle time，所以這樣的一乘的話，它是500再乘以I然後，B的話，它是600乘以I它們的I是一樣的，所以我們就知道說,A是比較快，然後，B是比較慢，一個是500，一個是600，那A比B快多少呢？快1。

2所以同學可以發現說我們這個A是比較快然後它的CPI值雖然比較高，但是它的cycle time其實是比較少，所以你單看這個也不準，你要看的是要看這兩個的搭配，當然這兩個搭配的話還要再 based on一個，就是說它們是使用相同的ISA。你如果是不同的ISA的話，那又有得比了，因為 instruction count 也會不一樣，所以這個就會比較複雜所以這個例子大概就只是在相同的ISA 上面的一個比較。

接著我們再延續我們剛剛提到的，就是說它有不同type的instruction，它的CPI是不一樣，所以我們說如果說不同的instruction cases它是會使用它所需要的cycle number是不一樣所以我們真正在算所需要的clock cycle的number的時候，我們應該是把每一種種類所需要的Clock Cycle的Number加總起來，所以這邊強調的是每一種種類所以這边

有一個Submission它裡面的一個Item就是在算每一種種類所需要的它的Clock Cycle的Number，例如說DI種種類的這個Instruction，它的Instruction Count總共有多少個然後這一類的Instruction，它的CPI是多少，所以這樣相乘就是這個種類它的這個cycle的number total需要這麼多個這樣加總起來就可以知道它的clock cycle的number另外一個我們在談我們在談說CPI，CPI它既然有不同的CPI我們當然就是要所謂的weighted average的CPI weighted average CPI其實它真正我們在算一個CPI的時候真正就是

我們總共有這麼多個insertion count然後它total總共有這麼多個class cycle需要這麼多個class cycle這個一除的話就是它的CPI。我們如果是用這種weighted average CPI的觀點來看的話，實可以由這樣子來求得這樣也是一樣。它就是把每一種種類，它的CPI對於total最後total CPI的contribution貢獻把每一種種類算出來所以這個就是在算每一

種種類，它對total CPI的contribution。所以我們可以看到，說這個是這一類的instruction它的CPI值是這麼多，這一類它占total的instruction的比例是多少占total instruction的比例是多少。所以是total的instruction count分之這一類的指令有多少個，這一個呢就是指 這一類 DI 類，它的 Instruction 占 Total Instruction它的占的比例是多少。所以把每一種種類的比例乘以它自己的CPISubmission

起來就是 Average CPI。所以你 either 你也可以從這邊入手，你有這一方面的資訊either 是這樣子，它的 Fundamental Definition這边还有一个例子，這边这个例子就是說，有三个种类的指令我們來看，說它有A B CA B C它的CPI有三个case它的CPI分别是1 2 3我們假設有两種不同的compiled代码 sequence你不同的compiler compiler出来的code sequence是不一

样这是第一种sequence这是第二种code sequence它是2 1 1就是A类两个 B类一个 C类两个第二种它是A类四个 B类一个 C类一个就是这样子我们可以来看一下说这两种不同的code sequence它所造成的average的CPI到底是多少呢我们可以来看一下说第一個種類它的total的instruction count是多少2加1加2 所以是5它

所需要的cycle number當然就是這一個它需要1個它總共有2個 2乘1這一類的需要2個clock cycle它只有1個 1乘2這一個它需要3個clock cycle它總共有2個 2乘3所以total加總起來是10所以它average的CPI是多少就是2第二個code sequence它的average CPI是1. 5所以同學可以看到在這個例子裡面它其實就代表什麼呢它在這邊算CPI其實就是同學可以看到的

我們如果是以 execution time 來看的話是這一個所需要花的時間是比較長這一個所需要花的時間是比較短因為它只需要 9 個 cycle它需要 10 個 cycle以CPI 來看的話它的CPI 值是比較低的它比較低它平均一個指令所需要的 instruction 的 number數目是比較少當然它也是要搭配它的instruction count它的instruction count就是說這個值它還

是由這個來決定你這個數目如果太就是說數目如果太大的話你這個數目太大然後你這個去除雖然把它除低了然後最後你不見得你的這個cyclecycle的number增加的比例跟你這個數字到底是不是有成一定的搭配然後最後出來的會比較好 這個倒是不一定所以我們如果要做一個最後的一個

關於我們剛剛提到的 performance它要從不同的觀點來切入實際上我們最後要看的那個事實應該是我們就最後看到的就是真正我們CPU time我們concern的這個CPU time它是一個program裡面有多少個instruction然後呢這個當然就是CPI它instruction裡面一個instruction大概需要幾個clock cycle才能夠執行完這樣一乘的話就會得到total需要多少個cycle的number然後這一個cycle的number需要多少個時間它的cycle time將total乘完以後就是我們的CPU time這個式子出來之後我們要關心的是說在這個式子下面

我們要知道說到底誰可以improve CPU time或者是說我要在哪一個level我要focus在哪一個item的optimization比如說我不會在algorithm的level我們來探討說我們要如何去減少它的cycle time這是很奇怪的一件事情所以我們知道說Algorithm這邊我們一定要concern的是instruction countinstruction count當然就是我們的time complexity你可以roughly來說就是這個time complexity我們不希望說是一個很高的一個很高的time complexity的一個algorithmalgorithm它有可能會影響到這個CPI這邊只是說

有可能會影響到CPI為什麼有可能會影響到CPI呢基本上我們如果是在解決同樣一件事情的話我們通常不同的這個algorithm大部分都是它的complexity不一樣我們會使用到的什麼operation通常是一樣的也就是說我們通常就是使用那幾類的instruction那幾類的instruction呢我們只是說它會用多少次次數用的比較多 次數用的比較少

但是或許有一些 algorithm 它會比較喜歡使用某一類比較奇怪的 operation那一種 operation 你可能就是必須要對應不同的 instruction你必須要用不同的 instruction 去 dole 那個 operation這樣子的話 它會影響到你的 CPI 的值所以這純粹是你 algorithm 的 operation你 describe 的 operation 到底要用哪一種 type 的 instruction 來realize 純粹是這個如果說沒有這方面的影響的話

它不會造成這個應該是跟CPI比較沒有關係那Programming Language的話當然是instruction count還有CPI你用不同的Programming Language這兩個是絕對不一樣同理Compiler它的優劣它也會影響到這個數字至於說 Instruction Set Architecture 的話當然就是 Instruction Count, CPI 還有 Cycle Time這個 Cycle Time 純粹是因為你的 hardware 的 design你 hardware 的 design 你要去 realize 這個東西所定義的 operation它定義出來的 operation 你要用 circuit 去實踐它那個 operation所以到底能夠做多好所以它會影響到這個 Cycle Time

所以我們在不同的level它會影響到的這個factor大概就是在這裡所以我們有關於這個performance的介紹大概就是在這邊做一個簡單的summer同學有沒有什麼問題都沒有如果都沒有我們就繼續來看下一個議題我們前面介紹的這個performance的話我們就提到說我們有一個重要的Factor是什麼Clock Rate對不

對我們前面有提到說Clock Rate一直拉一直拉一直拉拉到幾年前之後Clock Rate突然就好像停下來停下來就沒有繼續再進步大家就開始就我們就不玩那個Clock Rate就開始玩Single CallDual CallMulti Call然後現在就有兩個這個Trend一個是往Many Call一個是Multicode的架構實際上這個名詞大概也在用不了多久就沒有什麼Multicode以後大概全部都是Manycode因為Intel他們的實驗的chip其實他們早就可以

把大概應該有100個左右的CPU把它做在一個single代裡面所以你說100到底是Multi還是Many100個Code到底是Marty還是Many所以以後數百個CPU放在一個袋裡面這個是應該同學可能一不小心就買到我這個到底是100個Code還是125個Code所以這個Code的數目會越來越多你會多到說我買這麼多Code到底要幹什麼

它的calculate我們說它之前calculate沒有辦法再拉上去其實最主要的問題就是在這個power那power的話我們要看一下這個table課本列的這個數據我們可以發現說它的powertraincalculate它是這樣一直拉一直拉一直拉拉到這邊拉到這邊然後就下來那就可以看到Pentium IVPentium IV它都已經到差不多到3. 6GHz然後到Core 2它就下來2.

6差不多是2. 6GHz左右，它為什麼要下來呢？其實我們這邊告訴同學說，在CMOS中，它的製程它的技術裡面，我們要知道說一個電路，它所需要耗的Power。其實Power，同學就可以把它想像成是熱，因為它耗Power，就會產生熱呢。所以，同學會知道說你的CPU裡面一定會有什麼一定會有風扇。現在應該沒有人CPU是沒有風扇的，但CPU上一定有風扇。

它一直要散熱，所以它要風扇一直去把它散散散那Supercomputer呢。他們的cooling的technology是比較先進的，他們不是用風扇他們的那種冷卻系統就是Supercomputer。你如果沒有好的冷卻系統的話， 你的系統很快就會crash掉， 因為太熱了。它最主要的問題就在這個地方，它的power 它是怎麼算呢？它是由電容的複雜乘以電壓的平方再乘以它的clock rate frequency就是這個式子 就是相乘大概是跟這個乘這樣子的正關係。它的power，

我們可以來看說我們早期IC，我們使用的這個工作電壓，大概是很早以前，大概是5伏，它就開始降一直降降到現在是幾伏呢？ 1伏或者是第一伏，所以說我們這個降了五分之一所以它就乘以25分之一Power應該會變少可是Frequency呢？結果它是多了差不多快了1,000倍大概是快了1,000倍所以你這樣

子相乘當然還要決定你的 circuit design它所製造出來的電容的負載到底是多少所以我們說power其實差不多是30倍的成長30倍的成長的話是非常非常可怕的一件事情它根本再往上做這個可能已經不是30倍它沒有辦法承受那麼熱的一個環境它很快就會燒掉另外跟同學講一個觀念就是說我

們的PC我們後面會看PC出來之後做測試我怎麼知道說這個chip它是好的我們當然就是給它讓讓看對不對PC它的壽命到底是多少呢PC壽命是多少PC壽命我們不知道但是我們知道說PC它賣出去以後它就會一直用一直用那你用的時候它這個環境就會很熱對不对就會很熱通常它們如果要去做一個robust test的時候，它必須要把測試PC的環境的溫度怎麼樣拉很高。它要把它拉很高，因為在

在一門課裡面討論IC，它的reliability其實它跟它的工作環境的溫度有關係。所以當你的工作環境的溫度很高的時候，會減少你的IC的壽命。所以如果說我們再做一個robot test，然後環境故意把它弄得非常非常高，然後讓它去跑。實這個等同於就好像讓PC在比較低的溫度環境底下讓它跑更久的一個時間。所以就是用這樣子去做一個測試。所以也就是說你溫度越高的話，它很快就掛掉了。我們來看一下，

說我們如果要去reduce這個power怎麼辦呢？他在講說，我們可以降低它的capacity load，大概是變成85%一樣。我們的voltage也是降為85%，然後frequency也是降為85%。所以我們全部都這樣子降為85%。我們就來看說，我們新的Processor CPU，它的Power到底是舊的，它所需要Power到底要耗掉多少根據這樣子一層的話，我們知道說0. 85的四次方大概是0.

52結果搞了好久才降了一半同學不要覺得說降了一半實在是降太少了很多research做了老半天能夠降個5% 4%都已經算是一個很好的work所以你這邊降了一半已經很不得了所以說這個power是一個很大的問題因為它沒有辦法再把這個voltage再把它降低為什麼沒有辦法把這個工作電壓再降低同學知不知道為什麼沒辦法再把工作電壓再繼續降它可能有好多個原因你隨便講一個都可以同學答對了雜訊的問題

工作電壓跟雜訊有什麼關係呢同學應該還記得我們資工系的我們CS的同學我們最喜歡的是什麼0跟1對不對雖然我們不會去寫那個machine code我們不會寫01 machine code但是我們在某一些場合會比較喜歡0跟1訊號都是01 01 01實際上我們的signal它不是01 01這個大家都知道的它是analog的訊號它不是真的是01工作電壓我們說早期如果是5伏的話所以它是0伏跟5伏它的範圍是這麼的大所以我們可以定義說當我們的

工作電壓假設這個實際的數據我沒有記得很清楚假設我說假設是3. 5伏以上的電壓我們都是把它歸類為1假設是這樣子假設是1. 5伏以下的工作電壓或者是2伏以下的工作電壓我都歸類為0所以同學你可以想見的我們要認定1跟認定0的範圍這個是多大這是1. 5伏 對不對這也是1.

5伏 對不對我們現在假設工作電壓是1伏現在變這麼小然後這是0 這是1所以你也要一樣要定義一個範圍假設我們說我們假設是0. 85以上的我們視為1我們假設是這樣假設是0. 2以下的是視為0假設是這樣所以這個範圍剩下多少剩下0點幾對不對1的範圍你要視為它是1這範圍就剩下0.幾要視為0的範圍也剩下0.

幾這個0.幾跟1.幾這是代表什麼代表你容許雜訊它的範圍發生的這個範圍因為我們知道說我們這個circuit在運作的時候都會有一些雜訊干擾雜訊干擾意思就是說你沒有辦法維持你的電壓非常的穩定它可能會降下來上去降下來上去它會有這種variation你這個variation你所能夠忍受的範圍如果

越大的話相對的它是比較穩定對你這整個circular運作它比較好就是歸類為0歸類為1這是一個簡單的一種說法這樣子一個簡單的觀念可以讓同學了解說為什麼你工作電壓再繼續降它其實是很危險你隨便一個雜訊它就從0變1 1變0這個是很痛苦的一件事情因為它整個系統就亂掉了但是它亂 它不是壞掉它就做一做 突然給你亂一下然後又恢復正常可以這樣子嗎

當然不行你如果裝那個心力調節器那怎麼辦亂一下 然後這個心跳突然170然後突然又恢復正常所以這是很危險的一件事情所以我們說它的voltage要降其實有一定的難度所以這個時候你的calculate沒有辦法繼續在往上拉的時候要怎麼辦呢你要怎麼去improve你的performance當然就是從unit processor變成是multi processormulti core就是這樣子所以我們這個table它是n
列表

几十年来我们这边看到的同学可以看到的这些Processor都是这些年代里面非常有名即使它在market上面没有卖得很好但是都是被公认它是设计有很好的design的CPU像这个Alpha这都非常有名然后HP PA RISC这个是早期有RISC跟Sysc的两大阵营的然後還有IBM的RSRS其實也是可能也是這個Risk的意思然後還有這個Alpha Intel AMD他們的這個Performance同學可以看到這邊它慢慢的就Situation越來越慢越來越慢所以它是受限於Power Instruction Level的Parallelism

你同一個時間可以執行instruction的這個數字 數目還有這個memory的latency這兩個issue我們在後面的chapter會探討所以就是需要這个multi-coremulti-processor multi-coremulti-core的這个multi-processor它就是一個chip裡面就有一個以上的這個processor但是這個系統就是我們這樣子的一個環境就是我們前面提到它需要什麼呢它需要一個explicitly的paraprogramming什麼是explicitly它的反向就是implicit一個是很明顯有這樣子

的一個味道implicit就是說你沒有去提但是實際上它已經隱藏隱含這樣子的一個意識跟味道它有這樣子的一個能力所以你必須要在Programming的時候你就必須要去考慮這個Parallel就是你必須要去設計Parallel的Program你不是說你寫完以後他Compiler他自動幫你Compiler他就自動幫你Compiler你就根本都不用去管他所以你要去寫目前的環境你必須要去寫這樣子的一個Program所以他其實是還

就是還不是一個很成熟的環境雖然已經有這樣子的硬體這個東西我們如果要跟instruction label的parallelism這是指什麼呢這是指說其實有的同學可能已經知道說我們現在即使沒有用平行的compiler平行的OS但是你program在run的時候你在CPU裡面它其實已經有平行化CPU裡面已經平行化它平行

化是什麼呢它在CPU裡面它會同時會issueMultiple的instruction出去執行這種就是所謂的什麼呢instruction level的parallelism所以，這個不是你決定的，這不是你控制，这是CPU它本身，它的架構的設計就是這個樣子，它有這個能力去同時去issue同時去執行不同的instruction，所以它有這個 instruction level 的 parallelism，所以這不是我們去 design，但

是我們如果是 multi-code 的話，我們必須要去真的要去 design parallel 的 program所以目前有很多那種 platform，實有一些 platform 是早期那種所謂的 distributed computing 的環境，早期 distributed computing itu透過 network然後把你的 program 平行化它現在是這樣子的一個platform，它慢慢把它發展成就是說我們可以在Multicode裡面，就是利用那個環境去做parallel processing所以這樣子的環境它當然是比較難去處理，就算好像要designerdependent設計師的功力越好的話，它的performance是越好，如果designer的performance

它的功率不好 它的performance就不好所以這個好像這樣子如果是這樣子的話就比較不好而且你必須要去考慮去做什麼呢去做 load balance而且你要考慮你在不同的 call 的這個 job因為它被分散到不同的 call你分散做完之後你必須要 merge 在一起你 merge 的時候你需要做 communication你需要做Synchronization因為假設Code 1 Code

2做得比較快Code 3做得比較慢你Code 1 Code 2做完之後你要去等你還要去等Code 3所以這個就是你必須要做Synchronization那你這個要等要做Synchronization它有可能是Load unbalance它可能是你在分散Load的時候本身就不Balance也有可能是他可能是去搶資源的關係他搶輸了所以Code 3他必須要

做得比較慢因為他搶資源搶輸別人這個原因都有可能所以你必須要去做這個Synchronization這個都是你Program裡面要去Take care我們目前做的Research很多在Multi-code的Environment幾乎都在解這些問題你如果做得好的話你的Speed up大概是多少如果是跨扣 你的speed up最好大概可以到多少目前Maticode

的環境你如果是跨扣的話大不了就4倍絕大部分都不到4倍你如果可以做到4倍以上的話，那不得了。 тогоwork算是很成功，這種叫super linearsuper linear speed up通常你可以超過4倍，大概是4點幾， 4點幾這樣子要做到五點幾那是很難的事情，這是目前的這個research的status，大概是這樣。那你如果是GPU many code的話，那就不一樣。 GPU many code它可能可以有幾百倍的speed up，但是問題是GPU，它沒有辦法在每一個application都得到那麼好的speed up。它通常是特殊特定的application

才有辦法有這麼好的speed up。 Multicode的話，它是比較general general purpose。後面我們花一些時間來看，就是我們前面提到的從unit processor變成這個Multicode processor為什麼會有這樣子的一個轉變呢？這樣子的轉變當然是因為我們把這個IC的製造的技術一直shrink shrink shrink一直縮一直縮一直縮縮到目前大家已經快要不知道怎麼縮下去了已經快要達到物理的極限，以物理的角度來看已經快要到那個極限。它沒有辦法突破，因為我們在製造的時候，

我們來看一下這個過程大家就知道說它為什麼會有極限。我們都只是簡單的觀念介紹，我們不講這個detail在製造這個IC的過程，它通常會先做這個晶圓。我們說我們有8吋晶圓、12吋晶圓，這個大家都聽過， 對不對同學？如果有注意這個News的話，應該知道，說目前是12吋晶圓，12吋晶圓，它的cost已經

非常非常的貴，到它已經讓整個產業的生態做了一些巨大的改變，就是因為它太貴了，所以不是每個人都玩得起，所以整個IC的產業生態已經在做改變，就是不是每個人都有辦法在12吋晶圓那邊下單這個晶圓，它怎麼做呢？反正，它大概就是用一些化學的的一些操作，然後讓一個圓柱狀的它

會產生一個圓柱狀，圓柱狀它去切切成很薄的切成一片一片很薄的，這個叫 Wafer，我們講8吋、12吋，就指這個 Wafer 的直徑有關於這個 Wafer 的，這個應該不算笑話，只是說聽一聽覺得只是會心一笑而已台積電 聯電他們製程工程師，他們每天都是要去看那個Wafer譬如說，他12吋廠的engineer，他每天都在看那個12吡的Wafer，所以他知道，說12吡多大，他非常的清楚，他不像我們一般，你說12吡有多大，他也講不出來，因為他每天都在看， 所以他很清楚

我們一般買蛋糕的時候， 你說你要訂幾吡訂8吡 訂12吡蛋糕送來之後，有拿尺去量的同學舉手， 有沒有有同學會去拿尺去量蛋糕多大的嗎 沒有所以我們suppose我們都相信這個蛋糕店他們是同手無欺， 他說8吡就8吋 12吋？可是他們不知道說那個經驗場的工程師他對那個尺寸非常sensitive比如說他就訂了一個12吋蛋糕拿到以後一打開，

他說這個不是12吋，那個蛋糕店的老闆還要凹他說，這12吋啊，我說我每天都在看12吋的Wafer，我知道12吋有多大，這一看蛋糕絕對不是12吡他拿紙一量，他說，你看這不是12吡然後，那個老闆就改口說，我們講的12吡不是指這個蛋糕12吡，我們是指這個盒子12吡他是指這個盒子裝蛋糕的那個是12吡，所以，這個是聽說他們對那個非常sensitive所以，買蛋糕都騙不了他們，他們一看就知道這是8吡這是12吡，所以，這個切出來之後是薄薄的一片一片，

這個就是基底，這個基底基座之後，這邊講說，大概20到40或許更多，它有很多那種化學的製造過程，每一層同學想像它是不同的材料，就好像是在疊三明治一樣，第一層做完，做第二層，第二層做完，做第三層，第三層做完，做第四層，它就一層一層這樣子疊上去，每一層它在做什麼呢，它就是我之前跟同學提過說Layout，就是一大堆Geometry，它就是這一層看看，你要刻什麼形狀上去，比如說，刻一個T字形，

刻一個M字形， 刻一個L字形，就刻很多Geometry，一層一層把它刻上去，同學，你如果說你的IC製造完以後，你就要署名，你就要用geometry去，把你的名字比如說我們在風景區常常可以看到說情侶；就是簽個名，你可以在鏡片上面把你跟你的女朋友或者是你太太的名字把它簽上去簽上去，那個完全沒有circuit behavior純粹只是做一個pattern 秀在上面就這樣子而已所以它經過那麼多製造

做完之後他就開始切 切成這個帶帶就是長方形或者是正方形 帶切完之後當然他也會對每一片的Wave去做TestTest之後他會找出說這個是壞的 這個是好的找出來之後他就做Dicing就切切切 切出來就這麼多個帶這個是壞的 其他的是好切完之後再做包裝就是我們講的那很硬的殼子包裝這邊包了六個袋包成六個package然後接著再做測試測試完之後就可以

出貨所以它簡單的一個流程大概就是這樣子我們常常在講year這個year是指什麼呢這個year就是指一個weaver它到底有多少個袋是好的到底有多少個代是好這個完完全全就決定一個Foundry廠就是TSMC UMC這一類的Foundry廠它的競爭力這個也是為什麼說TSMC它到目前為止其實它並一直沒有急著要到大陸去設廠的原因同學不要以為說TSMC比較愛台灣其實不是這個原因原因就是因為TSMC它的技術的確是有它的獨特之處它是世界No.

Foundry廠所以它的Year跟其他的這種Foundry廠相比的話是比他們還要高這個Year就決定它的Cost決定它的成本。 Foundry最主要的成本不是在說你要Hire比較便宜的人人力比較便宜，它最主要是在這個Year所以它它去大陸設廠其實際上是要去大陸local去serve大陸那一邊的IC design house。它並不是要去那一邊降低它的成本，所以為什麼台積電它沒有急著說一定要去大陸去設什麼廠？它的原因主要就是在它的競爭力強項，就是在這個地方。 nosotros這邊有一張圖片，

我們可以看到說這個AMD它的這個Wafer大概就是這樣子，這個X2是300mm基本上這是12吋長，大概是12吋長， 它是90奈米它已經有這個X4， 它是45奈米現在其實已經到了28奈米。接著我們來讓同學大概了解一下，就是說我們之前提到的Transistor它的長相是長什麼樣子，它的Layout就是我們提到的Layout，這個就是一個Transistor的一個基本的架構這個Transistor，我們知道說它是半導體半導體顧名思義是什麼呢？半導體顧名思義就是說它不是導體，

它也不是絕緣體是什麼呢？它是任何時間都導通的絕緣體是什麼呢？它是任何時間都不通的半導體，就有時候通有時候不通，就是因為它有這個特性所以我們可以去控制讓它設計成一個電路它如果全部都導通它沒有辦法所以這個元件你可以控制它通或不通那它怎麼控制呢基本上它就是在這個地方控制的同學只要了解說這個是一個source這個是一個drain這兩個是同樣的一個材質

它中間在平常不通的時間這個就是一個channel它是不通的你如果要讓它導通的話就是根據看你是P transistor還是N transistor你就要決定說它不加電壓還是加電壓這個地方就會變成跟它接在一起也就是source跟drain跟它們之間就導通了它們之間就通了通了之後你就可以透過這邊要比較高的電壓還是

這邊比較高的電壓來決定電流是從這邊流過來還是從這邊流過來它就變成是一個導體當你再把這個電壓拿掉或者是再加進去這個就不見了這個就不見了所以它跟它又不通了所以完完全全都是由這邊來控制這一層到底要不要跟這兩個source和drain接在一起所以它是半導體可以on可以off所以同學只要了解這樣子

就可以這邊只是要讓同學看的就是說它的立體的架構是長這個樣子它的立體的一個架構所以說這是一個material這又是一層material這個又是一層poly的material這一層material它就是只有一個rectangle這一層它是兩個Rectangle angle就是這樣子我們真正在看Layout的Cross-section view的話Cross-section view就是長這個樣子這是Metal 這是金屬 這是導線然後這個Poly就是這個M plus M plus就是這兩個Source跟Train然後這個Substrate呢 Substrate指的就是指這個P top Substrate應該是指這個

這邊還有一個P-TOP我們這邊沒有秀出來所以這個是一個立體的架構但是同學在這邊要了解的就是說它的Layout就是一層一層由下往上這樣子一直堆疊上去每一層都會製造不同的Giometry這個圖就是我們知道說電路最主要有兩個一個是原件 原件就是開關的控制你要決定開或者是關 開或者是關一個是開關的控制

另外一個是什麼呢線 就是interconnection就是把不同的原件把它接在一起所以電路沒有什麼複雜 就是這兩個東西一個device 一個interconnection就是這兩個我們這邊讓同學看到的是Y就是interconnection這個wire這張是IBM的一張顯微鏡照出來的圖同學可以看到它很像什麼東西呢它很像很多馬路對不對 很多路路有比較細的 路有比較粗的然後這個還有一層一層一層不同層的這個路 對不對就是一大堆路這樣跑來跑去跑來跑去

然後這個像什麼呢這像我們去牙科照X光照出來說這個齒根有多長這個牙齒有多長所以你看這個牙齒它的齒根是這樣這個其實是告訴我們什麼呢它有這麼多層它總共有七層1 2 3 4 5 6 7它總共有七層每一層跟每一層之間可以接在一起這個接在一起它就是透過一種叫view或者叫contact打一個洞 貫穿

它就接在一起這一個是什麼呢這個是Crescent view這個是Top view由上往下看的Top view這個Top view我們這邊不同的顏色就是代表不同的材質不同顏色代表不同的材質所以同學可以看到說Layout真正長的就是長這個樣子它用不同的顏色去代表不同的不同的 layer比如說紅色的這個 layer它的長相

就是長這樣它的 geometry 就長這個樣子然後其實這邊就是 p-type transistor這邊就是 n-type transistor藍色的線就是 metal wire把它接在一起就是這樣這個就是 NVIDIA 的一顆 chip 的一個 layout所以同學可以看到密密麻麻很多根本都認不出來這個就是我們知道的真正circuit的layer它是長這個樣子我們再讓同學看

它的interconnection我們是把一個比較簡單的cir cuit把它部分放大圖放出來之後，這個是它的一個wire這個wire就是同學可以發現它有兩個不同的layer然後這個呢是一個更複雜的layout這實就是我的實驗室這個router是目前academic學術界裡面應該算是最好的router同學可以看到這還不是整個chip這只是chip裡面的一小角它就是要從這一點找一條不會跟其他的線衝到的一個area

繞線把它繞出來然後這個是一個放大圖大概就是長這個樣子我用一個比喻就是說在四五年前的製程技術裡面同學可以想想看我們的帶一般差不多就是這麼的大這個帶我們把一個帶裡面的metal wire全部抽出來把它拉直 接在一起同學覺得這個線有多長把這個帶裡面的metal wire抽出來接在一起大概有多少場 拆完就下課同學都不拆 我們就不要下課了隨便拆一個數字都沒有人要下課我剛好像聽到那個鈴聲了對不對

解救一下同學吧隨便猜一下都沒有人要猜同學一公尺我們知道說這位同學主要是要解救同學讓大家可以下課吃飯答案不是一公尺在四五年前的製程裡面大概至少超過六6公里所以同學就知道說這個一個袋裡面它的geometry的複雜度有多複雜它是刻得非常非常的細我們今天先介紹到這裡.