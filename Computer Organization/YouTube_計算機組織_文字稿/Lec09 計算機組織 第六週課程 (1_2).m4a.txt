undefined
我們很快的把這個Flow重新再跟同學，就是再跟同學複習一次就是我們上一次跟同學提到的這個16bit 2-level的CurryLook-Ahead的Aether上面這邊有一個Generate跟PurpleGate的Circuit這邊同樣他們每一個就是每一個Group都會有一個Generate跟PurpleGate，所以這邊有G0 P0，就是GI的circuit還有PI的circuit這邊每一個可以look ahead的generator1 2 3 4 5這五個長得完全一模一樣這五個就是我們前面這邊看到的circuit同學可以回到前面再去看這個circuit，這個circuit基本上就是說如果它是要產生group generate跟group propagate的話，

它就是只由最左边的NO circuit它这边会产生group generate跟group propagate，所以它当要产生是group label的generate propagate的时候，它是用这一个所以同学可以看到这边有G03 P03 G47 P47 G811P811還有G1025 P1025還有八行這一個就是G015 P015這每一個都是屬於這個group general跟publicate所以，它就是由這一邊來產生那另外的每一個這個黑盒子呢！我們這邊看到的它有這個往上直的這個就是屬於這個個別的C1 C2 C3C4 C6 C7以這個的話，它就是C4 C8 C11它就是這三個就是1 2 3就是這三個所以這個是

產生它個別的這種bit的carryout這邊它是產生每個group的genre跟propagate！所以它的flow就是我們上一次跟孟學提到的它的gi先從最上面的 circuit 下來之後每一個 carry look ahead 的 generator它會同時去算它的下一集的 groupgenerate 跟 group propagate當然它這邊不是說不會算它同樣會算出來它每一個黑盒子都會算出它的 ci1-3 5-7 9-11 13-15！所以每一個它都會算

只是說在這個時候這四個黑合值算出來的個別的Ci只有C1 C2 C3是正確的值其他C5到C15算出來的都是錯誤的！它為什麼會是錯誤的呢？因為對這個group而言，它的group carry-in還沒有ready！它的group carry-in也沒有ready！它的group carry-in也沒有ready的C0是ready的！所以这边算出来都是对的！所以接下来呢他就这边就算出这个

group的general跟publicate到下一集那下一集这边呢他就读他的这个C0C0之后呢再加上他前一集的groupgeneral跟publicate呢他就会算出C4 C8 C12接着他就会算出C4 C8 C12所以这个时候C4 C8 C12呢他正确的這個C4 C8 C12被算出來了算出來之後再回到上一集上一集它就

再把這個C5到C15再產生它正確的值所以這個時候5到15它正確的值接著就產生了所以我們上一次才跟同學說同學如果了解這個2 level的這個flow的話同學就會了解說這個Ci正確的Ci出現的先後順序是什麼呢就是1 2 3它會先產生出來那到這一級呢這一級它會先產生4

8 12它正確的4 8 12就算出來那4 8 12算出來呢這三個group它的group carry in就ready了這三個group的carry in ready之後呢5 6 7 9 10 1113 14 15那就最後一個階段就會算出來所以同學一定要了解這個Ci它的正確的值出現了先後順序因為你了解了就表示你整個flow的觀念都清楚了所以同學這邊一定要搞清楚這邊知道之後我們就可以

來做一些簡單的運算就是要去算說它的two level或者是multi level它的delay到底是多少所以我們這邊有兩個case那第一个case呢我们来考虑16bit16bit有包含就是这个是repo-carrier的repo-carrier它的delay是多少那另外一个呢就是2-level的这个carrylookahead那我们假设什么呢它not的delay是1然后excuseAll或者是单独的这个end单独的end它的delay呢是三个unit那endAll structure呢

当然delay是2所以我们就可以看到说在最上面这一集就是说最上面这一集是产生generate就是bit的generate跟propagate所以bit的generate跟propagate它就是透过一个excuseAll它有一个end gate所以它是透过一个end gate跟excuseAll gate那你excuseAll gate跟end gate它的delay是多少是3都是3所以這一集的delay

這一集的delay都是3那bit level的generate跟propagate產生之後我們先來看什麼先來看repo-carrier它是怎麼算的repo-carrier這邊有一個例子我們畫在這個地方這邊是4個bit那4個bit我們要去看說扣除掉MSB這個bit我們總共要等幾個stage，carry in 要等几个stage呢就是我們可以看到这边carry 它产生

出来就是一个NO structure对不对一个bit一个bit就是一个NO structure你必须到达MSB之前你必须要经过一二三三个stage所以你4个bit的话你要经过三个stage那如果说是16bit的话呢要经过几个stage15个stage就是15个stage就是15个stage所以就是n bit就是n-1的stage所以你就是16-1 15n15乘以多少呢 2因為no structure它的delay這樣子

的一個單元的delay是2所以它就是15乘以2所以就是這邊第一個3就是算bit level的general跟publicate那bit level的general跟publicate都算好之後接著就是一個stage一個stagecarry in carry out 一直傳一直傳我們這邊是算說傳到MSB這個level的時候這個bit的時候經過15個stage這樣子算完之後我們還要再算最後一個stage最後一個stage就是這個stage這個stage我們就要來看說它的output有哪幾個它有幾個pace

從這幾個Path裡面去找 Delay最大的Delay最大的第一個我們可以來看MSB這個Stage它有一個Output叫什麼呢叫這個C，就是Carry, Carry的Delay是多少是2所以這邊可能是加一個2另外還有一個什麼呢它有一個sumsum是透過一個excuse all就是這一集前一集的carry in進來之後從這邊進來然後再經過一個excuse all會得到一個sum這個sum是最後一集的sum這個get是excuse all它的delay是多少是3所以最後一集它的delay是2跟3取max這邊是取max不是取min

就是二跟三取max所以這邊就是加3所以我們這樣子total算出來就是3加15乘以12再加上最後一個stage所以這個3呢指的就是指這個generate propagate然後這15乘以2呢就是指前面15個stage它的這個end of structure去產生這個carry那這個3呢就是最後一個stage它所需要產生這個sum所需要的delay所以加起來是36

如果是klookahead因為它是2 level2 level我們就來看這邊第一個bit level的general propagate它的delay是3就是一個是and一個是excuse all兩個取max就是33再加多少呢這邊經過一個什麼這個level是經過一個no structure然後呢再到這個level 它要經過什麼NO structure然後再回過來再回到這邊又經過一個NO structure這個時候同學可以看就是說你經過NO structure之後這邊所有的carry全部都ready了然後接著才是去算它最後的sum到底是多少所以它的值

就是这边3呢就是我们这边提到的就是这个bit level的general跟propagate然后这边有三个两个delay unit delay三个 总共有三个每一个都是两个unit delay这是指谁呢这是指anal structure就是指往这边走的时候经过一个anal structure到这边的时候又经过一个anal structure那你这边group的这个group的carry in ready的時候呢這邊要經過一個annual structure所

以總共有三個annual structure這邊就是3乘以2那這边加 3呢，就跟我們剛剛講的是一樣的。它每一個bit都要需要一個excuse all去產生sum，所以每一個bit，它的sum呢，它所需要的delay是最久的。它就是需要三個unit所以這樣子就是3加上 3 乘以 2 再加 3，這個是 Carry Look Ahead所以圖示的話就是這樣子就是這邊走到底再往回走。所以這邊有個特徵我們觀察到這個特徵我們就可以 Extend 到這個 End Level/Multi Level/End Level 的 Carry Look Ahead它的 Delay 應該要怎麼算它的特徵是什麼呢

我們同學可以發現說不管你的Curly Look Ahead這個黑盒子，它到底有幾個Level每一個Level的黑盒子，它的Anode Structure要算幾遍要算幾遍我們說Two Level的話，這個Anode Structure要算幾遍這個Level兩遍那这个呢、这个呢、一遍对不对算一遍就好了因为它的角色這一个在two level的这个角色呢它的角色是要產生誰呢—is要產生这个group这个group跟这个group的什么呢—carry in所以它只要算一遍就好了那这一个level它的角色是什么呢

当你的data flow是往下走的时候它是要透过這一个去算下一個level的group generate跟group propagate当你data flow往下走的时候是这样子当你自己这个group你的carry in ready的时候它还有另外一个角色你的carry in ready的时候它另外一个角色就是要去算它这个group里面的每一個bit的carry out它的carry out所以它的角色有兩個所以它等於就要算兩次一次是往下走那一次是往上走它要算兩次所以我們這邊就有一個初步的結論看起來是什麼

呢除了最底層的level它只要算一次end of structure之外它每一個level的carry look ahead的unit它都要算几遍它都要算两遍根据我们这样子的初步的结论得到这样子的结果我们说我们现在先做一个假设好了我们先假设这个excuse all它的delay是2我们都把它简化全部都是2这边都是2所以我们就来我们不要看这什么2 level 3 level我们就直接看n level就n leveln level

它到底需要多少個delay呢我們剛剛講說 angle level最底層那個level它怎麼樣它不需要走兩遍 它只需要走一遍所以我們說要走兩遍的是 n-1 對不對它是 n-1就是說你每走一遍的時候你每走一遍的時候它的delay是多少它的del aylor是多少就是一個N-0 structure它就是2所以你2乘以N-1所以這是

你每走一遍它需要這麼多的delay它總共要走兩遍它總共要走兩遍這個是要走兩遍的另外buttonLevel這個buttonLevel它要走一遍它走一遍node structure的delay是多少是2是2然後呢還有這邊一開始的時候這個bit level的group generate propagate它的delay是多少bit level的bit level的bit level的generate跟propagate是多少它的delay也是2它的delay也是2所以這是一開始的 然後這個是button level的end of structure還有一個什麼呢

還有一個sum每一個bit它的sum是要經過這個sum是要在什麼時候才能算呢sum是要在每一個bit的carry in都算出來之後它才能夠去算這個sum所以sum是要每一個bit它的carry in都ready之後才能算這個sum這個它的carry inready是什么时候呢就是我们刚刚算的这边这边全部都算好了全部都算好这个写法可能要这样写比较好这个是bit level的generate跟propagate就是一开始的这个是2然后再加上这个就不要了就是一开始最上面bit level的generatepublicate算完之后

就是這個 n-1個level它要走兩遍它的delay total是2乘以2再乘以 n-1然後button level的這個呢它的delay只有走一遍所以它是2然後再加上什麼呢再加上最後每一個bit它的sum每一個bit它的sum它也是需要2它也是需要2就是這樣子那這樣子等於多少最後就是4加2它的值就是

4加2因為這邊是4減4這邊是4n減4然後這邊扣掉然後這邊最後一個2就出現了所以是4n加2所以這個是end level它的care look ahead的delay是這樣子算法這個動畫其實就是剛剛跟同學講的它是往下的时候都是在算下一个level的generalgroupgeneralgrouppropagate最后一层出来之后它就开始往

上一层算送它的上一层的groupgeneralgrouppropagate然后这一层算完了又再往上一层送它的groupgeneral不是groupgeneralgroup的carry-in讲错了往上的时候是在送groupcarry-increateLookAhead的adder我們就介紹到這個地方接著因為我們介紹createLookAhead其實就是說我們有一個比較快速的加法因為我們知道乘法它

都是用加法一直在重複做運算所以你加速了加法當然也就加速了乘法當然乘法我們不是就只有可以從加速加法這邊來看我們這邊就介紹了一個就是叫boost algorithm這也是一個傳統一個很有名早期很有名的一個乘法的一個加速的algorithm它的idea其實就是based on我們對一個數就是對一個二進位的一個數我們如何來表示它的大小它的寫法不是就一種寫法不同的寫法

可能就可以導致我們在乘法的運算裡面可以做加速的動作我們首先來看我們之前介紹的乘法它的運算其實我們是根據這個式子來看的比如說我們說有一個式子它是01110這個式子它的表示它的大小到底是怎麼算出來的呢我們知道說我們首先根據每一個bit它的值乘以這個bit它的

position它的waiting比如說這個bit它的position它的waiting是2的三次方然後它是1所以就1乘以2的三次方再加上這個bit是1它的waiting它是2的二次方然後這個是2的一次方所以我們就是01110等於這樣子的一個結果所以以這樣子來看的話比如說這個數这个数其实我们就是多少呢其实它就是1再乘以2的二次方再加上1再乘以2的一次方这个就是乘数再乘以倍乘数所以我们真正在加的时候

我们就是这个数把它乘进来我们就是0010乘以实际上就是等于0010再乘以多少呢再乘以2的2的一次方然后0010再乘以2的二次方这个就是刚刚跟同学讲的因为这个数呢这个数其实就是2的1次方再加上2的2次方所以你看这个2的0次方它是0所以这个数其实是没有那

这个bit呢这个bit2的3次方它的value也是0所以2的3次方这个也是没有真正有的是这两个ten这是两个相加我们之前的乘法实际上是这样做那反映在我们之前的解释呢它的描述其实就是左边这张图所以同学可以看到这个数是什么呢就是这个倍乘数0010乘以2的一次方就是什

么呢往左shift一次对不对然后这个0010乘以2的二次方就是什么呢往左shift两次就是我们这边之前跟同学提过的你说0010记得要往左shift一次这边要记得往左再shift一次它total就是shift两次所以这样子的做法它的觀念其實是源自於我們把這個乘數把它用就是這種1乘以2的幾次方這種表示式把它寫出來然後你把這個倍乘數把它乘進去得到這樣子

的一個結果這樣子的算法就是最傳統的你就是看有幾個1你就要做幾次加法你有幾個1就是說你的這個你的乘數裡面有幾個1呢你就要做幾次加法 對不對你有幾個1就要做幾次加法那我們如果要讓乘法變得更快呢就是什麼呢當然就是我們要嘛就是前面介紹的讓加法的速度變快第二種方法呢就是讓做加法的次數減少那如何來讓做加法的次數減少呢我們可以來看我們來說這個式子就是之前有人觀察到說

01110这个式子呢它可以写成2的三次方加2的二次方加2的一次方所以你倍乘数去乘以这个数的时候你要做三次加法可是反过来我们可以知道说连续的1呢我們可以把它写成什么呢2的四次方再减掉2的一次方对不对我們以前我也忘了是国中还是高中就是2的一次方加2的

二次方加2的三次方加2的四次方一直加上去你不是要有一个公式可以把它算出来吗其实算出来这个等于它就是有连续的1连续的1这2的一次方加2的二次方加2的三次方它实际上就是等于2的四次方再减掉2的一次方就是这样子我們可以从这个连续的1来观察说这个

2的1次方到底是指哪一个呢我們看得出来它就是指这一个2的1次方这2'4次方它是指谁呢它是指这一个对不对它是指这一个这两个它到底有什么特征呢这两个有什么特征因为这个特征牵涉到我们等一下我们要推演出这个boost algorithm我们要有一个rule有一个如果是什么呢因为我们

先不要去管它如果是什么我们先看这个式子我们先看这个式子说这个乘数呢乘数从三个加法变成一个加法跟一个减法这代表什么这代表你等一下在做乘法的时候你只需要做一个加法跟一个减法就可以了对不对就是你把被乘数乘进来你把倍乘數乘進來你就等於你要做了一個

加法然後你再做一個減法你只要做兩個之前你是要做三個加法所以你就少掉一個加法減法跟加法是一樣快的所以你就只要做你等於少做了一個加法所以我們就有一個game它的game就是少掉一個edition所以我們就知道說這個是有好處的接著我們來看我們要如何來知道說我們要做加法跟減法呢我們說這個bit它這個e其實是要做減法它的特徵是什麼

這個特徵這個e就是什麼就是你一個連續的e當我們從右邊我們從LSB往MSB方向就是由右往左去做scan的時候這個是出現e的這個stream的开始就第一个一第一个一出现的时候第一个一出现的时候要做什么呢要做减法第一个一出现的时候要做减法第一个一出现其实就表示什么呢第

一个一出现其实就是表示它的右边一定是什么一定是0对不对因为它是第一个它是第一个一所以它的右边一定是0所以同学可以看到这个右边是0没有错这个bit这个0是什么呢它也是第一个它是什么第一个呢这个0是什么？第一个这个0是连续的1出现结束以后，第一个出现的0，所以这个0就是我们刚刚一直碰到1一直碰到1，然后这个连续的sequence1的sequence结束，我们从左往右看

1 1 1然後，這個1是最後一個1了，所以它結束了第一個出現0這個0這個位置要做加法就是這樣子那其他什麼呢？其他的case你就不用管了其他的case你就都完全不用管所以我們就從這邊一個簡單的例子我們就可以derive一個rule這個rule就是我們后面要看的它就是叫boost algorithm這boost algorithm它就是

要把乘法里面全部都是要做加法把它改成做加法再加上也可以做减法然后有些case它会变得比较快有些case它可能变慢它又可能会变慢所以这个就是我们跟同学提到的一个原理所以以这个例子来看的话它的这个这个是倍乘数这个是乘数它是01100110我们知道说根据刚刚的观察就是这个要做加这个要做减这个它的weight它的weight是多少是2的2次方所以是2的2次方121232的3次方1232的3次方所以这边是

2的三次方是做加这边是2的一次方一次方这边是要做减这一个这个式子它的演算就是在右边这张图所以同学可以自己回去看一下在这个地方是要做减然后在这个地方是要做加这两个算出来它们的结果都一样都是11001100就是这样子所以这个就是我们在这边看到的一个范

例就是说我们可以来做这个加速这个table其实就是在重复我们刚刚跟同学介绍这个boost algorithm它的一个观念它的观念其实就是我们这边看到的就是说我们从这个乘数它的LSB开始往左scan那我们会有几种情况第一种情况呢就是什么呢就是说current bit是1然后它的右边的never是0这种叫10这种10这种情况呢这个current bit就是我们刚刚讲的要做什么要做减法对不对它是这个1这个sequence的第一个

第一个出现的这个bit它要做减法就是1111最右边的那个111110就是最后边那个1它这个时候要做减法当你是11的时候就是目前的bit是1它的右边的never也是1这个是什么呢这个没有什么意义就是这个1这个sequence正在进行它还没有结束所以这个时候是no operation不需要做加也不叫

做减那如果current bit是0它的右边的never那个bit是1就是我们刚提到的是什么呢就是这一个它的右边的这个1的这个sequence它的结束然后current bit这个0是第一个0的出现第一个0第一个0出现，它的右边就是一个，就是一个1的一个sequence，这case就是要做加。如果是00的话，目前是0，它的右边的

never也是0这种case是什么呢这种case都是0，所以你也是no operation。所以根据我们这样子的一个观察，我们就知道了，就是说00它是no operation，01它是一个加，它是一个subtraction11的话，它也是no operation就是这样子，所以它的判断就是用这个rule来做一个判断其他的process跟前面的乘法，它的flow完全是一模一样，只是说我们现在不是要去判断这个multiplier，它的LSB到底是0还是1然后才去决定要不要加

不是這樣子判斷，我们是一次判斷兩個bit既然是一次判斷兩個bit的話，我们就必須要怎麼樣—we就必須要在Multiplier LSB的右邊再加一個Extra bit，在Multiplier的LSB最右邊再加一個Extra bit，那个Extra bit做什麼用呢，就是要保留我們的Multiplier往右Shift的時候就是当时的LSB被Shift到外面去，你Shift到外面去你Shift到外面去的时

候它就会Shift到这个Extra bit那个地方举个例而言，我们这边可以看到我假设这边有一个Extra bit有一个HardwareExtra bit在这个地方Initially它要设多少当然要设0一开始的时候你要把它设0所以一開始的時候就是先設0接著我們的current bit就是always scan lsbcurrent bit其實就是scan lsb所以一開始的時候 lsb 0然後再加上extra bit是0所以它就是叫0 0接著它做了一次iteration之後要shift right所以shift right

這個 bit 就會被 shift 到 extra bit 這邊來然後這個 bit 就會被 shift 到 lsb就是這樣子所以下一個 iteration 它一看還是 0 0還是要 no operation接著再 shift right所以這邊這個 extra bit它 always 是 keep前一個 iteration 的 lsb它往右 shift 的時候它就會 shift 到这个地方来所以你每一次要去判断说current bit还有什么bit to the right这个就是LSB这个就是什么呢就是我们刚刚提到的extra bit额外多出来的bit就是这样子到这里同学有没有问题

它的好處就是Suppose連續1的case比較多的時候它就有這個game所以這個演算法當然不是最好的演算法對 所以不會用這個演算法

應該這麼講剛這位同學他有提到就是說當我們有這種case的時候當我們這種case的時候這個是worst case就是这个boost algorithm的worst case这个worst case就是说我们initially是0就是extra bit是0所以你第一个是no operation之后你每一个bit都要做加减 加减 加减就是这样子每一个bit都是加减 加减 加减 加减这个是它就是performance是最差的它等于是把这个所需要做的加法

几乎double几乎double这是它的worst case如果你要问说那worst case它发生的这个几率是多少这个我也没有办法回答可是你也可以说这个algorithm它的优点就是当你当是这种情况的时候你说它没有优点吗它的game就很大了对不对所以我們介紹這個演算法的目的並不是說目前的CPU我們是

使用Boost algorithm來做這個加法的運算我們這只是讓同學了解說像這個Multiplier它的Algorithm其實有非常多的paper那Boost algorithm只是在當時在當時的時空背景之下曾經被人發現的一個Algorithm它在某一些case它會speed up這個multiplic ination但是某一些case呢Worst case的話呢，它的這幾乎是把它的這個加的這個次數幾乎就double那當然它有它的它有什麼呢，它有它的enhanced version就是說

我們不是只有看2 bit那我們是可以看3 bit那這個enhanced version呢，在舊版在以前舊版的這個這個課本裡面新版的課本那邊錫體我沒有check，但是在舊版的課本裡面是它的錫體是它的錫體所以同學如果有興趣的話可以去看一下這個錫體看是不是它錫體裡面有提到這個3-bit的boost algorithm，所以它不是final version，它有enhanced version我們這邊只是讓同學了解一個說

曾经有这样子的一个方法，它的idea就是觀察到連續的一它可以improve所以很多research都是這樣子，就是你有一个observation你可以based on这个observation去propose你的method去improve，有可能你的method可能是有一些case會非常好，但是有一些case會非常的差你要怎麼去做分析呢，通常如果說最好是你，如果有辦法做出theoretical analysis說in average它是可以improve這樣子是最好那你如果沒有辦法的話呢唯一的方法就是你要去run很多的benchmark其實我們的

research大致上都是這樣子你沒有辦法理論上的分析出來說Average case它是比較好那你大概就要去run大家公認的benchmark大家公認的benchmark就是一run出來就一翻兩瞪眼是比較好 平均比較好那大家就會recognize你的方法是會比較好當然不是就是最好一定會有這個potential的缺點也就是這樣子所以research才會生生不息一直有paper出現

所以剛剛那個同學的這個問題非常好還沒有問題老師 那如果這個case是只適用在說如果你今天假設只想要加法幾分去做乘法系的時候才會好如果你是直接叫他定同一個乘法對啊 這個就不用了它這個純粹就是減少你做加法的次數對沒錯還沒有問題好那我們繼續所以我大概加了加了這一頁那我會再把這個放上去同學可以看一下就是boost algorithm其實它就是test

就是 test product register lsb那这个-1呢其实就是我们提到的additional bit多出来的那个bit被shift到product register外面右边的那个bit我们suppose它有一个hardware有一个1 bit可以去存这个资料所以我们可以去check这个资讯我们就说 test product 0-1那它如果是01的话呢我們就是做加如果是10的話呢這個是1的sequence的開始所以我們就是做減其他的就都一樣他就是把product register就是把它shift right就是往右邊shift一個bit就是這樣子我們這邊有一個例子

我們這邊有兩個例子我們看一個例子就可以了同學可以看到這個倍乘數 0010我們這個是傳統乘法的algorithm我們這邊是boost algorithm我們把它的乘數叫做 0110我們把它放在 product register 的右半部這邊有一個 extra bitextra bit一开始 initially是设为0所以同学可以看到所以第一次呢第一个iteration 0 0所以它

是no operationno operation之后呢shift right所以这边呢这个0呢就shift到这边那这个1呢shift到这里这个时候是1 01 0呢它是做减法所以这边就做了一个减法那减完之后呢它就变成一个复数那shift rightShift Right的時候同學要記得你的Sine bit必須要Reserve你必須要Keep你的Sine bit你如果是正就是填一個0你

如果是負就要填一個1所以這邊Shift Right這邊Sine bit填一個1然後這個1Shift Right到這個Extra bit這個1到這裡所以下一個Iteration這個是1 11是No operation接著再Shift Right這個1到這裡這個0到這裡所以这边就一个0101再做一个加再做一个加加完之后就是这样子然后最后再做一个shift最后的结果就是1100最后的结果就是1100这个就是我们的boost algorithm的一个例子下面有一个例子同学可以自己回去trace一下

那在MIPS裡面這個我們很快的提一下同學回去自己看一下課本我們就是有兩個32 bit的register把它組合成這個product register那high就是它的most significant左邊的32 bit那lo就是它的least significant的32 bit右邊的32個bit所以它的instruction就是把這兩個相乘相乘之後它的64bit它會放在Hi跟Lo兩個組出來的64bit Prada Register同學会说那算完以後我怎麼去抓呢你可以個別去抓就是用所謂的MF High MF Low就是把左半部的把它M ove到某一個Register把這個Prada Register的右半部Move到某一個Register

或者是你這個指令一層就是你把這個就是它的這個 product register的右半部32bit把 move 到rd所以它有這幾個 instruction接著我們再來看這個除法這個除法就是我們知道說除法跟稱法也是一樣我們就是要再先回顧一下我們小學開始在紙上面就是畫這個符號有没有同学没画过这个符号的大家都画过就

画这个符号然后就开始怎么算呢我们就会开始1 0 0 0对不对我们就这4个我们就抓4个那抓4个我们会怎么样呢我们会眼睛看一下看一下什么呢这里要填0还是填1对不对我们就很简单看一下我一看就知道要填1那这边就会什么呢1 000然后去减这边就会余数就会1就会下来可是电脑会不会看一下

电脑没有那个看一下的那电脑其实我们看一下就是做compare就是做comparison那这个comparison呢我们前面也讲过说comparison你要再做一个compare的是很浪费的所以它怎么做呢它就是做减就是做減 一减之後就看說這個1001减1 000减完以後它到底是正數還是負數如果是正數的話這邊就要填什麼 填1這邊就要填1這個餘數就要保留下來如果减完之後 這邊是負數那怎麼辦呢就要填0 對不對

這邊要填領填領之後還要怎麼樣呢我們要還原我們剛剛比較比較晚如果說這個比較小我們這邊填領我們實際上是這一些bit動都不會動我們會把它保留下來所以你要保留下來其實電腦就是先做一個減再做一個加再把它加回去所以電腦比較笨但是它很快它先做一個減然後再做一個加

就會把這個什麼呢 這個還原回來所以電腦的這個除法呢它的原理就在這個地方就根據我們這樣子的一個描述我們就可以知道什麼呢我們就知道說它就是做減減完之後呢如果我們發現說這個餘數是正的我們的商就會填1然後餘數就會保留下來然後接著再把上面的這邊再拉下來然後再做減

再拉一個bit下來然後再做減減完之後我們會發現什麼呢它是負數負數所以這邊填0然後再加回去加回去它就會再保持這個是1010接著再看下一個bit再把它放下來是101然後這邊101再減掉1100101減掉1100當然是負的所以你這邊再填一個0填一個0之後我們要把101還原所以就是

再加上一個1000這時候101就會還原回來101還原回來之後再把這個0再填下來就是10101010再減掉1000一減完之後是正的余數是正的它是於10所以這個時候我們就知道說這邊要填多少要填一個1所以這個時候電腦它的除法就做完了，所以從我們剛剛這樣子來看的話，我們可以很清楚

知道說除法電腦，它還是做加又做加又做減。基本上就是先做一個減去比較目前的這個base就是比較這個base跟這個除數的大小。如果說這個base它比這個除數還要來得大，你的sum就會填1，要不然sum就會填0。如果说比较大的话你就直接把余数保留下来。如果它是产生一个复数你就是要再把这个除数再加回来然后把这个remember把它还原就是这样子所以这个是我们做除法的基本原理。我们今天先上到这里.