undefined
我們上一次跟同學介紹到DMA跟Cache之間的interactions我們有提到Data的coherence的問題。我們接下來跟同學介紹DMA跟Virtual Memory它們之間的interactions。我們知道說DMA就是沒有透過這個CPU的介入然後它就是在CPU繼續執行的過程裡面它可以透過DMA controller然後直接從這個IO跟這個Memory之間做這個Data的這個Transfer那畢竟它的這個

Data的这个operation它也是就是說它不管是读或者是写它都是跟这个Memory之间的互动所以当然它也有所谓的这个Memory的Address你要讀一筆资料你要寫一筆資料它就是要去做一个Memory的一个Access那这边我们要探讨的问题是说我们的这个Memory的Access那它到底是用Virtual Address呢还是用这个Physical我們首先我們來看一

下就是說我們知道說DMA它的這個operation資料量我們當然沒有辦法控制所以你就只能夠你的data transfer只能夠是小於一個page所以你每次做都只能夠做一個page不能超過一個page當然不可能有這樣子的一個限制所以我們的這個data的 transfer假設說它的datasize是超過一個page的話我們來看在這種情況

之下我們用這個Virtual address跟Physical address它會面臨到什麼樣的一個問題首先我們來看就是說如果我們的DMA它是使用這個Virtual address就超過一個Page的一個Data的範圍來看的話如果說我們是一個連續的Virtual的Page number我們知道說就使用上面來講的話它是一個很自然直接的一個方式

它所有的這一筆Data的這個Address它是一個連續的一個Virtual的一個Address當然它對應到Memory裡面的這個Physical的Location它不一定是連續的Page它可能這邊有一個Page在這個real的memory裡面這邊有一個page這邊有一個page這邊有一個page所以它數個page在physical address裡面它並不是連續的它就是

這邊就看看這個physical memory裡面哪一個page是空的它就對應到哪一個page所以它基本上是不連續的以這個case來講的話這個virtual就是說DMA它使用這個virtual address它的這個access上面來講應該並沒有什麼太大的問題，但是我們這邊要確認的就是說這個DMA Controller，它必須要知道說它的使用的這個Virtual Page是對應到Physical Memory裡面的哪一個Physical Page Number，所以它必須要有這樣子的一個Mapping Information。第二個，它Controller，它也必須要做這樣子的一個Translation，就是它必須要把Virtual，

把它轉換成 physical 的 address所以就我們說 DNA 它使用 virtual address 來看的話，look起來它有一個額外的 loading 就是它必須做translation。如果說我們 DNA 使用 physical address 的話，我們說，如果它是用 physical address那不是，它就不需要做 translation 對不對，所以跟它使用這個Virtual Assets來相比較的話當然它不需要做這個Translation，但是它有它自己的問題，那它有什麼問題呢？首先我們來看就是說假設我們在做這個Translation，我們在做Data Transfer的時候，我們在Physical Memory裡面，我們的確是幫它找到了一塊連續的位置，

比如說，它總共使用了三個 Page那我們也幫它找到了三個這個Physical Memory裡面它有三個連續Page的位置可是問題是我們知道說我們這個OS我們使用的是使用這個Virtual Address那在Physical Memory裡面它的三個連續它三個連續的位置不是三個連續的位置三個連續的Page Number就三塊Page連著連在一起的三個Page那實際上它的Virtual Page Number不一定是連續的對不對因為這個是

牽涉到你這個這個OS它是說你的這個Virtual Page Number你是對應到Physical Memory裡面的哪一個Page Number所以你實際上你在Physical Memory裡面三個連續的Page在我們的這個Virtual Memory裡面它不一定是連續的所以你就DMA來看的話雖然說你在Physical裡面找到一塊連續的位置它可以做一個Transfer可是實際上你Data假設你是寫到Memory裡面你從IO寫到Memory你把Data寫到Memory裡面去你這筆Data你後續要讓人家使用的時候那後面的人他要如何來使用這一塊三個Page的這個Data呢

也就是說我們必須要有一個Information其實也是類似這個Table它有一個Mapping你這個Mapping你必須記錄說我的這一塊IO連續的位置實際上它在Virtual Memory裡面它是三塊不連續的位置三個Page這邊一個Page這邊一個Page這邊另外一個Page它對應到的是對應到Physical三個連續的Page所以實際上我們要做的是要做這件事情

所以也就是說雖然我們用physical address好像說DMA你不需要做translation可是你DMA data transfer完畢之後我們之後接下來後續的program它要去使用access這些memory因為它是virtual address所以我們必須要maintain一個information來做這樣子的一個mapping所以這個當然也是一個額外的負擔可能同學會講說DMA它是使用physical的這個address我們如果說它不是allocate連續的physical的address假設它是allocate一個連續的virtual的address

也就是說它是連續的三個virtual的這個page number那這樣子對應到physical的話它可能就是對應到不同的physical的page number它是三個isolate就是不連續的三個physical的page number那如果是這樣子的話呢，那麼這個就是我們這邊提到的，如果是這種情況的話，那麼我們在送的時候，DMA它在送，因為它是physical，他在送的時候，

他就必須要分三次送，他要分三次送，因為我們DMA，它是告訴你說起始位置在什麼地方，我們要送多少資料過去，DMA，它就開始在那邊送現在，DMA，它是使用Physical的Adress，但是我們要送的送到Memory裡面去的這三個Page Number它實際上是不連續既然是不連續的話，我們就沒有辦法告訴他一個起始的位置然後它

就可以把三個page number的data全部送到memory，它沒辦法，因為在physical memory裡面那三個page，它是分開的，它不是連續的，所以就必須要怎麼送呢，你必須要送三次，就第一次，你告訴它第一個page，它的起始的位置然後，它的data，它就開始寫，然後寫完一個page它就結束了，接著，你再告訴它第二個page的位置的起始位置在什麼地方，然後，接著呢，他再送第二個page，接著呢，他再告訴他第三個page，然後，他再告訴他第三個page然後他再送第三個page就是這樣子，

所以這邊，他在告訴我們說，你必須要把這個data，他把它切成，就是page size trunk他一個trunk大概就是一個page，那你就是把你要看你切成幾塊然後你就把它就是把它變成一個chain，這樣子然後one by one的這樣子做這樣子的一個Data Transfer。所以根據我們剛剛的簡單的討論描述，我們大概都知道說DMA，它使用Virtual Address跟使用Physical Address，它分別它們有各自的問題。如果是使用Virtual Address的話，其實它不用管說它到底在Physical Memory裡面，它到底是連續不連續反正它看的是Virtual Address。

但是Controller必須要有一個Mapping的Information，它也必須要做Translation它才能夠知道說它是對應到真正送到這個Physical的哪一個位置。如果是DMA它使用Physical address的話，它當然不需要做Translation，但是面臨到的問題就是我們剛剛討論到的這兩個issue所以在課本裡面他討論到DMA跟這個VM它們之間的interaction最主要就是著墨在這個issue上面那接著我們來看就是這個IO的IO整個IO designIO system，它的performance，那我們

知道說IO的這個performance，它其實在這邊它有提到三個factor它說dependent一個是hardware另一個是software另外一個是wall lock。 Hardware當然就是你的CPU、你的Memory、你的Controller、你的Bus規格不一樣的話當然它表現出來的效能是不一樣Software當然牽涉到你的OS還有Database的Management還有我們Zero-ROM的Application。最後一個就是所謂的Work Log我們同學都知道什麼是Work Log這個其實牽涉到我們的Request Rate

另外還有一個就是pattern你的request進來它到底是什麼樣子的一個request這些都會影響到我們的IO的performance我們也知道說我們談到的效能其實我們現在知道的一個是response time還有這個throughput。實際上我們要在response time跟throughput之間它會有一種tradeoff的一種現象它不會是說我如果提高throughput的話那我也可以minimize response time那我們

的沒有這麼兩全其美的這個solution。我们举一个例子来看我们就知道说其实response time跟这个通過put它們有時候是會相沖的舉例而言就是說我們如果說想要提高我們的這個throughput的話，那譬如說我們可以做一個考量那什麼考量呢？譬如說我們在我們的IO，譬如說我們希望減少我們到這個Hard Disk它的這個Access Time。那我們前面提到的這個Hard Disk它的這個Access Time，它其中有一個部分當然就是牽涉到，就是說我們這個讀寫頭，它要移動對不對？

它要移動，然後還有它的這個磁盤，就是說它要轉到它所要的這個sector，這些都是浪費比較多的一個時間。所以我們可以把這一種就是這個hard disk它的這個request，我們把它蒐集起來之後，我們去分析，說落在附近位置的那一些request，我們就是先做這一區的比如說，我們現在有100個Request進來，我們分析之後，

我們大概有50個，-big概都是在這一區的Request，我們不管這50個Request它進來的先後順序，我們就先Service這50個Request，這個有什麼好處呢？這50個，因為它都是落在這附近，所以它可能不用或者是要花只要花很少的時間去做這個Move去做Rotate，我們就可以把這50個Request就很快把它的Data全部都讀出來，這個好處當然就是說

我們可以減少很多這種-io它的時間相對而言，這50個Request它可能很快地就它的所需要的Transfer它可能就Complete可是這個有什麼缺點呢，因為我們說譬如說假設這50個是100個裡面的50個而已，所以這50個service完之後還有另外50個另外50個裡面搞不好第一個進來的他是就只有自己一個人要去讀某

一個地方這樣，這個地方他可能就是人家會覺得說只有他一個人要讀所以他就是priority是最後面所以他可能service99個之後再去service那第100個可是那第100個他可能是第一個進來的他是第一個發request所以對第一個而言它的response time會怎麼樣會非常的長，所以這樣子來看的話我們是favor的這個throughput可是就某一些request而言它的response time可能就會拖得非常長，所以它們兩個之間並不是說我只要提高throughput我的這個response time就一定可以同步的

可以降低它的這個 response time所以這個中間我們必須要取得一個這個平衡，那課本裡面這邊就提到那這部分我們就把它簡化就是這部分同學可以看一下課本那在後面這兩頁的這個投影片，其實它的重點其實就是有一個名詞叫Transaction那因為我們知道說我們的這個IO其實它的應用根據應用的

不同的領域可能著重點也不太一樣，但是我們至少可以確定通常我們比較有興趣的是這種IoRate IoRate是什麼呢每秒平均每秒大家可以完成多少個Read或者是Write這個Read跟Writer的這個Data量有多有少，但是我們concern的是這種你平均每秒可以complete多少個Read Write這樣子那Transaction這個名詞它最主要的就是說它是一個Small Data Access to a DBMS，就是Database Management System那這個Transaction它有什麼特性呢就是說

它是一個Small的一個data access而且它也需要一個small的computation也就是說它既需要computation它也需要data access，但是一般而言這一類的operation它的computation量跟data access的量都不大所以這個就是我們所謂的transaction它這樣子的一個特徵這個我們可以看到其實在很多的應用都可以看到這一類的譬如說我們現在大家很流行的就

是網路銀行，不管是你的信用卡或者是你的網路的帳戶基本上幾乎都是在網路上面做交易，甚至我們做股票的買賣也全部都是在網路上面做交易，這一類的交易的話，其實它有一個很主要的一個特徵，就是說它並不是完全都不需要computation，它需要computation，但是它的量不大，那它當然需要data的access，那它

的data access量也不是很大，不像同學在網路上面一看就是看一部DVD那個抓就要抓很久那所以類似像這一種的就是說它的這一種我們可以分析說它的這一種這個IO rate到底是多少，所以同學可以看一下，就是說它們就是有分成幾種這種Benchmark另外這邊又有提到什麼這個Far System跟這個Web Server，那你Web Service跟這個Far System，它們本身基本上就是兩種不同的Application，因為就是這種Far System，它很明顯就是同學如果去信息中用這個Server或者是Workstation，

那同學可能就比較會有感覺，就是說你要去讀一筆資料的時候呢，最不希望的就是你在做operation的時候它給你出現一個訊息，它就是給你讓你的operation要中斷那中斷的原因是什麼？就是說你要去讀資料，你要去讀file的時候你讀不到資料那讀不到資料有可能是網路的問題也有可能是可能是你的這個Disk的問題

反正你就是要在那边等我们这种File System我们当然就是希望说你在一个File你Serve透过这个网路Serve很多Server或者是Workstation即使你有10个User跟你有100个User希望说大家在使用的时候大家感觉都是非常的一致这种你的File System你Access你有可能去Access一个非常大的一个File比如说

你要去run program你的program的input可能就是几G所以你一开就是一个几G的一个file所以它是一个很大量的一个file的一个access但是你也不可能说你就是这个时间就是先把这几G的这个file全部都开出来给这个人开完之后其他人然后再去serve其他人那你這樣子的話你可能會在幾秒

之內其他人全部都卡在那一邊就全部都在等那個人所以這個中間當然會有一些issue你要讓每個人都同時覺得說他的檔案都已經讀到了那實際上他可能不是全部都讀出來那另外像這個web server的話那傳統的web server基本上它的operation應該是比較像前面提到的那一種它是需要small computation然

後small data access不過當然，現在WebServe它的Service，它的種類越來越多。它已經不見不見的就是一個small data access或者是一個small computation這邊舉了一個例子，就是說我們在探討我們以前應該是在第一章吧。第一章我們有跟同學介紹介紹過這個Endless Law、Endless Law。我們就是在討論這個這個Computer，它的Performance。這边他就告诉我们说，我们

不要忽略到Io的performance，尤其是当我们的computing performance隨着我们的平行度一直增加，花在computing的时间越来越少的时候，Io的效能更是重要。这边举了一个例子，我们的Benchmark一開始CPU Time是花了90秒、IoTime是花了10秒。所以我們知道說這樣看起來就知道說我們的Bottleneck是在我們的CPU這邊。我們這邊，我們講說每兩年我們

就Double我們的CPU的Number，即使我們的CPU它的Clock Rate都沒有改變，但是我們就是Double我們的CoreCode number，就增加，但是IO System它並没有改變，所以它還是一樣是10秒。所以我們說一開始的時候是90秒，再加上10秒，所以我們的Elapsed time是100秒，那你過兩年之後，你Double你的CPU，你的Code number所以它就從90變成45。那我們的Elapsed time就從100秒變成55秒。接著再過兩年之後，時速又變成23秒，最後變成11秒這個中間的比例我們要看的是說我們的Io所佔的比例從一開始的時候是10%.

一直到最後變成Io佔了47%這個例子當然只是在強調特別強調說我們的Io的Performance是不應該忽略的那談到IO同學有用RAID的舉手個人應該沒有如果個人有用RAID表示這個麥克風很多應該是比較貴的我們個人一般應該就是買個另外一個隨身碟然後去備份或者是買那個重要備份或者是買那個比較便宜然後大容量

外插式的硬碟這樣備份現在應該都非常的就是用這樣子備份就已經很夠了這個RAID它的縮寫就是它的全名就是Redundant Array of Inexpansive Disk或者是Independent Disk所以就是RAID這個它就是要使用Multiple的Small Disk就是說相對的我們如果是一個很大的硬碟它非常的reliable然後它速度非常的快它的容量很大可想而見這個一定是怎麼樣非常的貴因為它既然又宣稱這麼reliable然後又大然後又快所以它一定非常的貴如果我們沒有辦法 afford 這樣子的一個

我們可能另外一個就是用Multiple Smaller Disk用Multiple Smaller Disk我們可想而見第一個我們大概可以提高我們Access的平行度平行度高的話我們雖然說它的Access Time很大但是我們同時可以做不同的Access所以我們同樣可以降低它的Access Time另外一個當然就是就是既然是Multiple Disk我們就有可能它是有Redundant的這個功能就是說你壞掉的話不用怕說這個資料就Lost就是我們有這樣子

的一個功能所以我們也提供這個ForTorrent的一個Storage所以我們就來看比較常見的這個Red0到這個Red6那Red0它說它No Redundancy它沒有Redundancy它只是把這個data把它stripe完之後把它放到不同的這個disk裡面所以它大概就只是improve performanceimprove performance基本上就是我們原本如果有一個很大的一個disk我們可以想像的就是這樣子這logical disk它就是這樣sequential的做這個access我們可以想像就我們把這樣子一個

很大容量的一個空間我們就把它切切切切切把它切成這麼多個strip這個strip我們假設有4個，4個比較小的disk我們就把這個strip把它distribute在每一個disk上面，所以這樣總共有16個，就0 1 2 3 4 5 6然後12到15，這樣16個strip這樣子分散開來之後很明顯當然，它就具有什麼呢！它有這個parallel access的capability，因為它是independent的disk，所以我們可以同時去access這四個disk，但是它完全沒有這個for torrent的一個機制，那RAID1呢！它就是mirror，它除了我們RAID0講的，就是說

它把它partition成這個Data，把它Strip之後，再把它放到不同的Disk，另外它每一個Disk，它都有一個Mirror的Disk，所以它的Number就是N加N，它原本有N個Disk，那它RAID1就是需要N加N個Disk，所以也就是說這個是它的Mirror，這個是它的Mirror，這個是它的Mirror，這個是它的Mirror！你這樣子每一份都Copy所以這個看起來是最完美的對不

對！它又有這個high parallel的access，它又有full torrent，因為這個壞掉它還有這個在這個壞掉它有這個在，所以它什麼。不，不用怕，不過我們知道說這個一定是怎麼樣，絕對是很貴的，因為你用了這麼多disk，所以這是RAID1、RAID2，它就是有這個Arrow Correcting Code加入這個Arrow Correcting Code，我們知道說我們這個Data，你如果說比如說它，如果就是一個By 8個bit，那你就是使用8個bit來存它，沒有任何驗證還有Recover的這個功能，你沒有辦法知道說你這個8個bit的Data到底是不是

真的就是你之前的那8個bit的Data，它沒有從0變1變0。如果說我們加入了這種Arrow Correcting的能力的話，那你勢必就是要加入幾個bit，那幾個bit可能你有不同的演算法，你可以產生那幾個bit，那你有那幾個bit來輔助那你那八個bit裡面萬一有一個bit壞掉了，它可以根據你多出來的那幾個bit再幫你correct出正確的

原本的那8個bit的資料這個REED-SOLOMON就是說我們把原本的資料加入了有這種error correcting code有error correcting的功能additional的這些bit加入完之後再把它一樣再把它分割完放在不同的disk裡面，它是在bit level然後把資料放在anger disk然後另外的ECC再放在另外的 disk所以這個是RAID2它是加入Arrow correcting code的功能它也是太複雜所以它說這邊實際上使用的並不多

接著我們再來看RAID3它叫Bit Interleave Parity它就是要修正RAID2代價比較高的這個它說N加1所以它就是原本N個Disk再加一個加了這一個大概就是Parity它怎麼N加1呢我們來看它這邊講說它是先Data先一樣先把Stripe在這邊是byte level byte level你可能是一個byte或者是一個nibble所以你就是用一個byte或者一個nibble這樣子

去切切完之後你把它distribute在不同的這個disk裡面我們舉個例而言我們舉個例說假設它一個word它一個word有4個byte我們把它以byte來切所以它一個word是切成4份切成四份那你切成四份以後呢就是byte0, byte1, byte2,-byte3所以它就這樣一個word所以它就把它distribute在這邊那我們把它分別放在這邊之後呢它的parity是怎麼來呢比如說我們舉例而已我們就把這四個byte做一個ExcuseAll

我們做一個ExcuseAll得出來的結果我們就把它放在這個ParityDisk這一邊所以這個就是其中的一種方法我們說我們把DataStripeAtByteLevel然後把它放在這四個DataDisk然後ParityDisk就是把我們剛剛Stripe完之後的那幾個Byte做一個ExcuseAll這樣子的話我們就形成了一個read n加1的一個structure所以這樣子的一個機制我們來看它告訴我們說

當我們要去做一個read access的時候它會發生什麼樣的一個情況呢以這個例子而言比如說我們要讀一個word讀一個word它就是read old disk因為我們已經把它partition然後把它distribute在所有的disk上面所以他就把這些資料把它讀出來那你要write access的話write access它要怎麼樣呢你必須要去generate你的新的parity因為比如說原本的這個word你要一個新的詞要把它寫進去首先你先把這些datadisk把它update那update你的parity disk要不要update當然也要update

當然也要update當然你也要算你的parity disk你的data你的這四個比如說以這個例子是四個strip那四個strip把它exclude完之後然後接著再把它寫到你的Parity Disk這個有什麼優點呢，這個優點就是說如果說你中間這邊有一個壞掉的話，有沒有辦法救回來。 可以因為你這一個資料是1 2 3 4做excuse all得出來的，你

如果這個壞掉的話，你把1 2 3 4做excuse all你就會得到這一個，你就會得到其中的一個，所以這個同學可以回去同學，如果這邊不熟悉的話，你回去自己驗證一下就知道了，就是你其中一個壞掉，你把其他這三個再做一個excuse all你就會得到壞掉的那一個，所以這樣子的一個優點，這個是我們提到的這個RED3RED4，它是block interleave parity顧名思義，它前面一個RED3，它是beatRED4，它是block，一個是beat，一個是block，它是strap，

这个data at block level，所以它就是，比如说我们假设一个block，假设一个block是32个word，假设一个block是32个word，它就把这个data根据block来分32个block，就是一个strip32个word讲错了一个block是32个word，它就32个word，就一个strip接着就把它一样是把它distribute到不同的这四个disk里面，所以以这个例子来看的话，比如说我们以block来看，它连续的32個world它就是在A0另外一個block它32個world它要在A1所以它是相鄰連續的32個world就是在某一個data disk里面這樣子有什么好处呢

我們可以來看一下就是說第一個你read它的read跟write的特徵read access它會怎麼樣呢它就是read only the diskholding the required block當我們要讀某一個word或者是讀某一個block的時候呢我們可以發現它其實就是落在某一個datadisk裡面所以我們就讀比如說它落在A0我們就讀A0它落在A2我們就讀A2你不需要像我們剛剛看到的read3它就是0 1 2 3 4個disk全部都在做一個read當我要write的時候

它在這邊講說我們只要去read我們只要read disk containing modify block當然我們就是只要讀這個block讀這個block我們不需要讀1 2 3我們不需要把這四個block全部都讀出來因為同學會想說這個parity我們也是把這四個disc它的strip做一個譬如說是做一個excuse all然後我們會得到這個parity那我們是不是要把這四個全部都讀出來然後去做excuse all

然後才能得到這個Parity呢需不需要當然不需要為什麼不需要呢因為我們知道這三個是不變的就一個單一的write而言就單一一個write單一一個write它一定只有write某一個Datadisk 對不對所以這三個值是不變的唯一變的是誰呢唯一變的就是A0唯一變的就是A0那現在唯一變的是A0的話呢我們當然

就只要知道說我們A0原本是多少然後現在新的值是多少我們就知道說這個中間做了什麼樣的改變你把它做一個Excuse all我們就知道說原本的跟新的它們之間的改變是什麼那這個改變其實就是反映在這個它的Parity上面不變的部分你不用去管它你只要知道它變了什麼就可以了變了什

麼就只有它會改變而已所以它如果是1變0那你的Parity當然也是1變0對不對因為其他人都沒有變只有一個人有變而已所以1變0Parity也一定是1變00變1Parity也一定是0變1所以我們只要知道原始的跟新的是什麼這樣就夠了所以我們只要讀這個我們要write A0我們只要知道A0原本是什麼然後現在新的是什麼這樣子就夠了所以它這邊講說你要write的時候

你也不需要說每個都要write每個都要讀然後這邊呢這邊再一個寫所以它等於RAID3它等於是全部每個disk都要去動都要 operation但是我們如果是RAID4的話基本上它只要讀這一個然後寫這一個再寫這一個其他這三個跟它沒有關係所以這個當然是好處的同樣的它跟RAID3是一樣的就是說萬一有一個壞掉它一樣可以把其他

以這個例子而言就是總共有5個有一個壞掉你可以把其他4個拿過來做Excusal一樣可以Reconstruct出壞掉的它的Original的一個Data他說它也是Not widely used好像已經很好了但是它還是沒有常常在使用那為什麼沒有常常在使用呢我們等一下來看那課本這邊就是這一張圖我是覺得是有問

題的那我跟其他老師有討論過反正大家沒有結論覺得這張圖怪怪的因為就是如果根據剛剛的這個定義的話其實你不管是Ratch就是說這個就是說RAT3跟RAT4假設假設RAT3它的一種partition的方式並不是把一個word全部都distribute到所有的disk上面去假設它是這樣子的話照理說就是說

它這一邊就是說它這一邊它也不應該是必須要做這樣子的一個application所以我們這一頁的投影片我們先就是pending我們這邊就不介紹那如果同學讀一讀有任何的心得歡迎來跟我討論覺得說這邊應該是對的那它是什麼理由歡迎同學來跟我討論那我們跟同學介紹這個RAID5，這個是比較常用的，他說這個跟RAID4是完全一模一樣，唯一的差別就是它把paritty distribute把它散開來。 RAID4呢？同學可以想想看，就是說

它有一個disk，那一個disk就是叫parity disk，它就是叫parity disk，那這個parity disk呢就是所有的paritty全部都存在這個地方，它沒有data，只有paritty那這個有什麼缺點呢？同學我們剛剛看到說，剛剛RAID4看起來，它potentially它的優勢就是它可以做Multiple Write對不對！它可以做Multiple Write，因為我們每一次要Write的時候，我們就是Write一個Data Disk，那既然

只有一個Data Disk必須要被Write，所以以這個例子而言，它還有三個Data Disk它也可以同時另外做其他三個Data Write可是同學可以想想看，如果同時做四個Data Write，那我們剛剛講每一個Data Write，比如說它是write disk0，它也要write parity disk，如果我要write disk1，它也要write結果，我四個datawrite有一個disk，它要做四次write，是誰是這一個你的parity disk要做四次 write所以誰最忙就是parity最忙，所以你必須要

讓這個parity disk，它的速度超快的，所以它的bottleneck很明顯就是在parity disk。既然這樣子的話，我們何不把這個parity把它distribute所以RAID5就是什麼呢。我們不把parity集中在一個disk，所以同學可以看P0 P1 P2 P3 P4它就是這樣子把它distribute在這五個disk上面，所以每一個disk它都存data，它也存parity。以這個例子來看的話，當你要write p0的時候，它就是去write這一個，它是write這一個。你要去write p1的時候，它是write這一個。所以這樣子，我們很明顯，它可以multiple write in parallel，

它可以同時進行，不會有bottleneck當然你的bottleneck還是會發生像你這個P0 P5是在同一個disk上面，那你如果同時要去寫這個P0 P5那沒辦法，這個就一定撞到。但是這個跟RAID4比較起來的話，當然它的優勢就是它可以同時做這個multiple write，不會同時都是在這個這個就是Bond在單一個這個Parity Disk上面，所以這個是RAID5，

它的這個優點。 RAID6呢，它是N加2，那N加2呢它這邊跟就是RAID5有什麼不一樣呢基本上它跟RAID5是一模一樣但是它既然是N加2就表示它多了一個Disk它多了哪一個disk呢那個disk它也是parity同學可以把它看成是parity其實它就是用它就是等於是用兩種不同的演算法去產生兩組這個parity所以很明顯它的這個就是它既然有兩組所以它的4T的能力是比這個RAID5的能力還要強但是很明顯就是一定是比較貴

所以這個 Red 6 跟 Red 5 完全一樣只是多了一個 disk然後多存了一組用另外一種 algorithm 算出來的 parity所以這個是 Red 6實際上 Red 它後來好像還有很多種形態當然它不見得是不一定我們現在市面上看到的 Red 都是這個standard有一些是某一些公司它單獨發展出來的一個系統那可能就是非常的powerful

當然它相對的可能也是非常的貴所以這個RAID我們這邊介紹的大概就是從RAID0到RAID6那最popular最常用的大概就是這個RAID5所以我們這邊RAID我們知道說這個RAID基本上它就是可以improve performance還有availability就是說這邊它說假設independent disk的failure單獨的disk failure的話，我們用RAID的話，大概都還可以救得回來，甚至就是說它可能系統它搞不好，可以它不用，

不會crash，它還可以繼續使用，甚至是說你還可以，就是搞不好，你還可以就是這個，你知道說這個壞掉了，你就把它抽掉然後再換一個新的什麼都很方便這邊講說，如果這個building burns down，那你不管你是RAID的level多少，那個都沒有用，因為你大概就是在一個building裡面，一燒燒壞了，就什麼都沒了。同學有興趣可以去看一下，這個就是這個網頁裡面，他探討的是有描述說這個Hard disk，它的Performance還有Quality還有Reliability文章好像還滿長的同學有興趣可以去看一下，所以這一邊RAID的，我想同學大概就是了解每個RAID，它的這個優點缺點，它的限制，在什麼地方最主要，大概就在這個地方.