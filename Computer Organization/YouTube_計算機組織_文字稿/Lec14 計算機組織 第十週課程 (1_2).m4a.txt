undefined
我們開始來介紹就是上一次介紹到這個Branch就是Store on Branch我們上一次跟同學提到說我們的這個Control Hazard最主要就是這個Branch的問題以這個例子來看的話在我們後面的這邊討論我們上一次已經跟同學提到過說我們是假設說我們已經加了適當的Hardware使得我們在popline的時候我們在判斷這個branch的時候

我們不用等到LU結束的時候才知道要跳或者是不要跳我們是在第二個stage第二個stage我們就知道第二個stage結束的時候我們就已經知道說它要不要跳所以以這個例子來看的話我們就是說在碰到VEQ我們必須加一個bubble我們必須要store經過一個clock cycle的一個store之後我们就在下一个

class cycle我们就可以init下一个我们就可以issue下一个instruction进来因为在这里面结束的时候我们已经知道说这个BEQ到底是要不要branch如果说beyond branch的话它就是sequential execution如果要branch它就是把target的instruction把它load进来所以最主要就是这边多了一个bubble我們提到說Branch實際上我們可以做一些Prediction這個Prediction一定是有必要的為什麼

呢因為在我們目前討論的這個例子裡面我們的Popline是五個Stage這五個Stage感覺說你如果說有這種Branch的話而且我們現在第二個Stage結束之後我們就可以知道說Branch要不要跳感覺它的這個penalty並沒有很大實際上我們的這個popline它的stage有可能不是只有5個它有可能超過10個以上我們可以想見的就是說一個popline它的stage如果非常長的時候如果說我們在這個popline中間的stage我們才知道說我們必須要跳或者是不要跳

我們中間就必須要store非常多的clock cycle你每碰到一個instruction你就必須要store四五個以上的clock cycle這個當然是沒有辦法接受所以我們必須要做什麼呢我們一定要做所謂的prediction我們要predict說我們的branch它的結果到底是要跳還是不要跳如果我們做了一個做的一个猜测的话呢那我们就知道说我们什么时候才需要store呢只有我们的prediction是错的时候才需要store也就是说我们猜对的时候

呢它根本就是不需要再重新再把这个对的指令把它issue到publine里面因为我们已经猜对了那个被我们猜对的指令它也已经待在publine里面所以只有猜错的时候呢才有这个 penalty所以这个就是我们的 branch prediction最主要的就是说我们希望我们大部分的时间都是猜对在MIPS的publine里面当然就是你可以我们后面会提到有一些你可以猜 taken有一些你可以猜 not taken你不同的 situation你猜的方式会影响到你的prediction rate就是说你猜对的几率

到底有多少所以这个是我们等一下在后面会看到的一个例子在这个例子里面我们这边就是说我们假设说这个是prediction correct如果是prediction correct的话意思就是说我们猜是猜对的我们这边是猜什么呢是predict not taken我们是猜它不会跳它不会跳就是sequential execution它循序的去做下一個指令把下一個

指令 sequential execution下一個指令把它抓進來執行所以這個load它原本就是在原本的program裡面它就是在這個veq的後面所以我們把這個load就把它抓進來執行猜對了當然就沒有問題如果是猜錯的話猜錯因為我們假设就是已经把这个load把它丢到这个popline里面结果我们在这个stage我们在这个stage我们

知道说猜错意思就是说下一个指令VQ的下一个指令并不是load而是做一个all所以这个时候要怎么办呢因为我们已经丢了一个load在这个地方我们在这个时间点我们已经知道说这个是这个是要跳的它并不是不要跳它要跳所以这个时候怎么办呢我们就必须要把popline已经丢到popline

里面的这个load的指令把它清掉你就把它清掉你清掉以后在这边下一个clock cycle我们再把正确的指令这个all再把它load进来所以以这个例子来看当我们猜错的时候它的penalty是什么呢它的penalty其实就是我们前面完全没有猜的penalty是完全一模一样这边就是什么呢这是我们没有猜

我们没有去猜它到底要不要跳要跳不要跳所以我们就是直接在VEQ算完以后它的comparison比较完以后我们已经知道结果了我们知道结果我们就把下一个正确的指令把它丢到这个POPLINE里面来所以它是在前一个指令的ExecutionStage的时候下一个指令它才进来这是我们要猜测的时候它的情况是这个样子这个是我们猜错的时候猜错的时候是这个样子所以在这里面其实，它是跳过了一个

原本，这边应该会有一个Load的指令，在这个地方下一个Class cycle的时候，Load就进来了。 Load进来，它会不会再继续往下执行了？不会，因为我们在这个时间点的时候，这个时间点的时候，这个VEQ它已经第二个stage已经执行完毕，第二个stage它执行完毕，它就已经知道说要不要跳，所以他已经知道他猜错了，所以

他知道他猜错之后，他就会把在这一个第一个stage的这个Load的指令，把它清掉。这一定要清掉，你如果没有清掉的话，就会变成说，这边是一个all，然后这边是一个Load，这边是一个Load，所以也就是说，等于你part line的這個instruction phase這個stage當你在執行對的指令或的時候，那我們的這個Popline的第二個stage，它是在執

行錯的這個指令Law，所以我們看同一個時間點同一個時間點，就是這个樣子，在这个时间点呢，它的Popline的第一個stage，这是Popline的第二個stage，Popline的第三個stage，Popline的第四个stage，它是同一个时间点Popline，它的Stage就是这样子区分的，所以12,34每一个stage都在做不同的指令，所以我们如果Load不把它清掉的话，在这个clock cycle，它这个load会继续执行可的是，这个load并不是我们要执行的，我们要执行的是这个or是这个or，所以

就是我们后面会跟同学讲说如何把它flush掉，把它清掉，它就会把这个load清掉。所以，清掉以后呢，就会像这个投影片上面的这张图一样把它清掉了，清掉了，所以，在这个时间点呢，第二个stage，它是空的，第二个stage，它是空的，它不会去执行这个load，所以，这就是这边一整个全部都是bubble，这個才是對的，如果

没有清掉的話，就叫loadloadloadload，它會把不應該執行的指令執行完，那你，把不應該執行的指令執行完，你等於就是把這一個register3它不應該去update一個值結果，你就是把某一個memory裡面的location的值把它load到register3就把它做了這個動作，所以，你的CPU的state就錯掉了，你的register不应该被update，它就错掉所以，这边要注意的，就是

說这张图它没有show出这种flush的动作实际上就是要把它清掉，所以，我们如果再看prediction，再看prediction的这个动作，我们前面只是说你要猜那到底要怎么猜呢，我们这边就提到說这边有所谓的static branch prediction跟Dynamic Branch Prediction就是有這兩種機制顧名思義第一個就是靜態的就是我已經採用某一種Policy之後

我就是固定都是用這個Policy一直去猜不管它的環境怎麼改變我猜測的方式都是同樣的我就是一直OS猜它要Taken或者是OS都猜它Not Taken所以這個就是他不会根据他的环境而做这个改变所以在这种情况之下我们可以来看有一些他猜taken有一些他猜not taken比如说我们如果说对那种backward的predictionbackward的branch我们去猜他要taken就是backward就是坐到这边你要往后跳你要跳到这边就往后跳这种叫backward

的一個prediction我們這樣執行 執行到這裡你要往前跳這種backward的branch就是我們要猜什麼呢他說他猜taken就是要跳他為什麼要猜taken呢就是我們上一次跟同學提到的什麼呢就是針對那一種for loop或者是for loop因為一般我們的for loop for loop大概比較高的機率我們大概會 iterate 幾次之後才會出來才會 quit 那個 loop所以 suppose 我們就是大部分的 loop

都是要 iterate 幾次的話那我們每一次都是猜 branch我們對的次數會比較多比如說它就是 loop 三次 最後跳出來所以我們就猜 Tekken 一次猜對兩次猜對 三次猜對然後第四次猜錯出R所以我就猜對三次猜錯一次所以這個就是我們的game我們對於這一種backward的branch我們如果去猜tec-n的話我們猜對的機率會比較高另外一種譬如說forward branch那時候猜not tec-n它可能就是所謂的if-else

如果說if這個condition成立的話它是怎麼樣呢它是一個sequential的execution那else的話它在執行另外一組instruction如果說類似像這一種的話當然這個就很難講說你if condition true的機率到底是比較高還是比較低這一種你可以猜這個not taken另外一種猜測的方法就是所謂的Dynamic Branch Prediction顧名思義是會更改

猜的答案他不會說每次都是猜Taken或者是Not Taken類似像這種我們必須要搭配一個Hardware的機制這機制做什麼呢因為它是Dynamic Prediction所以你必須要根據你的環境的改變然後來決定說我這次要猜對要猜跳還是不要跳所以這個Hardware最主要就是在蒐集這一方面的這個信息就是說

根據我們之前的猜測這些結果，我到底現在這次到底要猜跳還是不要跳。如果說我們的蒐集這個信息的機制是對的，我們做出來的判斷是比較正確的。我們也會有比較高的機率會猜对猜对的话，它就完全不会有bubble必须要store的这种penalty。所以这个就是所谓的要wreck a recent history of each branch。 Each branch是什么呢？ Each branch就是指說在我们的program里面，比如说我们有很多地方都有VEQ 对不对假设我在我这个program里面，我有

500個BEQ的指令其實這個意思就是說你必須要針對每一個BEQ指令，你必須要去record它的recent history不是說我只提供一個history的record去記錄BEQ這樣子的一個指令所有的500個去share同樣一個這樣當然沒有意義因為你不同的branch它的condition它是不一樣的，它的情況是不一樣所以你每一個VEQ你必須都要record它的

history的information這樣子才能夠針對每一個VEQ去做它個別的判斷所以這邊我們後面會有比較仔細的介紹這边只是讓同學知道它的觀念所以我們根據它的目前最近的一個猜對猜錯的一個這個情況，我們大概就知道說它的Train好像就是最近的Train好像都是要拆Branch所以你就一直Branch一直Branch當你發現

它拆錯了那就表示說最近好像有改變的趨勢，它有不同的機制其實舊版跟新版的書它的機制又有一點不太一樣我們到時候可能就是有機會就把舊版新版的機制就都介紹一下就是說你不可以說我猜錯一次然後就趕快見風轉舵剛剛Branch猜錯Taken猜錯了那下次就猜Not Taken那你如果說Not Taken

又猜錯了你又馬上換成Taken那你有可能在那邊一直換一直換永遠都猜錯所以它就有一種機制就是說你必須要猜錯兩次然後才能夠再換再換說表示說這個Train已經在已经在变了错了两次又表示这个trend在变这样子又可以improve它的prediction rate所以这一种就是所谓的dynamic branch的prediction所以根据我们刚刚就是前面的这些material我们大概就知道说这个popline它最主要的performance improvement我们知道说它并不是

就是它最主要都是在這個throughput它並不是說它有improve它的latency因為我們知道說它的latency基本上是跟single cycle是一樣或者是類似，所以我們最主要是讓它的throughput大大的增加，但是我們理想的情況沒有辦法在現實生活裡面看到它有這麼大的improvement。它最主要就是受到Hazard 問題的影響，就我們前面提到的Structure Hazard、Data Hazard還有 Control Hazard另外，就是說就我們課本所介紹的這個RISC 的架構的CPU，它有這個優勢它的優勢就是說它的Instruction Set 相對於IntelAMD

它們這些CPU而言，它的Instruction Set是相當的Simple，另外我們剛提到那兩種，它是非常的複雜，它複雜的話，它的Pupline的機制也相對的就非常的複雜。我的這一種Instruction Set比較簡單，我們的Pupline的Implementation它就會比較簡單簡單代表什麼呢簡單當然就代表說我們Design出來的Pupline的Hardware，它的delay應該就会比较短，所以这个就是它

的优势的所在，所以我們后面呢我們就開始來跟同學介紹這個MIPS的這個popline的datapath，這看起来其实就很像我們在前面介紹的這個single cycle它的这个datapath它要分成什么呢它要分成一个instruction memory還有 register file還有 ALU還有 data memory其他的這些 multiplexer就是我們前面跟同學提到的它的 data flow有兩個 source你要二選一然後讓它導到它的 input

裡面去如果說我們把這個 database根據我們前面介紹的 pipeline的五個 stage 來看的話我們要分的話大概就是這樣子分就是這樣子这边切下去这边就是所谓的instruction fetchinstruction fetch就是把instruction读出来而且也把我们的current instruction的address就是PC program counter做一个加试加试以后就指到sequential execution的下一个指令第二个stage就是所谓的instruction decoding还有register file的一个read

这个stage这边我们有看到的就是一个control unit的breakbox我们这边没有画出来所以这边就是你instruction读出来之后它这个instruction的每一个fear它的这些OP function它就会开始丢到这个control unit然后去做这个decoding同时这个register file就会开始根据它的read的source去读这个Source1跟Source2兩筆資料所以這是第二個Stage第三個Stage就

是Execution這個版本並不是我們前面提到的有辦法在第二個Stage決定要不要Branch的版本這個版本是在我們前面提到你必須要在Execution Stage結束之後才能夠決定Branch到底要不要跳所以同學可以看到它的comparison是在这边做的comparison在这边做然后它的branch的target edges也是在execution stage在这边完成如果说我们想要把branch提早在第二个stage完成的话我們必须要把这个搬到这里来首先你必须要把target edges的加把它computation搬到这边然后我们还要必须在这边

加一个comparator就是这边加一个comparator因为你这边加一个comparator之后呢我们的这个两个registered file的这个它的这个data读出来之后它直接在这里就直接做comparison它不需要再丢到ALU它就直接在这边做这样子我们就可以在第二个stage结束的时候呢我们就知道说这个branch到底要不要跳所以这个我們只要同學要

先知道說這個版本它是在第三個Stage才結束Branch的Execution這邊就是MemoryAccessReadMemoryWriteToMemory就在這個Stage最後一個Stage是WriteBackWriteBackToRegisterFile它的Source就是一個是從Memory讀出來一個是從這個LU這邊算出來的就是 R type 算出來的結果 2 選 1然後寫回到 register 5所以實際上我們最後一個 stage並不是好像一個 multiplexer 而已同學要知道說最後一個 stage它的 hardware

會用到的 hardware並不是只有一個 multiplexer是這個 multiplexer 再加上 register 5它就是要把它寫進去但是同學不要 confuse 說既然第五個 stage 要用到 register file我們的 register file 的 read 也是在這一個 register file好像衝到好像 conflict同學應該就要回想我們之前有提到過當我們要寫資料寫到 register file 的時候我們是在它的前半個 class cycle 寫進去的我們是把它寫進去

那讀的時候呢是在後半個cycle再讀出來所以它基本上是沒有conflict它沒有conflict這個是同一個cycle可以完成這個right然後再完成這個read所以這邊要搭配前面所以這個就是我們的這個在這個地方然後這邊要注意的就是說它這邊有提到說right to left flow我們的hazardhazard主要是什麼呢我

們剛剛提到的就是structure control大概就是這幾個還有data反正你只要是從右邊直到左邊的這個flow大概都會導致這個hazard它會導致這個hazard所以同學可以看到的這邊就有一個由右往左傳回來同學應該還記得我們在講data hazard的時候是不是都一直在解這個問題我们前面讨论的Data

Hazard比如说你如果是R-Type Hazard你透过一个Forward大概就可以解决这个HazardHazard的发生就是在这一边因为它有一个游游往左后面的Stage要写到前面的Stage这个Register 5这一个Stage又是后面的指令它要读出来的如果它要写的destination跟它要讀的source兩個是一樣的它就發生hazard

它hazard就是出現在這個地方但是我們的這個publine並不是就是像我們publine的design並不是像我們剛剛看到的用一個虛線就把它畫出五個stage就結束了不是說我畫一條虛線然後它自己會做synchronizationHardware上面你Hardware虛線沒有用它沒有辦法去做Sync的動作所以我們最主要是要

在每一個Stage之間就是加入所謂的Publine Register要加入這個Publine RegisterPubline Register它的目的是做什麼用呢同學可以把它做一個簡單的連結這是什麼呢就是說我們知道說在這個publine的datapath裡面呢它最多可以有幾個instruction最多可以有幾個instruction五個 對不對一個 兩個 三個 四個 五個有五個stage我們有五個stage如果同學又忘了哪五個stage就是這邊instruction phaseinstruction decodingexecution1 1 2 3

instruction execution memory然后还有writeback 1 2 3 4 5总共5个stage所以你5个stage每个stage都可以执行一个指令最多是5个指令现在的问题是在什么地方呢现在的问题是在说同学可以发现我们看前面这个版本我们说这5个stage它可以允许有5个指令我们就随便写了5个指令

我们就随便写五个指令同学可以看说这五个指令你如何让它可以同时存在这个popline而不会打架而不会后面的盖掉前面的或者是前面的盖掉后面同学会说前面怎么盖掉后面反正大概就是说你的information被其他的instruction给override这样子的话大概就会有错错误就会出现所以我们要让怎么样

呢我们要让这个load跟它所有相关的information signal全部都要keep在这个stage我们要让所有跟all instruction相关的signal全部都在这个stage同理你要让每一个指令跟它相关的information都在这个stage那在这个DataPath里面每一个instruction它有什么information呢它的information是不是就是我们这边有一个controlUnit它会decode这个instruction然后controlUnit会generate所有的这些controlSignal这些所有的controlSignal

都是由这个control unit在决定的都是由它在决定所以说同学可以看到你这个线呢从这边拉到这里来然后呢这边拉到这里然后这边你可以发现说这边control unit它的讯号会拉到这里会拉到这里也会拉到这里也会拉到这里它会接到的Functional Unit或者是这些Multiplier它是散落在每一个Stage你如

果说不加一个Register的话你只要这边Control Unit有一些新的信号算出来它马上就把它Override掉它就Override所以这个指令比如说我现在这个指令是All现在是All在做Decoding这边是Load这边是8这边是8那比如说这边是这边是8的所以同学可以想见下一个clock的时候是怎么样下一个clock的时候是这边变all这边变load这边变8对不对这是clock i加1

它是 i i 加 i 下一個 clock所以 all 會跑到這個 stageload 會跑到這個 stageaid 會跑到這個 stage都是往前一個 stage就往後一個 stage 移動執行完就往下一個 stage那同學覺得這個 aid 它會它會怎麼做選擇呢它會選擇誰他會選擇誰假設是這樣子的話這個A的他是會選這一個還是會選這一個他會選哪一個他會選哪一個我們選1的舉手同學猜一下選 1的舉手選0的舉手同學都對

都没错因为我这个例子举得不好因为它都是什么呢一个or一个add它都是什么呢它都是属于这个rtype它就是把这个arrow u的结果写回register file如果这一个是两个都是load会怎么样这个是load所以我们在这里这个就不是or这个就是什么这个就是load对不对这就load所以这个时候当我在执行add的时候它会选1还是选0它会选1为什么

因为add在这个地方的时候刚刚这个load它的control unit decoding把它认出它是一个load认出它是一个load就表示说它是要读这个memory的data读到register file所以当你下一个clock的时候这一个input selection的值已经被override掉了add的input selection就被它给override掉了这个就是因为你boundary没有用register把它hold得住所以现在流行这个所以要hold得住要把这个popline register加进来加进来就是要把我们的information跟每一个instruction

同学把它想象把它pack在一起就把它pack在一起所以我每一个指令相关的资料它都是被register所挡住当你执行完你要进到下一个要进到下一个stage的时候我跟我这个instruction所有的information就进到这个popline register进到popline register所以它比如说它就全部進到這一邊這裡面的值就全部進到這裡來這裡面的

值就全部進到這裡這裡面的值全部進到register裡面所以我們透過這個register我們就可以有辦法把每一個instruction它的值怎麼樣跟它相關的signal 訊號全部都hold在它自己的這個stage裡面Hold得住在它的每一個Stage裡那這樣子的話整個Pupline在運作的時候呢它才會是正確的所以同學要知道

說我們要加這個Register在Stage之間加Register最主要就是要去Hold這個Information然後把每一個Clock Cycle這個Clock Cycle它的這個產生出來的Information就是把它Pack在一起然後一起把它丟到下一個publine的register那這樣子它就不會有這個問題所以同學可以看到我們這邊加了這個register之後所有的signal進到下一個stage都是要先進到register所有進到都是進到register進到register都是一樣這邊都是一樣然後最後這邊feedback到這邊做一個writeback的一個動作

這個就是我們第一個版本的這個POPLINE的DATAPASE這個POPLINE的DATAPASE其實是有BUG的它並不是非常正確它有BUG所以我們這個禮拜四的時候我們再看一下就是說它的BUG在什麼地方。.