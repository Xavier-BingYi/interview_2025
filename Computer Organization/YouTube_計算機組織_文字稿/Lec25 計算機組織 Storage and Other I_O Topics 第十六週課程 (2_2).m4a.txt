undefined
那我們跟同學介紹這個第六章Storage還有這個IO的一些topic這個應該是我們就是最後一個章節我們就是其實這個IO的部分同學因為大家在用電腦的時候大家都不太會注意這個IO的部分因為總覺得說整個電腦系統裡面大概最重要的大概就是那個CPU然後IO的部分大概就是我們大家習

慣的這個Keyboard、Mouse這一類的實際上同學可以發現說其實在現今的科技的發展這個IO以後電腦這個IO的界面它會越來越就是越來越炫同學應該有看過一些那個虛擬的鍵盤有沒有有看過虛擬鍵盤的都沒有虛擬鍵盤它不就是用一個類似這種投影的裝置它完全沒有鍵盤它就是一個投影的裝置那投影的裝置讓你以為就有一個鍵盤那你就在上面打實際上你是在

現在的發展是它要投影在一個比如說投影在桌子上面或者是投影在牆壁上面你就在那邊打你在那邊打的時候就好像真的是有鍵盤當然同學會說你這樣打的時候好像沒有觸感你按鍵盤你會覺得有按下去彈起來早期的鍵盤就是所謂的機械式它有按下去會卡卡卡卡所以我們以前早期的時候

在買鍵盤是那種有喀喀聲音的是比較貴的後來這種潮流好像都會變後來大家覺得說這個喀喀好像用起來不是很順後來就變成是那種比較軟性的軟質的那種鍵盤是比較貴的可是你現在幾乎都找不到那種喀喀的大部分都是無聲音所以聽說好像你現在反而要去買那種有那種機械

式的反而是比較少見那少見的就比較貴像那種虛擬鍵盤的話你會覺得按起來好像是沒有觸感但是實際上我們人是很容易受騙尤其是感官我們人的感官很容易被受騙。我相信同學常常在網路上面瀏覽各式各樣的網站大概都有看過一些網頁它就是人類視覺的錯覺它用很多那種圖

案實際上那個圖案是靜態的你看下去的時候你會覺得它整張圖是在動或者是很多之類的這一類的就是它會騙我們人的視覺實際上它那種虛擬鍵盤它雖然沒有觸感但是它會發出那種類似就是你按下去的聲音會讓你感覺好像好像有感覺似的真的是在按鍵盤所以這個是現在看起

來好像比較炫的以後我們在電影上面看到的Tom Cruise他以前有演過一部電影那部電影名字叫什麼我忘了反正它整個操控的介面就是在一個虛擬的屏蔽上面你可以做各式各樣的操作之後的這種Io介面的話那我相信大概就是所謂的這種人機介面是往後就是往後我們這個電腦的一個

發展一個很重要的一個里程那甚至像那個就是這很早以前就已經有在發展的就是我們這個就是對一些就是可能他身體的這個功能比較沒有那麼健全他就是有一些傷害所以他沒有辦法用手或者是手腳比較沒有辦法行動可能必須要透過腦部抑制的控制它可以控制Mouse的Cursor在那邊移動一直有人在講這一類的裝置大概在很快的這幾年之內都會應用在我們的一些產品上面

所以我們現在這一章節最主要就是要來跟同學介紹CPU之外的這種IoDevice它們的一些運作的一些原理還有它裡面的一些Structure。首先我們來看一下就是說這個IoDevice，它可以被根據它的特性，可以把它區分成幾種。就是說，我們可以用不同的方式來characterize這個IoDevice，包含它的Behaviour。 Behaviour的話，我們可以說它有這個Input，因為我們剛剛講Io，所以In I就是Input那Output可是重點，這個Input是什麼Input，那Output是什麼Output？意思就是說，你既然說In到什麼地方，那Output是Out到什麼地方去。

所以這個牽涉到說你的主體到底是誰？就是說你的觀察觀察者的角度到底是誰。在我們這邊，我們指的我們的主體指的就是指這個CPU，而言那所以說IN是什麼呢？ IN就是讀進來，那OUT呢？ OUT就是出去。所以這邊的主體指的就是指這個CPU根據他們的Behaviour，我們可以大概說它是一個Input、Output或者是Storage。如果是Partner，這個到底是接到Human還是Machine比如說我們的Keyboard，Keyboard，我們使用的是Human，好像我們有一些現在Microsoft的Kinic，

他們那個很流行的，那種體感的，那種裝置，那個也是都是人工，那實際上我們的電腦很多應用都是應用在這個機器就是它跟儀器設備什麼樣子的一個連接，那在早期其實電腦剛推出來的時候就除了個人的使用的application之外，其實應用在很多的儀器的控制上面，所以那時候就是說，在學這個community

science其實很多人，他們都會去，就是像同學現在，如果在外面接case的話，大部分大概都是做什麼，大部分都是做一些網路的case或者是做一些像跟database相關的case，在以前早期，其實做比較多的是，在做電腦跟外面儀器，它們之間的連接，還有電腦跟儀器之間的控制，所以這種是Human跟Machine另外一個，我們又可以根據它的Data Rate來characterize這種IoDevice，它到底是高速低速或者是，比如說我們做Data Rate的話，我們可以說你concern的是每秒你可以

傳送多少個byte或者是你每秒可以做多少次的transfer，完全dependent on你的application，我們可能會focus在這個或者是focus在這一個我們的IoDevice當然不是就是平空的，就是直接可以跟電腦來做一個communication它必須要透過這種bus才能夠跟電腦做一個connection，做它的這個data的transfer所以就我們來看我們看到的第一張的這個IO的圖示，我們可以很明顯的看到這個是一個Processor，這個是一個Cache接著這邊有Memory跟IO的這個Interconnection，

所以透過這個Memory IO的Interconnection，它可以接到Memory，Memory它可以接到這個IoController這個IoController，它再接到這個Disk或者是這個Graphics Output或者是Network就一大堆，我們知道說像我們的Desktop，它的擴充性比較高，所以它可以接出各式各樣的IoDevice，它也可以接得比較多，那我們的這一種就是Led Top通常這種擴充性比較少，它可以接到的Io的

Device數目數量大概會比較少，這個就是我們等一下會介紹一下這一邊的一個架構，我們在談這個Io的System的特性，首先，我們要了解就是說這個Io有一個很重要的，就是它的Dependability，這個Dependability最主要尤其是針對這個Storage的這個Device當然我們不希望說這個Storage我們存進去以後結果明天來用的時候就發現說它就不見了就是第一筆資料在第二筆資料不見或者是說你存一個100的資料進去結果明天變99

這個就差很多 60到59 這也差很多所以我們說這種Dependability對這種Storage的Device非常重要像現在有一些筆電就是它強調開機非常快速我們以前都一直在質疑說奇怪怎麼Intel它做的機器好像永遠都快不了多少就是你覺得說這個舊的機器開機要這麼久你新的機器它明明clock rate已經增加提高一倍了你開機應該會變很快怎麼現在開機還是一樣慢那現在有一些那個laptop開機它不是強調兩秒鐘或者是很快就幾秒就馬上就可以

把它開機那其實那個當然除了你OS的這個精簡在refine之外有一個很重要的就是說它很多資料它去讀資料的時候比如說它說要從硬碟裡面去讀資料那你從硬碟讀資料的時間到底要花多少時間那這個可能就會差很多所以同學你只要買到那種硬碟它說不是硬碟就買到那種筆記型電腦你說它開機幾秒之內開就馬上就可以開好它那種硬碟大概都是那種特殊的硬碟就所謂的固態硬碟它的速度就非常的快可是

這個固態硬碟據說目前的這種可靠度並沒有那麼的高，它有可能用、用用然後它就crash它crash實際上，它並不是真的crash，而是因為它已經沒有辦法判斷說它這邊到底你去做讀寫到底成功的情況到底是怎麼樣當它沒有辦法判斷的時候，它就把整個硬碟就把它鎖住，就把它鎰起來；使用者大概就

沒有辦法再用，像這一類的它的速度非常的快，但是你如果說要把你的這一種很重要的資料都儲存在上面的話，這個就是大概有很大的問題另一個就是Performance的issue； 我們知道說，有兩個，一個叫Latency， 另外一個叫Throughput；Latency 就是指這個Response Time，Throughput 就是指這個Bandwidth，所以我們了解說，像這個Response Time對一般而言，我們個人在使用的話，我大概會比較Consent這個Response Time，我不希望說用一個東西，在那邊等很久所以

像以我們而言，我說Desktop Embedded的這個System的話，這種大部分都是屬於個人在使用的，所以它大概就是比較注重的是這個Latency；那這個Server的話呢，因為它並不是只有讓一個人使用，它是很多人進去用它要讓每個人都覺得說這個Server，它的效能不錯，就是我在上面用，不會說兩個人、 五個人、 十個人，它的效能差非常多，所以它比較注重的是這種throughput可以deliver給多少人我們談到dependability我們就要來看一下，

說一般我們的分析就是說，我們一個device或者是一個system，它可以正常的運作跟它沒有辦法運作，這個中間大概是什麼樣子的一個情況。我們可以說，一個系統或者是一個device，它說它可以deliver service，它就可以正常的運作，所以它這樣做做做做一做之後，它可能有一天然後就掛掉了，掛掉以後不管是掛掉了或者是它的工作異常，

它大概就是屬於就會進到這個Failure的State。你進到Failure的話，我們就必須要想辦法怎麼樣呢，就必須要把它Restore，把這個東西，把它 Restore回正常的狀態這個Restore有很多包含，就是你可能就是先動一動拿起來搖一搖或者是吹風機吹一吹或者是你再送是送修之類的，那你大概要花多少時間然後才能夠回到

一個正常運作的一個時間，基本上我們在討論的大概就是說，在這個過程裡面，它大概需要花多少時間提到的這個Failure的話，我們指的就是指首先，我們要來講什麼是Failure什麼是ForFailure，它通常就是指一個Compose，就是說，我們首先來看一個for這個for就是指一個component的這個failure所以一個device它有很多的component你如

果說你是一個很重要的一個component那個component fail掉以後它整個device或者是system它可能就亂掉亂掉它沒有辦法再deliver service其實這個時候也就是等於是failure。如果說它這個component產生一個for它，其實有for存在但是它還是可以work就好像我們人其實我們每個人身上或多或少都有一些大大小小的毛病可是還是一

樣每天可以睡覺醒過來吃飯然後讀書上學工作都可以正常的工作。所以這一類的這一種component的failure我們是把它稱作是這個for它，不一定導致這個system的failure像在做这一种就是說FOR同学应该聽过这个FOR TORRENT之前有跟同学提過說FOR TORRENT其实就是說它要保證說它發生就是說希望說它里面有坏掉的时候它可以继续正常的運作像比如說在很重要的那种太空里面的computing它们就不可能說都是只有一台

那它如果再算一個東西 如果那一台壞掉的話那你太空船送出去 結果就一台壞掉然後就廢了掉那你那個發射花那麼多錢 那個整個都白廢掉。 T的這個機制其實現在這種科技它已經進展到我們知道說現在進展到奈米的這個科技現在他們已經發展到可以有這個實驗他們已經實驗有做出來就是說他們可以去修復電路，修復電路

不是叫工程師去修復嗎？工程師修復那個不算什麼它是要自動修復電路的能力。同學會想說這個電路如何自動修復呢？其實它非常簡單，因為我們知道說我們在第一章有跟同學大概介紹，就是說你這個IC裡面其實就是有很多device還有很多線，那個線其實你一個IC它如果壞掉的話，它可能就

是大部分，它可能就是你那一條金屬線或者是什麼線，那個線可能就斷掉，那你那個線斷掉的話你的訊號就中斷了，它又可能沒有斷掉，它可能是就是快要斷掉，然後那個線就是損毀的很嚴重，本來是一條完整的一條線，然後損毀的就好像快斷這樣，這個時候它的它整個晶片它的運作的時候，那個情況就會變得很怪他們現在發明了一種，就是說

他們在製作這個晶片的時候，他們在那種線上面他會灑很多那一種那一種可能就是大概是narrow scale的，就是一些膠囊，他灑了一些膠囊在那個線上面，這個怎麼灑呢？這個當然是一種技術，你把這些膠囊在那個線上面，那個線當它有損毀的時候我們知道說現損毀的時候整個電路的特性它會改變，它改變的時候

附近的膠囊它就會自動釋放出那個Material那個M材料就會把壞掉的地方等於是把它填平就好像說同學就想好像說這個柏油馬路上面它先放一些膠囊你那個膠囊如果柏油這邊挖一塊挖一個洞不見了然後膠囊自動就會把那個物質釋放出來把那個填補所以這個線路它又變好了所以這一種你要如何盡量不要讓它壞掉一直維持在這一個State這個是

很重要你如果說壞掉了你要如何很快的讓它Restore這個也很重要所以我們就要來看一下說這個Dependability的這個Major我們要怎麼去評估一下就是說它到底這個到底好不好首先我們來看什麼是Reliability這個Reliability它就是指Mean Time to Failure Mean Time Mean Time to Failure就是MTTF的一個縮寫很明顯它指的就是指說我平均大概多少時間我的這個Device我的System來Fail掉這個叫Reliability

另外一個service interruption它是meantime to repair什麼是meantime to repair當然就是指說你壞掉我們剛強調說你壞掉你就可以把它修復你要花多少時間去把它修好這個就是所謂的meantime to repair這個完全是因為它壞掉你必須要service來提供repair的緣故，所以我們說Mean Time Between Failure，這是比較重要的。我們想要知道的是平均兩個Failure，它兩個

Failure發生，那個Failure然後跟下一個Failure發生的這個中間大概會隔多少時間。所以這個叫Mean Time Mean Time Between Failure Mean Time Between Failure，它就是MTTF加上MTTR。我們來看這張圖，實就非常清楚。我們說原本它是good，所以它是deliver service然後一直用一直用用到壞掉了壞掉了。我們要repair，那repair之後呢花一段時間repair好了，它要回復到good然後good了之後呢，又要用到它要壞掉了，它要用到壞掉。所以我們要知道的是要知道這個，這個是在這邊壞掉下一個時間點壞掉，是在這個地方壞掉，

總共隔多少時間當然就是Mean Time to repair Mean Time to failure這兩個相加就是兩個，就是我們要的這個MTBF。我們要定義說這個系統到底，它的availability到底多好。如果說它的這種可用度很高的話，當然就是非常好。所以我們說它的availability就是什麼呢就是Meantime between failure分支 meanwhile to failure所以就是說這個間隔分支就是說你真正可以使用的時間到底是多少這兩個failure發生中間這麼長的過程裡面到底有多少時間可以使用所以如果說

這個值很高的話其實就是表示說它的availability不錯很好所以我們要如何去improve這個availability我們要improve當然說第一個因為它要高 大比較好所以我們要就是increase這個mean time to failure希望說它每一次修好以後它可以使用的時間久一點所以這個是可以增加這一個另外一個我們知道說我們要減少這個分母所以要reduce mean time to repair我們希望說它repair的時間period是越短越好所以這個就是我們這邊提到的availability用這個東西來判斷說它的實用性

可用度到底有多高我們再來看這個Disk storage這個是我們現階段資料都是儲存在這種RD上面這個架構基本上就是它這邊有磁盤就是有很多片的磁盤然後它這邊有幾個專有名詞一個是Track一個是Sector一個是Cylinder這邊我們首先來看每一個Plat它有很多個這種同心圓每一個圓它就是這個Track我們的資料就是儲存在這個Track上面

每一個Track它又分成很多的Sector就是一段一段一段一段另外還有一個名詞叫CylinderCylinder它指的就是指這個圓柱狀就是說我們看到的這個圓柱狀比如說假設我們設定的圓柱形是在這個地方當然它必須要Match某一個Track但是它並不是一個平面 它是一個立體所以我們這樣子畫下來以後

這一邊所交錯的所有的這個Track都是屬於這個Cylinder所以這邊的Cylinder它是指我們這樣子的一個立體的一個圓柱狀它所包含的不是說這邊包含不是說包在裡面的就剛好跟這個圓柱這邊切到的這些Track所以在這個例子裡面就是這個Track然後這個Track然後這個Track它如果是Double Side所以它就會有

double 的 track就是我們講 double side 就是 platedouble side 所以就是兩面所以我們這邊有三個重要的名詞一個叫 sector一個叫 track一個叫 cylinder它的差別就在這個地方這邊的 sector最主要就是我們儲存資料的一個基本單元這個基本單元我們的一個 file就是一個 file 它存到hardd裡面它並不是都儲存在連續的這個se

ctor它可能是就是這邊存一個那邊存一個那邊存一個所以他們大概就會反正他們會有一個方式來記錄說我們的這個file大概是存到這個hardd裡面的哪一些位置那我們大概簡單看一下就是說我們剛剛提到的就知道說它的基本的單元就是這個sector這個sector它記錄什麼東西呢當然

就是包含它的ID每一個sector的ID然後還有它存的資料還有這個ECC就是Error Correcting Code我們知道說如果說它有發生這個error的話它在某一些範圍之內它有辦法就是利用這種ECC Code來做一個correction另外還有所謂的Synchronization Field跟這個Gap這個Synchronization Field純粹就是要給這個Controller要Guide的Controller去做這個Read的Process這個Gap其實就是它是屬於什麼就是說我們知道說我們在讀一個Sector的時候

它把資料讀出來我們的Controller它必須要去處理它這些資料如果說Controller假設Controller它要處理它資料讀出來之後 處理資料的速度不夠快的話同學可以把它當成這個Gap就是所謂的緩衝區這是一個緩衝區這個緩衝區不是所謂的Buffer要存資料而是說這個Gap它在這個磁頭讀到Gap那邊的時候因為它只是一個Gap就是一個Space它就是一個Space所以它沒有資料可以讀但是它的動作它還在進行它透過這樣子的一個

方式可以讓 controller 去處理它剛剛讀出來的資料讓它有足夠的時間去處理剛剛讀出來的資料所以最主要大概就是這幾個 information我們要去 access 一個 sector 的時候我們大概比較 concern 的就是說我們的 access time我們的 access time 這邊它平均大概就是它就歸類出大概需要這幾樣的時間第一個就是因為你不是Access你

就一定馬上就會被Served你必須如果說有很多人都有這種Rewrite的Access的Request我們可能大概就比較Panned在那一邊所以它會有一個Curring的Delay它如果不是在這一個Track的話它可能必須要去移動它的讀寫頭所以它必須要sig time它必須要把它移到正確的track你移到正確的track之後你也不一定是落在你要的那個sector我們知道說一個track分很多sector所以我們必須要rotate我們這個磁盤把它rotate到就是說

我們要rotate到我們要讀的那個sector所以這個叫rotational latency接著就是就是data transfer 它就開始送資料另外還有一個controller的overhead所以我們用一個簡單的例子來算一下我們的disk的access time我們舉例說 比如說它是512B sector就是說它一個sector 它存的資料是512byte然後它的轉數是15000轉U5000轉它這邊是每分鐘就是per minute另外它的average的sig time是4ms microsecond它的transfer rate是每秒可以傳送100個MB另外它的controller的overhead就是0.

2ms根據這些資料我們就可以來算出我們大概是平均我們的read time大概要多少首先我們把固定的這個值先列出來Average SIGTIMECMS SIGTIME先列出來接著我們要列出Rotational Latency在這邊我們的Assumption是假設說我們平均每一次你的Rotation大概就是轉半圈我們就平均就是轉半圈就

好不要說我可能轉六分之一圈我可能轉一圈我們就說我們就帶著轉半圈這平均叫轉半圈你轉半圈我們當然就要知道說我們轉一圈要花多少時間這邊就是說這個是每分鐘有一萬五千轉一秒這邊是一分所以一秒大概有幾轉所以這邊要替換成60這邊就算出每秒多少轉然後取導數

就是每一轉要花多少秒所以你這邊取導數就是每一轉要花多少秒然後這邊是1 2分之1轉所以再乘以1 2分之1我們這邊得到的Rotational Latency就是兩個ms接著它的這個Transfer Time因為我們一個Sector是512個byte它的Transfer Rate是每秒可以傳送100MB所以我們就是512除以100MBper second這樣一除我們就知道說這個512b它需要花多少秒0.

005ms再加上0. 2ms的controller的delay這樣子加起來大概就是需要6. 2ms就是6. 2ms這樣子在這邊我們就說如果我們的實際上我們average的sick time是只有1ms的話我們這個平均的read time它就可以從6. 2ms降到3. 2ms所以我們的sig time如果夠短的話我們的效能可以很顯著的提升差了將近快一半所以這邊是我們一個簡單的例子了解說我們如何去算這個disk的access實際上我們在就是說

我們的這個HD 它的這個vendor它當然都會提供那個數據就是說它的這個HD大概它的access time大概是多少然後它的這個就是說大概比如說average的sick time大概是多少但是實際上因為我們在做access的時候就是我們這邊有提到有locality還有OS Scheduling會導致我們真正去做Access的時候它的Sig Time通常會小很多大概會比較小如果比較小的話當然就表示說我們Hardee的Vendor他所提供的引用的Average的Sig Time大概就是一個參考值

實際上我們可能真正在用的時候我們得到的速度會比較快所以同學如果做實驗我們得知說我們的Average Access Time好像比廠商所提供的數據還要快很多所以同學不用太高興說我們好像賺到了好像真的花同樣的錢然後買到效能比較好的實際上最主要就是Locality還有OS Scheduling這個Hardly Access的關係它才會得到比較好的SIGTIME當然另外還有就是說

我們可以有比較聰明的Disk Controller這些Disk Controller它也有一些方法可以讓我們的Access Time來得比較Efficient我們這邊看到的就是有幾種比較像SCSI ATA然後還有SATA這一類的這個我想同學可以自己看一下這個Spec另外它這邊還有提到Disk Drives它可能也有Cache所以它 Cache的話， 既然有Cache，它就可以做什麼呢？ Prefetch就是類似我

們在CPU裡面，它也是可以預測什麼樣的一個Access所以這邊Prefetch的話，它又可以避免SigTime還有Rotation的Delay這一些都可以讓我們的Disk的Performance可以得到有效的提升。談到談到這個Storage，除了我們這個Disk之外，就是還有這個Flash的 Storage我們現在應用就非常的廣泛，它是屬於這個Non-Volatile的Semiconductor的Storage，它大概是比這個Disk大概快它說快100倍到1,000倍，它又小然後又Low Power然後又比較Robust。當然就是

這個麥克要比較多，就是了這個Flash，它這邊介紹的種類，就是有這兩種，一個叫NoFlash，一個叫NameFlash。我們這邊不談它的Design，它這邊就是說它的BitCell比較像一個NoGate，所以它才叫這個NoFlash。它這邊說BitCell，它是像這個NameGate，所以顧名思義，它是叫NameFlash這兩種Flash，它有什麼特性呢？ No Flash是Random Rewrite Access，所以它是Useful Instruction Memory在嵌入式系統

裡面的Instruction Memory另外如果是Name Flash的話它這個Denser密度比較高密度比較高但是它怎麼樣呢密度比較高通常它大概容量比較大它大概就是它也是但是它Access的時候它是一次就是一個Block就是BlockAt Time Access所以這個是NAND Flash它的特性這個比較Denser容量比較大比較Cheaper平均每GB的這個Cost也比較低所以這個大概是什麼

USB Key Media Storage大概都是用這種NAND Flash另外我們知道說類似像這種Flash它其實有寫入的次數所以它這邊有說大概是到一萬到十萬左右的write大概你在寫入那麼多次以後可能那同一個位置它那個bit cell它可能就會它可能就沒有就是會沒有辦法再寫還是壞掉什麼之類的所以這一種使用呢它有一個東西很重要就是什麼呢就是你必須要去把我們的這個data呢它必須要去remap

Remap它才能夠提供整個Flash它的整體的Storage就是說良好的Bitcell的數目是比較多是比較平均而不會說它都是集中在Access某一些地區結果它很快就到了幾萬次然後那個地方就沒有辦法再寫它就等於說它壞掉的地方就越來越多，所以這種Remap到比較少用到的這種Block，這個就非常的重要所以這個是

Flash的特性。 Storage之後我們談到接下來我們就是要跟同學談這個IOIO，就牽涉到這個IO Device，它的這個Interconnection，所以我們這邊要先跟同學談這個Interconnecting Component。我們要如何把這些Component把它，把它連接起來然後接到這個CPU，讓CPU可以去做這些Access。所以這邊提到的就是說，我們要如何在CPU Memory還有Io Controller之間，這個Connection提到Connection，大家都

知道的一個字，就是Bus。我們就是有很多種類的Bus，可以連接各種不同的IO Device跟我們的CPU Memory，可以讓他們做一些Communication這種Bus，它基本上就是所謂的Shared Communication Channel它是共用的這種Communication Channel。什麼是共用呢？意思就是說，這個Bus它並不是Dedicated，就是給某一個Device使用。如果說是Dedicated給某一個Device使用，如果說我有四個Device的話，你就必須要有四個Connection。這個Connection

它是independent 它是獨立的這等於是什麼呢等於我們比較常聽到的是好像說它其實就是一個點對點的一個communication所以你如果有四個device你就要有四個點對點就是這樣子communication這個不是 它是share所以你四個device它是share同一個bus所以它是這個paraset of wire那它paraset of wire這個wire是做什麼用呢當然就是傳data用的

還有做Synchronization用的所以這個是Bus它們就是有這樣子的一個特性這個優點當然就是說我們可以共用資源我們可以Mathemize它的Resource的Utilization但是它的缺點就是說你如果說有很多Device都同時都要去做這個Data Transfer那當然它會有可能會形成Bus可能會形成這個Performance的一個B

ottleneck這個是它Potential的一個缺點還有我們就是說它的Performance我們這個Interconnection的Performance它有可能被實際上的一些因素所限制住就是說Wire Length大概是短的還是長的有一些是For Short Dist ancel有某一些是可以For Long Distance，所以它是有不同種類不同應用的這種bus還有它可以接的connection，到底有多少

不同的這種bus當然它的規格不一樣，它是for long或者是short，它的number of interconnection，到底是多少。現階段除了bus之外有一些比較常看到的一個字就是叫switch，它可以透過high speed這個serial connection都是透過這個switch，switch它可以控制你的communication，大概是從這邊連到那裡，switch開關，它可以控制，那就是所謂的這個network，像是在電腦裡面好像建了一個network一樣，那我們知道說network，它的communication的方向起點終點，

它可以控制的，從這邊接送過來送過去，這個是可以控制的。所以現階段另外以外Bus之外還有一個就是所謂這一種這個Network，那我們這邊後面要介紹的大概是介紹這個Bus，像這個Switch Network這一類的Interconnection，實際上學在去搜尋這個paper應該現階段可以看到蠻多這一類的Research，他們有在做這樣子的一個HIGH SPEED

INTERCONNECTION我們比較常見的BUS的種類，這邊列出來，有三種一個是Processor Memory的BUS，顧名思義，它是什麼呢？就是連接Processor跟Memory做一個高速的，這個一定是要很快，因為我們的CPU是非常的快，所以它是SHORT DISTANCE，它是HIGH SPEED TRANSFER，就是這樣子當然，我們這種Processor Memory的Bus，它的Design，我們要Match我們的Memory的Organization，我後面會看，就是說，它有提供幾種的機制。 IoBus的話，IoBus，就是接到IoDevice，它是可以比較Long Distance，它也可以允許Multiple Connection，但是我們知道說，IoDevice，因為它就是

很重要的一個，就擴充性，就是你到底有多少種IoDevice可以接到這樣子的一個Bus通常，我們要求的，當然，是希望說，最好是共通的，我們在不同的電腦品牌上面，我們都可以使用同樣，你只要是用這種Bus，我們不同的這種IoDevice，其實，你可以跨平台、 跨電腦，你不會說，我在Computer A可以接在Commutator B結果就插不上去，

所以我們當然，不希望有這一種，所以我們大概會有一些standard，你在不同的platform上面其實，它都是共通的當然，它不是，就只有接到IoDevice IoDevice接進來資訊進來。你最後還是要到Memory還是要到CPU所以，你還是必須要到Connect到Processor Memory的Bus透過一個Bridge。所以我們等一下會看到一張圖就是現階段PC所採用的架構另外一種叫Backplane Backplane Bus它是允許Processor、Memory、IoDevice共存在一個Single Bus這個Bus它在運作的時候我們要首先這邊做一個簡單的了解就是說第一個，它要傳資料

第二個，它要做Synchronization所以它就有下面的這幾樣基本的information第一個是Data Line當然你要傳送的Data就是透過這個Data Line它可以傳Adress它也可以傳Data就是透過這個Data Line上面去傳你的Data Line你可以是Multiplex或者是Separate它可以是獨立的或者是分開的或者它是共用但是用類似Multiplex的功能可以去多選一這樣子這個Control Line當然就是說你必須要通知說我的Data Type到底是什麼至少我們這邊它就告訴我們說你可以

送Address你可以送Data你至少要分得出到底是哪一種還有你要做Synchronize的時候它也是透過這個Control Line來進行。如果是一個Synchronous的一個Operation的話，它就必須要有一個Bus的Clock。你要Synchronous大家都同步大家都同步的話當然就是要有一個Clock。這個Clock不是CPU的Clock，它是Bus的Clock。這個Bus Clock當然也很重要。如果說是很慢的話

當然你也很難Respect說你的這個Communication大概有多快那另外一種如果是Asynchronous的話，它就是用這種所謂的這個Hand Shaking，就是一個Request出去然後它就會做完之後然後再Acknowledgement回來說我這邊做完了就是這種互動式的。然後，這個就不是Synchronous，它這個是Asynchronous 所以你可以有這兩種這邊我們列出來 課本有看到這種FarWire、USB、PCI、Serial、ATI還有這種Serial Attached SCSI。在早期，這種Workstation他們大概用的都是這種SCSI裡面SCSI的硬碟速度相對的是比較快不知道有沒有比較我們不知道

這個同學可以自己讀一下這個Spec看一下這個就是我們在一般我們這個X86 PC，它的IO System大概一個簡單的架構圖，大概就是長這個樣子。我們這邊看到的，就是它的這個Processor，這個Processor，它透過一個front-side bus，所以Processor到Memory，它到Memory這中間，它會有一個Memory Controller Hub這個是什麼呢？這個就是我們所謂的北橋晶片。這邊寫說North Bridge北橋晶片，實它最主要的就是在銜接Processor還有Memory還有什麼呢？還有一些圖形加速卡之類的，所以大概這個

他們當初分出來的架構就是這邊速度當然是比較快的這個北橋晶片，它旁邊除了接Memory、接Processor，它這邊還透過PCI-Bus，它可以接到這個是什麼呢？它叫Io Controller Hub，就是我們所謂的南橋晶片。這個南橋晶片同學可以看到，它這邊的Transfer Rate相對的都是比這邊還要來得慢，這邊都很快，這邊的是屬於比較慢的這邊就是接到Storage Disk、接到Io Device、Keyboard Mouse或者是USB這邊是什麼PCI或者是Pairer ATI什麼之類的，所以這邊就是一般的Io Device大概就是透過這邊來接

這邊是北橋然後它透過一個PCI然後再接到這個是南橋然後再接到北橋，在北橋就是銜接Processor還有Memory就是這樣子所以我們一般現在看到的大概都是類似像這樣子以前跟同學提過說早期我們台灣有幾家很有名的IC Design的公司它不是只有台灣有名它是世界有名在以前是世界有名的就是

說類似像那個VIR類似像那個那個陽智還有類似像那個SYS系統這個同學可能現在還聽到的是VIR威勝還有那個SYS比較少聽到的大概是那個那個A理就是那個陽智大概比較少聽到他們以前都有做這個晶片組他們就是做這種chipset這個生意早晚會沒有的所以像系統他們現在已經開始停

產了晶片組 mereka已經停產了 他們不做了因為Intel他們後來最後都會把這個整進去整到他們的chip裡面去所以大概你光是要做這種chipset要賣的話大概以後生意大概都沒了前面我們這邊看到的這個現階段我們常用的這個PC它的這個IO的一個System接著我們就慢慢來看在PC就是說一般電腦裡面的IO它的一些觀念還有它的一些Structure首先我們來看這個IO到底如何來Management如何來Manage這些IOIO基本上當然是透過這個OS它來

Manage他來協調這個IO的這個Resource我們知道說在我們的很多Pro gram裡面他有可能會Share會Share這個共同的IO的Resource因為IO的Resource基本上就是固定就是那幾個那你Program很多可能大家都想要Share你要Share的話你這個OS你就必須要做好這個Protection還有這個Scheduling如果說你沒有做好這個Protection的話那整個系統可能很容

易就會crash掉所以這個partition非常的重要那你要efficiency的話你就要做好這個scheduling我們後面會提到說IO它大概是怎麼進行的基本上IO它可能是一個asynchronous的interrupt這邊指的這個asynchronous interrupt是指什麼呢它指的就是指說我們IO基本上它也是它就是一個interrupt我們前面提到過有人用的名詞不太一樣比如說你如果是

internal它叫exception外部它叫interrupt不管是interrupt exception它的機制是一樣的但是我們這邊為什麼強調說它是asynchronous基本上它跟instruction的execution它並不是同步的它跟instruction的execution是完全沒有關係我們的exception它跟instruction execution是有關係的怎麼說呢因為我們的exception是因為執行指令然後它發生了問題比如說它發生了page4它必須要給一個exception的handler比如說我們run program它出現了arithmetic overflow這個也是一個exception它可能要去處理那一類的事情所以

Exception它是因為執行指令而發生但是我們的IO它並不是說因為執行指令然後發生了什麼樣的問題結果它就有IO所以它跟它是Asynchronous我們後面會看你做IO的話基本上IO Programming非常Tedious 非常的繁瑣所以說你如果說OS沒有提供比較High Level的Extraction給這個programmer的話那你programmer全部都是那

種low level的IO operation那個大概會做得很辛苦所以management的部分大概是這樣子我們了解這個要管理這個IO我們當然就要知道說IO是什麼資訊首先我們先來看跟IO資訊有相關的第一個就是command第一個我們就說這個IO這個device它是由這個Io Controller這種H硬體來管理這個Io Device接到Io Device，它是透

過這個Controller所以你就要Transfer Data送到哪邊去或者是你要接收資料到你這個Io的這個Device就是說當然你要有一些Command來執行還有就是說做這個Synchronization跟Software做Synchronization這些command我們要搭配搭配什麼樣的硬體裡面就提到一個command register還有stata register還有一個data register我們要去做這些控制的話當然要有一些硬體的搭配第

一個就是要有存command的register Register，它存的command就告訴我們說這個device你應該要做什麼事情StatusRegister，它告訴我們說我們做了這個IO這件事情做完以後它到底是成功的還是失敗的它目前的狀況到底是什麼樣的一個情況如果失敗的話它到底發生了什麼樣的一個error所以這個是屬於StatusRegister另外一個DataRegister當然就是包含說

你要資料要in要out到底你要先存在什麼地方所以這個write你就是要transfer data到一個device然後讀的話，你轉 data就從一個device所以這個就是需要這三類的register來搭配我們才有辦法去用一個這種IO的command來做這個IO的operation。我們剛提到的這些Register我們要如何去能夠去Access這些Register這邊提到有兩種方法，一種是所謂的這個Memory Map IO另外一個就是叫IO Instruction。我們這邊看到的一個Memory Map IO顧名思義，我們其實就是把這個Register把它當作是Memory，我們把Register當作Memory Register

它的 address 就是其實就是一個 memory 的一個 space 的一個 address。但是，畢竟它這個雖然是一個 memory address，但是畢竟它是 IO register， 它不是真正的 memory。所以我們要透過這種 address decoder，它要去判斷 它去 distinguish說你這個是 IO register 或者是這個 memory。還有一個很重要的就是說它既然是Adress，那你是不是所有的人都可以用所有的Program所有的Process都

可以用這個Adress裡面的這個資料呢當然不行。如果是這樣子的話，因為你IO crash掉的話，你可能這個系統可能會出現很多異常的這個狀況，所以我們當然要做好這個保護，所以這個OS，它這邊就提到說它會用透過一些Translation這個Mechanism，然後去保護這個我們的這個IO Register，所以只有特定的Process，它才能夠去Access

到這個Adress，這個Adress其實就是指IO Register，所以這類的都是屬於那種Kernel的Process，它不是一般的Process，它都可以去使用Access到那個，那另外一類呢，當然就是提供特殊的指令IO的Instruction，所以這一類，它並沒有特殊的指令，它去做Access的時候，它也是這樣General Instruction，這一類的，它只要是要去Access你IO Register的話，它就是必須要透過特殊的IO Instruction很明顯，我們也要達到同樣的目的，我們就是要Protect，Protect說我們的IO Register不能夠隨意的去Access，所以這一類的

這個Instruction它也是只有kernel mode的時候它才能夠去使用這個IO instruction不是所有的一般的process想要code這個instruction，它馬上就可以去執行這個不行，它必須要switch mode到這個kernel才可以所以我們到目前為止我們知道，說你這個我們會有一些IO command，那IO command當然就是你必須要搭配我們剛剛提到那三類的register它才有辦法

去知道說要做什麼動作，它的狀態是怎麼樣，它的資料要擺到什麼地方去那些register。我们有前面提到两种access的方式，它真正在進行的時候我們有兩種機制可以進行I-HOLD operation第一種叫Polling，這個Polling它就是什麼呢？ 它就是定期、週期性的去Check它的這個IO Status Register，那它定期去Check這個IO Status Register做什麼用呢？它就是說，如果說這個Device它已經Ready了，那它又有這個IO Request，因為你IO Device如果是Busy的話，你即使有Request你也沒有辦法去Serve

去完成這個IO Operation，所以你一定要它是Ready，它只要是週期性的去Check的時候，這個Available它就開始做。如果沒有Available你就要等下一次它在週期性Check的時候Available它才能做或者是說，如果說它發生錯誤前一個IO Operation做一做它沒有Com plete它是錯掉了錯掉的話，它這週期性簡單來說，它有發生error那，它就必須要有適

當的action去回應這樣子的一個error的message，那很明顯，這個polling的方式，它的performance是比較差的，所以我們這邊說它大概就是那一種，就是low performance的real-time embedded的這個system，那這個有什麼優點呢，這個優點就是說，這樣子polling的話，它可以有這個predictable的一個timing，那為什麼它會有predictable的timing呢，因為它是週期性的去check的說，不需要做

IO那需不需要做repair或者是其他修正錯誤的這個action，它是週期性所以它知道說，它的IO的operation大概都是在哪個時間點會進行，所以它是有predictable的一個timing，那相對的，它是low hardware的一個cost，但是它就是waste CPU time，因為你CPU，你必須要一直週期性的去花時間，因為這個check是誰check呢，當然是CPU check，所以你要週期性的去check這些，它會浪費這個另外一個是interrupt，就是用interrupt的一個方式 interrupt的一個方式當然就是說

一個device它ready或者是有錯誤發生它需要一些operation的時候它就controller它會interrupt這個CPU這邊我們就提到的就是說這邊其實它要講的就是說這個interrupt其實它跟這個exception是一樣的它的機制是一樣的，但是它跟interrupt不一樣的地方在哪裡呢不同就我們剛剛提到的就是說exception它是執行指令然後指令執行到一半

它出了問題所以它有一個Event那Exception它就會去Call這個Handler然後就去看它是什麼樣的一個Event然後就有不同的Handler然後去處理這樣子的一個情況，但是Interrupt它並不是說因為指令執行到一半它是指令執行完然後要啟動下一個指令它等於是在下一個指令要開始執行之前它會去看有沒有這樣子的一個interrupt這樣子的一個IO request所以它並不是跟這個指令就是說並不是跟指令是一個說執行這個指令的時候

然後跟它同步，它並不是這樣子的一個情況所以它是指令執行完要啟動下一個指令的時候看看有沒有這個request有interrupt request如果有的話它就會去做這個通常你的inter rupt通常你必須要包含什麼？包含說到底是誰在request這個interrupt，你不能說它偵測到有interrupt結果是誰都沒有人舉手，所以它也不知道要到底要做什麼樣的一個IO operation所以你這interrupt你除了要讓CPU知道你要知道說是誰到底是誰另外它也要；就是說，

如果這個interrupt，它有所謂的Priority；我們不同的這個IO device，它有不同的這個優先度；這個時候，你也必須要有這個Priority，那Priority的話它才能夠根據說它先Serve那個Priority優先權比較高的這種IO Operation，那種Priority比較低的Request它就會等到後面去；可是這種IO的Priority，一般而言，我們跟我們比如說Exception，那一類的這種Priority相比的話應該都是比較低的；因為這種IO是也不是說可有可無，是因為我們CPU正常的運作，

它這是最重要最重要一定要維持住的所以internal的這種exception它的priority會比較高它要做這個IO operation當然IO幾乎就是在做這個data transfer，就是in-out的這個data transfer，這個data transfer就是in-out的這個data transfer這個data transfer我們這邊有看到的就是說你可以pull in interrupt driven的這個IO它就是透過CPU，就是我們前面提到的Polling Interrupt Driven 的Io都是由CPU來Transfer Data 在Memory跟Io Data Register之間，所以它就是需要CPU來介入。 CPU介入

那你不管是用Polling或者是Interrupt的一個機制反正它只要要開始啟動這個Data Transfer，那你CPU大概就是要忙著開始去送資料就是接收資料然後傳資料出去。所以這個對High Speed而言，就是說CPU其實它等於就它沒有辦法做其他事情，它就要花時間在做這些事情那另外一種叫DMA是Direct Memory Access，Direct Memory Access DMA，這個同學

可能都聽過了。基本上CPU並不需要花時間在做Data Transfer，OS先提供一個Starting Address，就是說我們現在要送的這一筆資料，比如說我們要把資料送到IoDevice，我們先送了一個Starting Address就是在Memory的某個地方，IO controller他就會開始當然你要開始說，你可以開始送了，IO controller他知道了我要送多少size。的資料我的starting address在什麼地方

我可以開始送IO controller他就開始去送不管是送進去或者是從memory讀出來讀到他的IO device他就開始去做這個時候CPU他根本就不用管他所以他在data transfer的period他完全由IO controller來掌控來掌控它就開始去做那IO controller做完以後呢它就會interrupt interrupt CPU那interrupt呢它就會告訴它說我做完了或者是我有error發生不管是你做完或者是有error發生那它一定會通知就會有一個這個interrupt那CPU它

之後它發現說它有一個interrupt它就會看看到底是complete還有下一個request然後就再送下一個request如果是error它就看你error要怎麼去restore或者是它有什麼handler要處理的所以這個就是DMADMA當然聽起來很明顯這個是優於這一個可是問題是當然優於這樣子的一個機制當然你的Io controller當然就要Smart你要聰明你要能

夠多做一些事情所以像IoController如果說你必須要有比較複雜就是比較多的功能有人就做做做做完以後，實它就變成一個所謂的IoProcessor這個IoProcessor既然它叫IoProcessor，它自然而然就會有定義一些它的這個Processor可以執行Io的instruction，那這個Io instruction你一些instruction組合起來就會變成什麼呢？就會變成所謂的Io的program就是你要執

行這個Io operation，它就會有所謂的Io program來完成這些事情。那你Io program要存哪裡呢？那當然有一些它就是直接存在你的Io processor裡面，那你的Processor好像功能就會越來越強壯有一些，它是存在這個Memory當你要執行的時候，它再從Memory再把你的IoProgram把它load到你的IoProcessor裡面去來執行。所以完全dependent說你的這個系統，你的定位 定位是什麼呢？定位就是你要快還是你要便宜這種東西當然都是一種trade-off我們再介紹

我們再介紹個一頁兩頁好了這個DMA接著我們來看就是說假設我們是用這個DMA就是說CPU它就做它的事情，DMA它就開始做Data Transfer這個會發生什麼事情呢？這會發生說因為我們知道說DMA它的資料，它不管是讀或者是寫，它的Source都是從Memory那邊來CPU呢，它也沒有閒著它不是Hot在那邊等Hot在那邊等

的話不是Hot的，它就忙著做這些事情那大概不會有什麼問題可是現在是DMA它在Read Write Memory裡面的資料，那CPU呢，它也去做它的Run它的程式呢，它自然而然就會Access它的Cache，那Cache呢，它也是從Memory那邊過來的所以這個又牽涉到一個你的Data你的data到底是不是有一致性什麼一致性呢所以這邊就提到了兩個情況，第一個，

他說DMA write一個block到這個memory裡面去可是，那個block它其實CPU在run的時候，它已經把那個block搬到cache裡面，它搬到cache裡面，所以這表示什麼呢，表示說我CPU裡面之前從這個Memory讀到Cache裡面的這個Block它是什麼， 它是舊的資料，因為這個Block在Memory裡面其實已經被DMA給update了，但是CPU它一直去Cache讀得很高興，它一直去讀Cache裡面的那個Block，Memory裡面已經被改過的那個Block是最新的，所以這樣子就不對了， 這個是錯的，

另外一種說假設我們的Cache是WriteBack的Cache它是WriteBack的機制WriteBack的這個CacheCPU它已經update了這個block在Cache裡面的這個block我們知道說WriteBack就是表示說這個block被搬出Cache的時候它才會Write回Memory這個block目前它是在Cache裡面一直被CPUWrite所以它沒有被踢出 cache 外面所以它 memory 裡面的資料是 jolt那這時候 DMA 它如果去 read 一個 block 會怎麼樣它會讀到 jolt它會讀到 memory

裡面那一筆 jolt 的資料最新的資料在哪裡 在 cache因為它是 write back 的一個 cache那這樣子都會發生我們剛剛提到兩邊資料的一致性就會被就會被毀掉所以我們必須要Ensure我們Cache的Coherence這邊他提到說就是說我們要Flush Block from Cache什麼時候要Flush Block from Cache呢Flush的意思當然就是你就把這個Cache裡面整個Block的資料全部都寫回這個Memory即使它是WriteBack而且這個Block還在Cache裡面你還是要把它寫回去

這個時候他寫一句並不是因為他被踢出 cache 的外面他是為什麼呢他是因為 D MA 有一個 request,他要準備要去 access 他要去 useuse use 這個 memory 裡面的這個 block所以你必須要趕快。你只要偵測說這個 DMA, 他要 access 的 block 是 dirty, 那你就把它 flush 出去,flush 到 memory這樣子就保證說他要讀的時候他會讀到最新的,讀到 cache 裡面最新的資料。另外一個呢,他在講說就是你 memory你 IO 要寫的這個 memory location必須要怎麼樣?

必須是一個 non cacheable 的 memory location意思就是說我 IO operation data transfer memory 的這一塊位置呢,它是不會被搬到 cache 裡面去。那它如果不會被搬到 cache 裡面去,它會不會有 coherence的問題就不會它OS read write全部都是到 Memory這邊來。那你就是同步所以你 DMA write它這邊read最新的所以就是說你可以指定就是這樣子的一個 location,它是 non-catchable所以可以解決這樣子的一個問題。我们今天先介紹到這裡因為後面這邊可能要花一點時間來介紹。同学记得我們同学回去赶快复习一下我們下禮拜一教的内容禮拜四就要考了所以先把这篇读完礼拜一上完课可以马上再复习礼拜一的进度.