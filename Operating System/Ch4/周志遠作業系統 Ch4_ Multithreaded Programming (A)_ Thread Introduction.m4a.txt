undefined
好，那我們就進入這個第四章，因為比較晚交啦，所以期中考不會考期末考才會考到那，這個章其實際上蠻短的，但雖然是說裡面最短的，然後大概也是最容易讀的，那更重要的是，是大概大家最容易用到的或許已經接觸過了，所以我先問一下，有多少人寫過Thread Programming的，可以舉手嗎？有一些嘛，我看到應該有不少，但也不是全部啦，所以就知道Thread Programming非常非常基本，尤其在現在這個世代，因為我們的電腦都是多核心嘛，就是

然後你要處理的問題都是越來越複雜，計算量越來越大，所以大家一定都會用這種平行的方式，那平行裡面呢，最容易取得的這種平行的方式就是這個Thread的方式，那以前我們OS都有一個作業專門請大家寫一個簡單的Thread Programming的作業，不過最近我們因為增加NACHOS的Loading所以就沒辦法只好讓大家就是透過其他的課程或者自己

在自己做一些練習，但是我們會簡單介紹Thread Programming，就是有一個叫Pthread的Thread Library，所以其實它不會很難使用，所以其實自己稍微找時間有時間的時候做一些練習會比較好至少有這個經驗是非常非常基本的一個Programming的技巧，在現在這個時候，好，那我們這個就來介紹這個Thread Programming這邊第一個會強調在

這個formal的define一下什麼是一個thread它跟process有什麼差別這基本上是101各位去找工作等等大概都會問這種問題答不出來那就完全不會被考慮了我想那再來你再看進去一點的話其實我們這個章節要點出來的是大家就可能不會意識到的是thread這個東西它有分user level跟kernel level的所

以我們知道OS的設計其實有分User跟Kernel對不對所以Thread這件事情其實是分在兩個Layer是分開來不同的東西那它們都叫Thread所以我們會介紹到底是什麼是User Thread什麼是Kernel Thread然後兩者的關係在電腦運作的時候是怎麼去Manage它的那之後我們會介紹我們剛才說的就是一個Thread Library讓大家稍微知道

有哪些API可以code去create thread然後去使用這個thread programming那最後會提到一些thread上面會產生一些issue因為畢竟它不是process嘛所以有一些additional的事情在使用上可能要特別去留意的好 所以什麼是threadthread呢其實我們又把它稱之為所謂的 lineway process所以從這點就可以看出來Thread跟Process的界線其實是滿模糊的有時候大家也不是說它是不同的東西就只是所謂的Live weight而已所以也就是說

一個完整的Process我們知道是我們之前教過的是很清楚的嘛對不對但是我們會有Thread在系統裡會有所謂的Thread產生是把Process的一些東西把它拿掉或者說是跟其他的Thread去做共用那這種樣子的Process我們就稱為Thread它就是一個來位拿掉一些東西雖然它是其中的Process可是你看說的電腦系統其實US Thread是Process的有點像它的紙機盒而已所以其實Thread才是真的在使用我們CPU Core計算這個Core的時候

的基本單位因為Process其實我們可以把它Break down成很多Thread所以最後真的執行在我們CPU Core上的是Thread而不是Process一個Process的哪一個Threader在使用這個CPU Core所以其實它才是最基本去Utilize我們CPU的這個Entity好那什麼叫LiveWay勒所以從第一個很重要的觀點就是它的Memory Content所以我們在講過什麼是Process重點不是它的Code而是它的Memory Content對不對所以有它的Code SegmentData Segment等等我們之前介紹過了

那Thread的Definition很明顯的很明確的就是根據這些Memory Content所謂的Thread呢就是指說它的這個Code SectionData Section跟Resource的這個Section這些Memory的Content是Shared的所以如果是同一個Process裡面它有不同的Threads的話它的基本定義就是這三個Minimal在大部分的OS現代的OS裡面設計的定義就是這三個Memory Content是Shared的所以你們也學過了segmentation跟paging

更detail一點的嘛所以其實你就知道這些就是不同的segment對不對然後在你的segmentation table都是一個一個entry所以當你create一個thread的時候就是把這些segment做sharing就可以了對不對那你就可以create出一個thread然後是同一個process下不同的thread就可以跑出來所以是他們的關聯細節是很緊密的那因為有sharing嘛所以其實他

並不是真的，是他自己來位就可以省掉那些部分所以看見就像右邊這個樣子對不對所以這個是一個single thread的process。他就什麼memory content segment都有可是，如果你是在這個process裡面create出來的thread的話，那他們同一個process下他的code，his data segment還有這個resource這個segment就會去做sharing但是它畢竟可以獨立的去做執行啊所以就

代表它一定有很多而且是很重要的部分尤其是執行上的部分，它是不share的對不對必須要自己擁有的那主要咧就是第一個，就是它實有它自己的Thread Control Block所以我們知道Process有Process Control Block那Thread當然就叫做名字而已就叫Thread Control Block那麼也提到像NACHOS你去Trace Code你就不會看見Process Control Block你只看見Thread因為Process跟

Thread essentially是同樣的東西嘛所以就同樣的Data Strat同樣的這個就可以Manage只是嚴格來講比較複雜的OS當然有所區隔然後Thread跟Pro cess Control Block的資訊有可能會設計的不同也有可能會相同像我們最後就會提到在Linux這種很常用的對不對我們說Open Source這些開發出來它比較Simple比較好Maintain它根本就沒有Process就像Nachos一樣全部都是所謂的Thread

或者名字無所謂就是其中一個名字啦但就是同樣的東西但Windows我們沒辦法教到但各位有興趣可以去看textbook它有很多case study裡面就有介紹到Windows就複雜它的thread跟process control blah的定義跟裡面內容就有所差異所以當然這設計上是可以相同也可以是不同的那所以在這block裡面我們知道它就是在manage一個執行的entity嘛所以

像他的ID所以每個Thread是有他自己獨立的ID的然後他的Program Counter是獨立的所以你可以每一個Thread意思就是說每一個Thread他在執行的位置可以不一樣這是非常重要的一個差異或許你沒有感受但是其實在平行的這些程式在執行的時候他們是要同時間要執行相同的Structuring還是不同是兩種完全不同的Model那你可以看見Thread這邊

它自己有自己的Program Counter就代表每個Thread可以完全獨立Independent的執行不同的Instruction做不同的事情，那以上我們後面看見的不同Thread基本上就是在Run不同的Function Code，所以當然內容可以相同也可以完全不同那因為獨立執行嘛所以當然Register也會是獨立的對不對，所以Process Control Block裡面這些很重要的資訊都是獨立的另外一個勒

我們看到data或者說我們現在還沒列出來，但是heap就是dynamic allocated也是sharing data包括了就是global variable跟dynamic allocated variable是shared但是有一個variable不shared就是你的stack所以大家應該知道stack裡面存的就是local variable對不对，所以意思就是每一個thread執行function裡面create的variable雖然名字你在你的code裡面看見名字相同，但他們其實是指到不同的 memory address，所以是完全獨立的，所以就讓大家知道一個 function code return

東西就沒了嘛是 temporary 的，所以 thread 就是每一個人其實就是一個自己獨立的 stack所以這樣應該會很清楚了thread 跟 process 到底差在哪尤其在 programming 上其實很容易辨別就是你是 local variable因為在 stack 所以是獨立的你的 global variable 或者說你去MATLOG出來Dynamic的Pointer的Memory的Allocation你在Thread之間是可以Share的

不會有這個Segmentation for的問題因為本來你的Data Segment或是Data的Section就全部是Share的所以當然是有效的所以Thread跟Process這個差異性非常大非常重要那大家應該是能夠很輕易的去辨別他們才對雖然說在Implementation跟Manage這兩個entity的時候OS它可能是有些混淆的但對programmer而言是應該

是很清楚的是完全不同的東西好那為什麼thread program這麼重要這樣很多同學就用到了就代表它其實有很多好處甚至有很多事情你必須透過Multithreading這樣子的programming才能夠完成那常見到的其實大家有意識無意識的可能就會發現的第一個web browser一天到晚大家在上網嘛對不對，那你去開一個網頁

不知道各位有沒有發現，就是你開網頁裡面的內容，它是慢慢的出現然後文字可能很快就出現然後圖片又過一陣子才爆出來對不對，然後就是會有先後順序為什麼咧就是因為我們的ブラウザDownload資料的時候，它就是用Multithread，每一個Object它是用不同Thread獨立去Download的，然後最後再秀在你的頁面而已對不對，所以其實ブラウザ通常都是一個Multithread的一個Application，就是可以同時

去Download這些不同的資料那Web Server，我們其實之前就介紹過了，在講Socket Programming的時候大家還記得的話，就有提到一個Web Server當作一個例子，它就是用Multi-threading對不對，因為一個Server它必須要接到很多的Request，然後這些Server通常每個Request的處理都很短很小對不对，就是Download幾個文字幾個Byte就結束，那所以說我們的server希望不

斷的可以接受到新的這些request的話的方式就是他有一個main thread一直在等對不对，那但是一接到一connect之後，他會create一個thread出來，slave的thread去hand le這個request然後讓main thread可以繼續的等下一個request所以這樣大家才可以不斷的可以access到一個web server因為如果你的access的時間的delay很久就是大家常看到的denial service嘛

你那個server意思就是你連不進去那如果你沒有用Multithreader Programming的方式的話通常WebServer就常會出現這個狀況就是連不進去只是因為單一一個使用者一個request就卡住所有的使用者所以WebServer全部都是Thread Programming第三個其實跟WebServer非常非常像大家就學過了所以其實溝通上我們說過除了你可以用Socket Programming你也可以用Remote Procedure Code

其實是類似的概念對不對所以其他機制也是類似的所以像RPC它是有一個server的所以才能讓很多人同時remote去call這個server上的一個function call那一樣的道理它也當然是一個Multithread的方式所以就像我們之前看到client連進來之後其實這些request會去用一個新的thread去接然後main thread這個server的thread其實它是會一直在那邊loop

去等待下一個Request所以讓使用者至少可以很快的做Connection那你的處理或許會很花時間，但Connection應該要馬上可以接起來才對好。那剛剛那是例子，所以如果你看它的作用的話，基本上最主要的就是這邊列的幾項，那第一個就是Responsiveness也就是反應所以你就去想server的角度就是這個意思對不對。所以，我今天

server可以非常快的去response一個connection然後讓他連進來對不对，不會因為某些request把整個server給卡住delay他的response time。所以，如果你需要很及時的反應的方式大家都是用一堆thread然後讓他可以就是有responceness或者是玩Gain啊。 我相信有些人寫ThreadProgram可能是為了要implement一些GainOnline Gain或是這些的Gain就是Interaction嘛 對不对。所以，你會看見

簡單的採取這個比如說是這個青蛙過河之類的大家可能知道嘛 對不对就會用不同的Thread去Control一個Thread去Control那個中間的車子的流量，一個是這個接受使用者Keyboard的Input你這樣用很多Thread你就很容易可以把這整個程式兜出來然後他們之間你可以看見他們是獨立的但是有必要的時候又可

以同步或是溝通像青蛙被撞到要死掉啊 對不對所以你可以要溝通的部分那重點是你要很快可以反應都是靠很多Thread所以才不會互相的去卡到對方第二個呢Resource的Sharing 對不對所以就有點像剛剛的例子如果你再接下去就是說我們說撞到的時候那你要怎麼溝通如果是不同Process我

們知道為了Protection不同Process的Memory不Share所以你要溝通其實是很複雜你要透過OS會很慢不是不行但會很慢對不對那為了要Protect你的程式嘛但是像我們在寫一個剛才說的青蛙過河的遊戲我要很快的這個Thread跟那個Thread要知道我們倆撞在一起了對不對你就可以透過我們剛剛Share的Memory的部分就是像Global Variable

所以本來By default你就是可以透過這塊Memory做溝通所以你就很容易去Share你需要的Information或者是Data這些資訊所以By default你就可以用那個機制來做Sharing第三個就是我們剛才提到的為什麼你現在不會Thread Program ming會是Concealer這樣落伍的，或者說就會被淘汰掉，因為所有的Hardware都是Maticore就是現在所有

的Computer System都是所謂的Multiprocessor對不對，多核心甚至於多CPU甚至於是到多台電腦，如果你跑到到Cloud上面等等，這全部都是多個CPU的，那所以說最容易我們剛才說最容易可以去Utilize這些Resource然後可以在跑在這樣的Device上，你可以達到最好的效能的話，你一定要靠Thread，所以你不用Thread基本上就浪費掉這些資源對不對，好最後一個那提到這個利用這些資源，你會說我可以用Thread，那我也可以用Process啊對不對，但是Process跟Thread的最大差別是什麼，

就是像我們剛剛講溝通就是一個例子，就是他們做事情的時候，Process都是比較cost比較高的，因為他凡事都要透過OS然後咧他的這個memory content去create一個process的時間會遠比create一個thread的時間要長，因為它的memory content比較多嘛對不对，那它也需要比較多的management的data structure的資訊等等，所以這一切一切都是花時間，所以如果今天你可以用Thread，那麼就更好一些。 read做到的話，你就不會用process那，這樣的話你就可以

節省到很多。你執行起來你程式你會發現會比較快或是系統的loading可以比較輕。所以就是所謂的economic就是這個意思。那你可以看我們這邊有些數據明顯的去證明這件事情，所以你可以看到當然不同的作業系統啊不同的電腦設計等等會影響process跟thread的差異嘛對不對。但是你可以看到process這邊呢，我們學過了。如果你要去create就是call這個fork對不對，那如果你要去create一個thread呢我們之後會教就叫pthread create這個library這個API

那你可以看見大家就做過實驗雖然比較早的現在應該也是差不多你可以看見它的差別Speed up就是它快了多少倍從20幾倍到50倍都有所以你就知道這個時間上是有很大的差異。那很多事情你是要Responsiveness就是幾個mini second的這種要求或是幾個0。 5個秒那，這個差距就會很大了或者說你的應用你要create一堆的thread或一堆的process

那這個差距就會出來了那第二點呢就是我們剛才說的溝通的部分所以這邊這個MPI指的是就是Message Passing我們之前覺得過了嘛你可以用Shared Memory或是Message Passing那Message Passing呢就是用在Process之間的方式所以那也是一個Library所以你去看它用這個Message Passing裡面的這種Send跟Receive Memory Copy的方式溝通這個是它每秒鐘可以傳

輸的資料量這個是Shear Memory所以就是Thread你直接寫到Global Variable然後再讀出來的速度一樣你可以看見就差到兩倍甚至於到15倍都是在同一台電腦所以都還沒有考慮到網路這件事情就在一台電腦裡面它可以差到很大的距離所以這為什麼如果可以用Thread大家會用Thread除非你有其他考量像是這兩個溝通的人根本是不同的系統或是不同的application對不對

所以你當然不可能把他們直接混在一起這時候你當然就會有必要用process但是如果你只是要把一個自己的工作把它做平行加速對不對等等剛剛的應用的話其實thread當然是可以的因為他們本來就是在解同一個問題那你就會用thread programming好那所以知道之後呢我們這個Thread Programming其實你又可以從Software

跟Power的角度來看所以软件當然就是所謂的Multithreaded Programming就是用我們周圍講的Pthread這樣的一個Library或是Java Thread就是Programming的部分所以我們知道這就是讓使用者就是可以比較有效率然後比較方便可以去concurrent的執行一些指令所以是所謂的Programming的部分那Hardware這邊也就是我們剛才提到的所以是相輔相成Hardware這邊就是我們知道的現在都是Multi-Core System就是多核心多CPU這樣子

的一個系統所以說在這樣的系統下你就會需要Thread Programming那因為有Thread Programming所以Hardware的Vendor也才會希望不斷的去增加擴速讓你一台電腦可以更加的Powerful尤其是在現在這個從五年前開始大家就知道了就是所謂的Dice of CPU Scaling就是在二十年前嘛我們的電腦的演進一直是靠Frequency對不對我們就是Gigahertz就CPU的時脈一直增加增加然後讓它更Powerful可是到現在

這製程技術就已經到一個瓶頸是沒有辦法再增加下去的大家應該也有發現我那年代我們大家買機器大家不問你有幾核心大家只問你時脈多少3. 5 2. 3 2. 3好落伍大家就不要現在大家去買2. 5 3. 5然後3.5 2。 3你笑他，他說我有8個，你幾個，我才一個，那你就那個是落伍的對不對，所以現在大家其實靠的就是這樣去增加核心數來讓單一台電腦的計算可以更powerful，那所以你有這樣的

系統，你卻不會Swap Programming或是你的程式沒有Swap Programming的功能，那基本上怎麼跑得贏人家對不對，所以就剛才說其實這兩邊是相輔相成的，那對OS而言呢，我們接下來會講的這部分就在於說你怎麼樣把Thread跟這個Core去做Binding的這件事情對不對，這個就是OS要去Manage的，甚至於應該嚴格來講是OS的部分功能也已經被拆到了CPU本身裡面去了，就像大家應該有聽過的Intel的CPU的特點是什麼呢，有Hyper-Threading、Hyper-Threading，就是它一個Core

可以讓兩個Thread同時跑，所以這個Scheduling這件事情其實會更複雜比我們之前講到的Scheduling再更複雜一些，其實當然不只是OS在SchedulingCPU內部，它也在Scheduling或甚至應該說CPU裡面的單一一個Core它也在做Hardware Level的Scheduling，那Eventually當然還是一樣就是各位執行的這些Thread會Bind的到最底層最底層的那個Thread的其中一個，所以它才

可以進行執行的動作，但是其實你要意識到中間有好幾個Layer就像Memory的這個Address一樣，其實不是直接就是使用Physical Address，你有Virtual Address，然後你可以做轉換可以做Sharing，那這個執行序這邊其實也是同樣的道理好，那Thread Programming當然或是說Parallel Programming，因為Thread Programming就是Parallel Programming裡面的其中之一，另外一個當然就是我們剛才提到

的Message Passing的Programming，因為只有兩種溝通方式，所以就是One or the other，但他們在Programming上的Concern其實是相同的，只是你的技巧不同而已方式不同，但要解決的問題遇到的問題是相同的，那我們這堂課當然是作業系統所以不會去講那些也不會讓大家去寫平行的程式，但是還是要知道最基本的就是比如Programming跟一般的Programming的差別到底在哪或者說Thread Program ming這邊對不對幾點第一個

Dividing Activities也就是說你用Thread就是把原來一件事情把它拆成很多人一起做所以你要很多人都有事做的條件就是你要把事情先拆開來嘛對不對所以大家寫作業要先分配你要寫report我要寫code對不對你去做survey然後我做實驗所以拿到一個程式你第一個要想去還把它拆成不同的activity讓每一個thread可

以知道他要做的事情是什麼那這就是第一個並不是所有的問題都可以這樣拆而且怎麼拆影響就很大對不對我想大家都知道teamwork的重要性所以拆得不好就有人會不滿意或者說時間就會被delay掉會卡在某一個人身上對不對第二件事情計算勒電腦其實做的事情很單純它就是拿data出來然後做計算就這樣子

而已說穿了就是compute on data而已對不對一直在manipulate這個data所以大部分的這些程式其實都是在處理data那所以當然你的計算要猜data也要猜啊這兩個是不一樣的舉個例子來講就是大家show algorithm現在一定在學各種sorting algorithm對不對所以你會拿到一個array那今天如果你要平行的去sorting大家都學過quick sort了應

該吧那這些sorting algorithm其實都是可以被拆成平行的sorting algorithm但是它要能夠運作的話呢第一個你的data要能夠切同時也要除了algorithm要切data也要切所以我給你10個element你有5個thread的話那你要平分嗎每人各兩個還是說你不要平分always平分也不是一定是最好的事情因為有時候每一個data它要的計算量是不同的這沒有說一定怎麼樣

通常當然是你說平分啦但這也是個decision到底要怎麼切有時候你的data是很複雜的講的複雜一點像graph大家有想過一個graph的data可能大家有學過shortest path algorithm了對不對給你一個 graph 算是 data structure它是一個 graph 你要怎麼 partition你要 vertex 數一樣呢還是 edge 數一樣你要怎麼切不是這麼單純的第三個接下來的三個才是真的 parallel programming或者說 thread programming

難的地方第一個是這個第三點可以看到就是你切了之後會產生一個會產生附帶的一個可能會造成問題是有 data dependency也就是說data你當然都可以說十個element各兩個就好可是你的計算有可能會involve多個data所以這些data的之間它可能會有dependency就是兩個人同時要去修改那個data或者說第二個人

必須要等到第一個人修改完他才能夠做這就叫dependency所以這邊才是開始複雜的地方所以有dependency的時候你就很難去切割這個data或者說切割完之後你的計算不一定會正確再來n
balancelow balancing也就是就像teamwork一樣對不對真的這個程式結束的取決於最後結束的那一件事情所以說你有很多人一起來做這件事情可是如果你的work load你的執行時間沒有平均的話等於是沒有平行因為你會bump得擺最慢的那一個人所以怎麼樣

balance他的執行時間是最重要的事情所以怎麼切對不對又沒有dependency然後要能切切完之後計算的結果要能夠相同這樣你才能夠讓它的執行效率會達到比較高所以怎麼balance這又是一個很大的issue而且很多執行時間是你執行了之後你才發現的不是說我可以事先預測這種事情所以就不容易去達到一個最好的執行效果最後一個完全無解的部分Testing跟Debugging

所以我相信大家現在寫程式嘛一天到晚也在做Testing跟Debugging bugging對不對，在 Trace Code那或許你就學到一些好的Tool事實上是很必要的， juste 会發現其實寫Program很重要的是你會Debugging跟Testing，這也是我們OS Nachos希望大家多練習的部分Tracing然後你會Debug，那你都知道有一些像GDB啊或是一些對GUI介面的這些Debugger滿好用的，你就Watch然後就隨時可以Sustain，可以 Tracing各種功能，

但各位可能沒有發現那些東西，都只存在Sequential Code，就是單個Thread或是單個Process而已，但是當你的執行是跨電腦或是跨Core的時候，其實是非常難去同時Trace所有的資訊，因為會花很多的時間，就算有個Debugger，他花了很大的精力把所有的資訊幫你蒐集過來人的大腦基本上也很難去理解它，因為它是所有是同時發生的，

而且它執行的時間點會有關係，所以你當不出來每個程式，你知道它做的事情都step by step跟你說的一模一樣，但是一個先做一個後做的結果就是不一樣，所以你要去從這些去做debugging然後知道到底錯在哪會是一件非常複雜的事情，那像我們考完期中考之後回來會介紹的這個synchronization的章節為什麼會產生就是在做

Thread Programming 的時候Shared Memory 的時候會產生的問題那就發現要很多的機制才能夠確保執行的正確性所以事實上 Parallel 的 Debugger 是很少的那有的話通常它的幫助也還是滿有限的因為人其實還是還滿難同時去思考不要說十個真的 Parallel Programming 可能是一萬個 Process一萬個 Thread 在跑那人基本上是很難去做任何判斷的好所以就只到這邊大家知道Thread Programming或Parallel Programming跟一般Sequential就是單一一個Process的差別.