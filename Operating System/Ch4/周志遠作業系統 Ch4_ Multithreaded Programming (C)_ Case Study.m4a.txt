undefined
後半段我們講比較說這個Thread正在使用上的一些特性尤其是在User Thread這邊我們說是一個Thread Library就是Programming所以我們會簡單的介紹一下Pthread也就是如果你是在Linux上你用C、C++這些語言的話你會使用的Thread library那Java不用講你們有用過Java就知道其實它可能會更容易使用它有這個Thread的這個class那OS的部分我們主要是講會是Linux它是怎麼處理Thread的至於Windows它比較複雜那我們就不會去講它你就如果有興趣的同學就可以看一下課本它會提到

這個Windows這樣的一個比較複雜的OS的話它是怎麼樣子用不同的Data Structure管理Thread跟Process那Linux的話其實是每做區隔就把Process當作Thread來管理就好了所以我們說Process跟Thread的關係Programmer要有非常明確的區隔對不對是完全不一樣Programming的Model或者是這個物件但是OS它可以把它變成相同的東西來管理因為只要他

們基本上就是執行序碼然後需要CPU的Core來執行它的Instruction所以其實可以用相同的概念一樣的Data Structure Mechanism去管理Thread跟Process好那講到這個Thread的Programming第一個就是大家要知道我們說其實在做這個Thread Programming它其實就是一種平行程式的程式語言那平行程式就會分成最主要就是怎麼溝通嘛所以我們一直在

強調在電腦系統裡面的溝通其實可以很簡單的透過Memory的方式把它區分成所謂的Shared Memory的Programming跟Message Passing的Programming那當然 Thread就是屬於 Shared Memory意思就是說你透過一個大家都可以Access到的一個Shared Memory的Space裡面的這些Variable去對裡面的Read跟Write的方式來做溝通那Thread Programming當然就是屬於Shared Memory Programming所以你可以看到它的

基本的架構就像這邊一樣你就是把它給看起來 concept來講就是你有一塊Memory的空間大家都是讀得到的所有的Thread都讀得到但同時每一個Thread也有它自己Local的或者說Private的Memory的空間也就是我們一開始就講過同一個Process裡面它產生出來所有的Thread它的Global Memory就是shared,對不對，它的data它的data

segment它的heap是shared的，但是呢它的private的部分則就是local variable就是function在stack裡面的variable這個是每一個thread有它自己的memory的空間所以是別人是不能去取用的就用這樣的方式透過這個shared memory這些variable通常用global的variable或是pointer你dynamically locate variable的值就讀取來做溝通的動作所以就像剛才同學有提到的啦它就是會通常比

較快跟Message Passing這種來比的話因為你不用做Memory的Copy那這是它的一個特色那它的缺點呢就是我們之後會介紹到有一個章節特別在講的Synchronization還有Data的這個會產生Deadlock的狀況因為所有人可以隨時的去對同樣的Memory Content去Write那這就可能大家會有覆蓋的問題執行順序會造成結果不同的問題那所以

這是非常麻煩去解決的所以有時候呢為了解決這些問題確保你程式的運作是正確的符合programmer他的邏輯的反而會造成他花的時間可能比這邊得到的benefit還多所以到底哪一個真的會比較快當然也是看情形那通常當然還是會比較好一些畢竟不用做Memory的Copy那像這種ShareMemory的Programming的方式其實有很多種那大致上大家通常的用法第一種就是我們這個會講的KeyThread就是用Thread的概念去做這種Memory Sharing的Programming

第二種方式你其實也可以用process對不對所以沒有人說這一定要thread就以share memory概念而言我也可以是process跟process之間我們也可以透過OS跟大家講說我們哪一些segment對不對所以我們知道了其實OS管理memory是靠segment的概念所以我們可以在runtime去create一些segment然後跟OS講說這個segment的memory是share between processes的那這樣子我也可以做share memory programming

但是當然Thread會比較快跟Process比因為Process是比較heavy的一個執行序所以很多東西你就要透過OS才能夠做share memory aringThread它默认你就可以share你的Global Variable第三種其實是最方便的那也是其實對於Porting的角度比較多人會去使用的其實透過Compiler這種方式，但我們這堂課不會講，但基本上就是有一些這種Library這些Shared

Memory的Library，那你只需要在你的程式碼裡面去Indicate加上一些Compiler的Directive就是告訴Compiler這一塊部分的Code要做這個平行化的部分把它變成Convert成Thread的方式，Compiler就會幫你去做這件事情，那當然你平行化的這一段程式碼當然不可能是任何程式嘛，一定是很有規律的嘛，所以 Compiler可以認得出來知道怎麼幫你解決的簡單講一個例子比如說for loop好了對不對，

所以我們知道很多時候我們寫程式就是在寫一個for loop然後要處理一個很大的array很花時間對不对，那你就可以告訴Compiler說我就要把一個for loop把它平行每一個iteration呢，你就幫我create一個thread然後去同時平行的去處理這每一個iteration裡面的instruction，那這樣子 Compiler就可以幫你。把它Convert成一個Multithreader Program所以第三種是這種用Compiler的方式那這樣最省Programmer的effort但是當然並不是所有的Code都能夠叫Compiler做通常就會有限制的一些Pattern存在才做得到好那我們

這堂課當然主要是Thread所以Thread這邊咧最主要的兩種方式在Linux的平台或者應該說Proxy的平台我們很早的在第一個introduction的時候可能就有提到過了對不對就是我們有API跟system code的概念那programmer呢都喜歡就是有這個portability意思就是說我今天在某一個平台上面某一個作業系統上面寫的程式碼我只需要recompile但我不需要remodify我的code

就可以在另外一台電腦上去執行那怎麼做到這個Portability呢為什麼我的Code可以不要重寫呢就是我們提過的所有的OS它的上面一層還有一層API Layer Interface對不對所以說不同的作業系統我可以寫自己的自己的複雜的Kernel的這些Module然後甚至於定義自己的System Code但是我們在API這一層大家可以同意就是一定要

Support完全相同的Interface，那下面怎麼用System Code去實現它是自己Implementation的事情所以當早期在開發這些電腦的這些作業系統的時候, Windows當然是一個大眾，所以它當然自己就有它自己的API。但是,Windows之外，尤其是那些Open Source的Community，像Linux或者早期也其實像是UNIX，那這些作業系統，他們的Developer就做下來就同意了訂了一個API叫做Poxy。那它的簡寫，你可以

看它是這個Portable Operating System Interface的簡寫。意思就是說所有的這些作業系統，他們的API完全相同的，所以OS不同，但是它的API完全相同都要符合這個Standard。所以，它是一個Standard。所以你只要按照這個standard去寫你的code，基本上就可以run在很多的系統上面，就像Mac其實它也符合這個，所以Mac、Linux，你會發現你的程式碼可以

recompile就會可以run可是報到Windows上，那就不一樣。你可能要整個重寫了好。那所以呢Key Thread我們那時候其實也提過，在介紹API的時候也提過像CLibrary就是屬於Foxy裡面的一個，那這個 Pthread 則就是 Th read Library裡面的 P 指的就是這個 Proxy所以就是在這個 Standard 下面定義的 Thread 的 API就叫做 Pthread所以你可以看見這個 Pthread 的 P 指的就是 Proxy所以當然這是只有在 Proxy 的這些 OS 上它的 Thread Library 我們就稱之為 Pthread

所以大家就知道這個名字的來源那基本上它就是一個Thread Library然後是Rock在Apoxy的OS上的那這個eThread Library其實基本的使用其實是蠻單純蠻容易的因為Thread Programming基本上是非常有彈性的它基本上只要讓Programmer可以Create Thread可以Terminate掉一個Thread還有一些很簡單在Thread之間溝通的

一些Function Codes那些定義它的行為的Function Codes就可以至於一個Thread裡面是什麼完全是讓Programmer自由的去控制的所以可以看見它的流程就是它有一個PthreadCreate是一個最重要的Library Code讓你去Create一個Thread那這Create的Thread裡面要執行什麼呢你可以看見它就是對到一個Function所以

符合當初Thread的架構跟定義所以其實一個Thread在PthreadLibrary裡面的定義還有大部分的ThreadLibrary的定義都是這樣就是去執行一個function code就對了。所以當然一個function code裡面的local variable是private對不對。然後function之間的global variable當然是share。所以其實比較容易去體會那結束了之後呢你可以看見就是我有一個join所以join的意思就是你把它create之後join就會把它的結果再把它回傳到所謂的main thread或是你的main的這個program裡面去。就這樣子

就可以完成一個thread programming。所以你可以同時空很多pthread create然後就可以create出非常多的thread出來。好那我們來看一下它裡面的argument有哪些第一個其實是一個return的值你可以看見這邊是一個位置所以是一個pointer的位置所以這個指的是這個thread的ID。所以它是希望取得每一個thread query之後會有一個token那之後你就可以用這個token像這邊的例子你就可以去指定你是要跟哪一個thread read去執行這個動作第二個參數第二個argument呢是一個parameter是一個attribute

就是一些比較detail的控制這個Thread被create之後的行為的一些option的一些設定，例來講我們其實之前也有提到過程式Process或Thread讓在一個Multi-core的系統的時候有的時候你會想要指定它讓在某一個Core上面，因為不同core它的L1 cache不會share嘛對不對，所以如果你想要增加你的這個heat rateCache的heat rate你就會把這個thread綁在某一個指定的core上面，那這件事情怎麼做到的或者說怎麼樣

讓OS，因為OS by default它不會去幫你去限制它只要有空的core它就跑，但是如果你想要去control它去告訴OS這些Hint的話你就可以透過這個attribute這atribute，大家可以有興趣自己再看API裡面，基本上就是一堆它其實只是一個integer每一個bit就代表不同的行為的一個disable或inable像這個樣子，所以你就follow它的這個定義去改變裡面的值，它就知道你給進去的這些指定的這些hint等等的選擇是什麼，通常這些detail就是去比較f ine grained去control一個thread它在

運作時候的一些管理上的一些條件或者是限制後面兩個你可以看見就是 function code所以第三個這就是一個 functionpointer所以他知道你要仔細哪一個 function那最後一個就是這個 function argument所以當然你可以看見他的行為就像是去把這個 argument去扣這個 function code所以就是去扣一個 function code簡單來講那你可以注意到的是其實Function Code通常我們知道不只一個Argument嘛對不對

有的時候寫一個Function Code我們會定義一堆的Argument可是在這個API的設計上它卻只給你給一個Argument為什麼呢因為畢竟這個API我們都希望能夠越簡潔越General越好對不對所以說我們不可能去定義一個P3 create for一個Argument兩個Argument三個這個太囉唆了所以它就限制只有一個Arg

ument那你會問說我要很多的argument怎麼辦其實solution很簡單大家應該也學過的就是把它包起來包到一個data structure的一個object然後把這個data structure的pointer對不對的這個object的pointer放進來傳進去就好了那function的裡面你可以自己再把這個data structure把它解開來去用裡面的每一個他member的這些值對不對然

後去把很多的這些variable k都可以讀出來所以這是基本的用法是這個樣子就是通常是用一個pointer圖一個data structure的方式在做溝通所以P3 programming有時候也是至少在P3這邊他幫你做的事情比較少比較單純所以像programmer就要做casting因為其實他的定義這邊是一個void的pointer所以它可以是任

何的data structure對不對它不限制你都可以讓它去用但是你傳進來之後programmer自己要先把它cast成正確的這個data structure然後再去解讀那如果你搞錯了當然你讀出來就變亂碼都會是錯的資料那是programmer要自己負責的好那空進來之後就像一般的function code所以就大家知道那return的話對不對那你要怎

麼return呢是一樣的你會發現它也是透過一個pointer所以你的return不能夠是return一個直接return一個value它就像傳進參數一樣傳出參數也是用一個pointer所以你會看到這邊其實是給的是一個pointer那要讀回來的話這就是為什麼你要code join因為你一定要code join你才有辦法去取得這個return的這個pointer的值

你不join的話當然你就沒有辦法取得這個return的值了所以這就是怎麼樣去long time的時候依照你的需求去create一個thread然後再把它給再把它拿回來那沒有所謂delete thread因為thread其實就是它是執行一個functionreturn那那個thread就會結束掉了那只是說你的main thread可以決定要不要把值給讀回來好那這是一個簡單的example所以你可以

看見我們的main program我們就去只是print這個hello world而已那你create thread的方式像這邊我們就是用一個array所以你可以create任意數量的thread是都沒有限制的就是我們說的user threads對不對其實是通常可以很多的不代表他會map到不同的kernel threads那這邊create thread因為有很多嘛所以我們就用一個array那反正

就是一個pointer of array就是一個array of thread的ID，所以你就可以用這個for loop然後就create了很多的thread出來，那這邊是一個簡單的例子對不對，所以說你可以看見我們傳進去的argument就是一個pid對不對，就是thread的ID啦，那你可以看見我們就必須要把它變成void傳進去，那讀進來的時候我們的function就必須要對它做cast這是thread programming就是必須pthread

就是必須這麼做那所以每一個Thread他都會執行這一行，但是他裡面Thread ID會不同，那這裡直接當然你要扣不扣都可以啦Return等等都一樣他就當然知道那個Thread會結束，所以這基本上就是Pthread，你基本上需要用到Library就是這個Create然後Join回來而已，剛剛提到的這個join你可以看見最主要的目的當然就是要把它的return值給讀回來，所以像剛剛來講，如果我們create了很多thread的話，我們也可以，

就是一個一個的再把它給join回來，那你就是寫一個for loop這樣，你就可以把每一個thread的return值，把它讀回來，所以一般thread programming的model就是它執行的過程就是這樣你會有一個main thread執行沒有要平行的部分然後呢你可以create當有平行的部分就會開始create thread每一個thread執行不同的function或相同function都可以然後傳

進不同的data對不對然後呢執行完之後呢你再join把他們全部回過來變成你的main thread把資料讀回來return的結果取回來之後再繼續運作然後可以動態的create thread然後再join這些threadnn那有一件事情要比較小心的就是在create thread之後如果今天你不要把資料讀回來的話你當然就不會call join對不對可是呢如果你不call join的話大部分的thread library會要求你去call pthread detach意思就是說告訴我們的thread library這個thread結束之後你就可以直接把它的resource給free掉因為如果你

不去call這個的話只是畢竟程式是runtime的嘛那我們的OS也不知道到底未來它會不會join所以它就會一直hand在那裡把已經結束掉那個thread它的return值會一直把它keep在那裡然後就會無法結束你的program因為它不知道你什麼時候會去code join所以比較好的比這個行為programming的習慣就是你要嘛create完之後你要嘛就是會去code join你不要code join的話你就立刻去code detach就告訴我們thread library

結束就直接說不要了那這樣子的話你就可以它結束之後OS就會把它的它用到的Memory空間就會立刻把它清乾淨然後也不會Hand在那邊的問題那當然你一旦Detach了你就永遠不能Join所以它的定義就是這樣所以你一Detach就代表你未來Man-threaded跟這個Worker-threaded是沒有關聯性的就是除了Global Variable的

這個使用上但是之後他們是不會就影在一起的所以這就是Pthread了所以其實Pthread主要就是這兩個所以Programming比較麻煩的是Synchronization所以我們其實到了下章講Synchronization的時候就會講到一些Locking等等的機制那些機制主要就是要了解怎麼樣什麼時候去做Lock什麼時候做Lock那P3

的Programming其實是有提供一兩個這個Library的Function Code去讓你去所謂的Lock跟Unlock的動作那在那部分我們今天當然沒辦法講那可能我們講完我們Synchronization的章節的時候我們會回過頭來再幫大家再補充一點P3的Library在Synchronization那邊的Function Code好那Java Thread的話你可以看見基本上它就是一個Thread Class所以Java它本來就有一個Class專門for Thread的部分然後它是Implement了一個Runnable的這個Interface所以這大家只要知道就可以

了那未來有興趣有需要自己再去用那主要呢就是這個Java的Thread它也是一個Thread Library那我們知道Java的特性就是它其實是在自己有一個Virtual Machine所以它其實自己就像OS一樣那所以說其實Java的特性它的Portability又比其他的Language都好為什麼因為它中間隔了一層Virtual Machine嘛對不對所以今天你寫了一個Java的Program你可以Run在Windows也可以Run在Linux因為其實你去選擇你的Java Machine去裝它的時候你就可以選擇你在Windows上的Java Machine還是Linux Proxy上面的 Java Machine

這Java的Virtual Machine所以如果是Windows的Java Machine的話那你Java這邊的Thread就會對到的就是Win32的Thread那如果你是UNIX它就會對到Key Thread所以意思就是說它其實隔了一層你看這兩個都是這些OS的Thread Library可是Java上面Create Thread會先對到它的User Thread Library然後再Run到下面的Kernel

所以說它的portability會更好不像剛剛的Pthread你就沒辦法run在Windows上可是你寫Java你就可以為什麼因為Java是一層Layer一層Virtual Machine的Layer它會再對到他們個別OS的User Thread這個是Java Thread比較特別的地方或是Java這個語言為什麼它的portability很好就是這個樣子那你可以看見它甚

至於對照不同的作業系統它的Behaviour就可能不一樣因為就看那個OS它的設計等等所以比如說它可以是One-to-One的那它也可能讓到比較複雜的OS它會變成Many-to-Many就沒有一個一定的情況那是這個Java Machine這個JVM它會幫忙控制那，如果是Pthread話，你當然就是透過Attribute那邊可以控制一些，但是是Programmer自己來控制的

那Java會Java MachineVirtual Machine來做控制好，那最後我們講Linux的Thread所以這個跟剛剛完全不同 Linux Thread這邊我們指的是Kernel所以一個OS Kernel是怎麼去管理一個Thread那我們會講Linux就是因為它非常好講，因為它根本不是Process所以你可以看見其實Linux根本不捨破Thread某種程度來講對於OS本身不是對於Programmer那，所以Programmer還是有Thread

的為什麼因為Programmer就是用Pthread Library嘛，所以你可以Create Process裡面你可以Create Thread就像我們剛才介紹的，但不代表OS真的要把每一個Thread你Create當成一個Thread在Linux裡面，他是把每一個Thread你Create的呢就當作一個Process那差別只是在於我們之前已經教過了你要Fork一個Process你要去Create一個Process你會用Fork對不對然後它的 Behaviour就是這兩個人的Memory完全沒有相通所以我們要Copy那可是今天有Thread跑出來啦所以會有透過KeyThread你會Create一些很特別的Process他們是有些Memory是Shared的

所以在Linux裡面的做法就是再提供另外一個system code叫做clone所以這個目的也是create process但是它會有比較多的argument它這個argument裡面有一個參數可以讓你去控制哪些segment是share的哪些segment是不要share的所以就是透過另外一種方式去create這些process然後利用它的參數可以直接控制把它變成像是thread的那樣子一個行為

好所以簡單來講就是像這樣子啦所以Cloak就是另外一個在Linux這邊的System Code是可以去Create一個Process的但是它裡面會有一個Flag會有一些Flag你可以看見這些那每一個Flag就是很明確的定義說它的File SystemParent跟Child之間是不是Shared意思就是File Handler嘛你開了之後另外一個人是可以讀得到

然後你的這個Memory的Space是不是Shared你的Signal的部分這些Resource它都會有一個Flag然後你就在這邊控制0跟1的方式你就可以去把它Create出來一個新的Process然後其實很多Memory的Content是By default就是Shared這個就是它CreateThread的方式所以其實是你可以看見就是Process它其實不需要另外再寫Code去maintain或者去管理thread它就是process只是說create之後哪些memory contentsshare跟不share它利用一個system code很多的參數讓你去控制然後去create出你要的一個thread的behaviour.