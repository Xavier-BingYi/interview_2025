undefined
好，那接下來我們就回到Thread Management這邊了，所以我們剛剛就有提到Thread這邊其實在我們電腦系統的運作，它也是分層的那尤其呢它會分的就是所謂的User Thread跟Kernel Thread。其實是有分成兩層的什麼是User Thread呢？就是各位平常看見的我們剛才提到的Pthreads。我們這會教簡單介紹然後Java Threads對不對所以寫Java的人可

能都有用過了再來Win32 Thread這只是Windows上provide所以跟Pthread一樣。 Pthread是Foxy是Linux這邊的，Win32 Threads就只是Windows上API那邊提供的Thread API。所以簡單講就是這些都是一些Thread Library然後他們就是被include在我們俗稱的一個電腦系統裡面API層的裡面那些Library。所以現在電腦都support Thread Programming所以都是其實在User Level這裡API就會加入這些所謂的User Thread的Library

所以各位Programming其實就是直接用這些User Thread的Library。什麼是Kernel Thread呢？所以 Kernel Thread指的是OS裡面的所以是OS，它真的在去Manage這些執行的這些Entity的時候它的這個基本單位我們剛才說的基本單位的Thread，其實指的是Kernel Thread所以當然這就是每一個OS就有自己的啦，所以當然就是每一個OS都有自己的 kernel threads，就像它有定義它自己的 process 一樣那這兩個咧我們等一下會看見就是這兩個並沒有一對一的關聯性，其實這是一個 binding

或說 mapping 的關聯性也就是你用使用者，你會扣一些 APIcreate thread 啊，等等那是 create user thread，那它要執行的時候咧透過 OS 的時候OS 會把它 bind 得到其中的一個Kernel Thread上面去這樣子才可以開始執行裡面的程式碼跟Access裡面的Memory那這個Binding其實在Runtime它也可以做調整，所以你的這個Thread可能現在執行它是Bind到第一個Kernel Thread然後它可能去做IO所以它就知道它 Suspend離開我們的

CPU了嘛，它再次被放到Ready Queue再次被Schedule執行的時候它可能 Bind得到第二個Kernel Thread 它可以 Bind到不同的只要有空的他就可以翻譯過去然後開始執行所以其實是兩個level當然programmer不會care kernel thread但是OS的designer當然就是在manage這些kernel threads好所以我們再進一步講的話就可以看見所謂的user thread就是這些thread library所以就是這些API就對了那他通常會很快因為

它叫做User Thread的原因不只是因為它是User使用的Thread更重要它是User Level Thread就是在OS的上面所以就像我們之前一直強調的API只是User Level的東西System Code才是Kernel 對不對所以說只要是User的話來講你就不用透過Interrupt然後你沒有你不需要跟OS溝通所以其實它的所有的這些Implementation都可以比較快只要它沒有Touch到System Code的話

所以它通常會是比較快的比較快去create也比較容易去manage等等的那問題是什麼為什麼要有kernel thread因為如果一個kernel thread是只有一個single thread那user level有很多thread其實是沒有用的因為所有我們剛剛說這個binding的關係嘛所以如果你上面是可以create一堆的user threads那如果他們全部bind到同

一個kernel thread的話只要有一個user thread在kernel裡面call了一個io或者說sleep就把它自己block掉的話那就沒有人可以再使用那一個kernel thread了因為大家都bind到同一個嘛所以說有一個人在等那就大家都沒辦法所以會變成使用者以為他create一堆thread其實在kernel這邊如果沒有的話就沒有用只是一個假象或方便

Programming的結果而已還是有好處但是它在執行上會有這個限制那Kernel Thread就我們剛剛說的重點就是Kernel這個Kernel Thread就是OS裡面最基本去Utilize CPU的這個Entity了那因為它在Kernel裡所以凡事都有經過很複雜的Protection等等的機制所以它一定會比較慢那好處是如果你有很多kernel threads的話因為它每個是獨立的獨立執

行的所以任何一個kernel thread被block住其他kernel thread一定可以照正常的運作就像大家一般的概念看到不同process是互不相影響是一樣的道理但是這其實是kernel level的thread才有這個特性user level是不一定有的所以kernel thread跟user thread的差異大家要能夠很清楚的去知道它們的差別那既然有User Threads有Kern

el Threads所以我們剛才講的就是一個Mapping的關係而已所以在OS這邊在Support Threading的Programming的時候它其實有一個部分就是要去決定這兩個Mapping到底是什麼當然不管怎麼樣MappingOS的責任就是要能夠讓它正確的執行嘛所以幾個model所以一個OS它就可以有幾種不同的方式做這個mapping從最簡單的第一個就是我們剛剛說的所有的user thread就對到一個kernel thread當然也可以

這麼設計這就是所謂的many to one所以user呢不管他create多少個thread我就全部對到一個kernel thread而已那當然這個model通常則是以process的角度就是說你是同一個Process你Create了一堆Threads那我就只管那個Process所以一個Process是一個Kernel Thread然後裡面Create了所有Thread我全部對到相同的

Kernel Th因此只要任何一個Thread在那個Process裡Block那個Process其他Thread就不用跑了。所以就是比較像是傳統Process的觀念然後只是讓它做Resource Sharing。所以並沒有真的平行在執行它為了這一層也再講就是說，如果我們這台電腦有四個CPU有四個Core，那你create四個Thread同一個Process create四個Thread同一個Process create四個Thread，它從來就沒有同時執行過因為大家在排隊所以沒有辦法炸出你Hardware的這個資源。但是你可以

用Global Variable做Sharing像我們剛才說的Responsiveness這些它可以做得到。所以它的用途是不一樣的第二個比較常見的就是這個one to one一個user就一個kernel。所以你根本就沒有差別就是實際上它們是不同的東西。但是你不會有任何的感覺因為就是一對一的mapping而已那純粹是電腦系統因為kernel跟user是不同的所以其實是不同的。但為了方便implement manage等等它就是一對一很單純的這樣去使用就好。

其實很多OS是這麼做的尤其現在電腦資源還蠻多的所以不怕你create一堆的kernel thread然後有一大堆的這些thread block要去control去存等等反正它可以handle只是還是有壞處就是你的這些kernel的threads畢竟它比較耗資源因為它有thread control block等等所以你create的數量通常是有一個上限的就像大家可能有試過就是在一

個OS在一個電腦上你去開file的數量也有一個上限它不會讓你開無線的file它一定會有一個limit在那邊因為它怕影響到整個電腦系統的運作所以多少都會有一個限制在那那如果是one to one就可能因為使用者他就是assuming他可以開無線的threads很多時候有事沒事方便或是programming error就開了一個thread對不對

可是如果你一做這樣做可能就造成整個系統卡住了第三個可以想見的嘛最複雜的Many to Many就是沒有什麼只要能夠對到就好所以這兩個數字不一定要相同沒有什麼關聯性你可以想見這當然就是最複雜的要implement支持這樣的feature的OS當然是最複雜的implementation所以它就必須要在內部自己類似context

tree但不是這只是在mapping而已所以就直接執行的時候他就做的管理就是他要ensure要正確就對了，所以意思就是這四個他可能只Share三個kernel threads，那有一個人假設他被block了，那他就可能用掉了一個kernel thread，那這時候剩下三個人就Share這兩個，然後可以繼續執行，因為隨時他們只要不要lock住一個kernel thread其他

人就可以繼續的去輪流的去使用它，那所以當然是最有彈性的，所以最不容易碰到會被lock的互相影響的問題同時呢，你kernel也可以自己去看說我到底要需要幾個kernel threads，因為可能很多user thread的loading是很輕的，那我就把它全部都用一個kernel thread去處理就好，所以就很有彈性處理得好當然整個系統效能會達到最好

相反的處理不好或者是說你可以想見這個管理機制一定複雜所以它一定會有很多的overhead就是你要花很多額外的時間做管理等等對不對，所以如果你的使用情境很單純那你可能就多花一些時間在這上面卻沒有得到什麼效能的優化，所以這當然不是未必是好的好， 所以就是一二三三個其實大家看圖就可以知道它們是什麼意思，

那就只是他們的好處壞處會需要把它記下來其實我剛才全部都講完了，所以這只是把它整理下來所以你可以看到Many to One的話對不對就是全部對到一個嘛，那這樣的話來講，就是不需要去捨沒Kernel的Threads，所以一個Process，一個或整台電腦裡，一個KernelThread也OK那，但是這樣的好處當然就是你的Thread Management會在

user space所以很快嘛！我們剛才說，你create一個thread，它就是不會create任何kernel thread，所以一定會快，但問題就是它會有blocking的問題，所以注意它到就像剛剛的例子，它這個就會整個卡住另外，就是它實沒辦法去share這個multiprocessor所以這個可能是更大的一個issue所以，就沒有真的去做平行的計算對哈維爾而言1 to 1 剛才提過了，所以它就是最單純的 case那，它的這個一個問題，就是它的 thread 數量通常會被限制住kernel

一定會限制住所以反過來就導致 user 也被限制住了那，這對於programmability 的角度來講就是比較不理想我們都希望 programmer 不要受到任何的限制那，它的好處就是它的 concurrency 一定是最高的所以完全不會互相的影響然後，它的缺點就是當然因為你每一個user thread等於create一個chronal thread沒有選擇所以就一定是慢就等於

是在 creating...  ate chronal thread一樣所以就沒有辦法非常的快至少跟前面比就會明顯比較慢，但是我們說其實彎圖彎是很常見的因為這些問題只要電腦資源，現代的電腦資源都算是很多的，所以反而比較注重的就是一些programmability上，它可以concurrent然後不會影響這些，所以你可以看見大部分的OS其實那就是用1 to 1至少讓我們，我們說OS其實不希望太複雜嘛，因為不好debug然後太複雜的時候

它整體效能反而是會in general common case，它反而變慢，所以這是違背一般系統設計的理念，那many to many對不對，所以我們剛才知道它的意思就是最複雜的，所以他可以任意的去做mapping而且是wrong time做mapping所以不是事先，所以執行到過程中每一次這個thread要被執行之前他來決定這個mapping到底是什麼，所以當然就是沒有任何的限制然後也不太容易會被卡住，但是就是這個overhead所以很複雜所以一定都會通常會帶的就是他的執行時間in general case就會稍微慢一些

然後可能OS比較容易出錯，所以這是它的一個缺點，所以只要了解Kernel thread跟User thread的差別，它的好壞處應該就相對的可以推得出來就是只是使用上它們本身性質上的不同造成的差異所以前半段這個還滿重要的對不對就是Thread跟Process的差別為什麼要用Thread然後這些Thread Programming你可能會碰

到一些Challenge那更重要的是大概就是只有我們OS會特別去強調這一點就是其實它在管理上是分成User跟Kernel不同的Layer然後其實是有不同Binding的Option的存在那有一些OS大部分大概都是One-to-One也有一些是Many-to-Many那當然Many-to-One的比較少或可能或許在一些embedded device或這些比較limited的Hardware上或許會用這樣的方式所以我們今天就到這邊我們下禮拜一考試禮拜三放假那回來我們就會把這張結束就跟大家介紹一下Thread Programming的部分.