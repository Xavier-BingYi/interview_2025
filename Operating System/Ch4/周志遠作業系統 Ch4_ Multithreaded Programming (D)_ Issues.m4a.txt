undefined
最後我們看到的是去Create這些Thread之後，它會有一些跟Process上因為Process畢竟它們是沒有關聯性，但是Thread我們知道它們都是屬於同一個Process，所以其實有一些比較detail的小細節它的行為需要稍微注意一下的，那你可以看見課本其實列了很多啦，所以其實有列了六個，那我們只會講其中四個比較基本的然後比較可以容易需要去理解的這些問題。第一個就是我們知道Process可以Fork，

那第一個你可以想的一個問題是，如果我建一個process，本來我就有兩個Thread的話，我今天在某一個Thread裡面去Call了Fork，它會發生什麼事情，它應該會變成什麼樣子那你可以看見其實有可能是有兩種結果的，對不對。第一種就是Fork是針對整個Process所以雖然只有一個Thread去Call Fork，但是我就把整個Process做Copy的

動作，所以就是我會Create出一個新的Process當然而且呢原來有兩個Thread，所以這邊我也要兩個Thread那這是一種可能性嘛，對不對。另外一個可能性當然就是因為它只在一個Thread裡面Call Fork所以我新Create出來這個Process我就只Include原來那個Thread的行為就有點像在Linux裡面就比較容易這麼做因為本來他就把Thread當作Process所以其實OS看到的不是P0下面的T2而是他就只看到T2對不對

所以當你在裡面call fork他當然就是把這個把它Create而已嘛對不對所以就會長得像右邊那個樣子所以這只要再注意因為Process跟Thread在Programming上是兩個Level所以一個Fork的Behaviour就有可能是左邊那個或是右邊那個好那當然這個東西就像我們所有說的這些執行就是系統設計沒有

對跟錯然後也一定辦得到所以只是說一個作業系統它要捨破是兩種MODE這兩種都有可能然後讓Programmer選一個當作Default或者是它就是限制我就只捨破其中一個這在OS的設計上來講都是有發生的所以大家在Programming的時候其實要去試試看或者看一下那個OS的Spec他怎麼去管

理Thread跟Process的你才知道你的Behaviour到底是哪一個那是有可能造成這邊兩個不一樣的狀況的好那exe-eclp就比較沒有問題啦因為那時候我們教過Fork跟exe-eclp那這個定義是因為它是replace所以說這一個情況如果你call了一個exe-eclp就不用講就是整個Process就沒了就直接替換成新的這個是沒有差的所以原來到底上了幾個thread通常OS都不管就把它整個換掉就對了這是比較沒有問題的好另外一個就是這個cancellation對不對所以說今天一個thread如果它去被terminate掉的話那它的行為會是什麼那

那這裡的主要問題是在於說一個Thread如果被Terminate掉或是它被結束了所以它應該要Return回到MainThread對不对所以MainThread應該要去把原來這個被Cancel的Thread的一些Memory把它清掉等等所以需要一些動作這個Thread Library必須要去Clean up那一個被Cancel的Thread的這些Memory的Content那所以這邊比較detail一點只是說在這個Cancel的過程就是去Clean up的動作來講

通常Thread Library有兩種使作的方式第一種就是所謂的Insynchronous Cancellation所以也就是說Main Thread它一定會執行到某一個地方的時候它才會去做Cleanup的動作所以它不會隨時在那邊你一Cancel掉它就去Handle這個事情它一定會等它執行到一個階段之後再去執行那通常的好處就是它比較容易Input對不對只有在某些特定

的地方他才會做Cleanup的動作所以他比較容易拿到比較Consistent的State，簡單來講就是他比較能夠預測怎麼去做才是正確的Cleanup。另外一個勒叫做這個Deferred Cancellation，那意思就是說我們這個Target Threat他會去Periodically的去看說什麼時候會被這個一開始的時候，簡單來講就是說這個Cancellation這個Target Thread它本來就有預設幾個地方你才能夠被中斷，在中間的時候

雖然說你按了Ctrl C去把那個Thread給砍掉，但是它其實還是會執行到它指定的那個Jet Point的點，然後再結束掉，所以叫做Differed，意思就是說它會等到它執行到了Target Thread的某一個點之後再去做處理，所以意思說你當然都是會不會立刻去處理啦，那這個的話就是說你會等到他結束之後，然後看看什麼

時候再回去，你不知道他在哪邊，但是你會等Mans thread有空的時候，那這個defer的話就是他會有一個checkpoint的地方，然後到了那些點，他才去做clean up的動作，這稍微有點detail了，不過基本上就是說你兩個threader在互相在運作的時候，他們什麼樣子在什麼時候把他們Memory的這些Content把它Free出來的把它重新再做Allocation的

動作那通常並不會是說立刻去做就對了因為那個Overhead很大而且有時候你Run到一半有些指令還沒執行完嘛所以它可能會造成一些Synchronization的issue好那第三個部分是Single Handling這個比較明顯意思就是說什麼叫Signal Handling呢?舉例來講像是Sleep比如說你一個Thread裡面你就call了Sleep10秒嘛所以你意思就會知

道10秒之後它會有一個Signal跑出來對不對然後去Notify我們的Process這個Thread可以繼續運作了就是像這一類型的那這個Thread的Handling當一個Signal跑出來的時候因為一個Process有很多的Threads所以說其實我們OS第一個要先判斷這個signal是給指定的一個thread還是給所有的thread所以其實是有幾種不同的可能性存在的那我們

就先來看一下有幾種第一種的話來講如果是一個signal產生出來的時候那它有可能有幾個情形是第一個是他就是只有generate當初generate這個signal的人會得到這個event就像說sleep十秒所以當然是只有那個thread會去睡覺對不對然後只有他十秒之後他會收到一個signal把他wake up起來所以這就是第一個case第二個case呢是這個signal呢他是deliver給一個這個

所以這個只是順序啦剛才講的就是第一種case就是從第一個產生出來產生之後它會給這個process那這個process就會去給當初code這個signal的thread去把它去做執行的動作所以我應該講這個是應該說這是general form啦所以這很general嘛對不對所以就產生一個signal只是說signal會先送到process的level然後process的level再去決定說我要怎麼去handle這個signal

然後可能性就是下面的這四個第一個就是你當初去deliver這個signal的人他就會被去handle這個event就像sleep那第二個case是這個signal他會所謂的handle的時候他就會交給所有的thread比如說就像是有一個thread他直接call的是terminate process他直接就是EXIT了那這個時候當然你知道他就會kill掉所有的thread對不對

所以這就是第二個case那第三個case它是說它可以給到指定的某一個thread所以跟thread跟thread之間其實也可以互傳signal的因為其實你只要有thread ID是可以這麼做的所以第三個case就是那些一個thread create a signal之後它其實是給了另外一個特定的thread去做handling那這是第三個case第四個case第四個case就是丟出signal的人並沒有說要誰來handle但是我們的

process本身就會用main thread去handle它這個所謂的specific thread的意思所以有一些signal是by default就是由main thread來handle然後其他thread是不去處理它的像是一些file的open這些file handle的操作那就是main thread來去handle所以會有幾種不同的case所以這邊只是要跟大家講的就是當你去throw一個signal的時候其實OS是要去判斷其實當然你CodeSignal

的API都有明確的定義但是其實會有幾種不同的可能性會告訴我們的OS說這個signal al它是要broadcast給所有的threads還是直徑的thread或者是就是由main thread來去處理所以會有幾種不一樣的Thread Handling 的方式都是有可能的因為畢竟它是同一個 Process下面產生的 Signal所以要知道是誰產生誰來接這個 Signal下一個跟 Thread 有關的叫做 Thread Pulse那這個大家就可以好好把它記下來因為這個對實作應該是常常會用到的一個技巧

什麼是Thread Pool呢簡單來講就是我們看見原來Thread Programming的概念是當我需要平行的時候我在動態地產生一個Thread然後我不要的時候我再把它給把它Delete掉這樣的壞處就是你會不斷地在那邊Create Thread然後再Delete Thread對不對所以會比較不Efficient所以當很多的應用比如像我們說Web Server的設計它就會用Thread Pool的方式也就是說

它一開始就create了一堆的thread就是一個pool of threads然後可以control我這個pool of threads的size到底多少比如說是20個thread還是100個thread然後在我的執行過程中我就一直re用這些threads然後讓它執行不同的function而已，這就是所謂的thread pool，所以另外一種thread programming的方式是透過像這樣子的一個概念所以它的最大

的好處就是因為它不需要一直在那邊run time to create threads當一個event進來的時候對不對所以說我的這個handle一個request的速度就會更快所以我其實並不會一直在那邊delete然後create這樣的動作第二個其實更主要的原因是因為我可以control這個pool size所以意思就是我可以control我在我這個server這邊或者說這個host這邊它的resource的使用量

因為你想想看如果一個Web Server那你沒有限制的話Request進來越多我的Create越來越多Thread最後我的CPU就全部被分光了對不對然後電腦可能就Hand在那你OS都跑得很慢了這其實是一個很大的issue所以今天如果我控制這個Pool Size就是10或100那我就知道它最多最多也就只會去用掉這麼多CPU的Resource對不对剩下我就可以保留給我的System這是最主要的目的

所以Threadpool的目的第一個就是它可以比較快第二個就是它可以control它的資源使用不會無限制的然後一直去create過多的Thread早至最後整個系統的效能變得很差所以很多的應用其實是用Threadpool的概念就是那種runtime你會有event進來然後你用Thread去handle的話可以用這樣子的方式好,所以

Novel Thread其實就是一個Resource Control的方法，所以你可以Basic上你有幾個CPU Core或者是你有多少個Physical的Resource像Memory等等因為你可以估算每一個Thread它執行它的工作的時候最吃Resource的是什麼東西吃多少然後你就可以去估算最多最多Total加起來是能夠用多少就可以去控制了所以這個是Thread pool這邊就是我們第四章Multithread的部分，所以最主要就是User Thread跟Kernel Thread的差別然後三個Mapping的Model它們的差異在哪裡Pthread跟Java Thread後面這些Use case我想這個是未來大家去Thread Programming的時候

可以練習的時候自己在練習的時候可以再去學或是去用就是Pthread的一些基本的Programming的方式還有你要注意到在Thread裡面去開這些去Code這些Function Code這些Function Code它的Behaviour其實要考慪到它們是同一個Process有很多Threads所以它們被Handle的方式是什麼其實要稍微注意一下.