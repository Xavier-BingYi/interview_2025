undefined
Dispatcher只是稍微知道就好就是我們講Scheduling只是在講單純在選的動作至於做Context Switch是有另外一個Component在負責的接下來我們就要開始一一介紹各個不同的Scheduling Algorithm那介紹Algorithm之前當然要知道我們的目的是什麼啊對不對所以這些Algorithm這個問題到底我們的Goal是什麼

Argetive是什麼其實對於一個系統的效能而言是有幾種不同的定義的就是用幾種Performance的Metrics來衡量這個Scheduling到底是好的還是不好的第一個CPU Utilization大家一定最熟悉對不對我把電腦打開來我就可以看見嘛大家應該都有用過如果在Linux就是Top那如果Windows就是Monitoring大家應該知道啦所以你就可以

知道它的目前CPU使用量是多少如果很低然後但是你覺得電腦很慢那一定是有問題對不對通常就代表你的OS可能管理上沒有做好所以CPU都沒有用到那當然理論上我們都知道一定是介在0跟100那不過大部分的系統就是40到90所以大家通常就知道90應該就是已經是使用率滿

高的一個狀況第二個大家可能比較不熟悉但是對於計算系統而言大家看的其實是這一個因為有時候你CPU高不代表你在做有意義的事情對不對所以對於一個計算的電腦系統其實我們看的東西是叫做throughput什麼是throughput呢就是每單位時間內它完成的工作量那對於CPU的schedulingProcess的scheduling而言我們完成的工作量呢就是以完成多少個Process為當作計算單位也就是說

我今天電腦系統如果丟進去了100個Process 對不對那我可以算每秒鐘我完成了平均完成多少個Process就是執行完所以整個就是結束這樣子當然有些Process大有些Process小但是以SRUP的角度就是我們不care我們看的是整個系統的效能所以就是每秒鐘你平均就是可以完成多少個就對了所

以當然有一些Input的Workload比如說每個Process它都是很大的那當然SRUP自然會比較小所以這當然不同沒有一個絕對說0到100像第一個那樣子Normalize to任何值純粹就是你同樣的input給它那你電腦 不同的電腦對不對它的throughput高低的比較而已好 所以是throughput其實這個是比較長一系統角度大家會看的其實是這一個好那接下來我們會再看三個Performance計算的時間那這三個就是跟CPU Scheduler

比較緊密有關聯性的比較容易去計算的那通常這些值的結果也就會影響你的CPU Realization跟突破第一個叫做Turnaround Time也就是以單一一個Process的角度來講我今天Submit了一個Process在某個時間點Submit進去到我整個Process結束的時間這個時間就是所謂的Turnaround Time所以跟剛剛的差別是這個是一個Single Job的角度以使用者的角度 對不對

這個是以系統的角度那所以這個 turnaround time 就是每一個平均我一個 job他可以執行他需要花多久的時間把它執行完當然是越短越好對不對第二個 wait time所以這種 wait time 呢主要就是用在一些比較有 interactive 的 job 的系統裡面對不对所以就像一個系統我丟一個 request我多快可以拿到我會在這個 ready queue 裡面會等多久所以 wait time 則就是說

你執行的時間這段時間你要嘛就是在執行我這個程式的這個IO或者CPU或者是你就是被放在Ready Queue裡面其實你可以做但是你沒辦法做因為在別的程式在使用那Wait Time則就是你這個程式在Ready Queue ue裡面的時間Waiting在Ready Queue裡面的時間就叫做Wait Time那當然Again以一個使用者的角度他會希望他的Wait Time是越小越好

Ideality就是零嘛對不對那 Turnaround time Ideality就是你最小的程式執行時間那第三個 Response time這個就是我們剛才說就是完全是First response而已就是Interactive的時候我們會Kill就是我什麼時候可以知道它已經有回應所以 Response time就是從Submission time到第一個Response產生什麼叫First Response呢其實簡單來講就是你的第一個CPU Cycle這個第一個CPU Burst

可以開始執行的時間就叫Response Time所以差別在於一個程式的執行不要忘記它是有好幾個CPU Burst對不對那 Response Time指的就是你Submit之後到第一個CPU Burst開始執行的時間那Wait Time指的是你所有的Burst全部都執行完之後然後看看你有多少時間是在Waiting Queue裡面所以這兩個是不一樣的所以這是整個執行過

程中你在Ready Queue裡面等待的時間這一個是你一開始然後到你的Submit之後到第一次執行CPU Cycle的時間所以這兩個是不一樣的那對於Interactive的當然最重視的是Response Time因為只要有response我們可能就覺得它有在動作了嘛對不對開始執行所以通常是看這一個那Wait Time的話我們等一下會看見其實用一個algorithm所謂的Shortest Job的algorithm你可以theoretically的證明它是最優秀的所以這個其實是可以有Optimal的Algorithm的存在那至於上面的Super我們講是以系統的角度

好所以我們會等一下我們會Go Through這些Argorithm那當然主要就會去比的大家應該可以拿來做比較的不同的Argorithm他得到的好壞的比較就可以看他的Turnaround Time Wait Time或者是Response Time因為這三個是以Job的或是一個Process的角度那上面兩個當然你看不見因為是整個系統但是以Single Job角度你可以用下面三個Matrix來

做衡量好很快我們就來看第一個最直覺的First Come First Serve所以大家應該看名字也知道它的意思所以在我們這邊去看一個CPU Schedul er的input這個問題的input就是你會拿到一個set of processes這些意思就是他們在ready queue裡面的process所以有哪些processes在我們的ready queue裡面然後呢每一個process我們會知道就是它預計它的burst time也就是說今天如果讓它執行它會需要執行多少個比如說CPU cycle那這個

看見這邊你會看見它只有一個P1只寫24只有寫一個CPU Burst是因為它是比較簡單的例子你要知道真的的話其實它是有好幾個CPU Burst所以這邊只是一個簡單例子所以我們會只看到就是一個而已當然下一個Burst一定要等到這個執行完才會出現嘛對不对所以其實真正一個程式的執行行為是P1譬如說它現在要執行24個Cycle執行完之後它會進入一個IO的

然後等待多少個 cycle 之後它又會回到這個 queue然後它的 burst 有可能一樣有可能不一樣但我們現在在模擬的是只有當下這個時間點假設我們模擬自己是 scheduler那 ready queue 裡面就是有三個 process然後假設我們知道它接下來要執行的這個 CPU burst cycle 的數量那first come first serve所以假設我們就是放在Q裡面那就是

剛做ordering雖然都是第0秒進來，但是假設他們就是first come first serve，他是先進來稍微早進來一點，所以就會讓P1先執行，那因為我們先模擬的是所謂的non-pre-emptive，所以P1執行完之後當然P2才能執行，然後才是P3對不對，所以就會看見這樣的結果，那如果是pre-emptive的話呢，对於first come first serve是沒差的，对不对，因為就算我

今天會可以打斷，我也不會打斷，因為我就算是pre-emptive的scheduler他的scheduling的結果仍然長這個樣子，因为先來的就是先執行他的priority沒有變動，所以對first come first serve其實你是pre-emptive non-pre-emptive答案都一樣，那這邊只是讓大家可以看見，就是剛剛我們說那些performance的metrics的計算，所以如果今天是wait time當然P1一開始就可以執行，所以

是零嘛，P2是24嘛，因为我們說它的假設都同時Arrive，只是稍微慢一點點，对不对，所以其實它還是零秒就進來，所以就是24，然後一次類推，然後Average當然就是在這個例子就會是17，那如果是Response咧，对不对，如果Response的話,P1實它會跟Wait Time是完全一樣的，可是萬一今天我們後面還有第二波的CPU Burst，那你Wait Time的算法跟Response Time就不一樣。 Response Time還是0、

24跟27，可是如果我們後面過了幾秒之後P1又進來，那如果是Wait Time其實要全部模擬完然後在Ready Queue裡面的時間加總記住一點就是IO Burst的時間不要放到Waiting的時間。所以，如果今天P1有時候我們說24對不對，然後我們它接下來接了一個譬如說是 IO Burst，然後我們說4秒鐘好了好不好，那其實它在進來的時候

因為它是之後才進來對不對，所以它一定要從30秒才能開始執行對於P1的第二個CPU Burst。那它的Wait Time雖然這種30秒可是它的Wait Time不是6喔，它的Wait Time是你要6再減掉IO Burst我們剛才說4秒嘛，對不對所以P1的Wait Time是只有2而已喔就是wait time是說你在ready queue等待的時間，所以你在模擬的時候你

要把IO的時間考慮進去然後他下一次進來的時候卻不能執行的時間，那個才是wait time的算法所以Wait Time跟Response Time還是不一樣。 Response Time就是這個樣子我們不會管後面他的burst的狀況是什麼了，這邊剛好我們模擬一個cycle而已，wait time 剛好就會等於 response time，好，那這個 scheduling first come first serve很明顯，如果今天我們 care 是 wait time，我們希望把 average wait time 減小的話，first come first serve

一定是一個很糟的 algorithm，因為，就像這邊例子可以看見的，如果你一開始 run 一個很大的 process，那基本上後面的 wait time 它都是累加的，對不對都是從 24 秒起跳，所以就會變得非常非常的久，那這當然有個名字啦，不過很明顯就是從first come first serve的例子，你可以看見scheduling其實應該可以做更好的decision，尤其，如果我們想要把wait time給減少的話，好，那這個是first come first serve然後，如果我們今天稍微調整它的順序同樣的問題

同樣都是零秒來可是假設我們今天剛好很幸運的是P2先進來P3再P1，你一樣大家可以去簡單的模擬你就會發現你的wait time會大幅減少到平均就只有3，對不對這也是first come first serve，對不对，但是，如果我們把比較短的價格放在前面，它的整個average wait time自然就會減少很多，所以意思就是first come first serve它沒有intelligent嘛，所以就看你的運氣你的input適合或不適合。如果一開始是很長的價

wait time 就會非常非常的久，所以這當然不是一個很好的 algorithm那今天，如果我們的目的是要減少 average wait time 的話，其實是可以被證明大家自己想一想大概也不會太困難其實你要得到最短的 average wait time 的 algorithm 的方式就是你讓最短的先對不對，因為你可以用swapping 的方式就知道你可以 prove今天你做任何的swapping兩個 process 做任何的swapping

它的值值可能會增加或者是相同大概是那樣的概念那所以其實shortest job first就是這樣的一個solution就是它的目的就是要minimize wait time然後呢，它就是follow其實可以證明的就是最短的先執行就對了，那這樣子你的average wait time就一定可以是minimal，所以是theoretically可以證明是minimal那當它是最短的話等下就會看見那你的PREENTIVE

跟NON- PREENTIVE就有可能得到不同的結果囉尤其是當Process它進來的點是不同的話我們待會兒有例子就要注意到對於Shortest Shot你就要注意它是NON-PREENTIVE還是PREENTIVE因為它的Schedule Result就有可能會不同了那當然Optimal這件事情仍然成立啦就是你是在PREENTIVE裡面的Optimal或是NON-PREENTIVE裡面的Optimal對不對；然後PREENTIVE的ultimum的wait time一定是小於等

於non-pre-emptive的average wait time，因為pre-emptive是一定是更多機會，所以那個值只會更好而已；我們就來看這個例子稍微複雜一點，因為我們現在把它的arrival time讓它是不一樣的，但是這邊還是一樣只模擬single的CPU burst而已，一樣後面有burst time，arrival time然後有4個job進來，那我們先看non-pre-emptive，所以non-pre-emptive定義的話就是第一開始進來我們其

實只有P1，所以沒有選擇，所以當然P1雖然它7好像是裡面最長可是不要忘記2 3 4根本還沒有進到ready queue所以你只能去執行P1那因為它是non-pre-emptive所以它比較簡單你看到non-pre-emptive的意思就是我一執行下去那我就要把它執行完就對了一次就划到 7 了那到了 7 這個時間點我們才有機會去做 Scheduling那我們就回頭到這邊看我們的 Queue 裡面這時候 7 秒其實 2 3 4

都在 Ready Queue 對不對所以你就可以選那 Shorted Job 當然就會選最短所以是 P3 對不對所以 P3 會先執行然後執行完之後那剩下的就只剩下 P2 跟 P4那當然其實哪一個先都 OK 啦就是反正type breaker嘛所以either是二線或者是四線無所謂啦那所以這就是一個可能的一個結果啦那again這個wait time

的算法就是非常定義不要忘記是在REDQ裡面的wait time所以Key1它其實是0那Key3的話對不對它是7秒開始做執行那可是你要注意到它第4秒才來喔所以它的wait time應該是3所以是7減掉4這邊有個公式啦不需要死背啦因為大家知道一死就好對不對所以總之算完之後你要

怎麼算都可以但是基本上他的在Q裡面的ready Q裡面的wait time在這邊比如說7減掉他的arrival time是4嘛所以是3所以他的wait time就是3以死類推所以大家可以算出每個人的average wait time所以這就是平均就是4那其實這就是最短的了所以你任何的non-preemptive的agreement你不管propose什麼algorithm4應該就是最小的值

4一定是最小的值不可能有更小的那這不代表這個algorithm是最好這只是說它如果你用average wait time來去衡量好壞它會是最好可是它有可能犧牲掉其他的像是response time或是turnaround time所以你有很多的performance matrix嗎並不是說你有一個最好其他都會是最好的表現那所以不同系統 不同考量有些人可能像我們這邊看是response time對不對所以P1這邊是0對不對

那P2的話他是8秒開始執行可是他2進來所以他等了6秒對不對所以這是6以此類推那有些系統可能他是要minimize average response time然後wait time是盡量越小越好可能是4. 5可能是其他沒有一定的，所以看你系統的需求去選不同的演算法，但這些定義的這些metrics就是說你可以衡量的標準啦，那如果是

average wait time，shortest job是 optimal 好，那我們再跑一次那這次是用pre-emptive來看那pre-emptive來看的話一開始一樣是空的嘛，所以我們就把P1放下去，但是差別就在於說我們可以打斷它所以意思就是說今天在第二秒的時候對不對P2進來了，所以我們的ready queue就多了一個candidate，那這時候schedule的它可以把它打斷如果它符合比較短的這個要求的話對不对，

所以當然這個case P2它只要4秒那P1的話原來要7喔，但是你要減掉2對不对因為在這個時間點它只剩下5秒了所以其實是5秒跟4秒比，那4秒還是比較短所以我們就會把P1preempt就是我們說的preempt就是這個意思就是preemption就會發生了它會把它給打斷這個 CPU Burst 一半我們就把它砍掉了對不对然後讓 T2 去做執行好，

然後不要忘記它剩下就只剩下 5 囘，所以它並不是原來的 7那接下來對不对你會再去看所以 P3 4 的這個時間點又會 Trigger 一次 Schedule 的 Event 對不对，那一樣嘛，所以 P3 這個人是他的 Burst 只有 1然後呢 P2他原來是 4 做完了 2 個所以他剩 2然後 P5 人呢？ P1 的人是 5那 1 小於 2 小於 5 嘛所以他又 preempt 所以他又再次把人家可以打斷掉那接下來到了 5 的時候 P4

會進來那剛剛好這個 P2 他原來是只有 2那 P4 進來的話他是 4 所以他又會比他差所以P3已經執行完了嘛P3是一個cycle啦所以P5這個時間點的時候剛好P3也執行完然後P4剛進來那比較之下P2只剩下兩個cycle比較短就是P2先做然後做完之後再P4然後再P5對不對所以這個是shortest job first的結果但是你可以注意到顏色就會亂掉這就是preemption的發生

你可以算它的average wait time這個例子的話是3你就會發現它一定會比non-preemptive的要再更小或者是相同不可能更差當然這個response time跟wait time的算法當然就會比較複雜一點因為你會被打斷對不對所以像P2你不僅僅是要看它什麼時候開始執行你還要注意到它中間有沒有被打斷被打斷的話就代表他也是在做Waiting的所以像P2他雖然2進來的時候

他立刻開始執行他沒有等可是中間他真正的結束時間是7所以你可以看見是一個簡單的通識就是Completion Time減掉Arrival Time再減掉Long Time那這個只是在Single Burst下面的話你是這樣去做計算如果有好幾個Burst的話其實你還要再減掉IO 的 wait time對不對因為那不算 ready queue 的 wait时间所以基本上你有一些基本的這個通識大家可以去把它算出來的那 shortage 加 first 的話，雖然說 theoretically大家可以很容易證明它是optimalin terms of average wait time，

但就像很多 theory 上很好的 algorithm其實在 practical 來講通常是無法實現的那這又是相同的 case所以為什麼它實際上無法真的被實現呢，因為我們其實根本不知道它的 burst time對不對，所以其實這個 schedule 發生是在你執行一個 CPU cycle 之前，所以你在執行之前其實你根本不知道它的 CPU burst time 到底應該是多少那也不

是說就沒辦法所以就所謂的approximate的shortest job first也就是說我們就用它過去的history來猜測預測它的CPU burst下一個CPU burst的時間到底應該是多長然後就根據那個然後來做shortest job first的 scheduling這其實只是一個預測什麼意思就是它的 CPU burst 其實就是每一個時間點出現 burst 它的長度所以其實你會發現預測的方式就是會任何一個 time series 的 prediction 的方式其實都可以 apply

啦所謂 Time Series 的 意思就是說你有很多的觀察點，它們是隨著時間第一個 interval 觀察了點的數值第二個 第三個 第四個然後你要猜第 n 加 1 個對不對所以這其實是一個很常見的 prediction 的數學問題之一啦！所以任何是那一方面的prediction method都可以套進來，用那這邊我們當然是講的是最簡單的，就是大家其實可能也學過的就是用這種 Exponential Average的方式也就是你有原來你有這個新的觀察點對不對

還有你過去平均的觀察點，那你用一個比例 對吧α 1-α 來normalize看你要比較偏重於過去的平均值還是你要比較偏重於上一個最接近你的這個觀察值然後做一個Normalization然後來做平均得到你的預測所以這個是滿常見的所謂的 Exponential Average的一個預測方式所以為什麼叫 Exponential因為你會看見過去的觀察值它就是會以這個 alpha 的這個 ratio在做 decay它的影響力會越來越小所以我們稱之為 Exponential Average 好！這只是展開啦！這其實沒什麼對不對！

所以如果你把它展開來從第一項一直列到最新的話你就會發現它就是指數嘛！對不對！所以就是你越久以前的它的就是它的指數的倍數會是越多所以影響力會越小所以就是Exponential Decay好那如果套用在實際的implementation也就是你們作業三其實就是要去implement這個那它的意思就是說你第一個時候假設這個是真正的假設這邊這個紅線是真正的CPU burst的長度但是你一開始如果你要proximate就是你根本不知道對不對所以說

你就會去猜說以根據它真正的結果然後去做一個調整所以這應該藍色才是真正紅色是我們等一下會預測的假的就是這個是你的預測值所以藍色假設是真的那我們等一下就跑剛剛這個proximate的aggression那你可能畫出來的東西就像是紅線這個樣子那它不一定會一模一樣對不對可是hopefully它會貼近

尤其是如果它是有一定的一些比這些趨勢的話比如說越來越低或是越來越高那通常一個很簡單的prediction algorithm也有機會蠻接近的好那所以紅色才是真的所以這兩邊CPU burst所以這是真的這是guessing所以藍色才是猜的那假設一開始所以一開始的話你一定不知道真正的burst是什麼就是

在這個零的這個時間點所以我們只能就隨便猜這個沒有什麼好的這個你看整個系統的吧但不是這個process的平均值那假設我們一開始先猜10好了，对不对那結果你就跑下去做scheduling所以不要忘記一個程式是有好幾個burst所以我們這邊寫10是指的是一個CPU burst它的長度那第一次它出現的時

候我們猜他是10然後就schedule了那schedule下去跑完了你可能才發現他居然才跑6個cycle而已因為我們預測值要低，所以你就套用我們剛剛的approximation的方式你就有一個觀察點了嘛那你就去按照那個去算對不对那算的結果你第一次是10就其實觀察到6所以你可能就把它做一個平均對不对所以就變成8

然後呢接下來你再跑就會發現它的這個值突然間掉到了4而已那繼續往下，所以你剛才猜的其實還不夠低那根據我們的這個之前的算法就是8跟10對不对我們會再去修正對不对所以就會把它修正成6所以它觀察到的其實是4而已所以我們就會再把history就是8然後上一秒是4對不对，所以就把它假設這邊的ratio是0.

5剛剛忘了講因為這是很簡單的case，所以假設我們history跟上一次observation的ratioalpha就是0. 5所以就除以就好了對這個平均值就好那就會變成6對不對然後以此類推6跟6這是剛好一樣所以當然我們就繼續猜6可是它有可能會再做變化嘛對不对那以此類推啦所以這應該沒問題啦。所以就是每

一次的觀察的出現還有你上一次的猜測然後用一個alpha來控制你下一次猜多少。那如果它的趨勢是穩定Eventually就有機會猜中就會approximate所以這就是實作的一個方式那我們剛才講其實有很多time series的prediction method所以你當然可以套用很複雜的然後去hopefully可以猜得更久。如果它隨著時間是有一些pattern的存在

你就有機會可以猜得更準。但過這是所謂的這個approximate的方式。最後一個這個其實蠻簡單的所以我們可以很快的講過去叫做priority scheduling。所以priority scheduling的意思就是每一個process我們就給它一個priority。那這個priority的值當然你可以是固定的也就是說你一create一個process你就assign比如說 OS process priority 就是最高使用者就是最低或是一些條件來決定或者是這個 process priority。其實也可以是 runtime

去改變的因為可能我們會根據一些它的 runtime 的 behavior 決定我的 priority 是要增加或是減少那樣就是這個 priority 的值也有可能會去改變，但是對 priority schedule 而言，不管這個值改不改變無所謂。它就是在當下我看见每一个process現在的priority是多少，我根据这个来做scheduling，那当然有一样会有pre-emptive跟non-pre-emptive，因为你有可能执行到一半，

有一个priority非常高的人join到这个系统，那就可能会打断别人的对吧。所以其实 priority scheduling它是一个比较general的方式，因为就像我们刚刚的例子shorted job虽然说它是我们知道它是根据burst的时间来做排序的，但其實你也可以把它想成是priority scheduling的一種，也就是它決定priority的方式是根據它的時間對不对去assign然後

一樣嘛時間越小就是priority越高，所以你把那個時間當作priority的值然後來去執行所以其實shorted job first也可以是基本上它也是priority scheduling的一種只是說它是一個dynamic的然後它是根據execution time來決定它的priority而已這之後我們會介紹真實的OS的話全部都是Property Scheduling因為它其實是最簡單的那不過Property Scheduling會有一個問題Stabation不意外因為你的Property如果很低的人就代表他不會被執行對不對那如果你不去做調整的話控制的話有可能有人很低的Property就會一直卡在那

所以事實上這是一個課本裡面提到蠻有趣的例子就是以前有一個IBM他是那種大型的server執行很多人的job然後你可以看見他從1967年開始執行然後到了1973年他retire這台機器的時候才發現居然有一個process從來就沒有被執行過在他的queue裡面等了6年因為party scheduling然後那個人也不知道是怎麼樣

不太在乎他的程式還是什麼他也沒有去抱怨他就一直放在那邊然後就等了六年這個就是Private Scheduling所謂的StarvationStarvation的定義就是說你會餓死就是說你想要跑但你永遠跑不到超過某一個程度就叫做Starvation所以Private Scheduling它必須要能夠解決這個問題解決方式其實一個很通識的也是很簡單叫做Aging所以這個你們作業三

我們announce之後去看你會發現你就要implement agent它的概念很簡單就是每過一段时间它没有被执行过的话你就把它的priority增加让它变老所以你要理让比较老的priority增加所以eventually就不会发生这种事情所以这是一般priority scheduling都会伴随着的一个方式就是会有agent的机制然后才不会造成starvation好那我们今天就上到这边嗯.