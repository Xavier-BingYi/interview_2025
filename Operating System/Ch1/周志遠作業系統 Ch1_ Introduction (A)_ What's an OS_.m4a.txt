undefined
我們昨天開始要講OS了，所以上一堂課我們介紹各種各樣的系統唯一的一點就是希望讓大家知道其實很多系統的存在而且Hardware的變化其實非常多不斷在演進的，但你會發現呢不管是什麼樣子的電腦系統，它一定要有作業系統的存在，否則它一定沒辦法執行沒辦法讓使用者來使用，那這些作業系統它一定會有些核心的問題就像我們剛剛說的那些怎麼樣

讓使用者共用怎麼樣有能夠跟他做interactive那，所以就會有作業系統這些很基本很基本的component跟subsystem那些就是我們作業系統課要教的，那很多的電腦系統其實是special purpose，我們說它有很多其他的requirements所以這作業系統還有很大的發展而且不斷地在演進因為它必須要不斷地adapt這些不同使用者的行為需

求還有硬體不斷有新的technology出來，那你就有不同的設計那一塊我們當然不可能去講它對不對，但是其實都是我們上課教的東西的衍生而已，所以是很重要的一些concept好，那麼我們就來介紹作業系統第一個當然要先講一下到底什麼是作業系統你可以我們會從很多不同的角度它的角色半個角色來看一下所謂的作業系統到底是什麼

東西那接下來我們會先講一下這個作業系統我是不是說電腦整個系統作業系統就在管電腦所以一個基本雛形的這種電腦，它的基本架構是什麼作業系統用什麼樣的一個基本的方式去管理一個電腦，那最後我們會講一下怎麼樣去保護這個電腦的使用，但這邊的保護要注意，這是Protection不是Security，所以還記得我們說早期的說Personal Computer的OS其實他在Security那邊做的是非常多的缺失缺漏對不對，

那可是這邊的protection則是什麼呢，是說在正常的使用情況下使用者不會影響到別的使用者簡單講就是，如果大家同時在使用台電腦有一個人的程式，他crash掉了那你不能造成別的整台電腦的crash，因為如果你整台電腦都crash掉那其他使用者就被影響到了，這個叫protection，所以是非常非常基本的，因為所有電腦都是

剛才提到的已經都是多工多人在上面的，所以怎麼樣子可以保護這個電腦，讓大家在上面正常的使用的時候，你定義的這個電腦架構或是管理架構下去使用的情況下不會互相的影響對方，這個是我們這邊所謂的protection，所以這是非常基本的，所以我們會放在這個introduction來介紹一下，但不是Security那個

惡意的啊透過網路啊那些就不在這個範圍內了好，所以什麼是電腦系統什麼是這個作業系統，那當然就要先從整個電腦的組成來看起對不對，那實大家一定都很清楚天天在用對不對，所以你要這個一個電腦的系統，它在運作的時候呢，第一個，你一定會有user嘛對不對使用者來使用這台電

腦那，這個使用者，他要透過什麼樣的方式使用了當然都是透過應用程式對不对，那這應用程式，其實你可以把它定義的廣泛一點，不一定一定要是，比如說一個GAN或是一個Word的Editor，它也包括了像是一些Compiler就是，你只要透過任何其他的Program來達到你的目的的，你廣泛講一點的話，你可以把它全部

就叫做Application那，所以當然你都是目的就是要在電腦上去執行這些application，達到一個user他所想要達到的目的對不对，那執行在哪當然是Hardware囉，這是一個非常非常粗淺非常非常基本的一個breakdown所以當然，你run的這些軟體，要run在Hardware上，那Hardware不外乎就是我們知道的CPU、 memory啊Io的Device啊等等這些Hardware，那中間是什

麼呢，它會完全會特地切開的，就是我們的OS了，所以你的電腦，切到非常非常粗非常非常基本的這個組成的時候，你會發現OS仍然在那個地方，因為它就是連接使用者的application跟hardware這些resource中間的橋樑你要透過OS的管理才有辦法去使用或是共享這些資源然後來執行你的程式所以OS其實就是

介在這個我們常說嘛Hardware Software中間的這個就是OS的角色好那當然我們可以再把這些定義再稍微再講細一點的話其實像User也不一定只是說使用不是人其實也包括了Machine或是一些其他的Program其他的Computer尤其是現在這個時代還記得我跟大家提過未來十年最火紅的議題叫做物聯網指的就是物

體跟物體任何Device它直接的去做溝通每個Device它會能夠運作就代表它其實就是一個電腦就是有OS在上面那他們的溝通是直接的所以沒有人在Involve在裡面像自動駕駛我們車子它要跟很多的Device溝通它才知道它自己該怎麼走或車子跟車子之間要溝通那所以那些也就是user就是整個這樣子

自動駕駛系統裡面的user其實就是別的自動駕駛的車子所以其實也不一定是人那application就剛才說的其實廣泛地講就是它就是解決一個computer上要解決的問題的這些你需要用到的軟體就全部都可以叫做application好那下面哈維爾就不用講哈維爾呢在我們OS的世界里我們其实比较喜欢的是把它讲成叫做资源所以我不care它是用什么样子的device提供的我只care是它提供什么样子的资源有多少量的资源我可以怎么样

子去allocate跟分配有些资源是我一次就要整个资源就要独占因为Hardware的限制有些是可以做切割变得更细的去分配那所以這些資源當然不外乎就是CPU我們通常就講就是Computing Resource對不對計算資源Memory對不對這種儲存的資源而且是我們說主要比較快的儲存資源IoDevice就

是一些Io的資源你要Input Output資料的資源所以像你的Disk或是Network這個Bandwidth你可以傳多少資料傳出去這就是資源這些都是由Hardware提供的這些資源好 那作業系統我們說了他就是坐在中間他坐在中間他扮演的角色其實你又可以把它從他的角色上可以把它分成所謂的Control跟CoordinateControl的意思就是單純的是控制也就是說你今天run任何一個application你現在要 我要CPU那我要透過OS控制我的CPU讓他可以去使用

這些computing的cycle就是單純以一個使用者或一個application的角度我需要OS幫我控制來去使用對不對那另外一個角色就是千萬一直不要忘記電腦系統都不會是只有一個人對不對不會只有一支程式都是sharing就是這樣子才會讓整個系統變得這麼的複雜就像我們說第一代的Batch一次一個人

根本OS不需要做什麼事啊因為沒什麼好管理嘛一次一個人沒有sharing的概念所以事情都簡單了，但那當然不是現在我們符合需求的作業系統我們一定會有非常多的程式跟人在用所以他們都要共同去競爭你要CPU我也要啊怎麼辦OS所以OS就是在中間要做協調coordinate這樣才能夠讓大家都可以在上面使用

而且是可以滿足符合大家的一個需求所以它叫coordinate所以像剛剛我們才問嘛time-sharing何必要time-sharing何必我這樣子切得這麼細它其實我們之後會講它會造成overhead就是說它會讓它會浪費掉一些計算資源的並不是以系統角度並不是一件好事喔，但是對人的對使用者的角度那是我們想要的因為我們希望大家可以同時在上面用

所以用那樣的方式去coordinate大家如何來使用CPU所以其實這兩個字的意義是不太一樣的應該感覺到control是只是單方向要控制它coordinate其實是作業系統更複雜的部分就是怎麼樣子去協調大家怎麼樣去分配資源所以很多的研究倒不是在control而是在coordinate控制就是你想寫寫driver嘛，那實就是那樣子你就可以control了。那By the way 這個東西不是要大家invade這些，這個定義你可以

想這只是描述啦，所以就像我們說的，你要講是你要能夠把那個意義在你的用你自己的方式去回答，就可以任何符合那個意義的都是一個正確的去解讀它的方式這不需要去invade它只要大家能夠體會那個為什麼我們說會把它說control跟coordinate這兩個角度就可以了好，那第二個呢純粹就是以我整

個電腦系統有很多軟體嘛，application裡頭就一堆的軟體，那我這個系統本身也是軟體，所以這個軟體OS這個軟體有什麼樣特別的地方呢，所以它另外一個很特別跟其他所有的軟體的區隔在於它是一個permanent的一個software也就是說這台電腦只要一啟動你一定會看見OS它就會一直坐在那邊當你的OS不見的時候，這電腦基本上就是不會運作的，所以你可以

想見所有其他程式都沒有這個特性所以OS，你可以講它其實很容易區別就是它也就是OS會存在在那邊然後是介在兩個中間的然後去實現Control跟剛剛說的Coordinate，因為它介在中間，所以你會發現一件事情是其實OS這個軟體，它是非常非常特別的軟體在於它其實是製造一個abstract stract或者是使用的假象讓使用者來去使用這些電腦所以它其實就像一個virtual的一個machine的interface一樣

就像大家寫程式都喜歡call API程式就是這樣做出來的所以其實OS的角色其實就是在把下面的Hardware把它抽象化之後變成一堆的API讓上面的使用者去call對不對所以那個API是什麼樣子的定義就會完全決定上面的使用者或程式對於下面的這個電腦他所看見的使用的方式了所以我們說它

其實是個interface是一個API大家寫過C嗎寫過都知道interface API的意思其實OS就是這樣它就是把hardware它是hardware或是你下面這個電腦資源的一個API一個interface所以它其實本身它就是一個virtual的一個概念了我們會不會稍微再講一點大家應該也聽過了Virtual machine現在很紅很多人也是在使用非常popular的技術其實某

種程度來講這是很自然本來就是這樣OS它就是當然可以不斷的一個Layer一個Layer的上去去搭建因為它就是一層一層的Interface那當然它主要是要抽象化是抽象整個電腦的資源的部分好可以嗎所以這個是OS它的非常不一樣的地方好那所以剛剛這個抽象化意思就是比較接近Control那一塊，因為你把它抽象成那樣子，你就可以

使用著按照你定義API去Control跟使用那個資源，那另外一個Coordinate的地方。你從這邊也可以很明顯看到了對不對，就是我們知道其實你畫出來一個電腦OS是只有一個的，那上面會有很多的Application，那些實他們都必須要透過這個API才能夠去使用。所以當他們透過這API的時候會go through同一個OSR，所以這個OSR在這個時候就可以

動手腳來決定我要怎麼樣子去分配跟實現這些動作了。所以就像你去執行一個程式，我要執行一個extraction他也要最後會去哪會去OSR，所以OSR會決定我現在要把這個time slot這個CPU cycle給這個程式還是那個程式，這個時候他就在做coordinate的動作了，因為他們都必須要透過OS的API，所以OS這個程式它就可

以完全去控制了。再一個， 剛才這還比較concept所以我們就來看各位在這邊寫程式的時候是怎麼跟OS互動的，所以你可以看見其實電腦上面的任何的運作一定其實都是透過OS有時候你並不會感覺像你們大一大二的時候在電腦上寫程式嘛，他compile wrong結果output出來你就很高興了，這個OS在哪好像不是太清楚對不對

什麼時候我我為什麼什麼時候去call到OS的可能都還不是很了解那我們就來看一下他到底是發生什麼事所以下面當然是hardware上面就是各位寫的程式對不對那有什麼是U-SERMO什麼是Kernel-MO我們之後會講基本上User Mode指的就是各位寫著程式或使用的這些Memory空間Kernel指的就是OS這支程式它自己去

使用的空間跟資源所以我們說嘛程式就是你可以切成就是作業系統跟不是作業系統所以會有兩個Mode後面會講更多那你要run在一台電腦上你一定會碰到一些IO或是這些所以當然Hardware上就像我們所知道的要有Driver那Driver其實是Part of OS因為你要控制只是為什麼要特別切開因為就像我們

知道的Driver是不斷的可以Install的因為實在太多樣化的IoDevice了對不对所以每一個Device可能需要自己寫的Driver所以它在OS的架構裡面你會發現它在最下層然後可是一個可以抽換的所以當然你就按照需要你就可以要先Install Driver你才有辦法去最基本的控制嘛那所以Driver其實是Part of OS只是說它比較單

純一點那Driver上面當然就是真正的主要的OS是我們這堂課要講的這些怎麼管理Memory怎麼管理CPU等等的這個軟體好那這個軟體呢就像我們剛才說的其實OS的目的是什麼它在Implement一個API讓大家來去使用就像C Language他implement那些API function code一樣所以OS其實就是提供一堆API而已那這個API就是我們俗

稱的system的library或者說我們後面更常見大家叫他的名字叫做system code很職業了當system的function code system code所以system code我們都會講會是非常非常重要的一個名詞因為那代表的就是OS的interface的API各位的作業一就是要去implement APILibrary大家OK嗎應該知道對不對Library就是你定義了很多的function嘛然後把它包在一起的那個檔

案我們就稱之為Library所以你要去用C Programming你第一件事是什麼include C Library嘛所以你就可以用C Language幫你寫好的那些function code嘛對不對所以這也是同樣的道理其實OS它會把它package起來變成一堆四聲Library然後在那邊等著你去使用我們回到各位寫的Program各位寫Program當然第一件事compilecompile的目的只是把自己的程式從language變成你的machine language所以就是大家知道的.

odoc有時候你太自動化了可能你按一個鍵它就全部都build完了但是請大家可以回去看一下其實是拆開來的你可以先compileCompile完之後你會做下一件事情Link 對不對那Link的目的是什麼咧大家應該也是知道Link的目的就是把這些Compile好的這些. o檔Binary file把它給Link在一起為什麼要Link就代表你要去使用別人implement好的程式嘛 對不對所以咧其實在Link這個動作它通常不是它其實不是指Link你在程式碼裡面寫的C Library或那些

他一定會自動link的東西是誰System library所以其實這個時候他就會去link system library了那Link到system library之後你才成為真的能夠執行的一個完整的執行檔所以為什麼一定要Link呢？簡單講像各位程式寫個printf，那printf不是要output到screen誰負責output到screenOS不是C library用，所以其實他必須要去code到System library裡面的System code，所以當然要

link到System library了。他可能不是直接link到他可能是先link到C的library然後C的library裡頭說我要用到System library所以他可能間接地eventually他其實會link進去的等下我們講System code會更清楚，那所以這樣才成為一個能夠執行的完整的檔案然後你的電腦才可以開始執行，所以執行的過程中你就會Call到Printf，Printf會Call到System Code，System CodeSystem Code會Call到Driver然後就下去了，所以其實是經過OS的，所以其實是都是有在使用到的，而且就是透過這一層System Library或者是OS Define的這個System Code，

只是因為包得太多層了，所以各位沒有直接看到而已，所以這不管在什麼電腦系統其實都是這個樣子的，所以一定會透過OS你不link system library除非是你真的真的完全不使用到OS的code，基本上大概沒辦法執行任何的東西了，

所以剛剛那個圖就比較重要了，我們沒有給什麼定義，但是那個整個Program怎麼樣在電腦上面運作這整個流程，這個是很明確的，這個就是應該要好好把它記起來的部分，那所。以同時我們剛才講這些，如果我們今天要Define OS，你會怎麼去定義它呢？有人就說這應該叫做Resource Allocator，就像我們說的，整個電腦系統的確，它的角色就是在分配資源，

但是資源是任何的硬體，這個不受惠那所以他就去manage對不對然後去allocate，讓大家可以很有效的去使用這些資源，然後又可以滿足公平性啊或者是即時性啊等等的一些使用要求，所以操縱作業系統就在allocation啦！你會發現memory management在幹嘛，在做allocate memory嘛！ file system在幹嘛，allocate disk上面的storage blockCPU在幹嘛，Allocate CPU Cycle給Process所以全部都在做Allocation第二個

部分就是單純我們要做的Control這就比較Practical的角面，這個角度去看它，它就是幫我去Control就對了，所以它可以有Driver這些東西，讓我可以去Eventually控制這些Hardware控制的目的就是使用它讓它可以去做我要做的事情所以它其實又很像一個Controlled Program，但是這邊通常問題比較小，這就剛才說的多半是苦功啦！不同的

Device你要怎麼Control還有它的Spec等等你要寫它的Driver這些東西第三個前面兩個大家也是一樣不需要實際不是說OS就叫Resource Locator實際上也沒人這樣子直接喊它的啦只是它的概念這個就要請大家記起來囉KernelOS的別名就叫kernel就是它的別名事實上比較多的人是用kernel這個字來形容作業系統不會直接寫說我在裝一個OS那可能大家都

說我在裝一個kernel我在用什麼kernelkernel其實就是OS因為就是核心所以我們常常就叫它kernel因為它就是所有東西的這個核心的這個soft叫kernel其他的就不是kernel的意思就是那些application啊compiler啊那些突破圈啊等等的東西好所以這邊again啊這只是讓大家這個不需要背起

來所以kernel這個名詞知道它就是OS其他就只是它的代表的角色而已並沒有人一定要說OS的定義是什麼我們作業系統就這樣它是一個概念所以這個概念代表的意思大家知道就可以了那不過OS我們就叫它Kernel所以作業系統我們現在寫一個Kernel的時候我們要考量什麼事情我們今天如果自己要去開發或是要去選擇一個作業系統的時候

你會發現作業系統基本上它就是你的需求使用者的角度通常就是希望兩件事，第一件事， 方便尤其是越是commercial的product越是接近人的這些產品，這個convenience是非常重要的。這也是WindowsMicrosoft的崛起對不對，因為當時他是第一個是圖形介面的所以很多人就覺得非常方便，他可能根本不會，又不是CS background那時候也沒那麼多人學，所以只是想要用所以方便性就算在今天我相信大家的同意非常非常重要。第二個

角度咧就是比較需求面啦，比較這個對不對你，如果執行一些比較複雜的程式，比如說你跑一個game，你總希望它動作快一點不要一直delay吧。對不对，所以或是說你在run個程式，你當然希望它越快可以執行完越好所以就是efficiency或是說performance 對不对，所以並不是好不好用，而是它到底有沒有效率這是不是有一個很有效率的電腦，那早期的作業系統當然比較偏向efficiency所以像各位

這個上課使用的電腦，這個我們用Linux的Playform，我們不用OS為什麼很多原因，但是其實效能也是很重要我們不需要每個人還在那邊Display這些Image到自己的電腦對不对，那個都要浪費資源的所以大家就comment line打一打就好了，不需要去這樣做，所以Efficiency其實也是非常fundamental amental其實當你要解決尤其是要解決一些比較複雜真的是比較

需求比較高的時候那其實efficiency是你最後要追求的東西那所以這兩件事情都是我們人想要的但是很不幸的是這兩個一定是contradict就是他們兩個一定是相反的因為當你想要越方便的時候呢它方便跟效能是無關嘛它只是為了人所以它等於是多加了一些東西讓人或使用者覺得方便但是沒

有其實沒有適合實質的注意在效能上那你加了這些東西一定是方便啊可是結果是什麼咧就是你多加東西它就會變慢嘛這是一定的就像你要Display GUI的介面圖形介面那你就要滑Resource 滑程式所以它的速度就會慢下來所以這其實是一個Trade-off所以就看你是什麼樣子的電腦系統使用者care的是

什麼東西當然就會去做不同的取捨有的作業系統像我們說的Windows手機的convenience是非常重要的那如果你是要跑一些大型程式科學計算你要去解一些很複雜的問題那你就會想要用這種efficient的作業系統好那所以當然就像我們剛才說早期其實當然大家只care efficiency不是每一個人都可以使用電腦不普及所以當然

Efficiency是一切花了錢就要看到它的效果但現在因為價格嘛很普及還有很多其他的 Purpose所以其實方便性變得很重要，但都是在取捨，就像手機對不對我們知道方便性固然重要啊，但是它的耗電對不對我今天我吃那麼多電，我可以完成多少工作量？其實那也是Efficiency的一種對不對的一種概念，所以你也不希望它跑一跑然後沒電哇那你也不會想要這個手機啦對不對

所以這個OS是一個取捌在這邊，所以這個作業系統為什麼它是這麼的重要？所以我們知道大家想要它實現就是剛才說的方便然後要能夠效率好，但是當我們設計一個作業系統的時候為什麼作業系統這個軟體是在電腦這個世界也是這麼重要？這邊可以看到幾個原因，第一個就像我們剛

才說的，它是使用者的 Program跟 Hardware之間唯一的 Interface，這個是系統架構就是這樣，這是不可能改變的，這是Only的 Interface，所以你可以想見你今天可以在一個電腦上選擇我用C Language做 Programming還是 Java或是 Python對不對好多好多選擇現在這個倒是Open Source各種 Solution，但是如果你講到OS那很抱歉就是一個看你要哪一個而已那

你如果不要別的你整個東西就要重寫或者是你就要重新再去調整因為它是唯一的 interface所以當然它就掌握了上面的 Application 對不對你要透過它嗎第二個作業系統這個跟一般程式它比較困難的原因在它絕對不能夠壞掉不能夠有 bug所以各位寫的程式呢相信都有不少 bug就算一般的Commercial或是

我們一般用到的軟體就算Enjoy這些上面的App常常一定多少多少有一些Bug然後去Fix它很多Bug可能大家不在意嘛反正Risk就是重新再打開那個網頁就好之類的可是OS不一樣它今天如果一Crash掉就好像我們說整個電腦大概就沒了那不只是電腦沒重點是這個電腦的狀態就沒了上面實行的程式就都沒了

我相信大家都很痛苦所以當然很多軟體就是要為了這些事情當然也會去backup等等但是OS基本上它的原則是不能夠容許任何bug的因為它要有bug那就代表整台電腦就是毀了所以OS是非常的重要的一個部分對不對好最後一個OS很重要的原因就是因為它是唯一的Interface所以你其實會發現在電腦的發展過程中它這個OS的Technology如果你

能夠控制OS也就是你是提供這個OS的廠商的話基本上你就可以掌握上面的Software的開發還有下面Hardware的開發最後是最標準的大家就回想到之前為什麼Microsoft是最有錢的公司因為它只做一個OS可是上面所有的application如果想要run在Windows上的程式就要follow它的API嘛對不對所以

如果它不開一些後門不去做一些調整幫你去做一些特殊的設計的話那個application run在電腦上的效能一定是會比較差的所以它其他可以去控制同樣的Hardware也是因為它阻隔在中間嘛所以Hardware的設計就要跟OS做搭配所以我們一直有知道我們電腦產業叫WintelWindows加Intel有沒有Wintel大家都

沒聽過現在知道Wintel這個時代都快過去了所以指的就是這兩家公司Hardware OS的結合他們的所有電腦就是這兩個搭配所以電腦的效率等等才可以達到比較好的程度如果Intel要搭配各式各樣的OS他可能也沒辦法都做到很好相對的你去看MacApple它的差在哪裡就是它Hardware software都

自己做嘛大家知道它就是Hardware跟OS都自己來所以其實它也是必須要很強的配合的它就是自己來了所以OS其實是相當重要的好那對啊所以基本上它當然也不是說OS就完完全全控制Hardware怎麼做當然也不是就只是說它們會互相影響所以要互相的去配合當然隨著使用者的需求不同OS也要調整最佳的例子就是手機我們等一下會看見各式各樣的為什麼

會有各式各樣的OS跑出來為什麼手機的OS不就是裝在電腦裡的OS因為需求不同所以它要去做調整因為你的Hardware長相手機就是手機你不能強迫它變成PC所以OS就要去配合去調整所以其實當然他們也是互相去影響只是它的這個OS的重點是它只有那一個不像Hardware你可能會有

很多行星設置會改變Software改變可能更快不同的Application但作業系統OS畢竟它就是那一個所以當然它的影響力就很大像手機當然也就是iOS跟Android對不對所以你也很少看到其他的所以就像我們剛才講的其實OS是形形色色的那當然早期的基本就是這些X86的那X86的話早期不

外乎就是Windows大家很熟悉的另外Linux其實是當然是最長其實最久歷史的各位的程式這堂課也會去用它只是比較少用到是因為它當然比較並不是跟使用者intel為目的這樣的server但其實一直以來都有的以前都是Windows跟Linux當然Windows一般使用者喜歡但是真的大型的系統重要

的系統恐怕大家還是屬於選這個Linux跟它是Open Source當然有很大的關係再來就我們剛才說的這些Apple的它自己來所以就是我們知道它的這樣的作業系統這當然就是比較不一樣再來就是隨著時代的改變啦，所以就有手機的對不對，所以這都很熟Android、iOS講Windows對不对它就做調整，你有Windows 10，

但是你有Windows 10的Mobile，它其實就是把它做修改讓它可以跑在上面那像Linux這邊，這幾個有興趣大家可以自己去看一看，這都是非常常見的，那所以像Ubuntu可能現在更多人用，那它也一樣，它也會有不同的版本，就是要調整然後Embedded，Embedded跟這個手機比較不同，在於手機是非常因為太多使用者，所以它是專門為了就是手機就是手機Embedded，就非常廣泛的，所以是任何嵌入式系統尤其是未來我們說是物聯網的世代，所以你那個物體是什麼

device形形色色那些全部都叫做Embedded所以上面當然就需要OS，那這個OS就必須要很flexible，你可以想見它可以很快的有新產品出來，OS都可以裝得上去，然後甚至於可以去調整很快的調整讓它不要的部分拿掉要的部分留下來等等，所以是當然就是不一樣需求的，這樣子一個作業系統，那所以你要說手機這些事當然也算，因為手機也算是一種embedded，不過這裡就要注意到，它可能更general一些，那甚至於有些OS，這些OS它不僅僅只是純software，

它是綁在那個Hardware上的E mbedded System所以像是Xbox有些大概不是PS3 PS4這些啦，所以這實上面都有作業系統，那個作業系統也都是Embedded的OS。那另外，這個未來大家或許有機會碰到，如果走這些比較走到Device端的話，你就會知道一個叫做Roseberry Pi的作業系統，這是非常Popular的。它就是個板子，那上面就可以去刻各式各樣的

這些很小的板子，它可以各式各樣的一些應用，有時候大家就是把那個當作雛形開發，然後去開發各種應用產品等等還有軟體等等的這是 Raspberry Pi，它就是一個板子。 Raspberry Pi 的板子上面有 Raspberry Pi 的 OS，然後就可以開發各式各樣的切入式系統的雛形了。所以其實有很多很多 OS，那就像我們之前說的啦基本是一樣的。其實是沒有差太多，只是你大家可質化調整好 OK，那這個我講先不問了，所以這個我們剛剛提過的就是一些描述這個很概念，所以希望大家不是不是要把上面的字背下來，是只要能夠把那個概念，它的意義能夠了解就可以了.