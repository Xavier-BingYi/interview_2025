undefined
我們剛才講完Memory，所以 Disk我們知道現在最常、最普及存資料的地方還是在 Hard Drive那 Hard Drive的特點就是它其實是機械式的，它不是電子式的所以機械式的意思就是大家其實都應該也知道其實我們的 Hard Drive裡面俗稱的硬碟裡面其實是有磁頭的，磁頭的讀寫，所以其實就像這邊一樣，其實你會有一

個這個這個讀寫的手臂上面會有很多的磁頭然後你可能會有其實會有很多個磁盤在這裡的，那它可以同時的對這些磁盤做讀寫，而且它是機械式的意思就是它其實會轉動然後磁頭會移動，所以你才可以讀到這個磁碟上任何一個位置的資料那重點是因為它是這樣的一個機械的架構

所以很明顯的今天你的資料的位置在哪裡跟你讀取的時間有絕對的關係而且這沒有一定哪邊就是快或慢，因為有可能剛好磁頭就落在這個位置你要讀的資料在附近它就會很快，如果很不幸你剛好在對面那磁碟就要轉過去才能讀，那就會有一個access的時間，這個我們後面在講 Storage那邊當

然會講得很仔細，但是基本上大家知道就是其實這種像這 Hard Drive的話，它讀取時間我們會把它切成所謂的 Transfer Time跟 Position Time，那所謂的 Transfer Time就只跟資料量有關，所以當然你的資料量如果越大，當然你要讀取的東西越多嘛花的時間越長這是一定的，但是呢它就會多了這個Position Time而且這個PrecisionTime是跟你目

前SigTime就是你去找那個資料的位置的那個時間有絕對關係，所以它的時間不Uniform所以我們不會稱之為Random Access的，不僅它不是Memory，它也沒辦法Support Random Access太有效率所以這個你可以看見這個SigTime就是它在轉動所以你會發現你買硬碟你會看到什麼7200轉3600轉我不知道現在7200還是最快啦，但是越多轉數你

會發現價錢越高為什麼因為越快嘛，所以大家就會去看那個東西以後大家去店裡面看這些產品可以留意一下不然花錢不知道花到哪裡去了所以這個就是它的SIGTIME可以變短所以它應該讀取會更快一些，那像RAND，因為它就去掉這個，所以它才可以UniFORM那像SSD我們知道的為什麼它會快為什麼我們說它Performance好當然第一個它是這個電子的嘛，所以我們知道它就像跟Memory很像對不對

只是它資料不會遺失對不對，所以它這個是電子式的所以比較快另外呢就是它的讀取速度當然就沒有這個問題所以就去掉了這個SIGTIME所以它的效能啊等等就比較容易預測所以如果它是rand om的SS在SSD上其實我們知道效能就會明顯的比Hard Drive好可是喔如果你讀的資料是連續的其

實當你的資料Size夠大的時候對不對Transfer Time一定會Dominate你的Positioning Time所以它也不會差到哪裡去喔這是實際上大家會去Benchmark會發現的實際去測試會發現當你只是Sequential就是連續的資料讀取連續Physically它放的位置也是連續然後這樣讀過去的話Hard Drive並不會輸SSD太多SSD贏是贏在當你資料讀取是跳來跳去磁頭這邊會有很多造成浪費的時候

SSD才有好處當然大部分的程式尤其是booting有沒有一些control的程式就跳來跳去所以大家很多人買了SSD要裝什麼東西在上面比較貴嘛你買一個很小的空間你會裝OS然後你的檔案咧這個檔案系統你要空間大然後你資料有時候讀一大堆嘛其實就會把它放在Hard Drive系統設計了你要

怎麼樣去使用這些不同的特性的Device好這就是我們說的Hierarchy啦所以通常大家就說時間嘛Size啊等等啦所以你就會發現它就是當然就是越左邊的越左邊的是越快嘛空間越小等等所以你可以看到Size它的改變還有Access Time還是最主要的因素好，那我們說我們的Storage其實是有一個Hierarchy，所以為什麼要Hierarchy？怎麼樣去把它們去應用的方式就是我們的電腦的儲存Data Asset這邊其實都有用所謂的Caching的概念所以意思就是說我們的

資料Eventually其實是做在可能是最慢的那一個上面因為空間最大，所以所有資料最後最後其實都會存在那個最慢空間最大的這個Device上，但是呢如果你每次讀都要去這邊讀就很慢所以我們就會有一個Hierarchy讓他把資料在讀取的過程中你既然讀了那我就把它Cache暫存在做一個Copy然後暫存在比較快的Device上面對不對，

那你用到的頻率越高的通常呢我們就會把它Cache到越上層對不对，所以其實它每一層每一層這樣一直上去的這個大家其實應該都有這個基本基本的概念其實也大家都知道所以register最後是最快，所以我們才會有L1 L2 L3的cache就是加速我們CPU的計算這樣子，所以這個概念就是所謂的caching就是

將你的device從比較慢的deviceCopy 請注意是Copy喔不是搬移喔，所以你還是有一份在後面喔，如果你今天是搬移我們不會稱之為cash喔，cash的定義是你只是單純的Copy而且那份Cop y的資料是一個暫時性的所以它隨時你可以把它砍掉都不應該造成你資料的遺失那個才叫做cache好那但是因為他有很多cache

所以你要make sure他的資料其實是必須是這個一致性的那我們等一下會看見所以說如果今天有cache的話運作就像這邊看見的我們在做data access的時候一定從CPU來那CPU他就會拿最近的那一層去找資料如果有他直接讀所以會快沒有當然就往下一層下一層沒有他就會再下一層所以一層一層的往後看Eventually資料不會掉所以他會找到然後呢但是他讀回來的時候

呢他就會被cache住嘛所以他其實這時候其實會變慢一點如果你是cache是一個miss的話他其實有時候會比沒有cache還會更慢因為我們知道他必須要一層一層檢查而且回來的時候他還要做copy所以這就是一個copy是一個花時間的動作所以他其實可能就會變慢可是我們的目的就是我們知道人還在用電腦所以其實人的程式的特性遠重於重要於系統它本來的這個目的所以我們的

access的data其實都有pattern常用的東西就是那些所以你cache一次或許很慢第一次miss很慢可是之後會非常非常快所以total總和起來你會發現cache還是有助於整個系統效能的因為使用的特性今天沒有使用這個特性的話Again你要重新想一下我的Cache要怎麼設計我要不要Cache事實上現在有些系統呢它是

沒有Cache的因為Cache一點作用都沒有還會把事情變慢最簡單的例子稍微跨出OS一點了大家可能知道巨量資料很熱門的我要處理很大量的資料然後來做一些應用因為資料量這麼大所以你讀這些資料的時候你一定是少過一遍就丟掉你不可能在那邊來來回回看來看去或者說他一定大

到你的memory都塞不下那這種狀況下你還要cash嗎不要啊因為沒有1億嘛你讀完你下次回來他已經滿了那你早就被丟出去了所以處理這些巨量資料的系統他們的這些系統裡面他甚至於就是沒有cash他資料不cash他會效能更好一點所以不是always要cash的好那回來這邊就我們剛才說的cash的定義他只是copy他只是一個分身所以你不能夠跟本尊不同對不對

那如果不同那你就會有所謂的coherence的問題就是cash雖然對系統是很好可是他很討厭的就是他會有coherence或者說我們說consistency的問題也就是不一致性那所謂的不一致性對不對意思就是說它只是copy可是如果你在對資料如果今天對它做修改的話那我們說你又是修改最上層嘛對不對所以你可能只是修改Cache的還沒有update到Memory所以這時候Cache跟Memory它的資料裡面的內容就會不一樣那其實呢在電腦的系統運作當中它們不一樣是可以的

因為最後care的只有使用者所以就算我存的時候他可能目前還不一樣但是我只要在這個電腦系統上執行的程式他們看到的我如果能夠guarantee他保證他看到都是最上層那個大家看到都是一樣的值的話其實電腦還可以繼續運作或者說使用者還是可以繼續的執行他的program是沒有關係的所以重點是你怎麼樣可以讓使用者看到一個consistent一致的這個值

這個是一個問題至於你要你當然不可能同時把所有的copy做修改所以一定會有些delay然後有些技巧在裡面但重點是你仍然要保證上面的program看到的是一模一樣的值所以才會我們之前說的Multi-core processor它就要去處理cache coherence的問題因為大家的L1 cache是不同的L2 L3其實是相同的應該要是同樣的值所以怎麼樣去把它做

Sync把它變成一致就是一個需要去處理的問題好那這個Data Consistency的問題如果今天是只有你的Data只有被一支程式去處理去Access去讀取的話其實通常都不會有問題就是你怎麼Update它你再慢Update都沒關係因為我們知道這個整個電腦架構CPU讀資料就是一層一層它也不會跳所以說你今天只改最上

層的那你下次讀當然他也只讀最上層的他不會去讀後面嘛，所以這個coherence的問題其實就不會存在，但是很不幸的就是我們都知道的，實我們的電腦系統不是只有一個人一支程式，他們都是很多在跑而且他們很多的資料也就是memory的content是shared的，因為大家只要有pointer其實你都可以去access的到，並且

很多程式是故意是需要用share的概念去執行的，所以就是要讓兩隻程式可以看到同樣的資料，像是我們後面教的Multithread ProgrammingThread的概念，它就是要share這個Memory的Content所以這個時候就有問題了或者是我們說Multi-core的Processor你的Cache是不同這個時候就很難解決了，所以你的程式有時候可能是跑在第一個Core上面跑一跑它換到第二個Core

他們看到的cache是不同的cache那這個時候你就要必須解決coherence的問題所以重點就是我們的程式這個電腦設計必須要符合程式的邏輯對不對這個程式執行的邏輯，所以邏輯是資料應該是相同的，他們只是copy所以不管怎麼樣這個電腦系統必須要製造這個假象確保這件事情

所以我們才說這個問題。你越擴大的時候就會越複雜到了像是你這個這邊指的只是同一台電腦很多個Core或很多個程式那到了分散式系統是根本是不同的電腦雖然是不同Memory可是我們把它串在一起的目的就是讓他們以為是同樣的Memory所以這時候問題就會越來越大因為像到了分散式系統你還要考慮什麼網路的問題隨時網路會斷線

在這一台電腦我們的Memory Bus不會斷的可是分散式系統越跨網路網路是不穩定的所以這個時候你要仍然怎麼樣讓這個電腦系統可以正常運作然後確保Consistency這個其實是一個很大很大的問題那又多誇一點了就是大家也知道像Google大公司他們做這些分散式系統或是雲端計算為什麼可以漲到這麼大

電腦系統還可以運作其實他們後來的選擇是放棄consistency因為他有些應用是不care的就像大家在看網頁你看到我看到的真的一樣嗎一定不一樣吧同樣的網址打下去各種版本跑出來對不對為什麼因為其實也不影響使用者所以他們為了可以去避開為了讓他的系統可以漲到很大他們最後決定就是放棄consistency因為其實對於使用者而言那不是那麼重要的事情

因為如果你要保證這個，你就要很多的溝通所以一台電腦改你要告訴所有人都要改那這個不得了。如果你要告訴一萬個人那一定是沒有辦法很快的。所以這個就是consistency其實是一個很大的issue好這個大家回去看一下就好了這邊應該是比較大家熟悉的對不對 Cache然後這些Storage的Device.