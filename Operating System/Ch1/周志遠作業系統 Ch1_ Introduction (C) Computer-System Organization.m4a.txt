undefined
好，所以其實上一個上一次我們講的一開始，這些都是很基本的introduction就是介紹啦，那那個東西就是像上次說的，不需要死背，但大家應該去好好的想一想裡面我們講的這些東西，是不是你在使用這些作業系統的時候真的有如此的體會，所以你要先知道作業系統是什麼，我們才去看裡面到底做

什麼，所以很多時候只是使用所以你知道他在做什麼可能更重要怎麼實現這些detail那未來你們如果走到比較系統領域或是比較深的時候當然才會更需要知道變得更重要好，那我們就回到上次我們這個最後時候提到電腦的這個運作的方式對不對，那就有提到以這個IO從這個硬碟我們說把資料讀出來或寫出去，當作例子來看作業系統或者電腦運作的方式到底是什麼

所以上次提到其實在IO的過程，你仔細去進一步去看這個更清楚的話會發現其實Device跟Memory中間，其實會有一個Device的Controller在那邊，因為他們的速度差距實在是太大了，所以其實會有一個Device的Controller，就像我們系統會有一個Hierarchy一樣，所以其實Device是跟Device的Controller先做溝通，那這些Controller上它就Register所以可以讓你的CPU可以下一些Instruction到這些Controller然後叫Controller去執行做事情、做資料的搬移所以資料搬移就會有Buffer

東西。其實是會先搬到Buffer裡面這些Device的這個Controller的Buffer然後再寫到Memory的那當然你就可以想見畢竟這只是一個Controller所以它的Buffer的空間通常就還蠻有限的。所以其實這也是這個Controller的設計往往也就影響了一個Device IO的速度，它的極限在哪邊，它看到的這個Input Output每秒鐘可以多少個bytes。其實當然也跟這

些Buffer還有Controller搬資料的演算法設計是很有息息相關的。但是這邊重點是你會發現其實Controller也是被動的，因為當然一整個電腦最後的Masters就是CPU上面執行Instruction，所以其實是CPU下指令然後叫Controller去搬的那很重要一點就是你會發現因為Buffer是有限的所以你的資料並不能夠不可能像Streaming一樣不斷不斷的流進來或流出去，因為這個Buffer滿了這個時候你就沒有辦法再寫資料進去了對不對。

尤其速度我們知道這邊的速度是遠快於IoDevice那邊的速度，所以你可以想像如果要把資料寫出去我必須要等到Buffer有位置或是清空了我才能夠再去搬下一批的資料到Buffer然後再寫出去，所以這個IO這麼簡單的IO過程其實也需要CPU去給他做控制跟下指令的，所以我們就說在那樣子一個基本

的架構下，早期的時候大家最直覺想到的一個控制的方式就是所謂的BZ Waiting，也就是由CPU完全的來Control，所以就會像這邊的例子一樣，這邊是在Output一個String，第一個當然就是大家熟悉的，就是有一個End of Character，所以到那邊為止，我們就不Output了，那output的方式呢，就是它一個一個pointer的character byte嘛對不對，就poke這邊

指的，就只是這是一個例子，所以它就是假設這個API，它就會去將你這個character寫到那個device controller上面，然後寫到它的buffer搬出去這樣子，但重點是我們剛剛說的，它會滿，所以你就需要另外一個control的這個指令像peek去看，說這個status是什麼，所以你要想像這邊例子Status，就是他要嘛就是BZ，就是說裡面，他還沒有位置讓你寫東西或者是他就是現在是可以寫的，所以你必須要當然一定要

等到他可以寫嘛，所以如果他萬一他是BZ的話，他就要在這邊一直不斷的卡在這裡一直檢查一直檢查直到他說OK了這個時候你才會對不對去寫下一個Character所以這是一種控制的方式但是這個這樣子的寫法你就會看見很明顯的看到我們所在說IO很慢CPU很快所以你可以想見這個while這邊

我們搬一個byte可能就要花好幾個mini second那這個時間的時間CPU其實是不能做事的或者說它做的事情就是不斷的在pick所以就只是在很忙碌的在燒它的CPU的cycle可是事實上對使用者一點幫助都沒有因為那不是使用者需要的對不對純粽是浪費我們的CPU而已所以這個例子就很清楚的看到

如果是這樣寫那就算我的程式裡面有做IO的動作甚至於做很多花很多時間可是我的CPU仍然會很忙碌對不對它還是也在使用所以並沒有辦法讓我們之前說的CPU跟IO可以overlap也就是說一支程式在做IO的時候它仍然會霸佔住CPU那這樣當然我們就就算我們電腦裡面放很多的程式在裡

面我們說的Multiprogramming的概念對不對也沒有任何的注意因為其實CPU還是被把持住的所以這當然如果我們整個電腦的這個系統架構運作都是必須要靠這種方式CPU不斷的去主動的去監控去下指令的話其實是沒有辦法把CPU跟IO給分割出來我們的執行效率CPU使用率你可以看到百分之百啦，但

對使用者其實是沒有幫助的，所以呢現在的電腦其實都是driven by所謂的interrupt，也就是說我們電腦真的在現在的運作的方式其實是反過來，它是一個event driven的架構，那這event driven的方式就是透過所謂的interrupt，也就是非常重要。我們接下來要講的這個東西，那所謂的interrupt是什麼呢？正如它的名字，它的這個turn所代表的當初它會取interrupt這個名詞也就是因為它代表的意義，就是它可以改變CPU的執行的flow，什麼叫執行的flow也就是說

CPU本來它是在做某一支程式的這個程式可是你可以透過interrupt隨時把它打斷然後叫它去做另外一件事情所以就叫interrupt，所以它可以改變這個CPU這個control的flow。我們等一下就來看實際的例子如何透過interrupt來做IO就可以讓我們的CPU可以去做其他的程式的事情，所以這個interrupt是非常非常重要的那所

以假設有人interrupt之後對於剛才說的IO我們希望可以實現的或是我們預期可以看到的，就像這個圖上面所講的這個例子也就是說上面如果是往上這邊是CPU這邊是IO，那CPU的話高就代表它是在做它應該要做的事情低就代表它去處理別的程式的事情，那IO的話注意它是反過來的上面是idle所以上面代表

Io其實是沒有在做事的，Just沒有東西要Transfer那下面 往下的時候才代表它是BZ所以這時候它才開始在做資料的傳輸像我們剛才看到的而且它花的時間可能會很長那有了Interrupt之後我們希望看到的結果就是我們本來的程式在執行的時候我們的Io也可以同時的在執行，所以你看到這邊是BZ這邊是在Data Transfer

可是當我們的Transfer結束的時候，有點像說我們說像Buffer滿了，因為Buffer也是有點空間所以你可以讓他花一段時間去把那個Buffer給填滿可是填滿之後當他要搬到Memory的時候這時候可能就需要CPU的Involve進來了，因為Memory是由CPU在Control的，所以當他要去做這件事情的時候他需要CPU的協助的時候這個時候他就會發出一個Interrupt

然後呢讓原來這個CPU在執行的這個程式把它打斷直接切換到要負責處理IO的那一個routine，那個subroutine，那個小程式當然是OS裡面的一個小的程式去處理搬資料這件事情搬完之後它又可以回去這個interop就結束了然後去執行原來的那個程式，所以這就是Interrupt op的這個目的所以意思就是所以我們

叫被動Event-Given就是這個CPU這邊它可以就是做它自己的事情沒有關係當有需要作業系統或者說這個OS要來Involve OS要做事情的時候它可以隨時透過Interact把它切換從使用者的Program切換到OS的Program然後讓OS去做現在這個電腦系統必須要比較急迫要去做的事情然後做完之後呢很重要的是它可以Return

回原來的狀態然後去執行原來的程式可以resume而不會把它整個所謂conclude掉或者是讓它就中斷掉所以Juntion的方式可以看見我們在做IO的過程中才可以出現這邊看見IO就做IOCPU就做使用者是現在需要做計算的程式然後需要的時候透過interact隨時做一個切換讓我們的CPU跟IO可以同時的運作所以這就是有interrupt之後才可以實現的一個結果那我們就來仔細看一下

那個流程所以通常在做IO如果是用interrupt的方式而不是像剛剛寫的BZ waiting的方式或interrupt的方式的話你會看見的東西是今天假設我們的這個使用者要output一個檔案很大那當然Eventually我們說過他call OS然後就走到OS的最底層也就是Device Driver就看你是什麼HDD他的Driver是什麼就會到那個Driver的程式那因為你是透過Interrupt IO所以這個Driver就知道我要透過Interrupt的方式那他就會Initiate一個這個IO一個Interrupt IO的動作

所以他會幫你做IO而且他知道用interrupt的方式那我們說過其實電腦裡面不是只有CPU嘛還有controller對不对，所以其實controller會去幫你做一些資料binding的動作所以這個CPU就只需要下指令給controller跟他講你來幫我開始做binding動作的這個動作而且因為是這個interrupt所以意思是說我給你下指令之後你就bind譬如說他會給他一個

Byte的長度比如說就搬100個Byte或200個Byte那搬的過程中你不用來找我等你全部搬完了你再來通知我就好了所以Init這個Initiate這個IO之後我們的Controller就可以開始自己去做搬移的動作那直到它結束的時候這個時候它才會Signal一個Interrupt然後去通知我們的CPU說這個資料全部都搬好了然後搬在了Memory

的某一個指定的位置所以已經讓CPU可以是直接去Access了然後你要的東西全部都已經搬好為止，那麼這個Interrupt所以是Device這邊會Single一個Interrupt那Single一個Interrupt之後它就會打斷CPU所以CPU這邊其實原來的程式又要做IO嘛，比如說在Printf對不對，那Printf之後它其實會等在那因為它必須要執行完output或者input他才

能執行下一個instruction所以你原來這個程式他issue完IO之後其實他是停在那邊了停在那邊之後CPU會做什麼事呢他可以切換到另外一個program原來比如說在做IO是program A那A run到了IO的printf他就會做一個switch，switch到program B因為B他還要再做計算對不對，那他就把A就丟在那標管那他就去做A的事情去做B的事情，那當這Interop一進來的時候

我們的CPU看到Interop就知道A的IO做完了，所以這時候他就會打斷剛剛在執行的B回到A那邊然後去跟他講你的Print F做完了，所以接下來看看是不是要執行A的程式碼還是B的程式碼都可以，就看CPU的scheduling做決定了，但總之他會知道其實現在B也A跟B都ready了，因為A的IO已經做完了，所以就剛才說的他接到這interrupt之後其實他會先去把這個interrupt的handler去make sure剛剛的IO的動作做完，比如說把A這個程式重新把它啟動起來

或把他的State改成是他可以被執行的狀態，這是所謂的Interrupt Handler在做的事情所以他把B打斷然後去執行A的Interrupt Handler然後讓A的狀態成為像是IO剛做完的狀態，那這樣A跟B都可以執行了那所以接下來我們就可以回復正常，那就看要A做這個B該被打斷了嘛，所以通常OS的設計就會讓B繼續做下去

或者是A可能是一個比較重要的程式，所以他IO做完終於做完了，所以他Priority高有可能我們的OS就說好那就A立刻接受開始執行，有問題嗎？假設你滑鼠用Drag沒錯這個圖有一點不一樣的是你剛才說滑鼠所以這個SingularEvent其實是直接從Controller這邊出來的，像這邊還是從比如說我們程式這邊去initiate IO那

你剛才說的這個倒過來就是前面有一點不一樣啦對不對，直接就是Hardware直接Throw一個Signal所以差別只在於這個不見了而已對對對，那它會直接就Interrupt對然後處理完之後那就看是誰是要接這個Mouse的Interrupt的那支Program它就會被叫起來然後去做剩下的事情，所以說mouse因為mouse有driver嘛所以一樣它就會叫OS

的mouse的handler出來然後做完之後它應該要做的事情就是它的display它就直接去calldisplay的那邊的程式然後就可以開始去移動把它畫在你的螢幕上它就可以開始做那個動作了，那當然你可以想剛剛說的那些全部都在OS裡面就沒有到任何user program因為那是作業系統裡面的那些程式之間，所以這是一個大致的這個的確這個flow會隨著幾個情況大家也會看見，第一個他是software產生的interrupt還是hardware產生的interrupt，第二個

就是到底他是通常是hardware的意思就是他是被動的對不對，所以他是直接打斷現有的程式那如果software的話就代表他其實是自己把這個產生的interrupt之後把自己給suspend掉然後等著這個Interval完成的時候再把自己給叫起來，所以一個主動一個是被動這樣子好可以齁，那所以就是做完之後那可能就再去繼續執行你的下一個IO的動作不過重點是這就是產生用Interval的差別在於這邊這個中間，所以你可以

看見原來的程式去call了IO之後它可以被suspend然後讓這個C PU空出來讓別的程式來執行沒有關係，因為等到執行完的時候它會被叫起來，你也不需要一個while loop重點是你也不需要一個while loop一直在下指令然後一直在那邊看看register的狀態，那就會浪費掉你的CPU了，所以這是最大的差別所以我們說啊所有的作業系統現在全部都是interact driven

或是你可以想就像EventGiven對不對，所以它只有有事情要處理的時候我們才會wake up我們的OS去做事情沒事的話就什麼指令做好都不要執行就是CPU就idol在那所以你才會看見你的CPU realization變得很低嘛，因為沒有人trigger任何interrupt沒有人要執行任何instruction但是它可以responsive對不对，所以，但是電腦你只要一棟滑鼠像剛才同學說我一棟滑鼠怎麼馬上就開始有反應為什麼因為你trigger了一個interrupt

然後才開始做剩下接下來的事情好，那就像我們剛才說的啊也是同學問得很好就是interrupt呢，實有很多種方式可以trigger interrupt對不对，尤其是你可以通過software跟hardware這兩個其實當然是差很多的，那hardware的意思對不对，就是像剛剛說的任何的device這邊產生出來只要不是program使用者program裡面的instruction產生出來的interrupt其

實全部都是所謂的hardware的interrupt，那hardware產生的interrupt我們又給它一個名字特殊的名字就叫signal所以我們剛才才說用signal，因為它就是個訊號，就是打一個signal跟我們的作業系統講現在有事情要處理了。所以 hardware的interrupt我們又給它一個特殊名字叫做signal。那所以大家這個應該把它這個特別記起來，這是很重要的。 signal signal指的就是hardware所產生的interrupt，它不可能是software產生的，所以就可以

做一個很好的區別，那software這邊呢，就我們剛才說的基本上呢，一定就是triggered by使用者的program，那尤其使用者的program裡頭呢，會產生interrupt的狀況，主要就是兩個，第一個其實是被動的，就是不算被動應該說你不預期的，就像你的程式碼裡面有error，這個一天到晚發生對不對，segmentation for這個 fail掉了對不對，那這個就是因為你可能是除以0之類產生一個error對不對，

那為什麼 error會變interrupt因為當有一個像segmentation for或是這些for產生出來的時候代表什麼意思你原來的程式沒有辦法繼續執行對不對那為什麼不會變成整個crash為什麼他還會好好的幫你print out一個segmentation for的message出來原因就是因為當他detect到這些arrow的時候我們的OSOS是軟體所

以是程式他會throw一個interrupt然後開始處理這個arrow的狀況他至少譬如說把你的這個program counter reset到一個可以print out message的地方對不對就不會再繼續執行下去就停在那換到別的後面 recovery 的動作的程式所以最主要你可以想見是需要很多處理的而且這個處理是 OS 幫你處理的他沒有讓整個系統 crash 掉像你 access 到別的 memory他會把你擋下來然後 throw 你一個 error message所以這個是要 OS

處理然後是軟體 trigger 的所以就會產生這些 error 的時候就會透過其實也是透過 interrupt他發現處理 0 這個狀態一直行到這個指令不是有效的 field他就直接丟一个interrupt然后OS会有另外一个这个interrupt的hand ler去处理然后让OS继续的运作所以这个是你迫使OS去丢的另外一个状况呢其实是最常见的就是system call了所以说我们刚才在讲的啊大家的程式嘛要叫OS做事怎么办你要call OS的API也就是system call那这个所有的system call

你Call下去跟一般的Function Call最大的不同在於它一定是透過Interrupt所以你可能感覺不出來你覺得我也是Print F就像你自己寫一個Function A就Call所以好像只是Program Counter移到那而已事實上完全不然其實System Call它的運作方式全部透過Interrupt也就是它是間接的是你Call了一個譬如說Write out to screen這個時候它會丟一個Interrupt出來Soften Interrupt然後會等在那裡

等著OS去接接了之後他去看這個是對到哪一個subroutine或是哪一個routine來去handle然後把它去做處理然後處理完之後他才會通知你这个程式結束其實是間接的被处理的那為什麼要間接处理呢我們後面再说系統怎麼被保护的時候你就知道了因為你必須要透過interrupt所以他可以區分你的這個程

式這個function code是OS的function code還是使用者的function code因為如果是使用者的function code你就不需要透過interrupt或是OS的你一定要透過interrupt那透過interrupt的過程他就可以做檢查這個是不是有效的interrupt因為這些哪些是有效的interrupt他全部都有define所以你不能繞過去的好吧所以software大家就記住第一個就是

你自己不小心寫了error所以osdetect到幫你throw了一個interrupt或者是使用者自己call system call那所有的system call都必須透過interrupt絕對沒有例外因為這樣才可以保護我們的電腦系統好所以當然software我們也給它一個名字叫做trap所以hardware叫signalsoftware叫trap當你只說interrupt的時候就會不是那麼

的clear你指的到底是誰因為他處理的方式畢竟有一些不同為什麼叫做trap呢trap的意思就是你這個程式執行了這個動作本來他應該去做別的事情但是因為interrupt的關係所以他被trap到OS裡頭了所以他是trap到OS因為所有的system codeinterrupt所有的interrupt software interrupt都會有OS來做處理所以你就t

rap到OS的裡頭讓OS來決定這個function code是或這個問題這個event要怎麼做處理所以我們通常就叫它trap好 那我們來仔細看一下它的流程那也會稍微看到hardware跟softwarehandle的不同那Hardware的話這邊是Memory我們說Resident Monitor就是Memory啦這是它的別名這就是我們的Memory那這邊是使用者

的Memory使用者的Program這邊就是OS所以一大堆的程式碼等等那當我們說Hardware的時候呢就是我們說的是一種被動因為你的程式碼都是軟體Instruction你不可能直接直接Hardware會動作也是你Trigger的那這邊的Hardware值就像剛剛同學說的我移動一下Mouse所以我本來在執行某個程式突然

間有個使用者透過外力碰了這些Device那這個時候就會產生一個Interrupt我們要去移動座標那這個時候他就不管你原來的程式執行到哪一行他都會打斷就是我們說的Interrupt而且他就會打斷在你程式的中間任何一行的Instruction中間都有可能因為一個Hardware Interrupt然後被切換掉，那這個interrupt一產生之後那去哪咧OS，所以你會看到一個箭頭到了上面對不對，

所以第一件事情就是我們會detect到這個hardware的這個signal，那怎麼detect這就是hardware做的，就是你的motherboard，這些hardware跟software無關，那這個detect到interrupt之後他會做的第一件事情咧是去看一個叫做Interrupt Vector的一個ArrayVictor， 所以它是一個Array啦，那這個Victor咧其實就是一個Array of function pointer，所以他們裡面就只是function pointer那原因是因為這個，你當然

每一個function code裡面的code的大小不同嘛，所以你沒辦法control，所以它的方式就是有一個Victor把所有有define好的signal全部就是一人一個欄位裡面就是只是四個byte的function pointer，那你的這個signal裡面一定會有一個signal的number，所以他就看那個number，他就知道這個是有哪一個欄位裡面的function code要去hand le的所以當你是在這個裝driver的時候，

他是怎麼做的就是你插到某一個電腦的port對不對那個port，他是已經hardware燒死的。他有一個signal number，那個signal number那個signal number一定會指到某一個欄位pointer的位置所以就會去執行你要去處理的那些程式碼。所以實是先透過這個victor那像剛才說的這個victor只是一個function pointer，所以他知道拿到function pointer之後他就可以被redirect到那個function code裡面去去做處理了，那這就可以override成任何東西了。所以這個我們就叫做service routine，

因為這是一個服務嘛，你要OS幫你做一件事情，所以我們叫做一個Service，那處理這個Service的Function Code或是Routine我們就叫做Service Routineesso這裡才是真的在處理這個Signal的動作的程式嘛好。 那執行完啦， 不要忘記最重要的必須return喔所以不能夠影響到原來這個程式的執行，所以執行完之後就是OS做完了這時候他就

會知道當初interrupt的時候其實他會記錄被inter rupt的那個program他是哪一個program還有當初他的program counter的位置所以他會其實知道下一個位置從這一行開始所以當他執行完之後他就會restore那些information然後讓我們的作業系統再去呼叫這支程式從正確的位置開始resume他剛出在做的事情所以這就會return回到user的這邊去做執行好所以這是Hardware的一個流程那這邊是Victor你可以注意到是它是其實是固定的因為是Hardware所以其實

你一個主機板一個買來它就有固定的signal的這個是有限的它是跟hardware綁在一起的所以這些欄位通常都是sauce的你整體換掉裡面這個到底有值是多少可是它能夠handle有defined的signal的numbers其實是固定的好那我們再來看software看得很像可是剛剛你去想主動所以就會發現不太一

樣所以你會看見這邊來講如果是software就代表他原來是在執行使用者的某一個program然後使用者主動想需要OS的幫忙叫他做事情所以就像是call一個system call或是這邊寫一個除以0造成OS要來幫你做事情的一個結果所以這邊你會發現其實他是主動的不過主動被動都無所謂他就是只是你知道他的位置在哪邊，這邊是不會在任何一個地方這一定是你主動call的，

但是跟剛才流程其實一樣就是你只要call了這些system code之後，他就會記錄下我剛剛的位置在哪邊然後一樣trap所以我們說trap到這個OS裡面去，這邊你可以注意到一點不一樣我們是用case switch case而不是用一個array為什麼因為這是software對不对所以software有無限的可能性你可以definearbitrary number的system code對不对我一個

作業系統我的OS有一些define了100個system code有些define了1,000個你要define10,000個也ok啊因為是軟體嘛所以各有各的目的跟硬體無關沒有限制所以呢這些system code的數量其實是unbounded所以你會發現在實作上的角度來講它變成是一個switch case它不可能燒死是一個array然後去做一個限制所以你其實可以去load的

一些kernel的module然後任意的去增加新的system code就是透過這個switch case好，所以但是基本上是一樣雖然它叫switch case不是array了可是一樣你可以知道它就是這個system code它會有它的number它會根據這個number去比對知道是在哪一個function code然後開始去執行那個routine那執行完一樣就會return回來那這邊回來的當然就

是return到剛剛call完system call的那個人身上這個就是software的部分所以流程其實是完全相同的啦只是說你是突然間被打斷這通常就是hardware那如果是主動的去call去trigger一個interrupt那就是software那handle上呢其實是兩個不同的routine喔所以hardware hardware的interrupt victor對不對software software OS自己寫的switch case所以根據他是hardware還是software他們會跑到不同OS的code裡面去做處理但是流程其實是相同的就是因為是interrupt的過程嘛好所以雖然有hardware software可是

你如果廣義來講基本的架構就像這邊看到的你一定會有的東西咧就是會剛才看到的interrupt the victor那這個部分只是存function pointer而已然後咧你一定要有的是interrupt the handler或者是routine這可以被overwrite對不對那，how will how will the softwaresoftware的然後咧非常重要的是，必須要記住被打斷的那個人他的 address即使你是主動打斷

你自己那也叫做打断喔，所以因為他會從 user 的 program跳到 OS 的某個 program 對不对所以他必須要記錄當時執行的 address 在哪邊program counter 的位置，他才有辦法回到他原來的地方，所以他必須要記錄這個 address好，那最後一點咧我們後面會講比較多啦，那你可以，你會發現的事情，那我的電腦系統如果有一個interrupt產生，

我會跳到interrupt的routine對不对，那如果我在routine執行了一半的時候又被interrupt，怎麼辦，有可能嘛對不对，那這樣的話，不就會不斷不斷被打断嗎，那打断會有什麼問題咧剛剛看好像都很好很有彈性，一個問題，你被打断的話，那你的register那些program的state還有memory的狀態就是supposed要回到原來對不对，但是，如果你打断你

要回到原來的話，你就必須要把很多東西記下來，你要花很多的我們所謂的overhead去保證它還能夠回到原來的狀態，所以如果你一直不斷打斷的話其實會產生又沒有把很多狀態記好的話會產生很多的問題尤其是我們後面synchronization的時候就會介紹到了當你兩個程式不斷的在切換一直被打斷的時候呢會有很嚴重的Synchronization的問題那你要解決那個問題你就要浪費很多時間那OS呢必須要很快對不對

因為其實你在使用電腦的時候你最理想的就是你感覺OS是不存在的它就在執行我的程式而已對不對我移動Mouse它就立刻反應我不管這個OS到底是怎麼處理的但不要讓它有很大的Delay就好所以大部分的OS為了要保證它的service routine非常非常快它通常都用assembly扣寫而且它要避免任何

的delay所以比較注重效能或比較單純的作業系統像是我們說的Linux這些系統的話其實當有interrupt產生它會disableinterrupt的signal也就是它後面的signal它都是當作沒看見要嘛你就再送一次就對了他用這樣的方式去確保電腦他的OS裡面handle這些interrupt的速度可以夠快也就是他想要

跳開synchronization的問題啦這個我們後面會再講更仔細不過你就會發現我們後面都會提到這個interrupt這個是可以被mas k掉的喔所以會有比較high priority的interrupt跟low priority的那high priority的在執行的時候low priority的interrupt全部會被ignore所以有時候你就會發現為什麼我動滑鼠怎麼電腦沒反應有的時候是因為它

卡在某個interrupt的routine裡面所以它ignore掉你的synchrono所以你就沒有被處理到當然就沒有動作了所以這是這個interrupt的一個特性所以比較重要的就是大家一定要記住的interrupt victor是什麼interrupt的routine是什麼還有為什麼要記錄他interrupt的被interrupt的那個人他目前在執行的address的位置那剛才

有那個software hardware的流程的圖嘛這個稍微要知道好有沒有問題的那各位在trace各位的作業儀啊就會去trace了NACHOS裡面他的hardware的interrupt的部分的流程或是他software的部分你就會看見我們剛才看見exactly會看見一個switch case等等去處理這些事情那trap跟signal大家也這個兩個turn一定要記住喔這個是非常專有名詞一定要記住的trap就是software的interruptsignal就是hardware的.