p.34
所以最後一個我們在電腦的作業系統的基本架構上非常非常重要的就是它的protection。那protection就像我們一開始講的，不是指security。所以不是那種惡意的bug或是這些蟲啊這些攻擊網路攻擊而是說在一個電腦上有很多使用者很多程式同時在執行的時候，你要確保它整個系統不會在同一個系統在共用這些資源，可是卻不會影響到對方。簡單來講就是我的程式crash了，你的程式應該可以繼續跑，我只會看到我自己寫segmentation4我不會變成是現在machine要shutdown那就完全不一樣了。

所以指的是這個protection，或者說我的程式裡面能夠去touch到的memory的content只有我自己這個程式能夠使用的這些memory的content，我自己去create的我自己去存的我絕對不能夠不透過OS，然後不透過任何一個controller就可以去access到在這台電腦上其他在執行的程式的memorycontent。你不能跨過去因為這些都是會影響彼此的所以指的是這個


那這邊最重要的是dualmode，我們馬上就會講到如何去區分因為我發現剛才很多同學有在有點confuse，就是說這個OS跟一般program。不管我們看到好像都是我們都把它切開來可是真的在電腦執行的時候對於hardware而言，他真的知道誰是OS誰是user的program嗎因為他其實只是吃instruction。如果大家學過computer architecture就知道CPU吃的instruction上，從來沒有一個tag一個field說這是OS的程式碼，這個是userprogram的吧，對不對，其實並沒有說。所以CPU其實是本來的話只講CPU這個東西的話他根本不知道誰是OS誰是使用者的program，那如果不知道不就代表我使用者也可以寫一個像OS的instruction，叫他執行，那我就可以做OS做事了，那就天下大亂了嘛。所以你不知道你是總統還是平民，那這樣可以亂發號施令。這樣當然不行。

所以我們的電腦系統其實有所謂的dualmode，它是有辦法做區分的。那這個我們等一下就來講如何其實透過interrupt這個概念所以才會有所謂的dualmode。所以CPU雖然不知道，但是整個程式在執行的過程中，其實他可以知道，然後去做一個區隔。那根據那一個你就有所謂的Io、Memory、CPU都可以base on這個mode，他認得出誰是OS誰不是才有辦法去保護這個電腦。


---

p.35
好，那所以我們剛才說的其實剛才有講了。我們講的這個protect到底是指什麼東西勒，

這個不用重複了就是我們剛才說的。可以看見就是不影響其他的program，這個是我們所謂的protection因為電腦是shared的很多程式在上面同時執行的，不只是使用者，甚至於只是單純以process的角度不同process我們知道的，他就是應該是完全獨立的，不能夠互相影響，對不對，好，那要能夠去保證這些事情不影響的話，你可以想見就會需要很多的lock，對不對，或者是detection能夠做區分。所以有些動作只有OS能做有些動作是使用者可以自己去做的。必須要區分，不然你沒辦法做control

那怎麼樣去區分就像我們今天看到的其實最最底層最基本的hardware必須進來因為hardware是不能被修改的對不對所以你上面不管裝什麼惡意程式，你也不可能去修改hardware重新燒它嗎不technology或許現在有些什麼fpga那些或許可以啦但是一般電腦基本上對不對最基本的都是hardware就是燒在上面所以他可以做一些最minimum最基本的protection那其他軟體的protection就會basedon這些hardware的support來去實現。所以我們說叫做hardwaresupport的意思是hardware上幫我們多做了一些最基本、最essential的事情然後software用這個來support去做剩下的事情。

好，所以這個support為什麼叫做support就是至少要兩個mode我們剛才說的很明顯，一個mode叫做usermode也就是說這個整個電腦系統目前在執行的這些instruction這些程式碼是來自於使用者program簡單來講就是OS之外的全部叫usermode那這些就叫所謂的這些執行這些程式碼的時候我們就稱之為這個電腦系統目前在usermode，另外一個mode就叫做monitormode或者叫做kernelmode意思就是反過來，就是OS正在執行的時候

所以意思就是說像剛才說的instruction都是instruction他可能長得一模一樣，可是這個instruction是OS程式碼送出來的instruction還是使用者program送出來的instruction是不一樣的對不對。不一樣的點就在我們後面看到protection的時候如果有些事情user是不能夠做的是不能夠做這些事情，他就會把它擋掉。所以這個就叫所謂的monitormode或者說kernelmode就是指的就是OS正在執行的這些instruction透過OS執行的instruction

所以我們說叫做behalf of OS。這邊可能稍微大家去體會一下意思就是什麼，為什麼叫做on behalf，就像我今天要printf，printf最後是OS的程式碼在做printf，可是為什麼今天會printf是使用者call了systemcall叫OS去做這件事對不對，所以其實這個執行是由OS來去執行的，但其實他在幫使用者做事情，那為什麼要通過使用者就是因為那些I/o device我們會看見的是一定要OS統一來管理，因為你只有一個monitor你只有一個I/o device，所以你不能讓使用者任意的，不透過OS就print，愛print什麼就print什麼或做任何的動作，那他可能就會比如說我們剛才看到device controller，buffer就會亂掉對不對，你output我也output那buffer資料也會亂掉，所以就會造成很多的混亂，所以monitormode簡單來講就是說在這個mode下執行的程式一定是這個OS的程式碼，但其實是使用者透過system call叫OS去做的

---
p.35
好，那到底怎麼區分呢會發現意外的簡單。為什麼，因為呢，我們說過OS如果要做任何事情，是不是他就是一個systemcall對不對。你還叫他OS做任何事情，一定要call他的systemcall。OS來幫你做。那這個systemcall我們剛才說了他一定要透過interop對不對。

所以咧，其實我們的主機板上，他就是用一個bit，就是兩個mode所以只要一個bit做區分，這是相似的在hardware上面的那平常的時候就是所謂的usermode比如說他值就是1可是當你call了interrupt的時候，他就會flip變成0，因為他知道你只要call interrupt就代表你在call systemcall。systemcall的定義就是會執行OS的程式嘛。OS的service routine這就是OS，或者是你今天有個fail掉對不對。你今天有signal也好對不對。你打斷了使用者的program，然後去處理一個signal的時候，他在處理interrupt。

他做的第一件事就是把這個bit把他flip然後變成monitor mode。所以只要看到0他就知道我現在這台電腦在執行的instruction是來自於OS的。他只要看到1，他就知道這個instruction。不是來自於OS的，就是直接你就是讓我去執行的，所以都可以讓CPU直接執行，但是他其實是透過這個bit他知道到底是誰。那這個bit的control非常簡單，就是interrupt所以interrupt一來他就會切換所以interrupt的目的其實還有一個很重要的含義在裡面是他會從user mode切換到monitor mode或者kernel mode，等到OS做完。我們說return to user program的時候，他會把這個bit flip回來所以你就知道always control到底是user還是OS。所以這就是可以讓我們的CPU在執行的時候，他可以判斷到底是誰的方式。

好了那接下來我們就來grade on這個mode來保護我們的電腦。怎麼保護咧第一個你會想可以想見的就是今天我們在電腦上運作的時候做任何事情都要靠instruction有些instruction他譬如說是會影響到其他人的時候，我們就會要求他一定要透過OS。

所以我們就可以在這個是在instruction在設計就像x86 instruction在設計的時候就寫死了，就是instruction他其實有一個set叫做所謂的privileged instruction。特權instruction,所謂的特權instruction就是必須在monitor mode才能執行。你使用者你也可以送這instruction到CPU可是如果你是自己把自己的這個program裡面寫這instruction然後送到CPU的話，他會執行啊。但是一執行的時候他就會看見這是privileged instruction。他會去check那個bit。他一看到是user mode就抱歉我不幫你做，直接丟一個interrupt出來告訴OS有人在亂做。看OS要怎麼辦。那OS當然就是直接把你f不是segmentation fault就是一個fault然後就把他打掉了。那你程式就停掉了。所以privileged instruction指的就是那些只能夠在monitor mode執行的instruction。你一定要在monitor mode，不是的話，他就會被擋住，然後變成一個error或是fault然後OS會去take care剩下的事情。那program就被停掉了。那所以今天如果很多，privileged instruction當然都是很重要的，就像我們說我們要把資料寫到I/o device，那這個就是一個privileged instruction。那使用者竟然不能直接call怎麼辦，你可以看見這個邏輯，所以他會必須call system call。他必須叫OS幫我把資料寫到螢幕上，對不對所以這才是OS，他就可以完全control什麼事情能做什麼不能做。我今天就定義了一個這個system call，讓你把資料寫到螢幕那你就要透過我這system call才能去做這個動作。所以當你call system call的時候，他就會flip到monitor mode。他就會透過他寫好的routine他的 你的資料寫到螢幕上面去，而不是你自己隨便寫。你不能直接去寫device上面的東西，好所以就是透過這個system call的方式去call裡面有implement privileged instruction，然後去執行。所以他會在monitor mode，

所以你，所以才說你一定要透過system call做事情。如果你不透過system call，其實會被擋掉，因為使用者不能夠直接執行privileged instruction，所以這個privileged instruction這件事情，所以會定義怎麼定義。當然就是我們這邊會有一些例子會告訴大家，欸什麼是什麼不是那原則大家可以知道就是privileged instction的目的。就是要保護我們的電腦，一定要強迫使用者透過OS才能夠執行的instruction。然後這instruction一定要在monitor mode才能執行，ok所以你只能透過system call。

---

p.37
好，那我們來看怎麼去保護。第一個我們說嘛電腦不外乎就是I/o memory cpu again always。我們就一直在這三個繞來繞去就對了。Io哪些要保護勒答案是全部要保護，因為Io是shared的，對不對我們所謂Io就是你只有一個Io device。我們只能就這樣螢幕啊滑鼠啊printer啊這些東西全部都是只有一個。就網路卡寫出去，對不對硬碟寫出去這些全部是shared的。所以代表只要是共用而且他的buffer，我們剛才看到controller只有一個嘛。controller device controller只有一個buffer共用所以所有的Io全部都是privileged instruction所以剛才我們看到什麼poke peek，有沒有，全部是privileged instruction因為你不是的話那使用者就可以亂寫你的這個不透過driver然後亂寫你的這個device。那就會亂掉。好，所以其實簡單保護這個Io的方式就是全部把它的instruction全部變成privileged instruction，所以就必須透過os

好。那但是你好像覺得這樣子我們的Io是不是被完全保護勒。其實就很多的hacker嘛，對不對所以hacker就會轉漏洞。那其中有一個這個早期現在或許有類似概念的漏洞勒就是好吧我沒有辦法繞過你的Io instruction，那怎麼辦，我就繞你的memory。什麼叫繞你的memory勒意思就是假如今天我們的memory沒有保護，也就是說使用者我可以任意改寫我memory，我的os甚至於os裡面的memory content的話。那今天我是不是可以執行程式的時候，我就直接去執行去修改我的driver裡面的程式嘛。我就叫他去。本來我這個driver應該是要去修改，譬如說是硬碟裡面的資料好了。那可是我可以都是在memory啊。所以我如果可以任意動memory的content可以override裡面，譬如說他的interrupt vector的值對吧，我可以把他修改掉，然後勒不告訴os，直接把他換成去寫network device的一個driver然後裡面還是我自己的內容。

所以我就透過了interrupt os以為你要去修改硬碟了這時候勒他就把他繞到network這邊，然後做他要做的事。反正你已經進到monitor mode了嘛所以你愛幹嘛都可以。所以他就可以亂修改os裡面的instruction，因為只要進到那個mode就可以修改。那這樣就會繞過去，讓他執行不該執行的instruction所以還是會做，可是os其實並不是做他原來該做的事。這是早期很常用什麼buffer overflow那些其實就是在偷偷繞過os，然後讓他去改寫你memory的content，然後他就會做其他的事情了。就會送不同的instruction進去。

這個不用記啦，例子大家只要知道，簡單講就是大家這邊要記住的就是IO instruction全部是privileged instruction。但是如果你保護IO是不夠的，所以啦其實更重要的是保護memory。

---
p.38

就像我們剛才說的那個做法就是因為可以去修改memory的content。那怎麼保護勒那memory的content的話尤其像我們剛才的例子就是怎麼樣去保護在memory裡面的interrupt vector的值對不對，或者是我的service routine裡面的code。因為這些都在memory裡面。好，那保護的方式，這個是剛才的bug，那更常見的這種是hacker在做的。那一般人的話來講，我們所謂的memory的保護。指的就是你不要overwrite別的program。不只是os，就算是大家都是user program，你也不能互相的篡改。不然這怎麼跑那保護的方式。

其實原則上的方式其實並不會你想的那麼複雜。它的方式就是記錄兩個register什麼意思呢我們下一頁有示意圖。也就是每一隻程式，它的memory使用，它可以access可以去修改，可以去讀甚至於可以去讀的，讀跟修改都必須要符合的就是我需要知道你的這隻程式的區間在哪。因為memory你可以想像說這是一個連續空間。意思就是每一隻程式，我要把它限制住在一個空間內。超過了就很抱歉，你不能使用。如果這個空間是可以增長的，就像各位寫的matlock有沒有dynamic location有沒有，就是在調整這個空間。但是你其實是透過os調整你不是自己調整。你沒跟os講你就想要超過它就會丟給你segmentationfor這是大家最常見的指到不同不該指到的memory空間就是因為有memory protection

那它protect方式因為它是一個連續空間邏輯上，我們講到第八章會很複雜但你現在先只要知道邏輯上它是一個連續空間。所以你只需要base register跟limit register所以base就是在這個連續空間裡我在開始的位置在哪limit就是我到底有多長。所以我這個program可以用4個Gigabyte的memory還是100個Gigabyte的memory所以就是limit這兩個東西是當你的程式load到memory的時候開始要執行的時候它會load到我們的cpu的register裡面去或是我們的motherboard上面所以它會去檢查這件事情。它會用這兩個知道你有效的範圍在哪。

那如果今天你的一個instruction裡面它的address它翻譯出來發現你超過這塊空間，那代表無效。它就會丟error那就是各位常看到的狀況。所以只要是outside它就當作是一個無效的代表這instruction是違法的

---

p.39

所以這就是示意圖。所以我們把這個整個memory想的是連續的話，其實就是base register所以你就知道你的每一個程式它有效的空間在哪邊。

---

p.40

那就像我們剛才說的，它怎麼知道的呢我今天每個程式都會有base跟limit這個register 
那有這兩個register之後我們每一個cpu的instruction當它要去assess memory的時候，都是走過像這樣的一個流程，也就是你今天想要去讀一個memory address所以你的address藏在裡頭它會先去檢查，它會去load你的base register去看這個值有沒有大於。如果小於就丟掉，所以這就是trap所以這邊用trap因為這是一個software instruction trigger 的 error。所以是一個trap OS就會segmentation fault那ok之後呢就是我們剛才說的當然就是去檢查相加它的值有沒有在這個區間又有，那它才會成功的把這個指令送到我們的memory的box上面叫我們的memory的controller去幫我們做data的assess，所以就用這樣的方式可以保證它一定落在那個區間。

好，這邊有一個大家記好，這個base register limit register是值而已對不對今天請問，如果我今天要把這兩個值要做修改，所以這兩個是register所以每個程式的這兩個register值我覺得如果要去修改的話，它是有一個特別的instruction負責去修改的。這instruction是不是應該要privilege instruction應該要吧對不對這就是key了如果那個instruction它不是privilege instruction這一套機制也沒有用對不對我使用者我就偷偷來嘛我就下instruction把我的limit register擴展一倍，然後就開始執行，那就完了對不對所以其實像這些register，這些base register limit register這個整個在系統運作的這些要load的這些register的值令其實全部是privilege instruction。
所以當你call了matlock的時候裡面它會做什麼事情，它就在修改limit register，所以你才可以去使用新的空間，ok齁所以這個是它基本的方式，好。所以有那兩個register，然後那兩個register操作的instruction是privilege instruction。所以它才可以保護memory

---

p.41
好那最後一個CPU對不對CPU也要保護對不對那這邊的保護的意思是什麼呢又跟你們想的可能有一點不一樣。這邊的意思是你要避免，或你要阻止一支程式可以霸佔CPU，然後不讓任何其他程式，甚至於是作業系統的程式來執行。因為CPU也就是執行一堆instruction。所以今天各位舉個例子，你在這個自己程式裡面寫一個whileloop，寫錯了while(1)就這樣結束，對不對infinite loop這個大家寫作業常發生吧。怎麼跑不出來沒反應，一定是infinite loop對不對那當這個時候發生的時候，你會發現你其實還是可以去take control的system，也就是說你還可以按ctrl c或者是你可以下一些command，仍然可以切換掉。比如說你可以切換到另外一支程式對不對你不會這個電腦就整個就死在那然後只執行這支程式的instruction，因為他一直要嘛，所以輪到那個程式，他supposedly可以一直霸佔的CPU，只執行他的instruction，但這樣的話，使用者在做任何其他事情，甚至於想要呼叫OS來做事情都沒有辦法。這個就是一個所要protect的部分，所以意思就是你必須要能夠隨時的將這個CPU執行的這個權利從使用者的program把他拿回來放到OS上或者是其他程式，這樣這個電腦才可以。大家就是我們說的time sharing的概念，對不對所以他才不會卡在一個infinite loop裡面去或者是只做某一支程式的程式碼，然後完全其他人都沒有辦法輪到他們去執行。

---

好那所以怎麼做呢就是我們說的time sharing所以為什麼要time sharing的系統除了能夠interapp之外，其實他也等於是對CPU的一個保護，因為沒有一個人。可以always贊助那個CPU其實都會有一個timer。我們說的他就會程式使用者也沒有呼叫system call，也沒有丟interrupt。可是我們的motherboard上有一個timer，他就是到了那個時間click的時候，他就丟一個interrupt出來。為什麼要丟interrupt因為他要打斷目前正在執行的那支程式，然後叫CPU執行OS，執行OS的什麼呢，scheduler。這是各位的作業3會寫的，所以OS的scheduler就可以來決定我現在還要原來程式執行還是我就要換到別的程式。

甚至於他會發現有別的interrupt OS自己有一些事要做要先處理，他就可以決定要來誰做了。所以重點是你的CPU不會被某一支程式讓他完全的控制住一直霸佔在那邊。你OS可以去呼叫OS，或是去切換要他執行的那個人。所以簡單來講就是要有這個time sharing的方式。然後我們的系統會有timer，所以其實每一個timer被file起來的時候，就是在把CPU的control權利把它拿回到OS這邊的時候。所以其實OS是always在control的。他其實每一個timer出來就會回到OS，然後讓OS來決定是不是原來那個程式繼續執行。

---

所以這就是time sharing的system其實我們的CPU就是這樣被保護住的，所以again，一樣啦。所以timer是我們保護的方式timer裡面是個值啊到底是10個ms還是100個ms這個值是可以被修改的，可以調整的。動態Runtime等等那透過instruction所以那個instruction這邊叫做load，可是load的定義跟你們，就是load的定義是指load到那個hardware register所以load其實是overwrite現在設定的意思不是讀出來，不是readonly而已load是指的是overwrite原來的設定，所以這個是一個privilege instruction所以只有OS可以調整timerfile的時間點，使用者不行。使用者不能說Timer受到Infinite的無限大，那這樣永遠都不會trigger OS。那我就可以一直霸佔著CPU，這樣就會危害電腦的運作。

---
p.42

所以這邊最重要的希望大家記得就是DualMode，所以KernelMode、UserMode的定義是什麼，怎麼樣透過privilege Instruction可以讓我們保護整個電腦。然後一個大家去想一想我們舉了很多例子就是常常我們考試有人問的就是這個Instruction到底應不應該是privilege Instruction Yes or No就這樣子那你的判斷的標準就是你去想今天如果使用者擅自的call這個Instruction去做的事情會不會危害到電腦的運作。如果會他就是privilege Instruction不會他就可以不用試了

所以譬如說，什麼是不會呢，就像是加減乘除像我們程式碼裡面寫3加4那是一個Instruction Add大家應該也學過了，Add就不是privilege Instruction，因為他只是把MemoryContent就是register兩個值相加。所以這個是你自己program的資料。跟系統無關，他就不會是一個privilege Instruction。好，所以這個需要去判斷一下然後最需要了解一下去思考一下電腦系統的運作的方式你就可以判斷他到底是不是一個特殊的這個privilege Instruction。

---
p.43

好，一樣我們這邊有列一些問題所以大家回去自己可以看一下然後下一次當然我們一定會再挑一些重要的問題來問一下。好時間差不多了那我們今天就上到這邊.