undefined
所以剛才下課有蠻多同學來再問一下這個System Code的設計為什麼是長這樣就是為什麼要有Fork然後再execlp這兩件事。首先，第一個大家要回到根本MegOS可以define自己的system code，所以我們這邊介紹這個是Linux的話，他的decision是這樣。他有一個system code叫fork然後做這個process creation這件事然後呢，再provide另外一個system code叫execlp去replace任何一個程式他目前他的memory的content，尤其是指的就是他的執行的

這個code，它的execution的部分的這些content也就是可以把它reset一個program的意思。所以，他決定把這個兩件事切開然後用兩個不同的私生code來做這件事那programmer自己去看了這些私生code之後，那他的behavior根據他自己的需求嘛。所以，通常，如果你想要 run 的目的是create 一個新的 process然後叫他 run 另外一個 binary code 的話，就必須先 call fork再 call exe-clp 了這是結果。 run是指Linux OS

它 define 了這些 system code 之後，你的使用上是這樣子那所以這兩件事情其實這也是很合理的因為你會注意到create 一個 process跟reset一個process裡面的memory content就是binary code還有state這兩件事情是完全不同的create就包括你要去allocate這個memory的空間然後要把它的這個memory的很多要管理一個process你會always需要create很多的data structuremetadata等等像是我們之前提到的process control block對不對

有一個新的process你就要OS要幫他create個process control block然後裡面的值要空間啊等等嘛你都要去initialize嘛對不對所以很多很多事要做的不是這麼簡單的所以這些事情就是Fork在做的那至於create出來之後他裡面到底該存什麼variable的狀態他的program counter的值到底是多少他的binary calls這個call section裡面的content到底是什麼其實並不是這是另外一個問題

所以是由execlp這個system code去做setting所以其實他把這件事情就是切成兩個一個是create process另外一個是把一個process它的狀態去做重新這個reset的動作那兩個結合起來才是達到programmer要做的事情所以是把它切成兩個的然後呢我們之前為什麼我們要花一點功夫在講這些討論說這些Creation

上的Decision可能性對不對因為大家不要被綁死了那個只是Linux的決定而已所以如果你OS的ConceptProcess在Create的時候的ConceptParent跟Children的關聯性的話你可以看見這三個是最主要的一些考量執行順序然後他已經去取得的一些系統的資源的歸屬還有最重要的就是它的Memory Space裡

面的起始的狀態它的管理是要重新一份還是就直接把它給清掉其實是有這些選擇的存在Linux只不過是在這些選擇下它的決定是用過這三個System Code來實現而已所以其實你去查的話就算是Linux說不定你也會看見比較新版的或什麼或許他也會define新的system code去捨破不同方式的process creation這也是可以的沒有人說不行所以這邊只是就是最標準的這個方式通常都是這樣的方式去create個process就是這樣的

一個選擇因為我們說過system code這個kernel是很複雜的通常不希望就是define太多的system code會造成Maintenance上的困擾對不對，所以他都會希望定義的System Code是越少越好，然後都是很就像一個一個Module一樣Service嘛、Programmer自己去想辦法怎麼樣去兜這些Service然後去Implement他們要的事情，所以只要能夠做到其實就好或許Programmer要多寫幾行Code啦不過對於OS而言，那他可能是比較比較希望越簡化越好好，

那我們這邊就來直接用剛剛介紹了三個System Code的用法，會是長什麼樣子，那你可以看這邊，我們就寫假設，我們就寫一個簡單的程式，大家都很熟的那裡面就是call這個fork這個System Code其實這是C啦，所以其實這是C library的function code，只是我們教過了它會去call到OS的System Code會再進去call啦，那名字就取得一樣，就是fork就對了，在Linux上，我們就稱之為fork

也就是會Create一個新的Process那很重要的是，我們剛才說的了這一摳下去之後你的腦筋你就要去想像一下，這邊只是一支程式嘛，一支程式Process，但是我一摳了這個Fork，你要想旁邊我又來了一支Process然後裡面的程式嘛長得完完全全一樣，這裡看不見，但其實就有兩個了雙胞胎，而且他們有自己的Program Counter喔，所以是自己指自己的

那雖然說什麼都一樣，但就像我們剛剛說的有一個不一樣return值所以，如果你是parent的話你的這個a的這個值的設定他就不可能是0，因為他就會是child的pid所以當我們這邊下一行是寫一個if else的時候,parent跟children都是直行這一行一行直行，可是如果是parent他直行到這一行他會發現不符合因為他的a的值其實是有值的，所以他會跳到else

那、child的話就不一樣剛好反過來，因為我們說child的a的值它的是0所以它就會進到這邊了所以這兩支程式雖然程式碼一樣，但是它是同時你去trace它的code的時候，它們就會走到不同的地方去了，然後有自己的program counter，所以是獨立執行，所以 children這個這支 child 先被 create 出來的新 create 出來的他就會去扣這個 print

這一行我是 child process 對不對然後或許你可以 print 他的 pi就是去 print 它裡面的值，然後會扣這個等一下我們再講這個那 parent 的話咧當然就可以扣 parent然後咧在這邊的應用來講我們 child 咧print 完這一行知道他是 child 之後我們就叫他去扣execlt那 parent 我們就叫他去扣 wait所以這個意思是什麼勒就是我們剛才說

的execlp勒它會把原來的程式碼整個覆蓋掉這是它的目的所以勒這個chall的程式雖然它原來程式碼長這樣它執行到這一行之後它就會整個清掉去執行這一支程式所以這個只是就是這個binary file的位置而已。 ls大家應該現在知道了就是在Linux裡面去list folder的那一個指令那個binary所以這個意思就是我會把這個child它現在就會去call ls 這個指令然後呢

它就把它執行完就結束了所以它並不會再去執行後面的程式碼這些它全部看不見了因為它就等於被換成另外一支程式一樣但是是同一支程式喔只是它的程式碼原來在執行這邊call 了這個之後它可以重新 reset去執行別的程式那parent它是wait嘛所以雖然說它這個是這個裡面的程式碼內

容不一樣了但是它是同一支程式同一支process所以當我們的這個parent去call wait的時候它wait的人仍然是原來那個人它裡面執行什麼它不care反正是wait同一個它的橋的就對了所以它會等在這裡然後等到我們剛解釋過的它的定義就是等這支程式。 permanent了之後它才能夠繼續執行，所以它就會被放到

OS的 waiting queue然後等到OS知道這個process結束了，它就會 signal告訴這個parent你可以繼續執行所以把它放回到ready queue那它就可以執行這一行，所以它會知道執行這一行的時候剛剛那個child一定已經結束了，那最後你可以看見這個process end對不對，所以很重要的是這一行喔只會被parent給執行到children雖然說children他這

邊是if else這個是在這個branch的外面可是因為他已經去執行這一個程式了所以他已經整個都看不見了，所以他其實不會執行最後一行所以圖表上來講就是我們右下角那如果你看這個output message你應該會看到什麼勒前兩行就會是這兩行對不對，child跟parent，所以大家這個想一下，如果那個理解的話就會發現應該是這兩行這兩行的順序沒有一定喔所以這只是我們今天先寫綠色的有可能是紫色先喔，因為我們說是concurrent嘛 對不對，

所以這兩行順序有可能是會互調的喔好，那第三行呢就會是這個LS了對不对，所以為什麼這一定是LS因為這一邊有一個wait對不对，所以他一定要等child結束之後他才能夠去print這一行所以第三行一定是這個對不對甚至於他有可能是，但這一行也可能往上掉啦對不對，所以這一行也可以跑到第二就對了，所以LS一定會在這個下面這一行出現之前就對了，

那這邊LS所以只是List啦，所以這邊只是個範例，所以就是你可以Suppose你的螢幕上就看到一些List folder的Output就對了，因為他去執行了那個新的Program好，那但是呢，就我們剛才說的這個一定會在這個前面，所以一定要等到這個Child全部執行完Parent才會Break這個Wait的這一行然後進到下面的這個Pronoun Message而且最後這個Process End只可能看見一行而已，你不能夠看見兩行不可能看見兩行，所以這個是還蠻重要的就是這個基本Process

之間的觀念，所以大家要知道ForkExeclp 還有Wait它的 behavior 到底是什麼，所以今天我們像在考試啊或者這個我們可能會有一些題目是利用這些System Code去一個簡單的程式碼像這樣，那大家要能夠知道它的執行的行為，如果能理解這些System Code它的意義的話應該就可以知道它的Output會長什麼樣子，這個純粹只是這個只是一個Return它的狀態而已，所以

這個要去看它的這個System Code裡面的Spe c不過這個只是一個Output而已我現在這個程式碼沒有寫完整啦所以應該不能說蹦出來我只是就把一些省掉一些行數了好不好不過你去看看System Code你就知道Linux的話這邊會要求你塞一個Status的Pointer那這個目的是它會告訴你這個Process它的Status是什麼就是它Return譬如說是Arrow Fail還是OK就是Success等等的它會在這邊記錄

那這個就只是單純return那個等待的那個process的PID而已而且其實這邊我們都沒有講進去你會發現為什麼這邊沒有指定哪個process因為我這邊可以create很多process對不對所以你到wait哪一個這個wait的system call沒有指定所以任何一個trojan結束它就會break了所以你可以create四個那四個可能執行不同程式所以誰知道誰先誰後不知道但是whatever有一個結束它就會break

然後他會告訴你哪一個人結束了這個是這個wait的定義像這個就好多了這個大家可以去查system code所以wait有好多version所以你要指定還是不指定都有這個就還蠻多的system code了那我在child process裡面可以再cre ate一個child process可以所以還記得我們說是一個tree嗎所以為什麼會是tree就是這個原因所以child裡面我可以再create所以你問的問題就是我們下一個問題囉

所以不只可以這是大家去想的就像這個例子啊你看我們就寫一個很簡單很簡單的程式碼碼三個for loop裡面都寫個for就這樣會發生什麼事大家去要去trace call一下這個意思就是for的時候就會有child跟parent那我不care反正每個人他又會繼續執行下一個iteration他又會去call到for所以第二代的children他又會再去create第三代

然後價值這樣一直下去是可以的所以我們就把它畫出來這個這個因為很TrisCode嘛對不對在我們這邊的話我們通常都是會想要知道它到底是誰跟誰的關係就你剛才說的Parent,孩子到底誰是誰的child誰是誰的parent還有裡面的程式嘛到底執行到哪一個program counter這當然有點複雜但是最簡單的方式就是把它畫成那個tree你就不會Lost掉了所以你可以像這邊你可以看

P0就是原來的這支程式進來的時候所以這時候I等於0的然後你就call fork所以我們知道它就會產生P1這個人那這邊我們只是方便就是通常process the tree我們是不會去重複同樣的process但其實沒差你可以先畫完再把它精簡化對不對或考試我們也不會那麼care你只要畫出整個tree的關聯性就好

所以比較簡單就是你可以想P0它就執行完fork它仍然存在嘛那你fork完之後會產生一個P1然後呢這兩個人不要忘記喔他的program counter沒有被reset喔fork的話所以他們下一輪i的值都會是1喔所以所以1的時候P0它又call一次fork所以又產生一個小i對不对那P1它也還是存在啊然後它在I等於

1的時候又扣一次fork所以又好像P3跑出來了那這就已經P1就產生P3了嘛然後你再跑一次所以現在0 1 2 3 4個process都會再去走一次for loop然後是最後一個迴圈了就是I等於2對不对所以你又會再扣一次fork每一個人都扣一次fork所以就會得到後面的結果了那像是我們到時候問了問

題可能中間就會複雜一點就多一些if else然後加一些execlp的這些mix在一起它會稍微複雜一點但是最好的方式就是畫這顆tree所以如果譬如說我們這邊複雜一點這邊寫說if pid等於0你就code execlp的話那你就知道那個程式就斷掉了就不需要再去trace下去了那也不要忘記像EXECLP是什麼意

思就是我到了譬如說到了P2我這支程式call的話它只不過是內容換掉所以並不是會再產生一個P3喔它只是就停在這而已了然後其他程式可能會繼續call fork但是如果它call了EXECLP那它會被replace掉它就不會再去call剩下的程式碼了所以這裡最簡單的方式我建議大家是最簡單去練習的方式非常簡單自己給自己出一些題目你可以

自己寫一些程式這些combination就在我們的server上implement你就run下去就對了看看它的結果是什麼跟你想的跟電腦跑出來到底有沒有match一定是電腦對沒match就是你的理解上有一些漏掉的地方這個很容易驗證的所以像這個是可以跑的程式大家就拿這個丟上去compile就直接run然後你就叫

他print這些information你就會知道這個tree長什麼樣子我們不會刁難各位不會弄很複雜的啦但是基本的這種比較像這種比較基本的大家還是需要知道然後用一些簡單的exampleexercise然後自己驗證一下就可以了好那剛剛我們講完這個creation了所以creation的流程就是像剛剛那樣子會稍微複雜

一些那termination的話呢，終止當然我們都知道其實就是call exit這個system call當你program return你的main return的時候其實它就會去call到exit這一個system call那，它的行為其實大家應該也可以想像到它最主要就是要把所有的resource把它做deallocation的部分對不對所以包括你open的這些resource就是file handler啊io的buffer啊其實可以很多的然後還有你allocate的這些memory全部做deallocation嘛所以才可以讓這些空間回到OS讓OS給其他的程式使用那，除了這個方式這個是

自己對不对你自己call exit這個exit這個system call就把自己結束掉那就像我們剛才說的因為你有 parent children 的關係啦所以其實 parent他也可以強迫一個程式把他給 kill 掉那，這個指令就叫做 abort 了所以你可以去 abort 給他一個 pid所以你可以指定把某一個程式給 kill 掉但是基本上這個你只能是 kill 你的 children 而已對不对所以你不能 kill 你的 parent因為你 kill 你的 parent 的話

那自己也被kill掉，所以它只能是從屬關係所以你要把它的children你可以透過abort的方式把它給kill掉好 不只是例子啦所以什麼時候你會call abort通常都是有問題啦像是你的children可以太多resource啦對不對像你寫一個web server好了那種比較一些系統的server你很多時候你會很多connection嘛client進來你可

能就會create很多的child process去負責不同的事情那誰知道可能哪一個client他的這個使用的資源就是太多可能是malicious的user甚至於你發現了那你web server那個parent的process就可以去把它給kill掉或者是他事情做完了對不對你已經看到人家斷線了已經離線很久沒有回應了那大概是不需要了你就可以用abort把它給kill掉

但這邊指的不是Threads這邊指的是Process所以說我們在系統比較大的時候甚至於是在Process level在寫一個系統的時候你就透過這些System Code來控制這些Process之間的運作那就像剛才說的很重要的是因為我們是一顆Tree的概念OS所以說當你Kill掉一個Parent的話它下面所有的球輪都會被砍掉

所以你這個t ree嘛，所以任何一個點，你把它kill掉之後，你下面就全部都沒了，是強迫的會一層一層的把它kill下去好對，那還有什麼東西好對啊，所以這個是private，這邊去delete的話，基本上就是用這樣一層一層會有這個影響下去，所以這邊想要補充的是這個啦，你們一定都用過Ctrl C吧，对不对一天到

晚用啊，剛剛for loop的時候為什麼你Ctrl C可以有用，因為你們在下指令的那個是console，那個英文叫console所以其實console是很上level的process就是我們os launch之後他就會先create console這個程式是一個process然後你在那個process你在執行程式的話是其實是那個console下面再去create這些程式running的程式所以說其實這些程式是同步

在執行的所以你在那個console下當你按Ctrl C的時候它其實就知道是哪一個它的chall process然後它就去下個波然後去把它砍掉所以你才可以去砍它的因為你是上面那個console上面比較高的那個process在這個Console下執行的那些程式其實都是透過你那個Console程式再延伸出來的所以可以這樣去砍它還有另

外一個大家，這個你們如果比較進階一點的話有時候可能會用到，會發現的是有一次程式很討厭，它就一直Hand在那邊不動，比如說一個Web的Server卡在那裡，你想要去把它砍掉可是不是你產生的，你純粹就是別人哪個User產生的，你想去砍掉的時候，他有另外一個指令就是kill，那那個就需要permission，所以

那個其實是call a system code叫OS，不管是哪個使用者，他都可以叫OS去把誰把它砍掉，因為OS是root，是最上面的那個process所以，當然可以再去砍任何一隻程式，但那個其實就是要透過system code，你可能要有足夠的權限，你才能夠去砍掉那些程式，所以其實它都是有雖然你可能不一定使用上感覺出來，但實際上它是有很嚴謹一層一層的這個level的關聯在裡面，所以你才可以用這種方式去kill這些process好， 可以嗎好， 所以這個是我們這邊，所以大家知道這個creation跟這個把它去做deletion的部分.