undefined
對於上次我們講到這個share memory最後下課前所以有些同學還在稍微再問一下所以我們再提醒大家一下我們說利用一個buffer對不對這是一個標準的share memory的，這個例子是寫一個Program的話，的這個就是像這樣是一個寫法那這邊Shared的我們說的那個Memory Content那塊空間什麼勒就是指的就是那個Buffer這個Array的部分然後我們說我們就個別Producer跟Consumer個別用一個PointerAddress的Memory Address的Pointer來操作跟使用這一塊記憶體空間對不對那上次忘了提醒大家是

這個空間是有限的所以說怎麼樣可以讓兩個這兩支程式不斷的輸出跟不斷的輸入呢就是我們必須要reuse這個buffer空間所以這是一個circular的buffer也就是說當你寫到最後寫完的時候你會回過頭來然後再繼續寫上次忘了提醒大家這是circular這件事情不過大家看到code應該也有注意到就是我們都有mod嘛原因就是因為我們會把它折回來

所以你會看見為什麼我們會要用MOD然後加完1之後我們也都會去做MOD的動作因為它是一個Circular的Buffer那這個Buffer的使用我們說Shared Memory Programming很方便你可以看見都是用一個Variable對不對然後透過Pointer來做操作那它的問題是Programmer必須要負責Synchronization所謂Synchronization就是要Make sure這兩個程式

在互動的共同使用這個Memory空間的過程中不會造成你在Programming上面的一些執行上的錯誤那以這個例子來講什麼是錯誤咧就是說當Buffer如果是滿的的話那Producer不能夠繼續再Produce啊因為它會Override還沒有被輸出的資料嘛所以這就是一個所謂的Programming上我們認定是一個錯誤的事情那你要能夠去Detect它

你就必須要有些機制那像這一個例子來講這個機制是什麼勒就是我們需要一個condition能夠去有一個這個能夠去描述什麼時候buffer是滿的這件事情所以那我們有in跟out這兩個變數是大家都知道而且是共用的所以說這邊對out加1的時候這個程式他也知道out的值是被加1的因為是shared variable

所以說什麼時候會滿就像這邊例子看到的這個時候我們就稱之為滿了那所以說in的值加1會等於outmod again因為 circular weight啦所以你要考慮到如果是最後一格的話那可能會折回來嘛那你從這例子可以看到為什麼說這樣就滿其實實際上沒有滿啊這還有一格啊可是滿的意思說你不能寫了為什麼不能寫因為你看

我們現在只用in跟out來做判斷所以萬一我真的把它寫下去的話那你不就會變成一個真的是滿的而且in的值又等於out那這樣的話就跟下面很明顯的如果整個buffer是空in跟out的值是相同嘛對不對所以如果我們要允許它把它整個寫滿的話的問題就是那in跟這個condition你沒有辦法

判斷到底buffer是滿還空所以這就是一個同步上的問題這樣就不是一個正確的解法所以為了要避免這個事情我們才犧牲掉了一格當它只剩一格的時候我們就把它先定義為滿那空就不用講當然就是像下面的例子來講所以你就會看見我們這個while loop這個其實就是在做synchronization的動作了因為它就在同步化對不對它要配合有一個人如果拿掉他的while loop

或他這邊寫錯了他沒有加1大家可以想見這個整個會亂掉對不對其實buffer是空的你也在output裡面的值那裡面的值是舊的值啊所以是錯的好所以這就是為什麼我們會塞這兩個condition在裡面其實就是為了要做同步化的事情所以這shared memoryprogrammer就是要處理這件事情那後面這就很straight forward就只是兩個process怎麼去使用這一個

Memory的這個空間的問題那我們把它定義成一個Integer Array所以就代表我們是在Programmer是自己決定怎麼去使用這個Memory空間它可以是一個Integer的Buffer也可以是一個Floating Point的Buffer不同Data Type By 數不一樣所以你寫的位置也會不一樣這些全部由Programmer自己去處理所以這是一個標準的這個Shared Memory的Programming會遇到的一些基本的問題

那我們後面這個Synchronization的章節就會特別介紹怎麼樣用Locking的方式可以讓你所有的這些空間都使用到不像這邊會犧牲掉一個Memory的這個空間的這個問題那這個Producer and Consumer你不要看這個好像很簡單其實在我們的電腦系統裡非常多是這樣子的問題大家很簡單的去想因為我們說系統其實是很複雜的

所以你們在就算Compile程式還記得其實變成Binary是一個過程先做Compile再做Link可是各位都有經驗，你一定都有打過指令是一次就把它變成Binary對不對。其實你在那個Case，你就可以想前面的這個Producer是你的Compiler，後面的這個Consumer是你的Linker。它其實Output出來，它就會去做Link所以在程式跟程式之間也是透過類似的方式，

一邊一直在output，另外一邊一直在把它，一邊在input資料，另外一邊一直在output去consume它。其實這個是非常常見的，那都是用這種類似中間OS會提供這個Circular Buffer然後去讓他們去做資料的傳遞程式跟程式之間其實是很常見的那就是像這樣子類似的一個概念好

好。那接下來我們就要進入這個Message Passing這邊，所以剛剛也提到了Message Passing主要就是它是用Memory Copy的方式，那什麼是Message的Passing呢？那Message Passing其實它的目的跟Share Memory有一點點不一樣，它其實不只是包含了溝通這件事情而已。因為就像大家寄E-mail是為了溝通嘛對不对可是呢Message Passing我們大概會介紹到這個passing的這個

function code就是passing你可以想見的最基本的，就是你會有一個send跟Receive然後裡面是你的message的buffer memory的buffer一個message那基本的你們也很熟悉的就是一個function code大家知道其實它是一個所謂的blocking code對不對就是說你call下去除非這件動作完成不然它不會return那Message Passing的一個特色就是他必須要Center跟Receiver端都要Call這

個Function對不對個別Call自己的對在一起才能夠完成這個溝通所以說如果今天這兩個Function Call我們大家看到這個基本的定義是他會Block所以就有點像各位在打電話一樣對不對打電話另外一邊要接起電話你們才可以開始對話所以如果是必須要等到對方接起來的話其實他還多含了一個概念

在裡面就是同步化因為你現在就知道對方在跟你講電話對不對之前他可能在做別的事情他在睡覺等等你把他吵起來他接起來電話他就開始跟你講電話所以其實在程式的這個溝通上有的時候用Message Passing這個概念去Synchronize同步兩次或是不同的這些程式讓他確定現在這個時間點我們兩個

人開始要做某一件事情那像這個synchronize這個動作啊用Share Memory的這種溝通是其實做不到的就是溝通本身做不到。 synchronize就像剛剛的問題我們還要寫別的code才能夠去解決這件事情對不對。但是message passing它為什麼其實是比較雖然它比較我們說它會比較慢一點因為memory copy。但它會比較好寫因為它本身就包含了synchronization的功能在裡頭了。

而且你的 memory 不會被別人給任意的覆蓋掉所以你自己的 memory 裡面的 variable 的值是自己可以完完全全來掌控。你不用怕別人對方寫了這方程式來影響你對不對。所以說會比較容易做 programming。那到了這個 scale 比較大意思就是說你的溝通裡面的人是比較多的時候大家也都會比較趨向用 message passing因為比較容易 debugging 跟去想到底是怎麼運作等等。

所以其實你可以注意到它不只是溝通還有同步都在這裡頭了。这跟Shared Memory也有一些不一樣實現Mesh Passing的方式就我們剛才說的基本上最基本就是Send、Receive兩個然後給它一個Memory Buffer提供這個Function Code的人在我們這邊來講是說OS如果提供這樣的Service的話它這個System Code它就會去負責去做M emory Copy等等的動作了，

所以你會需要一個Message的System來去實現Send跟Receive的動作，而不需要透過一個Shared variable在這個溝通的過程中，以整個電腦系統的角度來看的話，你必須要做的就是必須要建立一個link嘛對不對，所以你要send你要一個管道對不对，就像我們send email是透過了http或是透過了internet對不对，甚至於可以說是在physical layer的

話，是透過一些網路的網路線對不对，所以either way，你其實從hardware到最上層，你必須要有一個link的存在那第二點的話就是你要去提供這個send跟receive的這個function code所以才可以透過這个link做資料的一個交換傳遞所以這個 link 咧，如果我們再仔細稍微看一下的話，實際上，你要把它拆成所謂的 physical layer 跟 logical layer

所謂 physical 的意思就是說，它到底是用什麼樣的方式把兩個程式之間甚至於兩台電腦之間建立的這個通道，所以像我們剛才說的，它是用 network還是用 memory 的 bus如果它是同一台電腦，我們也可以用Message Passing的方式啊，但那個就不需要透過網路線對不对我們知道，就直接就Motherboard上面的Memory Bus的溝通就可以，那

所以實它可以用不同的方式去建立這一個連線，包括了我也可以用Share Memory的方式建立這個連線啊！如果我在同一台電腦，其實我就是我其實是可以用直接就Memory Copy這個Memory去指定的方式對不對所以，這些都是我們所謂的physical就單純只是說怎麼樣子可以讓對方可以看到收到這個memory的content這件事而已那程序員什麼叫logical呢？意思就是程序员去 care的事情所以就是programmer去call我們剛才看到的send跟receive這兩個function call它的定義的問題那它其實你可以

看到我們書本上提了滿多的就是這個link的特性那我們就講比較重要的就好所以幾個特性呢！比如說像是Direct還是Indirect比如說我今天這個Programmer他如果建立了一個連線就像我們說Socket的話意思就是你開一個Socket的Connection那這個Connection它到底是有沒有方向性是不是我只要建立了那你就可以送給我我也可以送給你

還是說它有方向性那就是抱歉如果我建立我就只能是往單一方向那我連到你，我可以送Message給你。你不能送給我，那就是有方向性。所以你可以想見Connection的建立，你在Logical的角度，你可以定義它是有方向性或沒方向性。那再來就是這個Symmetric和Symmetric對不對，所以就是兩邊傳出的這個裡面的內容跟管理的

方式，它的角色是不是相對的，那這個就比較minor一點。最重要的是，這一個我們等一下會花比較多時間在介紹是blocking跟non-blocking所以，就是我們剛才提到的通常是blocking，大家很熟悉的function code behavior就是你call了之後除非這個動作它本來該做的這個行為完全做完它才會return，這個叫blocking可是呢，我们等一下會看見這個Message Passing的Function Code，它也可以

定義為Non-Blocking的一個溝通，也就是說你Call下去他可能就會立刻回傳他，並不會去等這個Message真的被對方收到，他就會立刻先回傳，這叫Non-Blocking。那後面還有很多啦，你去傳輸的時候真的是Copy還是說他也是送一個reference而已然後之後他再慢慢去做copy就是一些detail裡面實際上去implement的方式還有像是你的這個傳

輸的message它是規定是一個固定大小還是說可以一個不同大小的所以像是比較high level你大概可以想像比較high level定義的一些message passing的function code它通常會讓使用者比較彈性嘛所以你可以篩各任意大小的可是越走到越low level因為效能越來越重要你不同大小很難管理資源所以它就會變成fixed size的所以像這個我們說的溝通啊也是分很多層的嘛對不對

這個越下層的可能越接近physical layer的提供出來的message passing的這樣的服務它可能就會限制成是一個fixed size就像我們知道其實大家如果對網路那邊稍微有點概念的話知道最後到IP在下層變成真的傳輸的package的時候就是fixed size可是大家在寫網路程式http那邊你看到一個它塞一個body而已對不對這個溝通裡面的body那這裡面有多少bystream是無所謂的對不對它的size就是人意的所以也會有這樣的特性上的區分

但重點是只要跟Programming有關的Programmer看到的那個Behaviour我們就稱之為Logical那其實是有很多不同類型的Send跟Receive的存在好，那我們就講比較重要的剛才說的兩個，第一個到底是什麼，是Direct什麼是Indirect，他們管理上的差別，又是什麼，那所謂的Direct，可以看見，就是指我必須要指定我這個溝通對方的人是誰，所以叫做Direct，所以像我們打電話，我打給某人，我按的那個號碼就是那個人嘛，所以這就是Direct，所以你可以看見他的Send跟Receive不意外對不對，

當你在Call Send的話，你就要去指定對方那個人是誰，反正P就是一個Variable或你可以說是一個Token，只要能夠Identify對於這個Message Passing的系統而言，他知道那個人是誰，就可以，那你必須要是一個unique的人然後去送給這個message，那當然receiver端是對過來了嘛，所以他必須要指定sender是誰，所以Q的send裡面要有PP的receive裡面要有Q，這個就是所謂的direct了，那如果是direct的話，你可以看見我們剛剛說的這個link的部分，

因為你已經指定了，所以它知道你很明確誰跟誰之間必須要有一個link，所以在提供這樣子direct communication的這些function的這種library或者是服務的時候，它的link通常使用者不需要再call別的function call了去建立不需要再去什麼init connection之類的通常都不用它通常就是自動就可以去把它-establish起來，因為當你一扣send他就知道P跟Q要建一個link嘛，所以他就會幫你直接建不是always啦，但是你可以

看見他可以這麼做很多也就這麼做可以方便簡化programming的effort，那最重要是這一個他一定是one to one當然嘛，因為你了解他什麼叫direct的話你就知道他是one to one的communication，所以說你可以講它還是一個它的限制了對不對所以你就沒辦法用這種方式譬如說做 broadcast或者說你要去對一整個 group 要去做這個 message 傳遞也都不會用這個方式也都很不適合，因為它只能做到 one-to-one好，那這個當然這個這也是這只是 general 就是 link 通常就是

單向的，因為你說sender誰是sender端誰是receiver端很清楚嘛，所以他通常會是一個direct的link，不會是一個這個by direction的通常，但沒有規定啦好，所以這個很難傳所以這個就是一個例子啦，如果像我們剛才的consumer跟producer的話他就是一個send跟一個receive那，如果你看如果我們今天用message passing你再回去想我們剛才講的consumer跟producer例子的implementation是不是就變得非常非常單純了。我就寫兩行就好了。我就寫send我的下一個位置receive下一個位置printout結束對不對。

我完全不用再寫任何什麼file啊什麼假設這兩個都是我們剛才說的blocking。所以他send了之後這邊一定要先call receive這一行才會return。所以它其實就會卡在這裡了對不對。所以這兩邊自然就被synchronize而且它的synchronization是非常strong的。也就是一對一這邊寫一個message這邊output一個這邊output完一個這裡才能寫一個對不對。所以是非常synchronous的兩支程式。但是就非常容易寫剛剛的consumer跟producer的這個solution

當然這solution其實並不是很好啦。如果你去想跟share memory有時候太synchronous的缺點就是那萬一這邊有很多人要寫對不對。那在等他會不會那個寫的某個地方的memory buffer他的source那邊就會爆掉out of memory就有可能因為不可能等太久啊對不對，所以說其實也是有它的一個缺點就是非常非常同步的兩支程式有時候也不是我們

使用者Programmer想要看到的東西，但是如果你想要完全同步用Message Passing是非常Straight Forward的對不對直接Call就可以了好，這個就是所謂的這個Direct那Direct最大的差這缺點就我們剛才提到1 to 1而且勒他的對方這個人還不能夠替換我A跟B講話我想要reuse原來這個channel我想要變成A跟C講話是做不到的因為

很明顯你看到我們已經塞進去對方的ID是誰了所以說你如果今天call另外一個consumer的話其實等於就是要再建立另外一個連線所以當然會有它浪費時間我們所謂的overhead的這些缺點等於重新來過所以說通常這個Direct的話就比較沒有Modularity意思就是說你這套就是等於是我們通常叫做Adhoc我都知道是誰我就跟你這樣子

你不能做任何的調整修改的對不對所以這個是One to One它比較大的一個缺點看應用啦所以如果你有那些需求它就會不適合那你不需要的話它會是最簡單最快速的一個實作的方式好，那麼什麼是 indirect 咧indirect 咧大家就想各位的 email 就好，所以如果 direct 叫做傳統的打電話的話，indirect 大家就把它對到email，所以就是的確有一個mailbox，就像寄信一樣，所以其實我們寄出去的時候，我們雖然上面會寫人，但是我們並不是直接寄到對方手上，

其實這個東西會被放到一個mailbox另外一個system他去管理的裡面，然後由那個人再決定要把這封信或這個message傳給什麼人，所以說他在溝通的時候就會變成，其實是我送一個message，我送的並不是直接指定尤其是indirect的話，我並不是直接指定說對方的receiver是誰，我只是單純的把這個message放到一個mailbox裡面，只

是把它放到mailbox裡面，那要這個message的人呢，自己要去拿，所以說這個message，其實如果我們說一樣有P跟Q的話，P只是把message放到A這個mailbox，Q這個人自己去拿，所以其實Q這個人並不知道這個拿到的 message 是從誰送過來，他也不認得 P他，只是知道我要去那個 mailbox 的那個那個號碼對不對，那個位置去拿 message可是他不 care sender 是誰，那一樣sender 也不用 carereceiver 是誰，所以我們叫做 indirect，所以其實他是透過了這個 mailbox 的這個服務另外一個你可以說像是一個 port

一樣對不對然後去做一個溝通，所以不知道對方是誰，所以其實就是我們所謂的indirect的意思好，那所以像這個case對不對跟剛剛比的話很明顯像link啊，這個什麼是link，就是像A這個entity對不對這個mailbox，你一定要先建立嘛，不建立那PQ或任何人都沒有辦法去溝通，所以這就必須要programmer自己去建這個link透過這個mailbox來做溝通，

那它最主要的特色就是Many to Many對不對，不敢想像，因為你不知道是誰嘛，所以你事實上可以很多人同時去那個Mailbox拿Message，甚至於當然我們大家也看見你Mailbox的管理的定義也可以說一個Message，它可以重複被不同的人讀也是可以的，所以就很像Post出來嘛，然後大家都看得到一樣，所以有不同的管理方式，但是你重點是你就可以捨破Many to Many

就是非常general的一個溝通方式好，那這個比方講是maybe嘛，所以當然反正這個link誰是sender誰是receiver這個建立連線的時候，你可以想見你可以有這些option的存在那很重要一點是這個mailbox，這個mailbox，這個去keep這個message本身的這個人，他是一支程式那這個程式通常不會是sender也不是receiver他是獨立在兩邊因為他其實不知道誰會是sender誰是receiver

所以其實是會有另外一個程式用他自己的Memory的空間去在做這些Message的管理所以不意外如果我們說這是一個OS提供的這個Mailbox的服務的話那他當然這個就是OS要管理所以就是OS有一個Process他在負責提供Mailbox的Service他用Kernel的Memory去Maintain這些Information那使用者只是說需要的時候他去把它Copy出來回到自己user program 的 memory space

而已所以通常會是第三個人在管理的好那所以在 mailbox 的這個當有很多人同時在連到一個 mailbox 的時候像 direct 就不會有這個問題但是 indirect 就有可能很多人同時對不對要去讀一個 message那這個時候在邏輯上來講對不對如果你想要這個保證一個message只能有一個receiver端的話那你就會有所謂同步化的問題了因為你是indirect所以說所謂同步化意思就是說到底是P還是C還是這個P2還是P3可以拿到這個message 那supposedly不應該兩個都拿到對不對

因為那是只有一個message應該只有一個人拿到而已所以會有一些這只是一個例子就是indirect communication的mailbox它其實要address蠻多問題的像這個case因為有很多人同時concurrent去access的話那它本身也要去處理這個問題所以像比如說可能就是一個link最多就只能建立兩個這個process也就是一個是send 一個是receiver啦所以說你不能同時在這個mailbox裡面可能就只有一個P1跟P2或P1跟P3你不能同時有三個人

這是第一個 solution很爛的 solution因為這個等於就是 direct communication 對不對programmer 會以為他programmer 看到是 indirect可是他因為這個限制其實實際上他能支援的溝通模式 pattern就是 one to one所以只是把它簡化成 one to one所以其實是沒有很大的意義的不過這是一個 solution解決這個同步的問題的話第二個就是說那我就可以限制像

我們教的第七章可以用locking的機制我們就可以限制同一時間內你就只能有一個receiver去call我mailbox的function call就是call receive那個動作怎麼做就是用locking所以只要有人call了除非那個人完成receive的動作另外一個人是不能call的所以你就不用擔心永遠都只有一個人在這個mailbox拿資料不會有同時有兩個

人的出現就算link存在可是他沒有辦法同時做receive的動作那這個就是一個solution就是用locking的方式來解決的第三個勒就是我的mailbox勒不要這個去擋使用者你們就可以同時call沒關係但是我們的mailbox他會知道可以detect到什麼時候會有兩個人同時去Receive這件事情那如果他Detect到的

話呢他就自己自動的把其中一個人的Receive的這個Request把它做一個Delay或者甚至就把它Cancel Reject掉就是只允許一個人那兩個人都說要Receive的時候我會用Mailbox自己先決定好然後告訴這個同意可以讓他拿資料那個人去Notify他叫他再去做這個這個Receive的動作所以變成兩

個步驟啦你先給我一個request說你要receive message那我mailbox決定好之後我決定好這個message到底要給誰之後我再送你一個notification的訊息告訴你說你現在可以來拿了，你沒接到當然就很抱歉，不行有點像各位加簽一樣啦對不對，所以就是這樣子嘛所以這就是透過這樣的一個機制也是可以解決這個問題的

好，所以這是所謂indirect，所以比較重點是大家要能夠區分direct跟indirect的差別然後它使用上的時候對不對什麼時候你可以用direct的communication什麼時候用indirect的，這種communication的function會比較好好，那第二個就是我們剛才講的大家一定要知道很重要的基本觀念，就是blocking跟non-blocking的差別，那就像我們剛才說的send跟receive這些function code全部都可以說所謂的blocking跟non-blocking，那blocking通常會對應到的就是一個同步化的溝通(synchronous的溝通)，對不對，non-blocking，因為你不知道對方到底是不是

現在就立刻收到我的訊息，所以它又稱為所謂的insynchronous不同步的溝通，那就像我們剛才說的email，這就是一個其實是 asynchronous 的一個 message 的passing，那就是因為它是一個non-blocking，我寄出 email 我就 move on 做我的事了嘛，對不對？ 剩下的事情hopefully 對方接到這個 message，他也可能根本沒接到啊。大家常常看到 message 被 drop 的狀況，對不對。在 asynchronous non-blocking 的情況下就會遇到這些 issue，所以它會比較複雜。但它通常會比較有效，因為你不用等 對不對好，

那可以注意到，不管是send跟receive，它都可以有所謂的blocking跟non-blocking的version。那你在溝通的時候，這兩邊也不用一定要對在一起也就是說blocking send可以對到一個non-blocking receive這個沒有說一定要pairwise兩個人都要blocking或兩個都要non-blocking。在我們一般的這個溝通的服務提供的這種function code來講，並不會限制Programmer的這些組合當

然，以Programming的Logic的角度，Blocking對Blocking、Non-Blocking對Non-Blocking比較make sense，對不對比較很多應用會比較符合啦。但其實沒有規定喔，那在對到Send跟Receive的這個Blocking Non-Blocking差別就是像剛才說，blocking 的Send那就只是說意思就是說除非對方接受到對方已經真的Receive到這個Messagecopy到他的user space的memory的buffer裡面之後這個send的

sender端的這個function code才可以return那如果是non-blocking就是我只要send出去就這樣幾秒send就結束那就叫non-blocking的send那receive的話blocking也不難想像你一定要拿到那個message我才能夠return因為畢竟是兩次不同程式嘛所以當然他們什麼時候會send什麼時候會receive這個你無法預測的不一定對不對那所以就必須要等那non-blocking receive這個是比較特殊一點它的意思就是說

我今天去call了一個receive我想要把這個memory的buffer把它填成我要的message的content可是因為是non-blocking喔所以要注意到這個function call return之後裡面你的memory的content的值可能根本沒有被動到因為對方還沒有call send嘛對不對時間上的差異如果對方先call沒問題他會立刻return而且裡面的值會

是對的可是如果對方沒call那你看到的值就是原來的值所以其實他並沒有真的完成那個動作那所以通常的做法是這個function call啊他通常裡面還會return一個token啦那那個token呢你可以用來去check剛剛那個receive的動作到底有沒有真的receive到message就是事後再去檢查的意思所以就會變成拆成兩步驟你要自己去處理它這就是所謂的non-blocking receive也可以存在那其實用法就是他會有一個token給你讓你知道

到底是不是真的收到message好那如果是blocking跟non-blocking的implementation實作上我今天如果要提供一個這樣的溝通的服務的話最簡單的大家可能可以想得到就是既然他都要blocking了所以我可以直接就從sender端的memory copy到receiver端或者說等到兩邊都call了我再做memory的copy就對了所以我不需要中間不需要任何的buffer反正就只要copy兩次最多這樣就結束可是non-blocking到底怎麼做到的non-blocking的話就代表說有可能receiver在call receive之前sender就call了

好多個S end啊，对不对，然後Send一堆的Message給你，但是Receiver都還沒有Ready好，那為什麼他就可以立刻Return呢？原因就是代表中間的這一個服務，這個Mailbox或是這個Service Provider，他其實在Internal裡就要去Maintain一個BufferFor這兩個人，所以當你去Call Send的時候，他其實是放到Buffer裡面，所以只要Buffer有空間沒有滿就沒有關係，你可以繼續send那receiver等到他好了，他call的時候，

他再來看Buffer裡面有沒有東西，同樣的，如果sender没有call那receivercall了一個receive的話，他裡面是空的，他也沒差，他就是non-blocking的receive，他就是立刻return然後裡面就沒有值，有值他就把它copy進去而已，所以重點是其實是透過一個Buffer來做當中間的這個人去處理non-blocking的send跟receive，那其實我們剛才說blocking他不一定要buffer啦，但是

通常的implementation也是有buffer，但Buffer size就是1很簡單所以，如果今天Buffer size是1對不对而且Receiver如果看見這個buffer是空的沒有我要的資料他就把他擋住然後擋到他裡面有資料他再幫他處理那就變成blocking了所以其實實作上是很接近的這兩個方式所以你的buffer就有所謂的0那通常指的就是block

ing或是只有1那如果是bonded的話就是這種有限制的因為他bonded所以會有狀況是如果buffer滿了那原來是non-blocking的code就變成blocking因為他不能掉你的message所以一個選擇就是他會把他擋住或者是他就return arrowout of memory這種東西對不對那你就不准你再去callnon-blocking的send了因為人家還來不及滿了那最後大家都

unbounded啦所以就是你就是一直send那我就一直locate memory直到整個系統都out of memory為止不然我的buffer就一直漲所以就會有這些不同的始作方式那也就會對應到怎麼樣去implementblocking跟nonblocking的這個溝通機制其實就是透過這個buffer的控制而已.