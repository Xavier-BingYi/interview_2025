undefined
我們就進入正式進入OS的structure第二個chapter那這邊一開始會很簡單的講一下我們一直說嘛OS是唯一的API唯一的這個manager所以所有人都要透過它所以它提供的這些System Code等等的動作其實它就是一些服務Services所以你就要做什麼它去幫你做這個就是OS的本質了。所以我們會先簡單介紹OS有哪些

類型的Services的基本的一個概念跟這個picture而已那這張其實重點其實是在第二部分Application InterfaceAPI API大家常常聽過然後我們又介紹了System Code那這邊我們會把大家分得非常的清楚到底什麼是API什麼是System Code這兩個東西其實是不一樣的一定要很清楚的知道這個概念。最後我們會介紹OS Structure這邊指的意思是一個作業系統到底或是說一個電腦上面的管理這個系統

到底是怎麼樣子搭建的就像寫程式大家知道有OO嘛對不对還有一些不同的structure的概念去寫你的program作業系統一樣其實有不同的structure跟方式的那剛剛說的virtual machine就是其中之一所以在這邊我們其實會簡單的提一下virtual machine這個東西但是更重要其實是提其他類型的這些OS的structure就是這個整個軟體系統

有哪些方式它可以去把它做它的Architecture或它的Structure到底是什麼好那我們就從這個Service這邊開始那這個不需要背啦這就是你大概其實你看看系統整理整理大概可以到就是可以看見這幾個大的項目就是我們重點是為什麼我們叫它是要做Service因為OS就在幫使用者的Program做事情而且事實上很多

事情我們一定要它透過OS剛剛才說為了要Protect這個System所以你一定要透過我的Service你才能夠去做這件事情所以我們稱之為Service透過System Code的方式去呼叫這些Service所以這些我們說的這個Interrupt Routine其實有些人叫它Service Routine反正就是同意的意思我們這邊可以看就是使用者使用的interface到底怎麼樣跟這個電腦系統溝通裡面的程式到底怎麼執行IO對不對然後檔案管理溝通溝通指的就像是我們剛才也看到NACHOS裡面有network一定要溝通

這個溝通我們會稍微提一下不僅僅是指的是不同電腦的process的溝通像是你想得到的networking的這個所謂的http或tcp這些東西其實也包括了，是這台電腦本身Process跟Process之間的溝通，因為讓這台電腦我們說了，實你很多的大大的，如果一個系統角度或整個這個Application的角度，它不是單一程式組成的，不是單

一的Process組成的，它是很多個，而且他們要溝通，那或者是未來大家如果去學平行程式，那個全部在講是溝通也包括了我們其實有一個章節是Multithread Programming對不對就是Multithread那邊就是你其實可以把一支程式用很多Thread然後來完成，這就是最基本的平行程式，那它也要溝通可是在同一台電腦所以到底有哪

些溝通方式，那 Arrow當然不用講啦，因為這個沒有Arrow不知道Detect你沒有一個定義這些Arrow的話你有Bug啊等等都沒有辦法去運作所以Maintenance的問題那最後還有三個，那這些就有一點可以看見Allocation我們一直在講嘛，OS就是在做Resource Allocation，所以當然它是很重要的一個部分就包括了像是CPU的Scheduling Algorithm，這就是Allocation的Argument

那Accounting也就是說他要知道大家的使用是多少，就像OS其實要隨時KeyTrack，就是知道說每一支程式他開了多少個檔案因為如果有一支程式他開了一千個檔案開得非常多大家可能都有經驗整個電腦就會被拖累所以不能夠無限制的去使用這些Resource很多時候你為了Accounting的目的就是讓Argument來去用然後

知道怎麼辦那通常至少至少都會有一些Limit在那邊限制你所以你會發現比如說比較早期的電腦因為Memory有限它就限制你說一個Program一個Program或一個Process最多只能Locate四個Gigabyte的Memory或是你File只能開多少個等等很多很多限制就是因為要確保你的系統不會受到單一使用者的影響當然他也需要這

個資訊知道怎麼去做最好的分配那所以在電腦上其實你發現遇到這種說他說你不能做因為你heat一個limit的時候通常如果你是administrator也就是你這個你是system的管理者你有所謂的最高權限的話你可以去修改這些limit的設定然後讓他可以用更多當然這個support是你有特殊用途這只有你一個人用所以你知道你在做什麼

最後就當然就是Protection跟Security這個指的就是那些病毒啊這些就是去人家有Malicious user那一塊了尤其Security所以電腦最起碼，最起碼都會有帳號的概念叫Password才能Login對不對，這個就是Protection Security好，那基本上你可以看見後面三個啦都是為了，就是讓這個電腦系統能夠運作那通常基本上是內部跟使用的Program這些比較無關的，那中間的這個Program的ExecutionIO跟File System我們後面的章節都會Cover特別針對每一個是一個Chapter所以今天我們就只需要講User Interface跟Communication

稍微提一下到底是什麼那這兩個其實也相對User Interface也相對單純對不對，Communication當然比較其實是可以很複雜那我們只會很簡單的介紹它的基本的model，那未來你們修網路的課等等當然就會或者是說上修到平行程式那些怎麼樣透過這些溝通讓程式跟電腦之間運作那就會再更深入了好，Interface其實

大家都很熟悉Interface就只分兩個就這麼單純至少目前世界只看得出這兩個第一個CLI俗稱的Command Line Interface一言以蔽之Command Line，所以大家應該知道就是下指令傳統早期的電腦就是這樣子而已對不對，GUI大家也都聽過了對不對，GUI全名其實就是 Graphic User Interface也就是透過圖形介面也就是Microsoft為什麼會崛起的原

因，因為他提供了非常好用的GUI的介面所以使用一台電腦一個電腦系統使用的介面基本上我們就是這樣分要嘛就comment line對不對要嘛就用GUI那這堂之前各位我相信大家都是用GUI但從這堂課開始我希望大家用CLI也就是為什麼要login到我們的Linux Server上然後直接compile等等的其實你GUI做得到的事情CLI全部做得到因為事實上GUI是架在CLI的上面所以當然不可能做得比CLI多對不對甚至於CLI可以做到很多GUI做不到的事情

還有一個很重要的原因是，因為其實我們電腦世界也是就是一直在堆疊一層一層一個一個LayerSoftware Stacks 對不對，所以程式跟程式之間溝通或是說下指令的方式當然是透過Command Line程式對不對指令所以當然其實透過CLI所以當你要建一個比較大的系統或者說你要這些東西你要做自動化其實這是非常重要的一點

你要把東西Tool拼在一起然後自動的把它們串在一起去做事情的時候其實都是透過CLI的所以其實當然一定要知道這個到底是什麼未來你們工作我相信比較多Pure Programming或是系統這邊或是這個時候你都會用Linux系統跟CLI這邊其實用GUI的機會應該會相對少一些畢竟它比較容易的意思好那所謂的CLI大家知道了就是fetch command然後就開始執行尤其這邊指的是user command就是login到一台電腦然後就開始下指令所以不知道是什麼

大家login到我們的server開始寫作業就知道了你就是用CLI好那這個指令其實你下的這個指令並不是直接交到OS手上你下這個指令其實提供這個interface的是一支程式這支程式呢，尤其在這個我們的電腦世界,在OS的這個世界裡的話我們統稱為Shell，Shell也就是一層在上面的對不對。所以其實這個CLI是有Shell這個程式，就像你要把程式Compile Translate成Binary Code，你有Compiler，那你要接這個CLI的指令然後去告訴OS的話，其實是透過Shell，

就是方便你了。其實很多時候就是方便你，然後你可以做很多事情那所以分享這邊咧，你要知道的就是其實有兩個，實有很多個啦，因為他也是這樣Compile了很多version嘛，但最常見現在的大宗咧，我們稱之為c-share或是bash這個自己回去查一查，那這兩個就是你大概還有很多還有像我記得還有k-share吧，還有非常非常多啦。但這兩個是

通常你灌完一個作業系統它就會捨破那你可以去設定你要用哪一個助教應該跟你們提醒一下不過我記得我們應該是bash怎麼樣知道你的這個電腦是用哪個shell大家查一下Linux command就打Linux shell是什麼那你一定有一個command你可以看到底是哪一個shell好那為什麼要這一層重點來了我都有一個作業系統我就有一個Linux灌好了它都會運作嘛完整的

為什麼我還要我就只是下comment我幹嘛還要再透過另外一層叫做share原因是因為就算我們說過一台電腦不是一個使用者很多使用者每一個使用者他的行為跟他的喜好是不是都不同對不對就是如果是在GUI更明顯就是我至少要什麼桌面的圖案這種東西對不对顏色字體大小好了那就算

Connect也是啊我今天如果要我最簡單一個例子我要show說我這個資料夾下有哪些檔案我可以打LS這是Linux的標準的指令但是如果今天我是從Microsoft這邊來的你可能知道你其實習慣的是DIR反正有另外一個指令你就是喜歡用DIR做那一件事情怎麼辦透過shell所以shell它可以讓你去修改它的一些設定檔很容易的方式讓你可以改變這些command line的這個command的字其實做完全相同的意思其實是同樣的東西，但你可以

加一個alien就是別名，然後就可以做完全一樣的事情。所以重點是OS，它還是以系統角度出發，所以這些system code等等定義就定下去不能夠隨意修改而且是所有這台電腦上的人的程式都要follow的，但是真的使用者他們一定會有自己的behavior跟自己的preference。所以為了能夠讓大家可以自己去調整自己的操

作界面環境因此有shell這一層在上面。所以每一個人其實是自己的shell。 Login的Server你會看見比如說我們原來是Bash好了，你其實可以把它換成C Shell，因為那都裝好的，所以你一定可以去換，然後換了之後你就會發現它有些指令啊東西會不同或者是它本來就Bash你可以重新Redefine說我的list我的file folder的指令是什麼還有顏色。所以你會看見有些人login一個server為什麼

他的這麼漂亮很清楚folder是藍色檔案是綠色怎麼這麼清楚我的怎麼就黑色跟白色，因為你沒有去動他的shell，所以這蠻有趣的大家可以進入server你也是方便自己其實網路上你可以找到一些比如說你是bash那你可以去查一下bash下面有些D4人家建議的prof ile是什麼其實是一個檔而已你就把它

copy進去你的整個操作介面就變成那個樣子就變得很好使用或很方便這個大家可以玩所以在我們這個完全不會touch到OS而且是每一個使用者自己的就像個人的這些設定而已所以你login進去你就可以去修改變動這些是沒有問題的你就知道Share到底在做什麼了那可以多修改所

以你也知道其實它並不屬於officially並不屬於OS的一部分它其實在OS的外面它其實是上面的interface而已所以大家要知道的比較重要的是為什麼要就是shell的存在為什麼我的OS上還要再加一層shell這個東西在那邊那就可以提供我的CLI的interface或是比較friendly的CLI的Interface啦好另外一個大家就很熟了所以不用太多說啦GUI啦所以你就對啊滑鼠啊收啦等等都可以它的基本概念就是透過ICON嘛大家都

知道啦簡單來講就是它方便啦然後其實他的目的跟CLI是完全相同所以你如果不知道要幹嘛你去想CLI就知道了對不對你就可以修很多東西那個就是為什麼要其實CLI雖然是只是command line還是有同樣的這些需求每個使用者喜好是不同的所以其實現在的系統都是兩個都有啦早

期當然就只有CLI那GUI其實對於效能啊或者說對於一些真的只是在處理單純在處理資料檔案或是計算純粹要用這個電腦去做一些複雜的事情的時候跟人無關的時候都是用CLI所以為什麼你一定要學CLI因為並不是什麼都是跟人只有最上層的applicationWeb那些對不對可是其實下面都是CLI

所以當然不能只會GUI這個東西而已好那這也回應到我們之前說的電腦系統設計都有convenience跟performance的trade off所以GUI方便但是它會比較也會比較慢然後其實是比較受限制的好再來是communication我們說這邊的話我們其實只是很簡單的講這基本概念大家有就好Communication指的其實並不只是在一台電腦上Process之間甚至於可以到跨電腦但是不管是哪一個level我們基本上Communication都可以把它簡單的透過Memory的使用區分成兩大類第一個叫Message Passing另外一個叫Share Memory

為什麼透過Memory其實很容易想像因為程式應該說CPUCPU能夠Access的東西Directly Access的東西只有Memory大家應該有這個概念所以今天的程式讓在CPU上它就只能Access Memory所以重點是你要怎麼透過這個Memory讓兩隻程式之間可以溝通也就是交換裡面的Data那所謂的這個Message Passing的意思呢就是指我是用

Message的概念就像大家寫E-mailExactlyE-mail就是一個Message Passing的Communication電腦跟人的世界沒差多少就一樣的概念所以Message Passing的歷史就是像這邊你有兩個Process那這邊或許他是在同一台電腦不同其實也無所謂那他就把他的Message呢Copy到Kernel就是OS的Memory然後再讓另

外一個Process去把它Copy過來然後再去讀裡面的資料這就叫Message Passing簡單來講就是Memory Copy所以就是要做Memory Copy然後把它的Memory ContentCopy到另外一邊去但是在這個作業系統你要更清楚的一件事情這個Copy不是直接從這裡Copy到這裡其實是Copy到OS的Memory再過來的為什

麼因為Protection大家還記得我們一開始有說每一個Process都有它自己的Base跟Limit所以你不能夠自己擅自的雖然它就在你下面你也沒有權利直接把這個Content Copy到修改這裡這是違法的這是違法我們的Protection所以會危害整個系統的運作所以就算這麼簡單一件事情你必須要Code System Code只有OS他有權利去讀你的資料跟寫你的資料所以你會看見一個OS在這裡那當他做這個動作的時候

我們這裡當然是最基本的實作所以你會發現他會先把它copy到這裡然後等到make sure這全部資料都完整知道了然後再過來兩個步驟當然你注重效能的話你可能會修改一些提供比較快速的比如說真的就直接copy之類的當然也做得到但會比較少因為通常都會怕會危害到另外一支程式比如說你copy到一半萬一你斷掉系統fail怎麼辦對不對那你有辦法同時重建兩個程式嗎可能會很複雜沒有那麼單純

所以我們還記得不過TCPIP networking它其實是很慢的因為它很多層的copy就是這個樣子一層一層然後OS在那邊copy來copy去最後才送出去一個封包這就是所謂的Message Passing其實就是Memory Copy所以這個動作不限於同一台電腦今天我有兩台電腦一樣做得到也就是Copy到這裡之後我就

送一個網路封包像是TCPIP的Socket Programming到另外一台電腦另外一台電腦的Kernel接到再Copy到另外一邊的Memory就完成了不過一堆Copy所以其實有點慢另外一個做法也就是對啊,為什麼我們不就share咧share的意思就是我們兩個如果都能夠看見那一塊memory裡面的content而且都有權利去read跟

write就是修改它的話那我寫過來你就直接看我看到我就知道了嘛我們就可以溝通這是非常簡單的所以這個就是所謂的share memory但是你就要注意一般原來我們說為了保護它是每個程式有自己的範圍所以今天這一塊之所以可以share不是無中生有的其實是要透過system code是另外一個所以是一

個service所以其實process跟process之間如果要用share memory的方式溝通它其實一樣是在之前它就要先跟OS講透過system code去create這一塊share memory的空間出來大家在memory management的chapter我們會講exactly怎麼做可以做到這件事但是可以透過OS然後讓一塊Memory是兩個人都看得見看得見就可以直接溝通這就叫Share Memory那By default我們說Process跟Process之間這個東西不存在你可以透過System Code事後Create這可以那如果不是事後的話By default什麼時候會有勒

Multithread Programming所以我們後面會講Multithread Programming為什麼你可以用Thread的概念可以讓Thread跟Thread之間溝通就直接就可以溝通因為Thread的定義就是當我Create出一個Thread的時候它們有部分的Memory by defaultOS你不用跟OS講OS就會幫你Create出那塊空間或者知道哪些東西是要Share的當然你還是會發現不是所有Share它是有有管理的只有

某些定位定義的Memory Content是Shared的那其他不是好所以是Shared Memory所以最常見的其實是Multi-Thread Programming各位其實會用到會看到好可以嗎但注意到這兩溝通其實都透過OS喔不管左邊還右邊然後當然左邊這個Message Passing的壞處你可以看就是有Memory Copy啦所以它通常會比較慢很遲而易見Shared Memory的壞處就是各位的Chapter 7跟8嗎？ Deadlock Synchronization為什麼會有Deadlock Synchronization的條件就是你會Access一個Shared Memory Content所以就囉唆了會很多Unpredictable的Problem會跑出來所以其實也不是這麼容易的.