undefined
我們現在要開始介紹這個章節最重要的一個部分也就是System Code跟API到底差別在哪裡，因為你們以前一定都聽過API對不對，那這堂課OS我們一開始介紹大家最重要的知道的就是System Code的概念，那這兩個到底有什麼差別勒，他們其實是不只是不一樣的東西，並不是別名而已囉，這兩個其實是不一樣的東西那就像我們一開始說的，其實OS它就是提供一個Service的Software，

那它是提供各式各樣的對不對，我們也看到各式各樣的service，像communication，它可能就需要去send跟receive message對不對file要去讀寫，你就要rewrite所以這些file system的這個API或system code，那這些服務提供的方式，我們現在提供這指的是跟Program之間程式要去OS做的話，剛剛我們介紹的CLI GUI是使用者你 人 人要去下指令的話是用

這個CLI GUI，但是Program你要run在一台電腦系統上的時候，它能夠透過的只能夠是function code或者說就是API，就是system code，這些就是這些code，所以當然你可以想見這每一個service都會被定義成一個function code的形式這樣才能夠去呼叫他然後叫他去完成要做的事情，那這個在一個電腦系統尤其透過OS提供這些service的這些code的方式，

第一個當然就是我們說的System Code毫無疑問的OS提供的這個Function Code實就叫做System Code。我們說它是唯一的Interface唯一的，所以在一個OS上面，它會定義這個System Code Layer。那這個System Code，因為它是這個跟OS是直接緊密連結在一起的了，所以它的確是Part of OS裡面的一部分的最外層，那個Interface的定義那因為中文史所以

他要講求什麼小能對不對他不能顧及到所有的人，所以這個System Code有幾個特性很容易做區分的。他跟所有其他的Code都不一樣的地方，在於第一個，他其實就是一個Software Interrupt。我們之前講過的為什麼要Software Interrupt，勒因為他才有機會去改變你的User Mode跟Kernel Mode，所以當你Code的System Code之後，你一定是進到Kernel Mode你就會離開User Mode這個是

唯一只有System Code有這個特性第二個，它為了效能所以System Code通常都是用Assembly Language寫的所以才夠快，所以它就講求效能。它不管這麼多因為其實在上層，你還有Shell，我們剛才介紹的還有我們等一下會介紹的API，所以有別的人會去解決使用方便性的問題那System Code是OS的，所以它講求效能優先而且是能夠

大家都共用的其他你有特殊的你可以在上面再去打Layer所以System Code，它都是用Assembly Code寫的那這也是為什麼剛剛我們才講完作業一，你們在Trace Code的時候有一個檔案要改的是。 s檔因為它就是System Code，它就是System Code定義它System Code Interface的那個答案就是好像叫Starting S吧對不對所以那個就是標準的System Code了好，但

是因為它是Assembly Code啊，所以我相信大家知道也沒有寫過，我自己都不會寫Assembly Code老實講是真的不會寫，所以怎麼辦？你不會寫System Code，你不會寫Assembly Language，那你怎麼在上面寫你的Program呢？所以會很不方便對不对，所以跟Shell的概念是很像的，但是Shell是使用者下comment我們這邊講的是Program要去call function call這件事情，所以對

於Program在一個電腦系統上，它的這個interface它就會再加一層的就是所謂的API了，所以它的全名就是Application Programming Interface，所以意思就是在一個電腦系統上的Application當你要去Program這個Application的時候它所使用的Interface，所以它純粹是為了Programming的方便還有方便Application而設計的跟作業系統本身其實並沒有要有完全的這麼緊密的關聯

性所以你會看見其實這個API的建立是在System Code的上面，它是另外一個Layer，所以這兩個是不同的，你是API下面才是System Code、System Code之後才去執行OS裡面的那些Function、Service Routine的程式然後操作Hardware所以其實各位在寫Programming的關鍵的時候為什麼都叫API就是這個原因而不是說System Code，因為你並不會直接Touch到System Code，實際上你是Programming Against API這個Face，你並不會直接Code到System Code，你可以，但是比較少這個Case，所以我們說System Code是一些Assembly Code，那API到底是什麼到底誰在加這個Layer

那其實最常見的其實這個API的定義我們等一下會有例子就是也有網頁所以大家可以看到Windows的API還有Linux的這些的API但是基本上這些API它的形式就是一堆Library。事實上C Library是被定義為一個作業系統的API之一。所以為什麼大家說C Programming在系統上面那是因為一般大部分的作業系統跟電腦系統，它的API是使用C這個language，就是它的API。但是當然，這不是唯一的啊，像我知道大家有些在手機上現在越來越熱門了嘛或Android上，你會發現它其實是Java

這也有的，所以說他就是定義的他上面的API，他就只捨破可能只捨破或他至少會捨破Java所以他就是encourage上面的program是programming against Java然後Java再去call下面的system call那所以它其實就是可以看見，就是大家比較熟悉的language，但是比較system的language，所以我們常常叫system的programming language也是這個原因，因為往往這些language被定義為一個電腦系統的API，它的standard API你就通這些方式語言去做program ming那如果相對啦如果它只有include C嘛啊你不會C怎麼辦

很抱歉你可能就要去扣System Code喔那直接Program against System Code當然就很難嘛很複雜所以當然就會必須被限制在這個API上面好那這個非常非常重要它是不同Layer可是他們的角色不是單純的在做Translation跟Forwarding而已喔不是說一對一的關係它是根本是兩個Layer所以他們的目的都完全不同也就是說一個API的Function Code

它可能會變成很多的System Code才能夠完成它所以是一對多也有可能是一對零也就是你Code了一個API可是API居然完全不Code任何的System Code它就可以做完幫你做完這件事情它們倆對應是沒有絕對的關聯性因為呢要回去想API的目的只是方便使用者做Programming那所以很多事情舉

例來講我們這邊有這個像是數學對不對大家一定常常call到Math library對不對所以你會直接call個ABS就是可以取絕對值這件事情只是單純的在做數字的只是在做這個數值處理啊所以根本不需要OS進來對不對那但是為什麼我們的API還是會有這個function code因為方便你寫program嘛，所以我只要call這個function code，我就完成這件事情對不對或者說指數這個可能帶單準指數大家就可以

想見就會有很多的這個你用一個function code直接把它包起來容易操作所以API的目的是要方便使用者寫program跟OS只是當你有一些Code當然會需要OS那些Code當然就會Touch或是使用到System Code但是很多Function Code在API的定義並不是單純只是為了要讓你去Code System Code他的目的還是在於怎麼樣方便使用者所以這個時候其實是對到0個的並不是一個API一定會Code到System Code請不要搞錯了

相對的很多的API其實是需要好幾個system code才能完成的為什麼因為使用者使用的方式五花八門尤其是你想要去locate memory的方式或者是你在做IO你有很多不同不同的方式你覺得是比較方便你去使用這些資源的可是System Code卻希望是越少越好為什麼因為你越多你要debug就越多嘛越容易問題啊

等等越複雜所以最好就是每一個system codes完全沒有交集你一個人就做一件事情而已然後很單純很簡單debug然後沒有任何干擾各做各的所以當你在做這些方便的事情的時候你要下面的系統可能就會對到好幾個我們大家有例子簡單一個fopen你都不會想到一個fopen是API可是它對應到System Code至少是三、

四個以上才能夠完成那單純的一個fopen的動作所以它其實有可能變成一對多甚至於還有很有趣的。你可以看到像這邊manlock跟free大家知道API它是不一樣的大家都用過可是它去code的System Code其實是同一個叫做BRK因為其實你要去增加減少那個只是一個參數的差別所以它其實只implement了一個System Code

只define了一個System Code可是API為了方便區隔嘛所以他把它變成兩個function code但其實他們兩個都是指示code同一個只是參數不同而已。所以你可以看到這個關聯性是這個樣子的可以想見到沒有任何限制簡單來講就是看你的需求的問題一對多 多對一甚至於不同的API code對到同一個system code這都有所以System Code跟API是完全不同的所以API很重要API不會Call到不是Guarantee首先它不是一個Interrupt它不會直接產生一個Interrupt是裡面當它Call到System Code的時候

才會產生一個Inter rupt你Call的API並不會進到Kernel Mode是API裡面如果它Call到System Code它才會間接的進到OS裡面去叫OS完成所以這是很大的差別。所以API是大家很熟悉的C、Java這些System的Programming Language，System Code通常就是Assembly Code才夠快然後它是非常簡單的System Code，非常簡化然後希望它能夠非常快可以做完的因為大家不要忘記System Code是一個Interrupt意思代表它其實是打斷別人

偷偷的過來趕快做一件事喔。所以被打斷的人當然很不高興嘛。如果你被打断很久對不对，所以System Code一定要 implement的非常間接然後越快越好還不要去影響到原來在執行的那支程式可是ATS完全是只是我自己要去做這件事嘛方便我自己所以我雖然做很久也沒差所以他就是用C、 Java都OK。好，那

这个只是make sure大家观念正确啦。当我们在讲interface跟library，因为我们刚才提到CLibrary嘛，我们讲到API的interface嘛，所以其实大家学programming的时候应该也都有建立了对不对，就是各位写的一个program其实都是call这些function code那这个function code的定义就是我们说的interface尤其在OO跟Java里面大家会很清楚看见对不对所以你只定义了interface而已

那這個interface要怎麼被implement那是另外一回事所以你可以有很多的implementation就像這邊看到的簡單的一個指數嘛對不對那我可以寫個復回圈在那邊看你要是2的幾次方對不對然後在這邊乘對不對但是你也可以比較聰明一點厲害一點的他就會寫這種shift他就知道其實binary嘛所以我就shift一個位置就等於是乘以2嘛那更厲害的

有hardware support各位在讀第七章synchronization我們也會提到有些function code為了讓它真的要夠快你可以在hardware support就是你真的做一個hardware的device然後去可以去幫助你做那一件計算所以你要做的事情就是call那個hardware的instruction就對了所以這就是hardware support所以就瞬間就可以完成這件事情但你還是要call這instruction所以有三種,

這邊你可以看就是三種不同的implementation所以這個每個implementation就是我們俗稱的library就是這些implementation把它結合在一起然後看你要call哪一個所以這個是library所以我們剛才說interface API是定義在這邊的只是單純就是定義它的call的方式那不同的implementation其實是可以存在的那為什麼要特別強調這件事因為我們來看一下

真實的作業系統Windows以前最常見的所以Windows它的API你去看它就叫Win32現在好像只有4因為那應該只是幾個bit的指令而已所以Anyway之前是Win32那大家可以去看它的這個定義還有它的完整的API set到底有哪些function code是是被define的所以Windows這個作業系統它就要求你用Win32

的API在上面做Programming那你會發現它其實就是CR或它可能有提供Java或其他的不過就是它定義的這些那像剛才說的它不是System Code不要搞混了好那除了Windows之外另外一個很大的陣營到現在依然存在我們知道就是Linux這一派對不對這些USENX Linux那其實這些作業系統包括了MAC也是他們的API都是follow POXY所以POXY其實是這些他們這些Community或是Developer他們共同同意的一個標準化的API就叫做POXY，(有全名)：la你可以

看見Portable Operating System Interface for USENIX。所以意思就是說這些作業系統其實他們是不同作業系統，我們都知道的，所以他們的System Code其實是不一樣，他們的實作也都不一樣，但他們的API這個Interface的定義我們剛才提到那個定義是完全相同所以他們都是屬於Poxy，所以他們就在他們在開發的時候他就要保證自己要寫那一層API，Make sure他是可以

Code他的System Code然後提供這邊定義的所有的這些API Code。所以為什麼叫Portable就很顯而易見了，因為今天user的Program是Programming against這個API，所以我今天雖然在比如說Linux上寫我的Program這是一個特定的OS，我在上面可以Compile可以執行，我今天就有辦法把它拿到Mac或Linux另外一個作業系統上重新Compile不用改寫我的程式，因

為裡面Code的API長得完全一樣，他們是定義好的，所以就可以Portable意思就是你不需要重寫程式，你只需要重新CompileCompile。是一定的因為Instructions不同，它會有不同。但是你的Program是不用動的，因為API沒有動所以他們的Library可能不一樣，但是Interface是完全相同的，所以Proxy大家應該知道一定要知道這個東西，這個太基礎了。像

我們這學期，因為加了其他作業，所以沒辦法讓大家寫Pthread Programming Multithread Programming可是大家可以稍微知道Thread Programming用的是Pthread這個Library，為什麼叫做Pthread？為什麼多一個P在前面？因為是Proxy那個P，就是Proxy的間隙也就是Proxy這個API的interface加定義的thread的function code。意思就是，那個library是為了支持Proxy API的，所以基本上現在作業系統，我們

知道它都有包括了可以提供thread的programming的API，那Proxy這一個Interface裡面提供Thread Programming API的Library，我們就叫Pthread，所以會有個P在前面，指的就是Proxy。好，那最後一個Java所以當然為什麼Java大家知道它其實是個Language啦，但為什麼它也有一個自己的API呢，因為我們等一下也會提到Java是非常特殊的一個Language，因為你們應該也有知道就是它其實是run在一個所謂的Java Virtual Machine，所以

它其實是讓在一個自己虛擬的Virtual Machine上的一個程式，簡單來講就跟Nachos是差不多的，所以其實大家看到Nachos大家就知道這些Virtual Machine Java其實都是同樣的概念，所以它其實在它自己幻想的這個環境裡面執行，所以相對的等於是它可以控制這個Machine對不對它，不管你下面真實的Machine是什麼根本不重要，因為它其實都是讓它自己模擬的那Machine上，

所以我們說Java的portability更好就是這個原因，因為它其實是run在自己的假的machine上而已，所以它可以更保護你的程式等等就可以做到很多其他語言做不到的事情，所以Java因為它自己也是一個virtual machine，所以它自己定義的API就叫做Java API，好那我們就來看一下這個實際的例子，這只是要看而已，不用，只是跟他體會而已，所以，

什麼叫做一個System Code勒？就像這邊這個例子它只是很簡單的,我們要去Code一個如果我們今天要把一個Content從一個Filecopy到另外一個File欸,有問題嗯,對啊,是沒錯,它要轉到下面去,對那這個是就是它它就幫你去做這個部分啦所以Java相對它也會比較慢我們之後會講它要Translate你的Code所以

它要Translate的Code變X86或MIPS這些它要去做這件事情而且它是Round Time就像Nachos一樣所以它會比較慢一點所以它相對都是這樣所以這是一個Trade-off就是你要它越General然後越Portable的話你要做的事情相對會越多另外我沒有仔細那麼仔細去看啦但是還有一點是喔不要搞錯是像Java你去裝你去Download的時候他應

該也會問你你要哪一個版本對不對你要亂拿一個Machine上哪一個Instruction對不對所以你也不是把它整個打包下來然後有沒有所以你當然是針對所以是這樣子但是對啊Developer他就要都寫啊那一塊那就是有點像寫就苦力嘛對很多Software Developer也是需要做那一塊好 不過這邊可以看 這邊只要大家看我只是很簡單的copy這件事情

你們大一大二都要寫過這種程式這是多少system code大概零傻傻十幾二十個system code每一個都是system code然後你要按照那個很瑣碎繁雜的我也沒有仔細進去看了啦只是大家知道就是很複雜啦所以如果你要system code那就是你必須要做的事情不只是要寫很low level language你還要知道它很detail 然後它的設計非

常不Programming Friendly或User Friendly所以你要自己Figure out怎麼去兜它那所以為什麼我們叫API就是這樣所以大家都用過嘛C Library裡面我們就call一個fopen或是fread然後再寫一個fwrite當三行對不對那所以裡面相對的人你就會看見它會一樣會有很多的parameter那這只是例子啦所以大家也不用太那個所以這就是一個標準

所謂的API大家都用過所以很熟知道這就是API然後裡面的每個field其實通常就是它的設計一定是很明確的是為了這件事情然後才有那些field對不對所以那些parameter然後都會有清楚的定義你會看見它定義是什麼所以你通常就很好用就是這個意思好那比較重要就是我們剛才說的了其實不

同Layer所以發生的事情其實是User的Application他會先去Call API的LibraryAPI Library裡面如果需要OS的幫助的時候他會去Call System Call那他Call的System Call的時候才會進到我們的OS裡面去透過Interrupt的那一套做法然後把這個去CallService Routine然後再回到Return回到這個API的部分所以其實是兩層的但是很多的API其實

是我們說了它根本沒有touch到System Code那它就是單純在API那邊做完了所以這一樣啦Standard C大家就更熟了對不對Printf所以Printf因為你要把它Output到Screen這是一個IoDevice所以我們說那個Instruction一定是Preview Instruction所以你要call system call那system call你就會透過API去call system call再進去去下那些pre-instruction的指令好所以是這樣那call完之後它才會return回到原來的地方也就是我們之前說的system call的流程對不對是一樣的所以你自己call所以當然會回到原來的地方

所以這個大家應該很能體會啦所以為什麼我們在System Code上又要再加成API或就像Shell那種概念第一個很簡單因為這樣我們才可以很快寫Program用C、Java這些Lang語言第二個Portability像Poxy，所以Poxy為什麼會有Poxy這個Interface跑出來也很大的目的就是要整合，對抗當時的Microsoft，那第三個呢。 Efficiency的意思就是，其實很多的Code其實不需要Code OS的那對於一個系統運作不是那麼清楚的人，有時候他不知道

他到底要不要Code System Code，因為System Code是一個非常Expensive的Code，因為他不是只是Code，只是把你的Program Counter一個位置，他是Interrupt你們最一就會 Trace了那整段流程，所以他是非常比較花時間的，還會用到OS，所以會影響到其他使用者的那些控制，所以咧渣雷層API的目的其實就是讓使用者通常在用的這些事情，他可以幫你用最Efficient的方式去Implement它，就像我們剛剛看到Copy一個File二十幾個System Code對不對，

所以今天你自己寫，你有辦法寫到最好嗎可能贏不過人家吧，我自己設計OS的人，我知道怎麼去Code這些System Code去完成一個Fprint最Efficient的方式到底要扣哪些事之後怎麼扣所以透過API就可以去改善這個部分讓使用者不需要去對於下層到底怎麼實現這件事情到這麼的了解所以其實也有Efficiency這個事情在裡面最後這一塊其實稍微講一下你們都知道也就是System Code就是像一個Function Code一樣就像大一在教

Function Code的一樣從這塊是你要passing這個parameter所以parameter的passing其實有幾種方式就是完全一樣就是Function Code啦所以他只是後面的流程不一樣但是他的這個基本的把passing這個parameter的部分是跟一般Function Code是完全相同所以這邊只是稍微講一下那比較重要的是各位的注意你可以留意一下他現在的這個implementation他是用

哪一個方式去passing這個parameter的那passing的方式呢基本上不外乎就是你們很熟悉的啦第一個直接用register啦所以就是register嘛所以你就寫到那個register entryCPU就會讀到那個值就可以做事了第二個table of memory簡單來講就是傳一個pointer啦完全一樣啦所以就是意思就是當你的這個system code的parameter他可能要拆很多的這個參數的時候我們常常會做的這件事情是創ate一個data structure這個大家應該知道然後呢把這個data structure的pointer傳進這個function code裡對不對所以

收到被code的這個function code他拿到pointer他就可以去讀這個data structure裡面的值所以這就是這邊的這個意思所以一樣System OS也是怎麼去做的只是在於說OS因為他是有所有的權限所以今天他任何一個人給他的pointer他都可以去access他都不會被擋掉因為他已經在Kernel mode裡面了好那最後一個就是stack所以也就是一般的function code我們直接塞參數的時候

我們知道它其實會放到一個我們的到講這個process下一節的時候會講得更清楚所以每一個process它都有一塊memory叫做所謂的stack所以你可以把東西push進去然後pop出來所以第三種的方式就是透過這個制定好的這個stack基本的架構所以你By default,被call的人這個function他就知道去pop這個stack，然後把裡面的值拿出來所以他可以一直pop一直pop嘛，對不對所以這一樣，

這比較記啦這個就有點瑣碎你們應該是大一function code概念就應該有了所以system code也是一樣的，簡單來講那這只是圖啦這沒什麼對不對所以你可以把資料放到某一個地方這是table of memory嘛然後你把X這個pointer放到register然後就可以讀出來就知道資料放在哪裡了，那只是說各位的HOWARD1我會希望大家去看一下你不要只是copy paste而已，稍微看一下裡面content你就知道它是用剛剛說的三個裡面的哪一個了，

這個希望大家去想一下demo的時候或許TA會問到底他是用哪一種方式去pass這個system code的parameter好，所以這部分我想暫時不問了所以大家應該知道，所以這個大家就是一些很基本的問題希望大家去看一下最主要就是system code跟API的差別清楚的知道他們的不一樣的地方.