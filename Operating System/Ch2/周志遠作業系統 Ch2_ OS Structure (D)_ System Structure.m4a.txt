undefined
好那我們現在進入到最後一塊System的Structure也就是作業系統它的架構自己本身這個軟體的架構是什麼其實我們剛才你看到NACHOS的一點那我們先來看這個其實有非常多種那從最簡單的Simple的到現在很熱門的這種Virtual Machine概念的所謂的OS Structure我們都稍微Cover一點讓大家有個概念首先大家一定都知道我們一直不斷強調使用者他所要的東西往往跟系統

看的东西是不太一样的系统跟使用者有很大的落差所以我们中间才有API啊这些东西对不对那again在设计一个作业系统这个整个软体的时候他们的目标很不幸的又是不一样也不意外所以对user而言你就想想你自己就好了你今天想要惯的一个作业系统它怎么样你会觉得是一个好的作业系统

第一個easy to useconvenient嘛對不對而且是人喔人的話當然是這樣子對不對那第二個勒他要很reliable對不對就是說他不能夠隨時crash像早期的作業系統常常blue screen就是變成一個笑話一樣的大家就知道就是不穩定嘛那再來勒現在也很重要就是safesecurity對不對所以你不希望你的電腦隨便的被人家給入侵

那同時人就比較貪心所以他又要這些又要快所以Efficiency當然還是要還是蠻重要而且指的是Interactive的部分這也指的是就像是我們知道手機嘛你點下去它要反應所以這個Fast不是純計算的Fast喔其實是那種Interactive的Fast所以是那些IO要處理Time sharing的那個Fast所以跟純粹說我要計算一個for loop全部是計

算的instruction然後多快那個其實是有一點不一樣的使用者care的是這個interactive的這個環境下它能夠多快反過來這個系統這邊的design的話它並不是要easy to use它要easy to designeasy to debug還有easy to implement對不對所以你要去維護它這可是非常頭大的事情所以如果寫得非常複雜那bug很難抓或者是我今天要對它做一個extension我要把它做一些修改的時候我要怎麼去maintain它這會變得非常非常的

複雜那所以當然它也要reliable對不對我們說過kernel code是必須要沒有bug的對不对那當然他也要Efficiency不過這邊的Efficiency不是那個Interactive而是指的是單純的去處理這整個系統運作的部分不過最大差別就在於說使用者需要方便那系統則是需要去方便Maintain跟實作所以這邊的方便其實也是不太一樣的，所以我們來仔細看一下結果是什麼，這些例子就會很清楚這個差異性在哪。

所以第一代的OS，最早時候的OS不管裡面多複雜，它的System的架構其實就像這邊所看見的一個狀況尤其是當時的Microsoft DOS的OS是最具代表性的最簡單架構的一個OS為什麼叫它簡單呢？因為你可以看一下這個整個作業系統架構最下層是Driver一定要有嗎？因為IO Device所以一定要有Driver，這個不用講上面當然就是Application，這邊是BIOS的Driver這邊是Software的Driver，所以這兩個其實都算是Driver所以真正的OS就是這個叫做Resident System Program，

一言該過所有事情了，所以簡單講就是沒分啦，所以叫Simple就是他沒有架構啦，簡單來講所有東西就堆在裡頭就對了，怎麼摳隨便你沒有定義所以說他當然開發可能很快當時也系統沒有那麼複雜跑率的事情沒那麼多會動就好趕快把上面的GUI上面的API這些弄得user friendly比較重要，那系統裡面架構其實就是全部混在一起，所以就叫

意思，就是它沒有分任何東西就是基本上就沒有架構好，唯一的架構Driver跟OS切開了，這是很明確的不能說它完全沒架構就是Driver的確就是一個Layer所以你可以Plugin你可以去用其他的IoDevice，那這樣的問題當然很明顯就是他非常的不安全，所以為什麼90年代的時候為什麼那麼多bug現在不是bug是worm那些病毒現在可能好一些是因為系統架構有改善，但當時其實非常非常容易被鑽漏洞因為他太多因為定義不清楚所以他也不知道

是合理的還是是不是應該這樣去扣這些system裡面的function code然後呢非常難去maintain，所以其實就是那在Windows或Microsoft的角度這一點還好，因為他是一個單一的公司嘛，所以可能也還好，但是像Linux後來對不對我們知道現在軟體趨勢完全不同現在講求的是open source大家一起來是一個community大家一起來貢獻，那像這

樣子的架構這沒有辦法貢獻啊，你改下去可能就影響到所有其他人，那大家怎麼一起co-work那當時世代不同，所以一單一家公司當然這些有辦法去克服它所以這是所謂的simple，那很快的大家其實就發現那真的不是很好的solution就至少以系統的角度或許 interface 那些你可以做到很好啦，但是系統本身並沒有辦法很好的去 maintain

它等等，所以很快有人就提出了這個所謂 layered OS architecture。簡單來講就是我們要把裡面這些所有的 code，因為其實 OS 是一個很大很大的 program裡面會有非常非常多的 subsystem，所以你可以看到Memory可以看到IO Driver對不對User 的Program Process 像CPU Scheduling_even到最後一些Hardware 的這個Instruction的部分很多很多的Subsystem，所以就像我們這些Chapter也都在講這每一個裡面自己做的事情，那整個OS run起來就像我們說的其實是run起很多個Process然後大家互相溝通那，

但是這些雖然是很複雜他們的當然也互相會依賴彼此就舉例來講Memory我們提過有所謂的Virtual Memory Virtual Memory是用Disk來當作儲存空間，所以代表Memory要 Code IO那IO難道就不Code Memory嗎其實也會，所以IO如果他想要比較快他想要去減少一些Memory Copy的話它可能就要用到一些Memory Management的一些Feature所以其實Layer它的好處

就是它的是比較強硬就是要把這些所有的這些Process這些把它全部切成一個一個Layer那每一個Layer就是像這邊所看最核心的最Low Level我們叫做Layer Link然後再一直往上包那level上面的人可以call裡面裡面的不能call外面這就叫做layer對不對所以layer0可以去calllayer1可以calllayer0的這個範圍裡面你定義的那一些process或subsystem的API但是level1的人不能去calllevel2的人所以像這個例子來講意思就是說memory可以去call process可是memory不能call IO

因為它在比較高的layer所以你在design上你就不應該去make這個function call因為那樣就會破壞它的layer所以就像這邊說的所謂的layer就是指layer N的人可以去call任何0到N-1 layer的function call只能這樣call你不能往上那這樣的好處是什麼呢?非常容易Debug跟Maintain比較啦因為今天你可以一層一層去Test嘛所以

我們知道你每Code一個你Run個Program都可以去Code它的Code Pass對不對所以它的Pass不會是進去又出來不會這樣複雜不會繞一個圈圈等等它就是一層一層所以你會知道是哪一層的這些Process或Subsystem出問題了那出問題了才會導致於上面一層有問題對不對今天你在這邊出問題的話這邊如果是OK那其實基本上就代表下面的一定是也是OK的所以就會比較容易去做debug你知道

是哪一個Layer裡面的Subsystem出問題了好但缺點就我們剛才說的其實最大的問題在這個Define Layer是很而且是有時候是沒有辦法很好define我們剛才才說IO memory這其實是互相扣的所以你要到底要怎麼切那你切的不好可能它的效能就會變得很差因為你可能會用其他方式繞來繞去就會破壞整個layer等等那另外一個很大的問題就是它的效能會比較差因為你有layer對不對所以代表你今天就是一個layer一個layer往下扣

那就跟我們常常在說Socket Programming網路那邊的缺點一樣大家可能還沒完全學到不過如果有學到就知道它有Layer好幾個Layer然後一層一層在那邊Package unpackPackage unpack這也是同樣的道理所以你可能就會變成會有很多的Memory的Copy然後Code一大堆Function Code你Code我再Code再Code再Code才能夠完成你沒有辦法直接的跳到某一邊去Code

所以相較之下它的效能可能就没有办法做到那么的好这个就是传统的Layer所以大家知道就是切这个Layer的概念就可以好那所以Linux早期比较像那样就是比较Layer的这样的方式那除了这个我们看到的Windows跟Linux早期的雏形之外呢其实呢当初研究这边还有propose出来一个非常非常有趣大家其实要知道的叫做MicroKernel的概念

那MicroKernel它就是所謂的MicroKernel的OS是從Kamehameha這邊當時還在設計OS的架構的時候他們所提出來的那他們的最主要的概念是為什麼叫MicroKernel意思就代表說你的Kernel的程式碼應該要越少越好因為越少越小的話它就比較不會比較reliable第一個很重要比较reliable因為只有那些code不要有bug就好其他有bug無所謂第

二个它有modulize的概念進来了也就是說它的kernel只是負責去溝通這些不同module它把所有的這些subsystem都變成一個一個的module那它中間的kernel只是負責去溝通這些module之間怎麼去傳輸怎麼去handle le fail跟interface的部分所以今天如果你的系統有新的IO Devices或是新的一些做法的時候甚至於說你的這個Memory Management你今

天想要把它換掉就像我們NATURALS的作業一樣你要把它換掉變成另外一個方式的話那你就去只要把你的Memory Management的那個Module做重寫就好就把它Hook上來就好它並不屬於OS的一部分只是它可以把它變Module去Access而已這個就是所謂的Micro Kernel所以可以看到他有Modulize的概念在裡頭這個Micro Kernel尤其他的一個他當時比較嚴謹一點的定義是只要是在Kernel外面的畢竟這是Kernel所以這邊你看到的Graphic的Subsystem甚至於IO的Manager全部在User Space所以他並不在Kernel裡面他在

他在user space裡面所以就像是一個user program而已所以這也是為什麼他crash沒關係就像我們說的只要Kernel不crash就好所以Michael Kernel的意思就是他把這個Kernel縮到越小越好只負責溝通跟定義不同module之間的interface那其他所有的component OS的component全部implement成像是一個user的program一樣在運作所以你可以看見它都在user的space上面所以它很容易portable然後非常容易的去做extension這就是micro kernel的概念那這樣的

做法它的缺點很明顯的是什麼就是它的效能又會比剛剛再更差一點對不對因為這每一個User Space跟Kernel所以你每一次你在Subsystem之間如果要溝通你都要透過Kernel所以那都是一個System Code前面的你可以看見不管是Layer或Simple他們都在Kernel Space所以他沒有Interrupt他就直接Code就像

你們Program之間Code所以這個會非常非常慢因為你每一次溝通甚至於KernelSuppose是OS的這些Component之間溝通他全部都是System Code所以會變得非常的慢而且它為了因為很多人共同運作所以它為了要避免Synchronization我們後面講一些問題它是透過Message Passing所以要溝通你參數要去傳你一定要做Memory Copy所以會變得很慢這是它的缺點了很Reliable沒話講但是它的效能你可以預期可以看得出來因為 System Code因為 Message Passing

所以會變得更慢一些，但是它非常的Modulized。那現在的我還沒有這麼去Study，但我有聽說，我也知道大部分現在新的一些IoT的Device就是這種Embedded System。他們其實往這個方向走就是有一些新的作業系統Specialized OS或者甚至於大家都Mix所以就像Mac好像也有，就是有部分的概念它是像Micro Kernel的概念去做的，那這是很

極端啦就是說早期的時候那提出來另外一派就是那我們就用這樣的方式做OS全部把它變成Module然後全部把它丟到User Space去，然後Current要非常非常小。那這個概念其實大概有它可取的部分所以真實的作業系統還有新的一些作業系統有些人是這樣去考量去用的好，那第四個Modular的OS了，那這就

常見了，這個的確大部分基本上現在Linux這些全部都是用Modular OS因為就像OO概念一樣，Eventually系統也就像語言一樣，所以就應該用OO的概念所以就像剛剛其實很類似的它也一樣在我們的OS，我們就要把它變成一堆Subsystem而且這些subsystem必須要define好它的interface也就是像OO的方式去寫這個數學系統就對了，那跟剛剛的唯一的不同就在於說全部都在kernel space，所以它keep了那個modular的部分，

但是它沒有那麼的嚴謹所以它就全部就是一個單一的系統，然後全部在Kernel裡面，所以它就有很多的Flexibility至少你在溝通的這個部分，它就不需要透過Message的Passing，那很重要的為什麼叫Modular，意思就是你是Loadable，所以你今天可以去Load Kernel Module進去，然後就可以去改變這個作業系統，它的一些Feature，那again,我們沒有辦法給你們出那麼多作業但其實非常encourage你去看這兩這都沒有很多content怎麼樣

寫一個Kernel Module非常非常簡單的例子都有所以你就follow那個step可能一個小時你就可以做一個自己的Kernel Module你就灌一個自己的Linux然後你可以按照這個步驟自己去寫一個Kernel Module漏進去那結果是什麼咧為什麼Kernel Module怎麼運作的你可以看一下這邊基本上我們都說過任何

只要是System Code會透過InterruptInterrupt會到一個TableInterrupt RoutineInterrupt VictorHardware Synchronous的話是Interrupt VictorOS這邊System Code的話其實有一個叫做System Code Table所以就像你們改NACHOS是一樣的所以這些Table本來就有Reserve好一些Entry是空在那的所以當你用這個Administration的permission的時候你可以下insert module的意思

就是你去改這個table的entry所以今天你就可以定義新的system code那事實上因為最常見的重法其實是replace也就是你本來有一個system code叫做fopen好了那你今天就insert一個overwrite那個entrysystem open是你自己寫的一個kernel的code然後你中間呢就第一行就是說print filename就偷偷做一件事情然後呢後面再去

Code到原來的Function Code所以你只是在那邊間接啦有沒有所以你只是在Forward這個過程中Code Pass中間先Code到你寫的System Code的Module他再Code原來File System Code的Module所以其實不會影響到系統的運作對不對然後你就可以偷偷的Print出出一個訊息，現在的File Name是誰或使用者，這就是基本的概念，就這樣，所以通常去改kernel的一個方式就是這樣去insert一個kernel module然後去替代掉原來的然後再接回去，所以你就可以

攔截那個system code然後去做一些profiling、debugging或是其他的事情，所以是用這樣的概念，因為本來就是透過這樣的流程，就是system code table entry做修改好，那我想我們今天應該只能上到這了禮拜三有課，所以我們禮拜三會講Virtual Machine。.