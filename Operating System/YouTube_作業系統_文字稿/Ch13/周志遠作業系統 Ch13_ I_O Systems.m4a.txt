undefined
好，那最後最後一個章節Subsystem，所以我們從最上層一直講到了檔案系統講到了Storage System那最後缺的一塊呢就是Input跟Output對不對所以就是Storage Device還有我們的 OS 之間這個中間的過程input output 的過程是怎麼被 handle 的部分就是最後一個章節了，那這個章節其實如果你去看課本你會發現它比較的瑣碎啦，所以比較重要的部分很多它都只是點到而已所以最重要的部分呢其實是在這個 IO 的 method，大家就會看見就是

這些IO的方式Input Output的方式其實可以根據它不同的做法是可以做一些分類的所以我們之後會比較強調是這個部分好，那，所以IO System對不對為什麼重要因為我們都知道系統的運作要嘛在計算嘛要嘛在IO嘛所以計算我們都知道Memory CPUIO呢其實當然要Storage Device那它的運作的方式就是IO System要負責那IO這邊我們都知道當然最主要你的end point最後就是IO devices然後就有各式各樣的device對不對

所以它很challenge的部分就在於它非常的多樣化那同時呢，那要去控制它的這些部分的component就是我們俗稱的這種IO subsystem 就是你到底要怎麼對這IO device做input跟output那它最難的部分在這個很多樣化但是對於軟體而言對於Programmer而言 對不對對於Software而言我們當然都希望有Unified Interface 對不對所以才可以用同樣的方式然後可以控制不同的Device所以這個就是IO System它主要要去解決的問題第一個

是怎麼做IO另外一個就是它要怎麼樣提供一個Unified Interface那這個Interface的部分其實大家都很熟悉就是俗稱的Driver就是演進下來的結果就是大家最後認為的就是我們在整個系統架構下的最下層OS的最下層要有一個Driver Layer這個Driver Layer就是由這個你的去管理這些Devices你直接自己Install的對不對那你自己去根據我的Unified Interface去Implement怎麼樣去跟你系統溝通的這個方法就是用這樣的方式來做一個Isolation

那當然因為各式各樣的Device嘛所以這個Interface也不好定說真的那所以大體的方向咧基本上就是第一個就是去分不同類型的IoDevice嘛對不對所以你可以想今天有這種Storage的對不对不管你是SSD Hard Drive還甚至於是TAPES它們的Behaviour都很類似對不對所以你就可以訂一個類似的Interface比如說它就是以Byte為單位在那邊做讀寫的嘛對不對

或者是一些 networking 對不對所以不管你是用哪一種 networking不管你是哪一種 network 的adapter 或是 card他們基本上都是類似的運作方式所以我就可以為他定義這種類型的 interface所以當然也只有 eventually你不是單一一個 interface所以你也是先把它做這些分類然後不同類型你去設計不同的 interface那當然還有最後一種做法我們大概會見到的就是其實還有開後門

就隨便你所以就很多bug也是從哪裡出來的那所以這些interface也隨著時代像現在很多手機啊你可以想見touch screen這些對不对很難去區類在某任何一個或許是這個吧但是又不太一樣對不対因為他有position所以當然有可能就會增加不同的interface進去不同類型的電腦系統這一層的interface 当然也有可能會有所差異好

那當然我們今天介紹是基本的所以基本的意思就是說IO這個動作咧它整個流程它一定會有的對於電腦系統而言就是管理的OS或者說這個系統而言Subsystem而言一個Device它不管是什麼Device你最後就是要把它連到我們的系統對不對所以連到系統的那個Point就是所謂的Port所以Port的定義其實就是一個Endpoint所以就是對到就是一個Device所以像你有一個USB

你插進我們的電腦像我這樣一插進去像Projector好了對不對我透過不管什麼轉接我插進去我一定是插到某一個Port所以那個Port就是那個Device的ID了所以那就是可以去認到底有哪一些Device的方式對於上面的軟體而言我就是管的就是一個Port Number就對了然後呢這個IO的Device透過這個Port之後它要能夠去把資料傳進來

當然就要透過Bus那所謂的Bus就是我們說的這些Wire啦就是所以是在Controller之間或是Controller跟Device之間連接的這個Bus那這個Bus呢它的含義又是兩個第一個Physically它用什麼方式Physically的這個物理的這個方式去傳遞這個Wire到底是怎麼做的第二個就是它的Protocol對不對所以就是它用什麼樣的方式去溝通的所以讓我們的資料我們知道這個資料是不是有

是4個byte還是3個bit它這個長度每一個message的長度是多少等等怎麼樣去解讀上面的data所以透過這兩個就會有形成各式各樣的Bus那最常見的當然聽到就是PCI Bus就是我們一般Value Board上面Support大部分IoDevice的Bus好那透過Bus我們剛才說的溝通的就是Controller跟Device或是跟Port對不對或是Controller跟Controller之間所

以Controller就是那些控制這些跟透過Bus溝通的這些部分的Hardware那當然上面有它的Code對不對就是我們的Controller所以這些Controller當然也有比較Smart或是比較舊一點的對不對所以我們剛才說的這種SCSI的Controller就是比較Smart的Drive就會用這種Controller它就知道怎麼去修復這個硬碟它就不需要靠上面的OS來幫你處理或

是那些Driver它直接就可以處理掉所以這是Controller那這樣當然就可以減少我們CPU的Loading所以整個電腦效能也會更好嘛對不对所以當然這些比較Smart的Controller通常也比較昂貴就是這樣因為它等於是一些Co-Processor在幫助我們整個電腦系統的運作好那把這三個元件所以IO Systems這個溝通IO就是透過這三個那

你把它接在一起就像我們這邊看見非常常見我們電腦一般的電腦系統就是這個樣子對不對所以你當然有各種不同的Device那Locally它可能就會有一個Controller去管理這些所有同一類型的Device然後呢這些controller最後eventually是要跟processor溝通的嘛對不對或者說controller跟controller之間它也有可能直接的溝通像現在很多的

我們知道很多比較powerful的電腦的話可能有些controller的資料我可以直接從一個port進來直接output到另外一個port不需要透過CPU了所以這些controller當然更smart它就甚至於可以去做到這些事情所以controller跟controller之間當然同樣也還是透過bus那我們現在的電腦系統來講PCIeBus就是最主要連接這些Controller的Bus然後自己當

然又會有IDE的Bus跟Controller那就會自己再去連那這邊可以看見的是最後怎麼透過到CPU呢最後是大家去買CPU的晶片的時候你可能會注意到它會跟你講南橋晶片跟北橋晶片就是一個CPU買來它一定會有這兩個晶片在裡面，這兩種晶片其實就是在控制這些controller北橋晶片控制的就是俗稱比較快

的那些controller就是它的bandwidth是比較高frequency高的這就是北橋晶片在做的事像Memory還有很多high bandwidth的low latency的一些IO device透過北橋晶片直接接進來的就是指的是這個方式那南橋晶片在管的就是這些速度很慢的傳統的這些像IDE controller這些就是接到南橋晶片去因為不同速度嘛如果你全部一起管當然它會卡到上面對不對

你整個速度就會被拖累所以設計上來講就是會把它切成這樣子比較這個速度快的跟慢的就是有兩個晶片個別去處理然後當然處理完之後eventually他們會去跟CPU直接溝通好所以這是一般電腦系統的架構就是這個樣子所以有了Port有Controller有了Bus之後我們的電腦系統軟體到底要怎麼去下指

令下指令的方式最傳統的我們就稱之為Port Map的IO什麼叫Port Map的IO就是我們剛才提到的因為我們Hardware本來系統設計所以其實每一個Device本來就會identify被它的 port number 做一個分別或者說 port address 啦所以其實每個 port 都本來就有 label 號就是不同的 port number那一台電腦系統做出來的時候受限於它的 port其實

這些都是一開始就已經燒死了你就只有那些 port number 可以用所以大家當然也都知道這個 port 是比如說是 USB 的 port還是這個 port 是什麼樣子的 port其實這些都是一開始就已經指定好了這跟你軟體無關好那有了這些Port之後的重點就是你上面運行的軟體或者CPU這邊執行的這些Code他就知道怎麼樣子去把指定要傳給哪一個人了對不對

那所以他傳的資料是什麼勒其實就是我們最早時候在介紹在介紹系統運作Interrupt概念時候的例子其實也就是這個Port指到的這個Controller上他就是會有Register然後會有data的跟command的部分對不對還有它的狀態然後就透過這些值你就可以開始做資料的傳輸了因為eventually你就是只是要

資料的傳輸而已嘛什麼時候要做read或者是write然後要儲存多少的資料所以你就透過register的值去下你的這個instruction到那個port上面去你就可以做IO了對吧透過bus然後把資料傳過去那这些instruction因为它指的是对port address下指令，所以這些instruction就是我們俗稱的IO instructions所以IO instructions其实怎么去看很容易就是IO instructions它里面的其中一个栏位一定是port address其他的因为其他所有的CPU instructions都是跟memory在操作对不对所以都是memory address那如果是IO instructions它里面一定会有

Port address而不是Memory address所以這是很容易做區別的因為你就是跟Device溝通嘛所以是Port所以你是寫到Port而不是寫到Memory去好，所以有IN跟OUT這些常見的這些其實就是它上面就是寫的時候issue的時候你就會要一個Port number然後後面當然就是在裡面的Data的值等等好所以你可以看見這就是Port number比較typical的一個話

你看看前面就是DMA的Controller我們最後會講什麼是DMA然後當然還有Timer Gain Serial Port等等對不對所以這些全部都是一開始就Hackle好的那當然它是一個Range啦所以你還可以Expand等等但是有Limited Port的Space就對了所以透過這些，實本來也就知道它是有哪一個Driver或是哪一個Controller來Control的，這都是不需要再去其實都是一開始就設定好的

好，所以這邊非常重要，所以當我們在做IO，怎麼樣去把資料寫到IO device的時候，我們其實就有幾種不同的寫法。第一種就是根據我們剛才介紹的，你是用什麼樣的addressing的方式來知道你寫到的對象是誰，那最傳統的就是我們剛才介紹的Port，不對，所以它又俗稱所謂的Port Map IO，就是我是用一些IO Instruction直

接告訴我們的CPU，在執行的時候，我要把這個資料寫到哪一個Port去，所以你只要用這種IO Instruction，用Port Number用Port Address的方式做IO的話，這個就叫Port Map IO。第二種做法，所以你不用Port，你不用這個Device的話，另外一個做法其實是另外一個做法，是有的就是用MemoryMapIO，就是你寫到Memory，而不是Port，那什麼叫寫到Memory？勒不用講當然就是你的Instruction，就是用Move啊這些，所以你裡面沒有PortNumber那為什麼

寫到Memory居然可以寫到IO Device去，這發生了什麼事情其實大家已經學過一個例子了Memory MapFile對不對，所以我們其實是把一個IO Device勒它的Data，它的這個Controller上Buffer的空間把它Map到我們Memory的某一塊區間去了，那那個動作當然要先完成之後你才能夠做Memory Map IO，所以其實你的你雖然寫到Memory，實因為你已經Register那塊Memory了，他知道那個Memory就是某一個Device某一個Port上它的某一個Buffer的某一個位置，所以你寫過去就等於寫到那個Port上面去了，

但是以Programmer的角度，因為你的指令是用Move用Memory Address，所以我們又稱為Memory Map IO，所以這當然有條件就是你一定是用Memory Map的概念去做的所以這種做法的好處是什麼呢，就是它很適合做大量資料的傳輸，為什麼因為對於CPU而言不要忘記快不快就是CPU 因為CPU是最快的那個人，我們不希望他因為IO而

在那邊Idle 對不對，那我一旦把我的Device Map到Memory之後，我們的CPU根本只要管把資料寫到Memory就好，他就不管了，剩下的事情就交給DMA或是其他Controller去做，CPU就空出來了，所以咧他的資料這個CPU就可以當你要寫的資料量很大通常IO時間很久對不對可是你卻只要寫到Memory所以很快啊 對不對所以他會比較Efficient

它的缺點就像那時候我們在學Memory Map File一模一樣就是第一個很不太reliable嘛所以一crash掉你的IO就沒了對不對你可能是資料遺失檔案遺失對不對那第二個的話來講如果資料量很小的話你光去做map的那些動作你可能就要initialization的時間setup的時間就會浪費不少所以這會比較適合就是大量然後你就只是資料就是只要把它output出去這樣子的一個IO的device

那最好的例子我們這邊沒寫最好的例子就是有啦顯示卡嘛對不對所以所有的顯示卡其實或大量資料的IO全部適合Memory Map包括File如果你的檔案很搭的話我們就會這麼做了所以這兩種完全不同的做法但是資料量如果很小譬如說你在什麼Send一個Signal譬如說Keyboard好了Keyboard你用Memory Map就非常糟了對不對因為你一次送一個Byte那我幹嘛Reserve

四個byte嗎這個很不efficient對不對所以就看你的IO的特性你就會用這個Memory Map或是Port Map兩種不同的方式OK齁好第二個我知道怎麼去address這個dev ice不管是Port或Memory我下一個問題是我要怎麼樣把我的資料傳過去我要主動的或者是被動的所以這也是大家之前學過一些的對不對

所以主動的意思就是pull就是我一直把東西push給你所以就是我們最早那個busy waiting的例子大家記得寫個while loop我一直去check in the status register決定我什麼時候要寫下一個byte或者beat對不對這個就是所謂的pulling的方式一直把它push過去另外一個就是notification所以是被動的對不對我等到資料寫好了你告訴我就好所以用interrupt你只要notify我就好所以一樣是有兩種寫法

那時候我們也教過對不對其實這種雖然說你要Waiting所以你的CPU會浪費掉但是如果你的Io requirement其實很小的話你去Setup跟Interrupt比較花時間你乾脆就BZ Waiting就好對不對那如果你的資料量大你就會用Interrupt所以讓我們的CPU可以空出來去做其他的事情所以就會有Pool跟Interrupt兩種做法好 第三個

我知道你要給誰了我也知道你想要哪一種方式來做IO了那到底誰要執行這個動作對不對所以你要把資料做搬移這需要某一個Processor才能做到啊因為IO Device都是死的啊它是沒有這個很被動它只是空間而已啊真的有這個會執行指令的只有這些Processor包括了CPU對不對所以第一種做法咧就是很傳統的就是用CPU所以當我們要把資料

不管多少資料用什麼方式你要搬動的時候我都用CPU去下指令每一次的搬移這叫做Programmed IO所以意思就是你看你的code你就會發現我每搬一個動作它都會需要下一定刷新它就是每搬一個資料你最low level的跟我上層的CPU刷新會對在一起這就是Programmed IO所以當然ProgrammerProgram裡面你會看見每一次搬移的動作那缺點就是

CPU很忙碌嘛所以每下一個instructionCPU就一直在下這些IO instruction就好所以它其實就被綁住了第二個做法咧就是我們等一下要介紹最重要的DMADMA是一個例子但是這些所有就是Direct Memory Access就是它其實是用IO controller直接辦資料CPU不用involve所以CPU不再負責辦資料這件事情這樣類型的做法就叫做DMA的做法

那這個你不是CPU所以當然還是需要另外一個Processor了所以這個負責搬資料的就叫做DMA Controller所以我們的系統裡就是專門Install一個Controller它的任務就是搬資料它也不屬於任何一個IoDevice的Controller它是獨立出來專門負責做這個資料搬移的事情我們就稱之為DMA Controller那它做的事情其實就是取代CPU當時在搬資料的那件事情而已那它不負責計算

好所以你可以想見什麼時候我們會需要另外一個人來幫忙勒當然就是一樣資料量很大的時候對不對才會需要另外一個人來幫忙那對於CPU而言我們下指令因為他資料量大嘛所以當然等的時間久你就會用interrupt的概念所以在CPU這邊通常就是會去跟DMAInitial一個IO request之後用interrupt的方式去被notify

然後咧他搬的資料咧因為資料對於CPU而言他不想要看到每一個搬的過程所以他希望看到的是資料你搬好之後就在我的Memory裡面所以他整個對出來你會發現使用DMA的話他通常就會變成一個Memory Map的IO然後又透過Interrupt的方式來實現然後用DMA controller去搬移他所以這三個不同的切割方式其實是可以互相組合的喔但是比較

配合在一起做你會發現是如果是DMA它一定是透過Inter act然後用Memory Map的方式然後如果你是Programming的Io的話一定就是用Program Io然後用Pooling的方式然後用BZ Waiting一個Byte一個Byte把它Push過去通常會變成這兩大類型的結果就是組合起來使用好那我們就來看DMA到底怎麼運作的step by step所以呢第一個

我們知道當然一切要從CPU開始假設我們就想說Agenic program說我要print然後一整個整個螢幕好了我們要print整個screen對不對到我們的這個或這個意思是disk啦所以我就要一次寫比如說100個MB的資料到我的一個檔案去那所以當然一開始是由CPU開始下這個IO的Request的指令對不對那因為寫的資料量大所以我們就想要用一個DMA的Controller然後想要讓我們的

資料是在Memory裡面這樣子去做一個讀寫的動作這個例子好像是Read對不對Send對不對所以用Read好了所以我們這個例子假設我們今天有個Program他要去讀一個File一次要把100個Megabyte全部把它讀進來然後讀進來的時候現在當然在Disk可是對我們的Program而言就是我希望他把它讀到我的Memory的空間然後我可以開始對他做Access所以呢第一個CPU就下了一個IO Request當然然後Eventually從你的Program Level到OS最後到Driver 對不對

所以到Driver知道我要讀的哪一個File在哪個位置這樣子那第二步呢就是他因為他希望要叫這個Disk Controller要去做讀寫嘛 對不對所以他就會跟這個Disk Controller先溝通用Driver所以他知道他要寫的檔案是在這個Driver的哪一個位置比如說X這個位置然後我要把它不是是在這邊的Disk上某一

個位置但是我要把它寫到的是我的Memory Buffer裡面的X的位置然後Size就是C就比如說剛才的100MB的長度那當然我也知道它Disk的位置在哪裡然後把資料要全部漏過去所以他先跟Disk的這個Controller先跟他知會這件事情然後呢接下來他就會Disk的這個Controller然後他會跟他講說我

想要用DMA的方式去溝通就是去完成這件事情所以他就把這個指令給了這個IDE的Controller之後IDE Controller就會去跟DMA講去請DMA Controller去把這個資料做翻譯那所謂講的意思它就是setup一個IO的initiate一個IO的動作那它會提供這個controller的資訊就是它會知道我要讀的資料在哪邊然後要寫到的

memory的位置在哪裡然後呢這個DMA的controller就會開始根據你要寫是100個Megabyte但是這個controller上面的buffer假設只有4個byte那你就要4個byte4個byte慢慢的去搬動對不對所以其實在這中間其實會有非常多的IO request不斷不斷的來回那這個來回的動作其實都有DMA controller去執行的那等到這個他知道他執行的時候

的過程每讀四個半因為他知道他X的位置嘛所以當然他就知道寫到哪裡去然後寫過去之後他當然知道什麼時候可以寫完等到他都寫完之後他就可以產生一個interrupt然後去signal我們的CPUn所以告诉他说刚刚叫我执行的这个IO的动作request把它执行完了然后这个interrupt回去之后当然就会eventually就会

去signal给当初做IO的你的program然后他就知道这个IO动作完成了对不对然后完成之后他就会直接去看他的memory他就发现我搬完了对不对所以他的指令就会是其实是执行一行而已我要搬某个资料到X而已然后一次就是100個byte只要下這個指令就好，這個System Code一個System Code就好，然後它就可以把

它整個動作做完，然後執行完這個System Code的時候，它所有的資料都在這裡，而且在執行的過程中要注意到其實際CPU那邊只會接到一個Interrupt，就是做完之後的Interrupt，但是中間這裡其實是來來回回好幾次的所以，如果是我們剛才說的Programmed IO的話，倒過來的意思就是CPU 呢，每一次它就跟 controller 直接下指令，下完

指令，它就把資料搬到 memory，所以就這樣來來回回每次四個 byte，那一百個 byte，一百個 megabyte，那就是大家知道，就是這麼多次幾千次的來回然後CPU 就會一直在很頻繁的接到 interrupt，然後就速度就一直被拖慢所以，這個就是 DMA 的運作的方式就是這樣子就是跟Controller，他會先跟Controller這個DiskController講，然後叫 DiskController跟DMA Controller 設up一

個IO的一個request，然後開始做翻譯，然後結束之後 DMA Controller再signal我們的 CPU 好，所以這一個部分就是我們說的期末考來講，我們就是會cover到這邊，就是這三種不同的類型的IO的動作，它們的差別適合大的還是小的IO為什麼這是最主要的部分還有DMA的既然什麼是DMA就是有另外一款除了負責IO最後

我們只花大概15分鐘很快的講完後面的部分那知道這些IO方法之後當然可以想見這個其實實際上系統設計是很複雜的所以Subsystem其實要負責非常多的事情那基本上幾個大家需要一個概念的是第一個IO Scheduling這個其實大家就學過就是所謂的Disk Scheduling的部分還有File System的Scheduling就是這些IO的Scheduling當

然會影響你的Performance第二個部分Buffering因為資料的讀取其實很重要的是它不同的Device它的速度一定不一樣Memory的讀取速度跟Disk不一樣如果你Disk的資料寫到Network速度又不一樣所以你不可能把資料很快的直接從一個Controller直接寫到通常很難除非速度類似或者它沒有很好的溝通機制所以為了解決這

個問題就所謂的Buffer大家知道了就是有彈性的對不對所以你會把它寫到這個空間所以讓它可以累積一段時間然後等到慢慢的再把它寫到另外一個Device去所以這是主要Buffer的目的就是要解決速度之間的差別那它的代價就是你會發現一定是一個Memory Copy所以Buffer一定是某一塊Mem

ory所以譬如說你在搬移資料的過程中你要做比較多次的Data的Copy可是也只有這樣子你才不會有所謂的Overflow的問題第三個是Caching大家也看到了嘛我們在File System就一堆的Cache目的就是你不希望走到最Low Level的Device因為它的速度一定是最慢的所以Caching對Performance非常重要它也是透過Memory的Copy但是跟Buffer

目的是完全不同的有的時候我們一塊Memory我們會說它既是拿來做Caching又是拿來做Buffering但是那是目的上的不同當我們講Caching就是說這個資料是可以丟掉都無所謂的它只是一個Backup在那裡然後目的是讓我們的速度IO的Access的速度可以變快但是Buffer指的是要把速度之間Device跟Device之間速度的去把它做調節的目的

再來是 SpoolingIO4 都會有 SpoolingSpooling 的意思它是只有 for IO只有 for output 而已就是在像 Printer 這一類型的它的差別是它會把資料一直Buffer 在那裡但是它的重點是它要 Buffer 到滿了那個資料都進來了它才會做下一個動作這樣子用途的管理就叫做 Spooling所以像我們說printer你會發現他先load對不對

他load到spoolling的這個空間裡面去然後再一次送到我們的printer去把它印出來所以這就是spoolling再來arrow correction或是arrow的handling所以我們剛才也看到了所以不同device它都還會有一些arrow checking對不對或是RAID這些都是屬於IoSystem要去處理的你要怎麼樣子可以去detect arrow怎麼樣去recover這些arrow然後更重要的是

它不能夠讓整個System Crash掉所以這是IO System要去處理的所以其實很多的Bug等等都是從IO跑出來就是這樣因為它其實還滿難管理的所以很多人會透過IO的方式去入侵你的電腦然後就因此造成整個電腦Crash所以最後當然就是Protection就是我們也教過的Preview Instruction所以IO其實都是Shared Device所以其實非常Sensitive那我們的做法就是知道IO Instruction全部是Preview Instruction所以是在Instruction Level我們就可以

對IO做一個基本的Protection這講一下所以以這個Linux像Linux或UNIX這些系統而言，它怎麼管理IO的方式其實它全部把它當作File，所以其實反正一個DeviceIO嘛，Input Output，所以就跟寫檔案一樣的概念，所以它其實在OS裡面的Data Structure，在管理IO Device的時候就是直接把它想成一個File，然後它的那個空間就當作這個File的IO

的空間，所以如果你去看的話，你會發現Linux的作業系統裡面有個資料夾是IO裡面一大堆的檔案，然後每個檔案對到就是不同Port Number其實那個就是指到不同的IO Device，只是它最後寫到的時候他是寫到是各式各樣Device的這個Memory Buffer去，而不是真正的File System，那個Disk的空間而已然後為了管理各式各樣還

有Device對不對，所以就會有一個這個Device Queue所以他會知道我有哪些Device，然後每個Device上其實他有Request的時候他會把它串起來，所以他就知道這個Device他是有哪一些Request現在正在需要被執行然後你的這些Scheduling的動作就可以透過裡面的Information去排列知道哪一个request先做哪个在后做然后他可能会有一些stat

us所以他知道这个request现在是在waiting还是正在processing等等就是把这些request的状态把它串起来做一个IO的管理好这个有点这个蛮重要的就是需要知道的观念就是在IO的这边很重要的是它有分为所谓的blockingIO跟non-blockingIO意思就是说每一個IO當然都是eventually就是扣一個system code對不對那這些system code扣下去之後如果你會block就是意思就是說你不會return直到它完成之後才會return的話這個叫做block的IO那這樣的

結果通常就是會產生一個synchronous communication的結果就是同步的communication意思就是說我今天扣一個write當我這個write的這個code return的時候我就知道這個write的動作做完了對不對 所以這是同步我知道它的狀態是完成所以這就是blocking的API它就是要實現同步化的input跟output或者是溝通的這個行為那其

實有另外一類型的這個I order這個I order system code或是function代码是所謂non-blocking的所謂non-blocking就是說你call下去之後呢其實它會立刻的return它不會卡在那它可以立刻return的原因是因為你也剛才看見其實System裡面他有很多的狀態可以記下來所以他把他需要的資訊把他記下來他慢慢的幫你做IO他不需要讓你

的Program卡在那裡所以他會直接的Return這就是所謂的Non-Blocking但是因為他直接Return他事實上還沒做完所以這樣子的溝通或IO我們稱之為Insynchronous的IO也就是說你其實你Call一個Write你直接Return了可是其實Write完成了嗎沒有啊對不對所以其實他沒有同步你上面的人以為他做完下面的其實根本還沒做完所以

是非同步的狀態那當然這個做法以Coding的角度是比較直覺的對不對叫你做件事你就做完就對了所以比較容易Coding但是他的缺點就是他的效能很差因為你上面那個人就卡在那了對不對所以通常大家還是用Non-blocking然後用這種Ansynchronous的方式然後他什麼時候會做完其實就透過Interrupt所以你Coding完之後他會Interrupt

他會告訴你什麼時候做完對不對所以其實大部分的是生扣連 internally 的話幾乎都是non-blocking然後都是透過這種 asynchronous notify 的方式去完成一個IO，所以其實會比較像的是你會有一個 write然後會有一個 write callback會有兩個 function call來組成一個 input output應該說一個 IO 的動作就是你只要 write可是你會有 write function call先 callcall完之後呢你要去等的話你要去call那個writeCallback function它被call的時候

這個動作才真的做完就是兩個function接在一起的稍微有點難想像不過其實那個才是真正系統裡面做IO比較常看到的方法其實是會把它分成兩個階段這個稍微看一下就好了這個意思是說其實在做IO的時候從最下層的Hardware對不對到上面的Device Driver再到上面的IO System或者說File System其實上面呢就

會做Caching所以當你做IO的時候不一定會到最下層他會盡量的用Caching讓你很快的可以回到使用者端對不對那不行的話才會一路到下面這一個Device Driver真的Physically做一些IO的動作然後中間呢其實就會透過我們的Driver然後Driver會透過Interrupt的方式跟下面的Controller溝通，所以才不會讓我們的程式卡在那個地方，

所以這只是一個IO的基本上去看到一個動作，那這個流程想要跟大家看到的是，IO通常非常的慢很多的程式，尤其像現在大家在處理DataIO都是Bottleneck的原因，實你光從剛才看那個剛剛那個流程就可以感覺到第一個，你要去靠這些driver code對不對，所以你其實是要去一層一層的code下去才會讓一個IO

動作完成，剛剛看到就subsystem然後再driver然後再controller對不對，所以你要好幾層的程式嘛，然後咧你有很多層的問題就在於你會有一堆的contact switch，所以你每code一層一個driver，那每一個subsystem它就是不同的process，所以你都是一些remote process的code都在那邊做contact switch等等，所以它通常這些code也都會變得比較慢，然後來我們看到

每一層中間為了IO，我們都會有buffer或cache對不對，所以你有一大堆的data copy，所以supposedlyideally使用者想要看見的東西是我的資料在我使用者的application的user memory我要做IO的時候你就一個memory copy對不對copy到我IO device就好一個copy但事實不然事實因為這一堆layer所以每一層大家都在幫你做copy那你就可以想它的速度會慢很多很多了對不對

所以這個怎麼樣子去減少你的data的copy也是一個滿大的issue所以現在其實很多high bandwidth就是high performance的IO device它可以做到的事情就是zero copy它可以有辦法從controller之間的memory buffer直接做copy或者是從user的memory一直直接copy到controller的memory甚至於直接copy到remote host的memory都有那這些技術就是

現在很多在發展的就是為了要減少你的memory copy最後一個就是因為你這些通常都是透過interrupt有好處有壞處嘛對不對好處是大家可以分工啦壞處就是一定又是多加了很多overhead所以對於單一使用者而言其實他就是多加了這些要去launch這些interrupt的overhead所以才會看到我們就是content switch

盡量可以減少所以你不希望有很多的layer然後不要copy，然後尽量不要call interrupt。如果是小的IO話，然後用DMA，所以你的CPU可以空出來，然後讓他的performance變比較好。最後一塊這個幾秒而已所以最後這個我們提到了Driver對不對。所以其實Driver我們提到它最主要就是提供一個Interface。但是有時候有太多類型的IoDevice所以基本上就是去分類，然後不同類型的IoDevice我們制定它適合它的Interface。所以你看常見的對不對

這些不同的Device對不對，它有不同的Access Method，它可能有不同的速度，然後有不同的它是 one way 或是 two way。所以有很多不同的特性就對了那根據這些特性我們當然就是可以分類。所以分類結果呢常見就是這些啦block, character, memory, network 跟 timer 的 interface這個當然大家看過就可以那就是我們剛才提到的最重要的是就算你再怎麼分類總是有人不 match 任何一個對不對或者是為了要去 match 這些限定的 interface你就要做一些

效能上的compromise就是要犧牲掉一些東西所以大部分的主要尤其是早期的Microsoft的這個DOS常常會被Hack的原因是什麼就是它有一個Backdoor interface所以它擺明了就是讓Programmer它可以直接寫到Device的Controller根本不用透過中間的IO System這些規則它可以全部丟掉所以它可以很快去開發一些東西但是這個Backdoor就是這一個System Code

你只要Code這一個你就是可以去操作任何的IoDevice所以很方便但是它就是變成一個很嚴重的一個Bug也不算Bug而是一個Security的一個Hole在那裡所以大家看得到像Block是什麼這樣如果對到這個File System大家比較熟對不對你Code的這種Rewrite Seek這種是所謂Block它一次就是一個對不對一整個這個Memory Buffer的概念Character呢就是以Byte為單位

對不對所以像這個他可能就用pooling的方式做IO這個他就用interrupt的方式做IO因為一個是小的嘛一個是大的資料的size那如果是這種network就大家知道的會有send receive對不對那就是他的行為就是這樣那其他的話會比較特殊的就是一些stream或是file pipe這我們當然就不再講了就是一些像queueing的方式就是他整個運作他可能是很多個 layer 才完成這個 IO 的動作所以有一些其他類型的 approach那就會有不同類型的 interface好所以這是第 13 章所以後面只是稍微簡單的介紹那期末考的話大家記得就是前半段就到各種 IO method 的部分那邊大家需要知道好那我們今天就上到這裡.