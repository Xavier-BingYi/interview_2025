undefined
好那我们讲完software所以software这边指的就是像刚才看到我们就是写程式嘛然后去guaranteecredit section的这个requirement那你真的在自己寫程式碼,難道真的會去寫那些嗎?大部分其實是不會的,因為大家就是用扣Tool就好,對不對?所以我們教過了Pthread,Thread Programming就是常常會遇到Synchronization的這個問題所以Pthread這個Library它提供的Solution,Tool的API就是Mutex

所以在 P3 裡面它有一個這個自己已經 define 的這個 special 的這個 variable 或是說 token 就叫做 mutex它就是 mutual exclusion 的簡寫就叫 mutex那它的用法其實非常非常簡單因為它就是一個 lock所以你可以看見就是你要用之前你就是去先 declare 這個 token先去 initialize 它declare 之後你要去 initialize因為其實這個 token 它是一個 data structure 的其實它裡面是記錄一些資訊的

那還記得我們說critical section的解法就是你有一個entry跟exit所以你可以看見它的entry就是lockexit就是unlock所以這兩行程式嘛這兩個function code裡面是什麼呢就是像我們剛剛介紹的那些solution你可以implement任何的software solution或者是我們等一下會講到的hardware support solution在內去寫你的這個entry section跟exit section那pieceware把它包起來就叫做lock跟unlock

所以使用者就可以直接扣這兩方群去保護你的critical section那這個token所以你可以看見這個mutex就像是一個lock一樣所以你的程式碼裡面所有它可能會有造成raise condition的這些部分的process你在都必須要去扣這一行而且用相同的mutex的token所以這個mutex token是一個shared variable必須要相同的

Lock所以如果你在程式碼有不同其實它是有不同的Variable是不同Process之間要保護你可以去Declare其他的New Tags所以你可以有不同的Key在那邊不同的Token但是同一個Token意思就是所有相同Token的Critical Selection會有Mutual Cushion的這個作用所以你可以Declare很多不同的T

oken去保護不同的Critical Sanctions好那當然就是因為他這個Token是當然DLOK嘛所以要Destroy所以其實是蠻好用的所以Pthread裡面常常會用的就是這個Mutex其實就是在解這個Synchronization的問題就是施作我們的Critical Sanctions好那我會再多講一個既然我們都講了Pthread這邊了對不對所以P3

這邊除了這個有這個Mutex這個Critical Section的這個Tool之外還有另外一個跟Synchronization有關係的就叫做Condition Variable那Condition Variable的意思就是其實很多我們在寫程式嘛這種很多在同時執行的時候很多時候你會需要用一些Event去Trigger對不對所有其他Process去做事情這就叫做Condition Variable就是它其實代表的就是某個condition會發生的時候

它可以去trigger其他process把他們這些其他的process或應該說threads啦因為這個其實是thread program裡面Pthread裡面的功能嘛所以這個variable的目的就是它可以去notify其他的threads然後叫他們說告訴他們某一個condition發生了，所以你可以開始做接下來的動作。最常見的大概就是一些比如說你有很多process要處理data，那data都還沒有漏到你的電腦，你沒辦法process對不對。

所以你可能就有一個thread專門在把data漏進我們的這個程式裡面然後等它一漏完你可能就開始叫請所有的thread大家開始幫忙去處理這個資料那這個event你就可以用一個condition variable去notify所有的人叫他們開始做事情好。所以這condition variable其實你也看到它的用法也是蠻單純的就是你可以有第一個就是wait，

所以wait就是你可以wait on某一個condition。所以這是一個variable所以每一個variable就代表某一個condition的意思對不对。所以你就可以wait on某一個condition variable意思就是說這個condition如果沒有人去signal它沒有人去trigger它的話那這個thread就會被卡在那block在那裡就是等的意思然後signal呢意思就是這個event發生了所以你可以signal一個

condition variable那等在這個condition variable裡面的thread其中的一個就會被叫起來通常當然是第一個等的第一個被叫起來這是看library的implementation那如果你要叫醒所有在這個condition variable上等待的thread那你就call broadcast那就會把所有人一次把它叫起來所以就是一個這樣子的簡單的Synchronization的機制可以去控制Thread之間他們在程式雖然說因為我們系統執行的關係大家執行的順序、時間點可能不一定但是你就可以透過這樣的方式去Synchronize同步化所有Thread執行的動作

好,所以他的這個Pthread如果你去看的話他的這個API就是像這樣子Pthread,condition,wait,signal跟broadcast然後後面當然就是這個token對不對所以這個condition variable的部分然後當然用之前一樣要去做initialization還有destroy所以大同小異好,那你會發現這個condition variable咧他後面你要如果要wait的時候其實還需要一個Lock也就是Mutex Lock所以Condition Variable其實跟Mutex Lock必須要一起使用那我們先講正確的用法就是像這個樣子所以你可以

看到這個例子我們就是假設我們有兩個Threads一個是負責在那邊在這個操作這個Counter的值然後這個Action的Thread它就是會等只有當這個X的值是0的時候它才可以去做它的事情所以我們的寫法就是假如故事的人0那我們就wait對不對wait on 某一個condition然後當別人發現是0的時候

他就會去signal所以他會被叫起來然後去take action所以這部分應該OK那你會發現我們這裡必須要結合mutex就是把這個程式把它包在一個critical section裡面為什麼呢原因是因為簡單的原因是因為Counter這邊因為他一定是在做某一個condition的checking對不對所以當你想要trigger這個condition這個event的時候

一定是你的這個condition的值達到了你某設定的這個目標就像這邊x等於0才會去做signal那不要忘記因為有context switch所以今天如果你把它包起來的話第一個很多人這個x這個condition的vari able通常都是一個share variable所以你會想要保護x所以可能會有很多人同時code counter然後去做加加減減的動作所以第一個

原因就是大部分的應用你都要去保護這個condition這個trigger condition variable的這個變數所以它一定會被放在critical section裡面第二個你看到它檢查之後它就要signal對不對可是這是三行啊所以代表其實中間會有很多的如果有人touch x的話那麼當你synchronous被synchronous的這個瞬間它的值未必是你現在看到的對不對

所以你要想到隨時會有人插對然後context switch會發生所以為了要make sure我synchronous的時候它的值一定就是等於我想要trigger event的那個值的話那麼中間不能夠有人去改動它才對所以這個condition這個condition的synchronous跟這個x的減差必須要是一次做完的所以你也會想要把它包在一起好那既然包

在一起之後所以你就會知道至少signal這邊他一定會包在一個critical section裡面那所以在這個take action這邊對不對就是你要去wait的這個人你就也必須要被放在一個這個critical section裡面下次我們再把step by step好那不過這implementation啦就是你去call的話這個是design pattern一樣就是你用去這個condition variable去wait的

話就是記得兩個人都必須要在critical section裡面因為condition wait裡面它本身就必須要一個mutex好ok好好 這個下次我再拿出來補充我們先到下一個好了好那我們剛才講完是software的這個solution所以下一個我們要講的是hardware support所以software就是說你完全是寫程式碼而已我們就可以去驗證它的正

確性那所謂hardware support的意思就是說其實我們hardware它也可以幫我們去provide一些special instruction然後一次把很多的事情把它一次做完然後去保證中間是不會被interrupt也就是它一次可以做完的意思那這樣一次做完就像是我們說過的它不會有synchronization的issue所以它為了去implement的程式碼其實是不會

有synchronization的issue因為hardware是一次做完不會被打斷的那所以為了簡化的時候去寫我們這個synchronization solution就是可以去call這些hardware提供的function然後讓我們可以簡化程式碼裡面需要去寫的程式的內容好那所以我們說對Synology就是會interrupt嘛所以第一個software可能就會disable interrupt對不對那另外一個方式我們說那當然

不好因為它會影響到其他程式的人所以另外一個方式我們做的就是用hardware因為hardware本身它就是一次執行完的instruction那所以這種instruction我們又稱為autonomic意思就是說這些instruction其實是不會被打斷的雖然它一次就有好幾個instruction可是它不會被打断所以你不用擔心它會有synchronization的issue不管那個function code寫得多複雜只

要我們說它是hardware implement那就不會有synchronization因為它不會被打斷那這邊我們就用兩個例子一個是test and set跟swap所以就是假設test and set跟swap是兩個hardware support的function code那怎麼樣去call這function code來去implement我們的entry跟access action這就是我們俗稱的hardware support的solution所以它是有hardware這邊要有implement跟提供這些function才可以那真實的系統是有的事實上你去卡的話這些computer system其實它都會提供一些這樣子的instruction去幫助去解這種synchronization的issue

因為我們說這個就是速度嘛所以你用 hardware 它就是很快然後它可以確保它是不會有 synchronization 的 issue好 所以我們就來看第一個 test and set那 test and set 是什麼呢它的意思就是說你會有一個 lock所以跟剛剛一樣它就是一個 token 的值而已那 test and set任何一個 process 它去 call 它的時候它就會告訴你說目前這個 lock 的 value 是多少

然後並且他就把這個Lock的值設成除只要他被Call他就設成除大家先不用管為什麼這麼做因為這只是他可以拿來用來解這個問題而已所以他的意思就是我去Test所以我會知道原來的值是多少所以可以注意到Lock是我們要想要得到的Output對不對他會先把它設成這個Value會等於Lock然後Return Value對不對所以他會告訴我們這個Lock的值到底是原來是多少

所以它會return所以它會return出來它的值1的就是0或1所以只是lock但是它在這過程中你可以看它一定會把它設成true所以它會把它overwrite掉所以只要第一個人call的人其實就會上鎖一樣所以有點像我去看現在到底有沒有鎖可是不管結果如何我就把門鎖起來就對了所以就是test and set所以set就是它最後結果就是一定把它lock起來那你就可以看見什麼叫hardware support因為這其實是三行程式嘛

可是它是 hardware support function所以代表說你不用擔心很多人同時call 這個 function它不會有 synchronization 的 issue它一定的結果就是目前的 lock 值是多少它就會告訴你並且把它只設成 true 之後才換下一個人執行這一個 function所以是一定是被 serialize一個人一個人做就對了好那有了這個 function 之後我們怎麼 implement 我們的 critical selection 呢你會看見就變得很簡單了

對不對那它的概念就是一開始的時候這個 lock 的值呢我們會把它 initialize 成 force所以代表是 unlock 的對不對那第一個去 call test and set 的人他得到的值一定是 force對不對因為他就可以 return 對不對return 原來的值所以就是 force只要是 force 就可以 break 這個 while loop所以這就是你可以進到 critical selection 的條件就是你 call 的時候這個Lock的值必須是Force那第一個

人摳一定可以對不對所以他可以搶到那個Lock可是呢你一旦這個被摳了之後Set所以就知道他就被上鎖了所以第一個人摳的人這個會拿到Force然後他就把這個Lock的值設成True所以第二個人後面的人去摳的時候都會拿到的值是這個 true 也就是被鎖住的意思對不對所以只要是 true 你可以看見他的 wire loop 就會繼續嘛對不對所以就被卡住了所以就可以把他擋住好那所以怎麼樣可以 unlock

當然就是這樣子對不對所以離開的時候我們就把 lock 直射成 force所以這樣子的話就等於是 unlock所以一 unlock 之後下一個人再去 call test and set 的人就可以 break 他的 wire loop所以這個就是如何用這個function去implement我們的critical section的solution可以齁所以這個就是用這一個function的solution那我們一樣來看一下mutual exclusion會符合嗎因為因為這個是一個autonomic的instructiontest and set是hardware的所以不可能兩個人同時拿到force這件事情因為第一個拿到force的人就會把他變成

Lock 就會變成 True所以不可能兩個人同時拿到 Force所以既然只有一個人拿到 Force當然只有 Force 人進 Critical Section所以 Mutual Exclusion 沒問題Progress那 Progress 也沒問題的原因是因為這兩個人或是其實不只是兩個 Process這個 Solution 可以用在 N 個 Process 都無所謂因為不論有多少 Process反正第一個人call test and set而且他的值目前是force的人就可以進去對吧所以如果沒有任何人call那沒有任何人在critical section裡面lock的值應該是force的所以要進去的那個第一個

人call的test and set的值一定會得到force所以他可以進去好最後一個bounded weighted不符合如果你去仔細想一下為什麼因為他沒有排隊嘛所以Money Waiting就想他會有沒有first come first serve的這個特性就可以知道因為這個只是先call的人先進去對不對所以今天如果我們假設有100個process都想進critical selection大家都不斷地在他們的while loop裡面一直再去call這個function

不要忘記因為ContextSwitchOS所以沒有人說一定是你執行一次我再執行一次沒有wrong-robin這個不一定我們可以implement其他scheduling algorithm對不對所以沒有說是輪流codes和 set我可能是random或是whatever的情況對不對那先call的人always可以拿到key拿到這個lock所以就沒有排隊等於是在搶啦對不對那搶的結果就是沒有任何保證所以不符合Funded Waiting

就是我們說的很多時候 solution 它要全部符合可能 effort 會太大啦所以像這個它就可以至少解掉前面兩個那有時候還是會有 bounding weight 的狀況這也是 part of 為什麼我們說電腦的時候會卡住就是這樣其實你不可能保證解掉所有的事情通常會卡住就是跑到這種synchronization 的問題裡面去然後你的 OS 就卡在那邊了

好第二個solution第二個例子我們給這只是例子第二個例子是這個swap那我們沒有程式嘛因為大家都知道swap在幹嘛就是一個function code你給他兩個variable他會把他的值對掉就這樣子好那有這個swap這個很簡單的這個function然後我們用hardware去implement的話可以拿來解的方式是什麼勒概念其實很簡單概念就是你

可以想每一個人要進去每一個process手上他都有一個有一個球好了然後球全部都是藍色的除了我手上有一個球是紅色的那拿到紅色球的人可以進去執行那我是當然是我其實代表的是沒有人要執行的意思所以我不是其中一個要進critical section的人其他就是要搶這個紅色的球進到critical sectionswap的意思就是我們大家就來交換大風吹所以任何時候我可以把這個紅色球拋給任何一個人然後跟他換他的

球但是整個裡面就只有一個紅色的球所以這個球你可以想像大家在扣要進去之前就是去swap就跟我去換說我手上有沒有紅色的球如果有那就代表swap的結果你可以看見為什麼說紅色的球和藍色的球意思就是lock的值是force就是紅色就代表只要拿到這個force值的這個球就可以break這個while loop那其他的process全部都是true也就是藍色

所以你可以看見他這個只是把true跟lock去交換意思就是他就是always大家手上本來都是藍色的球只有這個一開始luck的是紅色這個是你要去搶的這個luck好所以你會看他進之前就是當然key then true嘛所以代表就是保證一次只有一個人可以是force的意思然後呢這個只要他的這個key是true的時候對不對就代表你手上的值其實是現在是藍色的球的意思那我就要去想辦法要進到critical net section的話我就要去跟lock對不對

也就是跟我去換我手上的球的顏色那只有一開始的時候你可以看見lock是force所以一樣第一個人我手上一開始是紅色的球所以第一個跟我去交換的人他就可以拿到force的值那就可以break這個while loopagain 不要忘記分號這邊 對所以這一個換完之後那 key 的 0 的值就會變成 force 囉所以就可以 break 這個 condition 對不對那就進到 critical section那出來的時候一樣嘛，所以出來的時候你就要把 lock

變 force，意思就是把紅色球還到我手上一樣。 對不對，所以就是把它交出去這個 key 的意思好，那 p0 p1 你就會發現這一樣可以 apply for n 個 process，因為它們的程式碼會長得完全一樣沒有區分對不對所以其實今天所有的人就是一開始設成 true 之後就開始跟 lock 這個值做交換那搶到這個人一定會把 lock 的值變成 true所以擋住其他的人執行完之後呢他就把 lock 變成 force也就是把這個 key return

給這個你說的管理者或 return 到這個原來的這個 lock 的 value 對不對所以下一個去 call swap 的人他就可以進去了所以跟test 和 set其實是完全一樣的就是大家去搶第一個call swap的人可以進去或者說當lock的值是force的狀態下第一個去call swap的人可以進去然後call了進去之後lock就會變 true然後離開的時候你把lock再把它設回成原來的這個值就可以了所以這個是 swap的做法其實原則上是一樣的

就是先扣 swap 的人他就可以 break 他的 while loop那你去看他的驗證性其實是一樣的道理對不對所以其實 mutual exclusion 也會滿足因為在交換的過程中，實只有一個人的手上就是所有的 key 還有 lock 這些變數 上只可能會有一個人，他的值是 false 的就是一開始initialize 其他人都是 true所以只會有一個人可以進去然後progress

也沒問題因為只要是一開始是force設成force之後第一個去call的人可以break然後bonding weighting一樣不反軸因為這一樣是沒有什麼規則先call的人先進去這就是為什麼很多process的話你要滿足bonding weighting就會複雜就會像剛才說你就比較排隊那就要implement我們剛剛之前介紹software那邊的那個Bakery的argument就會變得比較複雜一點，但如果你不care bounding with it你可以看見你就可以

很efficient的去implement這個solution好剛好有一點時間我來給大家看一下講一下就好我們只要go through這個step就知道為什麼兩個都要在裡頭了所以這之所以會有Mutex的原因是第一個首先右邊一定要在Mutex一定要在Critical Section裡面，又要保護X這個應該沒有問題那左邊這邊一定要也要配對在Critical Section而且必須要有把他這個Mutex Lock的這個Token給Conditional Wait的原因是因為這才會是一個正確的執行的這個順序也就是第一步你可以

看見當然等的人會先到Critical Section所以他會把Mutex給Lock住對不對當然這兩個人都可能誰先執行但是假如是Action這個人先進Critical Section的話你會知道他一定會先進到這個Mutex Lock裡面去然後呢他會去做Wait的動作對不對那那個人他會發現他沒有辦法拿到Lock就是Single這個人還沒辦法進去因為這是Critical Section所以只有這個人可以進到裡面

那他進到sleep就是這個waiting的時候就他會被put to sleep就對了所以不可能再被執行了但是因為caller就是在這個counter這邊的人他必須要進到critical section才有機會去signal所以這個lock必須要放在這裡讓他去release lock所以你沒有call unlock但其實condition wait這個function call裡面他會幫你把lock給release掉release 掉之後呢這個 counter 這邊才有機會進到他的 critical section

裡面去那進去之後對不對你才有機會去 eventually 對不對達到那個 condition然後去做 signal 的動作那 signal 之後他就會把左邊這個人給叫起來但叫起來之後其實呢他手上是沒有 lock 的所以這是一個有點特殊的狀況他在 critical section 裡面可是他手上其實是沒有Lock的那因為其實Lock是在那邊對不對所以他這邊已經

把Lock給release掉了所以其實他是沒有Lock的所以也就是說他其實被叫醒了但是其實他會被卡還是會被卡在這一行直到咧右邊Conditional Signal的那個人離開了Critical Selection之後那這個時候這一個對不對這一邊的這個Action的這個人才可以去重新取得他的Lock然後去執行他裡面的程式所以他在執行的時候中間我們當然可以塞其他的程式就是在OnLock之前但他執行的時候

你會可以保證他其實他手上也是已經有Lock的所以不會違反Critical Section這件事情就是兩個人其實看似都在Critical Section裡面一個在裡面等然後另外一個卻在Critical Section裡面在執行那之所以可以這樣的原因是因為在你call conditional wait的時候他會把lock先release掉然後他在return之前他會reacquire就他醒來之後的第

一件事其實是reacquire那個lock然後讓他滿足critical selection這個condition就是有Mutex lock這個條件然後去繼續的執行所以其實他整個過程是這樣子的然後才會離開這兩邊才會同時離開critical selection所以必須要兩個人都要有這個部分因為這樣子的話你在Code的時候你才可以保護這個Condition Variable的條件他們兩個都是在Critical Section裡面然後又可以正確的執行然後都是有在Lock的狀況下才能夠去執行它好,

所以稍微很detail這P3你如果去覺得有點奇怪的話其實就是因為它去保證一些它的特性所以他會要求兩邊都在Critical Selection裡面避免一些Programming上的Arrow所以他的API就把他寫死他必須要把Mutex按照這樣子的方式去寫你的Condition Variable的做法好那這個當然大家沒有機會去練習到那以後寫Pthread等等大家可以再去留意一下其實是有這樣子的一個運作的機制在裡頭.