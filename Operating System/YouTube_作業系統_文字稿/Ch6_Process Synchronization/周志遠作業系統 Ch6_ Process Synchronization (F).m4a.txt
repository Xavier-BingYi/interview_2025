undefined
好，那在這樣的下面你就會發現一個事情就是我們提到的竟然兩個都在critical selection裡面那請問是不是這個action的人進來如果我wait他不就停在這裡面了他不就停在critical section裡面永遠不會出來或者說他就沒辦法出來了對不對那signal的人因為有人在critical section裡面我們學過的那他不是進不來嗎那這顯然

是一個有問題就是我們說的deadlock的一個solution喔這不合理嘛對不對所以我們提到這個原因是因為其實當你在call wait的時候他為了讓signal這個人的threat也可以進到critical section裡面所以其實在wait這件事情發生的同時我們會把這個lock給release掉因為你已經在wait了，所以代表其實這個thread已經被放到一個waiting queueput

to sleep的，所以它不會執行就算它在critical section裡面它其實是沒有active的所以它其實是個inactive的狀態，所以既然它已經被inactive了，那我們就可以把這個lock給release掉讓其他人有機會進到critical section，更重要的是可以進去之後去sign 알讓這個人把他叫起來就不會產生deadlock，所以相對的當他被叫起來之後你也不用擔心

這兩個人會同時執行在違反了critical session的條件，因為其實他叫起來之後他執行之前必須要先acquire lock，acquire lock之後他才能夠真的return from這個function code然後繼續執行。那它要能夠acquire lock的意思就是其實它必須要雖然被叫醒了，它可以被它已經在active的state了，但是它要等這個thread先離開這個critical session把lock給release這邊才能重新的acquire到lock然後繼續執行。所以這就是為什麼你要把mutex雖然你現在叫condition variable雖然我們知道它是一定要在critical session裡面

可是為什麼我們Code 這個Function Code的時候還要有Mutex Lock的原因為這個Library 的 Implementation它其實會幫你去做Release Lock然後再Reacquire Lock的動作所以它要知道你說的Lock到底是誰，那當然不要忘記這邊指的Lock全部是同一個Object是同一個Lock 不同Lock當然它就沒有分辨就是不同Critical Session的程式就會亂掉好。 所以這是為什麼這邊你去call condition variable的時候

還要再給這個mutex lock的token那。你這樣子寫你也會發現當你去用pthreader在寫condition variable的時候你一定會把它放在critical section裡面嘛，因為你不放的話，那你mutex要寫誰你也搞不清楚對不對。所以這是相輔相成這樣的話。你在寫這個condition weight的時候你也不會忘記，programmer也不會忘記說喔。其實我應該要放在一個critical section裡面的，

所以正確的Programming的方式而且運作起來也才會正確好。 可以齁所以，如果step by step就是我們說的其實是假設我們action的話，它會其實當然是必須要先acquire lock所以這個就被卡住了那它到了wait的時候其實它會release。你沒有看到call這個這個unlock的動作，但其實你的implementation裡面這個function code裡面它其實會幫你去code這

個unlock的動作那也只有這樣子你才能夠讓旁邊的counter進到critical section。裡面然後去做single的動作然後Single完之後就像我們說的咧其實雖然說這個thread會立刻的被Wake Up因為這是Condition Variable的Behavior對不對但是它Wake Up之後它其實還是沒辦法執行因為它知道它在critical section裡面然後他根本沒有Lock所以其實他會Reacquire Lock會

卡在那邊仍然沒有辦法跟Counter這個thread的同時執行然後等到這個Counter結束了離開了之後對不对那Action的Thread才有機會執行就是去Acquire Lock然後繼續他的執行所以這是整個過程沒問題所以這就是整個運作的方式那這是Pthread所以其他的Library你可能會發現也都有Condition Variable的Concept像Java C++ High Level平行的其他的

語言很多他們通常也都會Support Condition Variable但是他們的Coding的方式實作方式可能就不一樣因為看你的Library怎麼設計嘛對不对那我們講的這邊是Pthread是這個樣子的所以這樣應該很清楚了這是實作那我們再補充一個既然我們都教過之前講的Thread Pool的Concept因為這個是在 Multithread Programming非常非常好用的一個Technique我們說大部分的Web Server啊等等都會這麼做對不對

大家還記得Thread Pool的概念就是你先Create Thread放在那裡然後你有工作要做的時候就讓這些Thread去做做完之後你不會把它Terminate掉而是把它留在那然後等到有新的事情要做的時候你在去塞給這些Thread去做所以重點就是你的Thread不會一直在Delete、Create的動作然後更重要的是我們說

過只能Control你整個系統裡面到底用了多少Thread不會因為Runtime的時候一堆的Requests進來你就Create了一堆的Thread然後最後Thread Create太多我們知道CPU、Hardware、Resource畢竟有限嘛所以你Create越多最後是什麼勒一堆Content Switch大家都很慢然後更overall來講更糟糕對不對所以你會控制這個thread pool的大小然後來控制整個系統的效能達到最佳化好那我們

今天要提這個就是其實這個thread pool的一種實作方式就是透過condition variable因為概念上來講你可以想就是我cre ate this thread然後怎麼樣讓它去執行不同的工作就是去給它塞一個function pointer一個 function 的 pointer還有這個 function 的 argument所以這個 thread 對不對我只要去執行這個 function call然後用這個 argument 去執行這個 function call就等於它在處理一個 request所以這個 request 可以是做任何事情無所謂反正就是一個 function call所以是先 create thread然後呢我們大家看見thread

裡面就是一個 while loop它不斷的在 loop然後在做什麼呢就是等著被叫醒來叫起來之後去執行他目前看見這個data structure裡面的function跟argument去執行這個動作執行完之後他就繼續再下一個loop就是再繼續等那他怎麼知道什麼時候被叫起來什麼時候他可以執行的一個方式就是透過condition variable對不對所以我們就把所有的thread都可以去wait on同一個event的condition variable

然後有一個master的server在前面如果一接到request來它就signal去叫醒其中的一個thread read然後叫醒之前它只要把這個function pointer還有argument這個data structure的資料把它填好叫起來的那個thread它就可以去讀這個argument然後去執行了。 對不對所以就是這樣一個概念。所以你會看到的實作上來講第一個就是當然你可以定義這

個data structure所以知道目前要執行的東西是什麼然後這是一個thread pool所以會有多少個thread對不對最重要的是看見它有condition variable跟mutex因為這兩個就是整個thread pool在share在共用的那個這個synchronization用的這個變數。所以他們會weight down相同的condition variable然後我們剛才才介紹過你要condition variable就必須要一個mutex所以這是要同時使

用的當然這是Pthread library的實作嘛好那這樣沒有這就只是allocate所以我們就會可以先事先create好你的thread pool所以你要create多少個都可以那所以那邊當然會記錄這個thread account啊等等對不对所以你會知道到底現在有多少個thread是active的有多少是對不對不active的所以你前面的master這個或是這個前面的manager他就

可以知道什麼時候他可以call signal什麼時候他是不行的那至於是誰不重要對不對任何一個thread只要是他目前是available的我們都可以讓他執行啊所以就是我們說的condition variable signal他不care是誰對不對反正在waiting queue裡的第一個人就可以來做就對了那一次也是一個而已好 很好那detail大家可以再

仔細看slice然後回去再想一想那所以就是剛才說的一個thread這個所以這就是我們說的thread它會去執行一個function嘛那這個就是那個thread你叫它去執行的function那這個function裡面就我們剛才說其實是一個for loop或是一個for loop就對了就是一直在那邊重複的在等對不對然後呢在等什麼呢就是我們剛才的condition weight

對不對所以這個 thread 呢他雖然說他被 touch create 之後其實他什麼事都不做他就在那邊 wait on 某一個 event他馬上就被 put to sleep然後在 waiting queue 裡面等著對不對那什麼時候他可以 break出來這一個waiting 的動作咧就是當他被 signal 的時候那他就會被叫起來了對不對好那叫起來之後他要做什麼咧就是我們希望他可以做任何事嘛對不對；在一般 的 design 來講

所以就是像我們剛才的就是扣這個data structure裡面目前要我執行的function跟argument是什麼那我就照著去扣所以你這邊就看見這個執行的部分對不對；所以它就可以去處理這個工作了那處理完之後當然就for loop回去所以它又會再去等到condition wait再去等著去接下一個工作那所以這個thread其實就不會被terminate

掉對不對；create之後他就一直在那邊等著然後就一個工作一個工作的去做那其實是一個thread pool的概念所以你到底哪一個thread被wake up起來是無所謂的；然後做完之後其實就會繼續put to sleep然後去等下一個工作好可以齁那當然你就看到這個lock unlock；所以你就會看到剛剛說的pthread的coding design來講就是一樣的流程就是會先有lock然後condition wait然後unlock

然後中間只有一個人一次子可能有一個人去操作這個data structure所以你不會亂掉所以不會說一個function被兩個thread同時扣不可能因為它在critical section裡面好 可以齁所以這個就是condition variable是其實非常好用的那thread pool就是一個這個例子如何去透過控制這些thread的執行然後去做不同的事情所以當

我們說同步其實兩個層面一個是解決我們說的Race Condition另一個就是要去控制整個質詢的順序不一定是Race Condition而是希望它能夠正確的這個Behaviour所以剛好就是Clue Session還有我們後面看到的這個Condition Variable的例子那我們就接回到上次講完這個software的做法講完之後我們介紹

了hardware那hardware這邊最重要的一點就是不要忘記這邊code function我們說在我們的這個slice的例子就是有這個test and set還有swap這兩個function code其實是大家都知道是好幾行程式碼的對不對像前面這個這個test and set對不對這有四行程式碼所以如果兩個thread同時去call這個function call的話它本身就有synchron

ization的問題本身就有 raise condition就會錯掉所以呢我們說hardware support意思就是把這個function用hardware的方式用logical用這個線路的方式把它給燒死的方式所以它因為是線路嘛所以當然沒有software根本沒有contact switch的東西出現所以不會有synchronization或raise condition發生所以這邊只是概念說今天如果你要 implement test and set就等於這四行程式嘛但其實你可以用像FPGA

等等對不對 hardware把它做出來一個 logic然後去把這件事情做完然後變成一個 single instruction所以這其實是一個 single instruction不是一個 statement不是一個 function code是一個直接就是一個 instruction就是所謂的 hardware support instruction然後把它用這個 instruction 的方式去 implement 我們的 entry section還有就接我們的critical section的問題所以這樣的好處就是軟體這邊可以簡化第二個

非常重要的是這個動作會這樣快我們都知道Hardware永遠比So ftware快所以當然這裡就算寫得很複雜的一個entry section你想要能夠把它包起來變成一個single instruction它的執行速度都非常快不像我們前面看到的例子可能有七八行對不對或是甚至更多個行的話變成Extraction更多 那個就會很慢就是浪費時間這是為什麼會用Software這個Hardware support的原因減少Coding的Overhead然後其實也增加它的效能所以同樣的Swap大家都知道我們沒有列出來了

但你大家都知道Swap至少還是三四行扣嘛 對不對而且會有一些Variable的操作所以它如果是Software去寫的話一定會有synchronization的問題就是兩個人同時扣swap的結果可能是兩個人都拿到比如說都拿到force就會所以這邊如果你是自己寫一個方尋扣答案是錯的可是如果swap是一個hardware support的instruction給你去解raise condition的問題的話它會是對的因為它不可能被contact switch所以hardware跟software support的差別這個是非常重要的

solution當然看起來都很單純而且你可以看到我們舉的這兩個例子其實都不是perfect的solution，因為他們都沒有符合boundary weighting的條件，但是從這裡可以看出來為什麼要用hardware support的solution好， 很好好， 那我們就要進入到下一個，所以我們就要介紹完critical section的solution就是hardware跟software跟hardware這邊接下來我們就要介紹另外一個非

常好用的Tool，就叫做Semaphore，所以它有一點像Condition Variable加Mutex的結合，所以這也是同樣我們就是在同步化或是控制執行序的順序的時候常常會用到的一個Tool，就叫做Semaphore，所以我們說它是一個Tool，所以Semaphore，它其實就是一個Tool，我們馬上就看見了，就像Condition Variable這些一樣，就是被定義出來去幫助我們去簡化我們程

式的複雜度然後解決可以控制程式指定順序的一個工具，那什麼是semaphore呢？首先，它其實是一個counter，所以Semaphore對應到的其實是一個數字，就像它這個變數，那裡面它就是一個integer的數字，那裡面的這個數字的意義是什麼呢？就是代表著這個semaphore，它其實每個semaphore對應到的就是它在管理某樣Resource或是說Object是

某樣Content就對了某樣Item然後這個Resource的數量所以它其實是像一個用Counting的方式去同步化程式之間的運作的一個工具那所以今天你可以想如果我們的Record的數量它設的就是1就代表說我整個系統裡面這個Resource只有一個那換言之不可能有兩個人同時去用它嘛對不對 所以代表一次就是一個

人所以這樣子的Semaphore我們又稱之為Binary Semaphore因為它就只能在0跟1之間變動而已因為它不可能增加就是0跟1所以0跟1的話就代表一次只有一個那就像MutexLock一樣因為MutexLock的概念就是或許有很多Thread想要進到我們的Critical Section我們把Critical Section想成是一種Resource的話那很多人都想要進到這一塊去執行一個程式但是我們只能讓一個人

去使用 就是去執行那就等於是Mutex Lock了就等於是Critical Section的問題一樣但是Semaphore呢它可以比它更Powerful所以其實Semaphore是我們在解說問題的時候發現我們會需要比較基本來勢一點的一些應用的時候會需要的一個Synchronization的Tool所以Semaphore如果是E通常大家就是用Mutex Lock就好或是就是用Critical Section的Lock Unlock的概念就好

但是之所以要Semaphore其實就是因為我們其實會有所謂的Counting Semaphore也就是這個數字我們可以大於1舉例來講就像我們剛才回到剛才的Thread pool就是這個樣子Thread pool我有10個Thread那就代表其實我同時可以有10個人去執行某一件事情我一定會有足夠的Thread去執行對不對我不能超過但是可以在那個數字以下那我們就可以把用一個Semaphore去Control什麼時候我可以去使用這些Thread

那使用的數量就像我們剛剛的Thread pool是10嘛那我們就把Record設成10就是Initialize的時候就把它Initialize成10那就代表只要是10個以內的人他都可以進到這個我們下面的這一塊Code裡面去使用我們的Thread那個Thread就變成所謂的Resource了所以這樣子的Symaphone就他的Record的Initialize值是大於1的我們就稱之為CountingS ymaphone那他目的就是可以幫我們做Counting

然後來決定到底現在有沒有足夠的資源這個是我們在電腦管理很多寫程式都是這樣嘛不是只有一個不是只有true和 false對不對我們事實上可能都是有一個數量級的一個resource或是一個可以使用的這個量那這時候我們就可以用simple form的概念好那Sympathone這個Record到底怎麼操作第一個當然它就是

Initialize它你會給它一個值去Initialize它代表這個資源的數量接下來咧你對這個去使用這個資源之前你就必須要去call所謂的Weight所以這裡也有Weight跟Synchronal但請不要把我們前面講的東西混在一起就是畢竟他們都在做Synchronization所以動作很像但是不同的Tool它這些定義是完全不一定一樣的那所以先把其他的

先不要混在一起Symaphone就是Symaphone那Symaphone一樣它的操作就是透過wait跟signal兩個function code來操作那wait的意思就是我需要一個resource我要去執行某樣東西了signal就是我執行完我要把這個resource把它free掉的動作所以用這樣的方式就等於等於是對這個rack的數字可以做減跟加的動作對不對所以一個wait之後代表如

果你真的執行完這個wait就是離開wait就代表你已經acquired到你的resource那麼這個record值這個semaphore對應到的數值就應該會被減1那你一signal就反過來意思就是release了所以這個record值就會加1所以這個數字就會代表著目前到底有多少available的數量那當然你可以想見當 record 數字零就代表沒有剩下的那你就必須要 wait就真的會卡在那邊然後直到這個 record 的數量是大於零你才可以繼續執行好那所以一個簡單的實作方式我們說的 wait 跟 signal 在 semaphore

裡面就是像這樣子所以 s 就是一個 data 就是我們的 semaphore data structure 對不對那裡面當然其實就存著數字會代表它到底有多少 available那可以看見如果要wait的話就像我們說的如果小於等於0這裡有分號喔所以代表它會卡住所以它就會在那邊等著那如果它是大於0就代表我有available的resource所以我就可以離開這個file loop然後s-也就代表著我把一個resource給拿走了對吧然後你就可以去執行接下來

的事情所以如果我會派卡住你的使用者這邊的code就會停在wait那如果有available的那你就会break out然后去执行进入到你下面的程式那signal你可以看见就很單純就是加加嘛對不對所以我就把resource free出来就是加加所以把它加了之后別的thread在waiting的thread呢它就有機會break或者loop然后去使用了對不對那使用之前当然還是把它捡回去好那這邊呢很重要兩個事情第一个

這個wait跟signal它們是autonomic的function code所以autonomic我們這邊稍微講到意思就是它一次做完就對了你用hardware也好software也好任何的technique也好都好都可以但autonomic的重點是任何technique你都要實現的就是這一些程式嘛必須要幫我一下子做完所以again你可以用hardware的方式把它變成一個special的instruction叫wait跟signal或者是用software的方式把它包成一個critical section

一次做完別人不能夠打斷或者是OS的kernel它的做法就會是disable interrupt然後做完再enable各種做法都可以重點是它不能被打斷就對了所以我們這邊寫的這個其實還只是concept。實際上你還要去make sure它必須是autonomic。那為什麼要autonomic很簡單你看到s是一個shared variable所以一個人在加加一個人在減減那就像我們最

早講的那個counter++在使用一個buffer的那個例子一樣s本身就有race condition所以當然我們就必須要make sure它是autonomic的意思就是s這個不會有race condition的問題發生。所以這樣的function必須是autonomic的function code好。 第二點這一個實作方式我們等一下會介紹另外一個更有效的執行方式這個執行方式這個implementation是我們俗稱的

spin lock也就是你可以什麼叫spin lock就是說它會在那邊一直spinning一直重複在做因為有個wire loop對不對所以說這個thread扣了這個weight之後它卡在這裡對使用者你會覺得你沒有在做事但對CPU而言你其實做了一大堆事因為你就是在那邊不斷的執行相同的instruction所以就在那邊spin所以叫做所謂的spin lock lock就是一直在那邊spinning的一個locking的方式，那這個壞處是什麼？

勒就是它會浪費我們的CPU的資源嘛，對不對。 所以你會看見哇，我CPU百分之百好像很忙碌怎麼程式都沒在動勒，因為你碰到了spin lock，所以就會有這樣的一個結果好。 但是它比較容易implement可以看見的， 對不對。所以它就是直接一個fire loop在裡面就可以了好，那在這個我們講這個再休息齁那同樣我們

把它對到那個是概念齁，那在你實作上來講你要怎麼去用Semaphore哪裡有這個Library？其實Semaphores是由OS來support的，因為其實Semaphores太重要了，Kernel本身在自己implement的時候就很多地方需要用這個方式，所以它當然就已經implement了這個Library在那邊就是part of它的API所以這個proxy我們提過的嘛，所以這些proxy的一般Linux都是proxy的OS的對不對。所以它裡面的這個API就有Semaphore這個定義在那邊，那所以它的用法就是像這樣子，所以在proxy裡面定義Semaphore就是你只要include semaphore。

h然後就一樣方式一樣嘛這跟Mutex非常非常的像對不對所以你看起來完全一樣但差別在哪裡就是你在init的時候其實你可以給它篩入不同的值可以讓它篩入另外一個integer所以你可以控制它的record值到底是多少那如果mutex你不能控制它就是0跟1而已對不對但semaphore就可以篩一個值給它去做initialization後面其實就都一樣然後當然還有get value因為它的value你可能會想要知道它多一些function code讓你去知道它的state

那所以這個東西雖然是在做synchronization可是不是屬於Pthread它並不是在只能限制於Thread之間很多時候它其實在Process之間來使用的尤其在OS的level所以不一定跟Pthread綁在一起其實它是Process之間也可以使用的一個方式好那這個所以如果我們把它跟Mutex來比的話你可以看見對不對所以它也可以拿來解決critical section的問題就是你把它initialize成e就對了然後就一樣weight,

synchronous就像當初的lock跟unlock一樣對不對但其實所以Semaphore其實更powerful但相對的當然Mutex lock就有比較更簡單的implementation的方式所以當然執行起來你如果只是binary的問題當然還是建議大家用lock那比較heavy比較你需要counting的時候你才會用到semaphore好所以呢好那我們就先休息10分鐘然後我們回來就介紹另外一種implementation的方式是不用spinlock而是用把它put to sleep的方式那我們就休息到15分鐘.