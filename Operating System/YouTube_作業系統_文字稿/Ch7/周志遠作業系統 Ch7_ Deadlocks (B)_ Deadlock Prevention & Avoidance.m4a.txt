undefined
好，那首先我們就先從prevention開始怎麼樣子可以根除整個問題。你不需要在那邊隨著系統狀態然後在那邊偵測。你就一開始就把讓這個系統不會發生第一個Mutual Exclusive，它的定義我們知道就是說不能夠同時兩個就是一次只能一個人去使用這個resource對不對。那你要把這個條件拿掉。 Prevention第一個就是它，就是基本上有四個條件。我們就來討論一個一個討論說每個條件我們要怎麼樣子可以把它拿掉，那Mutual Exclusion要拿掉的話，我知道很簡單就是

你可能會把一些Synchronization的那些Lock的機制把它抽掉那就是沒有Mutuous Cushion了對不對。但是這個Strategy這個Strategy在很多地方是可以用的，比如說你的這個Memory的Access如果都只是Read Only對不對，那可以啊大家可以同時去Access Memory不需要Lock對不對，這個就等於是把Mutuous Cushion拿掉。所以，如果你這個Memory本來它就是Read Only，你不會有任何問題。

你沒有必要在那邊有Lock機制然後造成Delock對不對。我們就直接就是讓大家Free-to-Access就好，那這就是很簡單的，你就知道不可能因為了Access這個Memory Content造成Delock，但是這個Solution我們也知道他也不可能什麼都用這個Solution，因為很多的資源一定要Mutual Exclusion對不對譬如說我們剛才舉的例子Printer對不對或者是你有一個Critical Section，那你也Critical Section

就一定要 meet your exclusion所以有一些資源就沒有辦法用這個方式把它解決掉，但是有一些是可以的，所以我們這邊的 solution 你也可以想成是你可以先把資源做一個分類，每一種資源你可以用不同的方式去管理然後去 prevent 它有 deadlock 的狀況產生，那如果你的資源本來就是可以 share 的，那其實你就是不要去 lock

它，你就可以把 Mutuous Cushion 的條件你不需要去強迫這個條件嘛 對不對，那你就可以把就可以 Prevent這個 Deadlock 的發生了，在使用這些資源的時候你就可以 Prevent會發生了好第二個Hold and Wait，那 Hold and Wait 呢我們一樣知道它就是Hold 一個然後再去等嘛 對不对，所以如果我們今天要把這個條件拿掉的意思是什麼呢，也就是說我們的程式的寫法

當你要使用多個資源的時候你的寫法上要做一個改變變成是你要一次就要把所有的 resource 都 acquire 到才去執行下一個動作只要其中有一個 resource 你拿不到return 的結果是 fail 或是 waiting 的話你就從頭來過就把你已經取得 resource全部 release 掉然後從頭來過這樣子你就可以避免掉 hold and wait 對不對所以你要嘛就是一次全部拿到

要嘛就是有問題你就重新來過要把所有都release掉從頭再來過那這樣就是一個solution如果你的管理資源的時候你用這種方式來管理全部取得或者是全部release掉那你也不會有deadlock的狀況發生但是一樣的這個solution的缺點在哪裡你會發現的就是你的資源的使用率會非常低對不對因為很明顯嘛你要同時

所有resource都可以同時acquire到的機率是比較低的對不對這是每一個是一個multiply的機率嘛對不對如果你有三個resource一個取得的機率只有二分之一那你三個同時取得的機率只有八分之一而已對不對當然就變得很低跟你原來是二分之一取得然後你就後在那然後再等二分之一那是不一樣的對不對所以很明顯的就是很多process他可能就會這樣子

不斷的在acquire releaseacqu我 release然後沒有辦法真的執行沒有辦法真的執行的反過來意思就是你的resource沒有人在用嘛所以你的整個電腦效能就會變得相對一定會變低對不對所以這就是hold and wait的缺點就在這了那有些東西是很重要的像CPU如果你用這種hold and wait把它拿掉那這樣的話可能你的CPU使用率非常低那整個這個當然是很不滿足

使用者需求的對不對會影響的執行時間很大的那就不適合用這個做法但是或許有些IoDevice本來就慢的那你可以選擇用這樣的方式對不對好可以嗎對hold and wait的solution就是把你resource acquiring的這種protocol或方式改掉變成all or nothing就對了好第三個No preemption 對不对一樣嘛 我們要拿掉的意思是什麼勒就是能夠去

做preemption 少對所以就是這個資源我們要能夠把它的state如果能夠把它記下來的話那就解決這個問題了 對不对所以我們如果把它的state可以記下來的意思就是我在任何時候都可以打斷說停我要讓別人來用這個資源了別人用完之後我再回去讓你用然後你可以從你剛剛停的地方繼續開始那條件就是要把它的State記下來那所以Solution這個Solution在哪裡有用咧CPU標準的對不對

所以為什麼我們的CPU有Contact Switch對不對就是因為我們用這個啊把No Preemption這個把它拿掉我們讓它可以去做Preemption啊對不對所以我們的CPU就使用率可以很高對不對然後不會卡住所以任何人要用比較重要的Process我們可以趕快把CPU讓給他但是代價就是你要去存這些State所以通常

就是你會有其他Additional的Cost在那邊去浪費一些Memory去多用一些RegisterHardware Register等等對不對這就是它的代價那當然還有一點就是不是所有都可以Prem對不對所以像是Printer你Print到一半你要怎麼記錄它的State沒辦法嘛對不對所以這個Solution當然也是一樣有它的Limitation在那裡所以CPU這種就很適合還有Memory啊Pipeline啊這些Program的狀態對不對

但是一些IoDevice那就沒有辦法了所以看你是用哪一種Resource好那我們講完這個再下課那最後一個Circular Weight所以一樣我們都知道它的定義就是process之間會去做一個等待的動作對不對那所以怎麼樣子可以把 circular weight的condition把它抽掉咧方式就是我們可以想把它變成一個total order也就是說會有circular weight就是因為你的priority是一個可能會繞一個圈的嘛對不對所以

最慢的那個人要等最快的那個人就開始有 才會有 circle 的狀態所以如果我們今天把這個 resource 分配的這個 policy 把它調整一下變成有一個 total order也就是說你後面來的人就不可能需要等最前面的人不需要等最後面的人這樣把它變成是只有一個方向性的話就不會有 circular wait 的狀況對不對 這是概念那我们来看一下

怎么样子实际上去设计这样的policy那这个policy呢一个例子就像这边看见的比如说我们知道我们有不同的resource的type对不对所以我们会有不同的这些resource有很多那执行过程中你可能就是会因为需要不同的resource的type然后导致了这个dependency的关系然后去在那边circular weight对不对所以我們就所謂的Total Order其實很簡單的一個例子就是像這邊我們可以加入一個Condition就是在Assign Resource的時候

多一個條件這個條件就如果今天你有一個Process它要Rock某一個Instance Type的話，它必須要把所有比K這個值還要大的Resource它如果已經有取得的話要把它Release掉，也就是說你這些resource type它是有一個ordering的對不對。所以0 1 2 3這其實是有關聯性的今天如果我們有一個process比如說它已經有了0然後5這兩

個resource的話，那今天這個process它想要再去要一個R3那R5它要把它給放掉，因為它要順序它要先拿到R3才順利拿R5。所以今天如果你R5已經拿到可是你R3卻沒拿到的話當你想要R3這個resource後你要先把R5放掉，因為你要step by step一個一個來。也就是說如果今天你這個你所有的resource都有可是你偏偏要的是R0的話對不起你要把所有的resource都先放掉從頭來過從R0開始拿到然後step by step

因為這樣子就是所謂的altering 對不對。所以大家都要從R0開始一步一步往前走的意思所以你就可以避掉circular wait好 那麼就像這件例子對不對比如說像這個taped drive可能它的這個index是1然後disk是5然後printer是12也就是一個process如果要這三個resource它一定要先取得這一個resource再取得下一個再取得下一個

他必須要依序的去取得他不能夠亂跳的方式好那我們就來簡單證明為什麼這樣的一個policy一定可以把circular weight這個condition拿掉那其實證明蠻簡單的因為你可以看到circular weight如果我們用我們剛才定義的process跟resource的這個symbol來表示的話意思就是像hold and wait嘛對不對所以一個circle一個circle當然是用hold and wait所組成的所以我們用這樣子

來當作一個hold and wait也就是P0 hold R0，wait for R1這樣沒問題嗎？ Hold and wait，那如果你要一個circle對不对就代表是你一定會eventually你會有這邊這一個通識的存在對不对就像P0要R1，要等這個R1這個resource然後呢R1可能被某一個process不care是誰反正就是另外一個process然後呢，eventually這關係你最後要變成circular的話你一定會有最後那一條式子對不对就是某一個process他已經有某一個resource可是他要的東西卻是R0就是回來這裡對不對

那你很明顯這一個式子就是你要hold的一個這個resource type的index是比你要的還要高的人啊對不對那你後的一個比較高的去要一個比較低的這個會擋掉啊對不對所以這條式子最後的那個condition絕對不存在對吧所以你wrong算寫成一個通識你一定會在你的這個通識最後一個relation的時候會需要有描述這個狀態這個condition可是這個condition是違反我們這個系統裡面分配資源的關係

的這個條件也就是說在這樣的一個系統裡其實這個不會存在他會這個PNA他怎麼樣可以拿到R0呢很抱歉他要把Rn先Free掉所以他不能Hold任何東西任何東西的情況下才能夠去Request R0對不對可是如果是這樣這不會有Circular Weight所以沒問題齁所以這叫所謂Total Ordering對不對所以Resource是有Priority是有這個Ordering 的所以你不能 hold 一個 order

比較高的人然後去 wait for 一個 order 比較低的人這個就是把這個條件拿掉的話你就可以 prevent their luck 好這樣可以那這樣當然缺點是什麼跟沒有這個 hold and wait 有一點像啦就是越後面的 resource 會越難拿到對不對因為你會拿到後面你會發現越多這前面的你要先拿到的前提下才能夠拿到後面的嘛所以你會等待時間一樣會比較久因為你只有一個ordering的方式可以滿足你的條件不像原來沒有enforce的話你可以

順序可以看運氣嘛說不定現在R5先available對不對然後在R3你可以或許你會更快的滿足到你拿到你所有需要的resource但也因此就會有delock的危險了這就是Circular Way就是我們在關於Resource的時候我們把它做一個Ordering然後規定所有的Process你要Follow這個Ordering的字來去AcquireResource的話就不會有Deadlock了所以剛剛這就是Prevention那等一下我們會介紹的就是Avoidance那一樣我們提過的Avoidance我們會把它切成兩大塊來討論第一個

勒就是Single's Instance那這個其實用圖來看就好所以像我們剛才前面的例子那你只要看有沒有Circle有沒有Circle的這個出現一個Graphic Argument你就可以得到答案了嘛對不对那Multiple Instance勒我們會介紹叫做Fenker's Arg dokument所以他把它Generalize然後變成你可以看見我們當中會有每一個這個type勒它可能會有多個instance那其實一樣你可以follow一個簡單的algorithm你就可以去判斷是不是會有deadlock了好 那我想我們就先休息十分鐘然後我們來介紹這兩個做法。.