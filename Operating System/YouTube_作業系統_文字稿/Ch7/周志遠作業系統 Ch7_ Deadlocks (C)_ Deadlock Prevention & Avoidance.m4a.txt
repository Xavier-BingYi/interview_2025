undefined
所以剛剛那個Prevention什麼叫做Prevention的方式我們再給大家用非常熟悉的CPU跟Memory當例子大家可能就會更清楚一點所以像是MemoryMemory以系統的角度它是可以讓你去Share Access的沒錯吧就像你有一個Multithreader Program只要是Global Memory所有的Process都Free to Access對不對它可以同時去使用去Access這塊Memory的空間所以在系統的角度就是它讓它可以用把Mutual Exclusion這個條件拿掉所以你supposedly是不會因為Memory Access而造成Deadlock

那你會之所以第六章會有這Deadlock是什麼呢是Programmer自己造成的結果對不對Programmer為了要去解SynchronizationRace Condition的問題自己introduce了Critical Section在你的Code裡面造成了Deadlock所以其實以系統的角度它是Memory是不會造成Deadlock的對不對因為它是Shared而是programmer自己造成的所以Prevention以系統角度其實它是用Mutual Exclusion exclusion可以把它不需要有這個條件的方式然後去解決memory access的問題，反過來CPU為什麼要context switch就是因為CPU就不能被share啦對不對我們的

CPU擴在run的instruction它有pipeline對不對，所以你怎麼可以把兩個instruction混在一起執行這是不行的啊，所以以系統的角度，它是不能夠share的對不对，但是它又不希望有delock 所以它怎麼辦? Preemption嘛 對不對所以我們的OS， 我們的系統會幫你用Memory的方式把Register記下來的方式用Content Switch的方式讓你的Process可以在使用CPU的時候做Preemption因此不會造成Delock所以這剛好是兩個反過來的例子可以看得出來嗎那所以以使用者的角度我們從來就不需要擔心

系統會因為contact switch而造成delock純粹是CPU這個資源造成delock是不可能的因為它是可以被preempt的所以就不會有這個issue所以這樣大家應該就可以對到一些應用的例子Memory跟CPU其實它就是用不同的方式去處理那當然Programmer這個layer往往會因為其他的方式它可能必須要把系統的solution要把它做一個調整就像Eventually memory access

還是要 introduce critical selection 的概念但那是 programmer 自己要去解決了系統就不處理了因為 supposedly 是不會發生 deadlock 的所以這叫 prevention所以這些條件把它拿掉的做法接下來我們就要第二塊就是 avoidance所以意思就是說怎麼樣在 wrong time 的時候假設我們四個條件就是有可能會發生那怎麼樣在 wrong time 的時候我們的系統仍然可以去幫忙去根據目前系統的狀態然後去即時的避免掉 deadlock 的發生就像我們說的這個所謂的避免就是分成 single instance

跟 multiple那等一下大家看到 solution 的時候其實它的 solution 的概念都是 follow 一樣的一個東西就是怎麼樣去 avoid 就是去考慮你的 worst case因為會發生 deadlock 都是因為城市做了某一個resource的使用的動作之後才造成的對不对那如果你要避免事先避免的意思就是你要去考慮到worst case對不对未來所有情況下最糟的狀況發生的時候它如果仍然不會有deadlock那你就可以安心的去做這件事情就代表你今天即使做了這個resource assignment，未來不管其他process做什麼事情

也不會發生delock那只有在這種情況下我才允許系統才允許去做這個動作，那樣就可以avoid了嘛對不對就是worst case。系統如果consider always consider worst case，且也可以make sure worst case裡面沒有delock的話，那當然就這件事情這個系統就可以去知道現在他去允許這個resource的assignment這件事情也不會有一些也不會有造成後續的問題

好。那所以我們來看什麼叫Worst Case那一樣我們Single Instance就是回到了這個Resource Location Graph這個東西對不對，因為他是最好的可以描述整個系統狀況狀態的。上面勒當然所有的Symbol都是我們之前定義的是一樣的對不對，有Request的Edge對不對，然後勒有Assignment的Edge，所以這都沒有什麼問題也就是目前這個系統已經發生

的事情所以這是代表已經發生的對不對。所以已經Resource R1已經被Assign給P1了，那所謂的Worst Case就是我們要去考慮到系統勒必須要考慮到未來還有這個可能會發生的事情所以，在這個圖裡面其實我們就是再多加另外一種Edge叫做Clanned Edge所謂的CleanEdge就是假設我們可以去Trace Process的Code然後知道這些Process跟

Resource的Relationship有哪一些是它未來可能的。所以，這只是Mail所以，這是未來，它有可能，我看它Code裡面我發現它是有做這個動作，這本來，它有可能對不對？那假設我們可以抓出這些Information我們就可以再畫出這個CleanEdge，那，這個CleanEdge，你會發現它也是從Process指到Resource，跟這個request edge是同一個方向，但是它是還沒有發生的。所以，我們用不同顏色，實它是代表的是不一定會發生的這些狀態那我們一樣可以把它全部標示出來，那為什麼

叫做為什麼需要把它標示出來，因為標示出來的意思就是說，它今天當然是還沒發生，但是worst case，在最糟的狀況下，就是它真的發生了那，如果真的發生它又沒有資源已經資源被人家搶走的話，那它就會變成一個真的紅線就是一個request的edge就會跑出來了。所以，我們就把這些edge就先把它也標示在我們的graph裡面，indicate worst case，它會成真這件事情

那你多了更多的edge，你可以想見就代表你有更大的機會，有 circular weight 對不對，因為未來發生的事假設都發生了，那這就是所謂的 worst case好，那所以咧你會發現原來這些 clanned edge雖然我們把它畫上去，但是他們因為都是從 process 到 resource，所以它其實並不會造成這個 circular weight 的狀況，不會因為單純加上去就造成它會

發生還是因為當這些claimed edge真的變成 requested edge就是變成紅色的那變成紅色之後，這個就是當它要的時候對不對，而且更重要的是它只變顏色還好，因為它的方向是一樣的，那我們真正怕的是它是不是應該變成 assignment edge，所以這個部分的去avoid的意思就是說今天假設有一個 client edge，它真的發生了，那它真

的發生的時候現在沒有人在使用 R2 噢對不對，那系統就要做一個 decision 嗯，我不應該把 R2給 P1 對不对，那如果我給它的話，意思代表我會把這個edge就把它變成綠色的 assignment edge了對不对，那如果我不同意那就代表它還是這個方向，但是系統現在有一個 Decision它可以做決定，所以當我們所謂的Avoid的意思就

是，因為我們把所有其他可能性都畫出來了所以我們今天可以做一個判斷：我如果把它變成綠色的線，會不會造成Circle？目前當然是沒有Circle，因為Always我們會去事先去避免嘛對不對。所以目前我們知道當然是沒有Circle，但是，如果今天他來一個這個真的變成一個request的時候，我們的OS，我們的系統可以決定他要不要變成assignment。那你可以

看見像這個例子，如果是P1要R2，他把它變assign的話，沒有circle對不對，因為很明顯嘛沒有circle。但是萬一是P2來然後要R2的話，我們把它變成綠色方向，一改是不是一個circle對不對。他就變成一個circle，那就代表這有危險，因為雖然說這條線現在實際上還沒有發生喔，但是，worst case，它可能下一秒就發生啦不可預測，你也不知道什麼時候會發生嘛。但它有可能發生，所以，如果今天這兩個線，雖然不存在，但是我們的

系統允許了這個assignment的話，把它變成綠色線，你有兩個綠色，一個紅色，這一條線，如果在未來發生了，那你就會有一個circle，那就代表它有可能會delock對不对，所以對於這個系統而言，他的decision為了要avoid任何可能性，今天P2如果要R2這個request的話，他不會答應，因為他一答應，就可能會造成delock可
是，如果是P1，他

要R2的話，在目前的這個狀態下，他會同意，因為他就算同意了，你很明顯可以看見，即使那條線發生成真的變成紅線無所謂的Avoidance就是把所有的可能性都先把它劃上去，然後當一個Request來從一個Clan Edge，它變成一個Request Edge它變成一個Request Edge的時候，我們的系統要決定這個Request Edge是不是應該把它變成Assignment，即使它的Resource是Available也可以把它擋掉，所以這就是所謂Wrong Time Detection的意思，所以這是Dependent 系統的狀態，因為你可以看見剛剛這個Decision是

這兩件事情已經是很真的，如果今天譬如說P1，他並沒有R1，並沒有Simon，他也只是Clan的話，那其實就即使那邊變成綠線也不會有Circle對不對，所以要Dependent想目前這個系統，它的關聯性是什麼然後問題就是一個紫色的線，它如果真的變紅線之後，我們要不要把它變綠線，你可以把它擋掉擋掉它就會維持只是紅線而已，

但是如果你agreed變綠線的話，又有circle就代表你可能下一秒鐘就有deloc產生了，所以這就是剛剛說的，所以你可以看到像這個就是deloc產生對不對，所以如果今天我這個 P2 R2我如果同意了，它變request然後我同意做這個assignment。你去run一個circle detection algorithm然後，如果你發現了那就代表這個Simon不應該同意他要把他擋掉就是等在那等到直到可能上面的兩條線的狀態改變了然後就算同意也不會有Circle的時候

你才會允許他做Simon的動作所以這就是Avoid的方式所以問題就是我們剛才說的其實所有的Detection或是這些Avoidance Aggression它的Complexity都不會太低因為你的resource type其實非常非常的多說真的你把一個程式系統break down下來它有可能會造成resource type遠比你想像的多很多那所以這個n的值通常不會很小那這個graph你可以想像process的數量像我們系統都是幾千這種級數的對不對

那你去跑一個detection最好的algorithm也是n square那時間就會花很多這是為什麼說avoidance除非你真的很怕deluxe真的無解不然你可能不一定會願意付這個代價好 可以齁所以這個argument就是這樣基本上就是把client edge把它畫上去然後今天當一個client edge變成request的時候這個系統要去run一個這個argument去看看你把它變成assignment之後會不會有circle產生如果會它就應該維持在request的狀態下那如果不會你才會grant就是同意

這個resource assignment的動作然後把resource assign給某一個process那用這樣的方式去做這個avoidance的動作接下來我們就要介紹就是這個banker's algorithm所以就是multiple instance的話我們又應該怎麼做那因為multiple instance所以你就比較難把它用图的方式但是其实是有简单的虚度扣这个简单的argorithm其实也是可

以去detect它的当然complexity可能还是n2这个Bankers algorithm的概念其实跟刚才是一样就是所谓的avoidance都是就像这边看见这个图也就是说我们会把整个系统的状态分成safe跟unsavesafe的意思就是说他絕對沒有DELOCK發生絕對不可能有DELOCK發生那UNSAFE意思就是他有可能Worst case的情況下他有可能那UNSAFE的狀況下裡面又有所謂的DELOCK的狀況也就是他真的發生了或者說做這件事情，

他真的就會造成DELOCK，所以所謂的AVOIDANCE的意思都是一樣的，就是我們要維持在SAFE STATE。我們只要worst case他有可能被de-lock就是所謂的進入unsave的話，我們就會把造成從save state移到unsave state的這個動作把它擋掉，就像我們剛剛的例子，有沒有這個一個request這個P2要R1的時候，我們就會把它擋掉，因為如果你允許了，你

就會進到unsave然後其中另外一個client，如果變成request哇， 那你就完了就變de-lock了，所以所有的avoidance都是一樣的，就是我們要維持在所謂的save state。好，那這個OccursionBanker Occursion，它的概念又是什麼呢，也就是說如果今天要維持在SaveState，實我們是可以有一套方式去檢查的那檢查的方式，我們等一下可以看見，就是一個Sequence of Allocation 的Plan也就是說，我們可以允許這些Assignment去找到一個順序讓Process有一個順序可以依序的執行完畢，

只要他們能夠依序執行完畢，就代表他沒有Circular Wait就是不會有Deadlock，所以重點，就是我們大家看見，就是我們要去能夠找到這個SequenceProcess執行的Sequence只要找得到就代表你在Safe State也就是你不可能會有Deadlock那當然找不到這個Sequence我們大家看到Sequence如果你找不到就代表你可能進到了你現在已經進到了Unsaved State那進到Unsaved State

就有可能會產生delock所以重點就是我們要能夠確保那個sequence是找得到的那同樣所謂的avoidance的意思對不對就是我今天同意了某一個assignment之後如果我就變成找不到所以原來一定是找得到嘛所以才是save state但是如果今天有一個processrequest某一個resource我同意了同意了之後發現找不到sequence了

那就代表你在 unsaved那就代表我要擋掉這一個或者是要 hold 這個 assignment 的動作讓它維持在 safe state直到系統狀態的改變改變之後你可能又可以找到一個 sequence 了這個時候你才去同意這個 assignment 的動作我們就來看什麼叫做 sequence這個又叫做 save sequence所以就代表你在 save state 的Sequence就對了那我們當然這邊因為

你要考慮到比較General case所以其實它可以用一個表的方式去做一個描述那一樣我們這邊只要考慮一個Type就好就是Type是一個Resource Type但重點是它有12個Instance，所以Module Type我們之後會有例子但是其實Occurrence本質沒改變因為每一個Type是Independent的嘛 對不對所以我們care其實這邊跟剛剛的例子graph的例子不

同在於一個type我可以有my instance好那什麼叫考慮worst case呢在這個例子你可以看見假設我們系統裡有三個process那這是我們目前的狀態always我們要知道目前狀態嘛對不對所以P0可能現在它使用了五個tab然後P1用兩個P2用兩個那所謂的worst case呢這也意思就是我們需要知道最多的時候對不對整

個程式執行下來假設我們可以profile它的code我們知道它最多的話會使用多少個instance就是同時間喔同時間會使用到多少instance的話那這個就是所謂的worst case對不對所以目前雖然只用5個，但是我們看它的code發現它說不定最多的時候會用到10個代表它下一秒鐘它可能就要再要5個它才能夠執行它下一個statement

那這樣他就可能因此會卡住了，因為你只要不給他十個，他是動不了嘛對不對，所以這就叫所謂的worst case就是他的maximal need那這個資訊當然在我們的問題裡就是假設either我們的compiled tool或者是programmer你提供這個資訊給系統就對了所以這個是given的那不要忘了他是同時間你要這麼多的resource的這個instance他才能夠執行他的下一個動作

的意思不是說total用了多少而是說某一個步驟它最多最多需要多少instance好那這是它的worst case是它的現在狀態那我們其實在這個例子我們可以找到一個safe sequence叫做P1 P0跟P2那我們就go through一下這到底是什麼意思為什麼叫做P1 P0 P2呢？意思就是說假設今天這是worst case對不对，所以我們要希望讓這三個process它可以執行完畢的話我們知道total是12個對不对那我這裡用了9個所以剩3個對不对

那今天worst case發生的意思就是說瞬間下一秒這個人說我也要10個意思說他還要5個他才能動他還要2個他還要7個他才能動這是worst case嘛對不对那就算在這個狀況下聽起來很糟但是你看我們可以可以找到的Sequence ence就是我們三個，它只要再兩個就可以動了啊，那我就把三個Resource全部給P1

對吧那P1拿到三個它就可以執行了嘛，執行完之後就代表我可以讓這個程式整個先跑完整個跑完之後，那它手上那兩個是不是就Free出來了對不對所以第一個我們會讓P1執行那，執行完之後那我就會變成這樣的狀態對不對，我就知道我如果就讓 P1 執行我就可以有五個留下來了然後呢，這五個我再去看，那就會發現 P0 也可以對不對，所以剛好 match，所以我就知道下一個P1

執行完之後，P0 它也可以執行完對吧那 P0 執行完了，你就繼續把值就加上去了對不對所以每一次做完意思就是把你手上的因為程式結束嘛，所以就可以Free出來，所以你就有10個你只要7個可以對吧，所以Safe Sequence這邊就是P1 P0 P2，因為就代表這個現在這個狀態是Safe的，因為我知道我只要強迫他P1先執行完再執行P0再執行P2的話，大家都

可以順利的執行完畢，不會卡住，所以就代表這個狀態是一個Safe的狀態，所以這就是Save Sequence了，我們就是要能夠找到這樣一個執行的順序，所以make sure現在其實這程式不會卡住，因為只要你現在手中的resource是一樣的數目的話，我們只要用這個ordering一定可以保證它大家可以event通常執行完畢不會有卡住的狀況所以這就是 Save Sequence了

那所以大家可以再看另外一個例子就是我們找不到Save Sequence這當然是有可能的比如說我們其實是要很簡單的做一個小改變假設我們今天把我們的例子從原來的2把它改變3它就是剛好只是多拿了一個resource的一個狀態的話大家可以自己去跑跑看你會發現你一定會卡住就是一樣這個

找Sequence的順序勒其實大家不用擔心ordering你只要找到一個Sequence就好它的順序無所謂而且勒其實你去檢查的時候你可以從上到下沒有順序也無所謂因為每一次你只是把這個incrementally的增加你的Free Resource嘛對不對大家可以簡單證明啦所以順序不重要也就是說你今天手上有多少Free 的Resource你就少過這這個表就對了然後看他差的值只要能滿足的你就先 Assign 給他就對了那在這例子剩下的你會發現只剩下是兩個那這個是 ok可是 Free

掉之後呢剩下多少四個對不對原來的兩個加上Free 出來的兩個是四個四個他要五個不行他要六個也不行對不对所以哇就卡在那了所以你就是找不到一個Safe Sequence所以就代表如果我們系統進入了這一個狀態的話它已經進入到 unsaved state了它有沒有de-lock沒有啊事實上目前它沒有de-lock

因為這只是它目前才要三個兩個五個對不對所以它會de-lock的狀況是worst case假設下一秒鐘就是這麼倒楣它就說我要從五個增加到十個它要從兩個增加到四個才會進入真正的deadlock所以avoidance就是他事前就去考慮worst case會不會進入unsafe state來做一個decision所以意思就是說用這樣的方式沒有safe state的話就代表這個state是沒有safe sequence的話就代表這個state是unsafe那我們就必須要去把它擋掉了

那所以怎麼去找save sequence就是這個algorithm的核心啦所以大家其實他的蠻容易理解的啦對不對很簡單的step但大家一定要注意一點每次大家都會搞混掉這個是maximal need所以代表這是最多會使用的resource的量他的意思是這樣子所以你每次用完之後free掉的勒请不要加这边的值是加这里的值因为这个才是你目前hold的resource instance的数量好那知道这个save sequence的定义我们就来看怎么样

它变成所谓的bankers的algorith m那它的算法基本上就是刚才说的，它會去做pre-determine，就是事先你有一個request來，你要去更改你的目前current holding number的時候，我在改我會先把它做一個修改，但沒有真的做那個assignment，所以它只是事先去看看，會不會有什麼樣的狀況所以假設我幫你允許的話，它是不是仍然它是不是仍然留在save sequence如果它不是就代表

我不能允許這個Simon的動作，那就是會把他擋掉，這就是Bankers Algorithm的概念，所以整個算法基本上就是剛才說的先去Assuming Worst Case，就是把Maximal Process這個使用Resource的量，把它記下來然後先去看一下目前，它是不是一個Safe的State然後，如果這個只要是滿足他的要求的，我們就可以把這個process給free掉，也就是把他的resource，把它

拿出來然後就給其他的process來使用然後找依序能夠找出一個save sequence出來好，那只要找得到，就代表這個assignment是沒有問題的那你檢查完了，你才會真的approve這個resource的assignment的動作好，所以我們就把剛剛這個延伸到M ultiple Resource Type其實是一樣的啦，對不對，所以如果是Multiple Resource Type，就像這邊我們可能不只有A這

個Resource，我們還有A B C甚至於Whatever很多都無所謂嘛，對不对都是一樣的演算法，那所以只是更稍微數字多一點可是Follow完全一樣的概念就是你有Maximal，你有Current的Allocation，所以這一行指的就是Current Holding的意思那，這一個勒就是這兩個相減也就是我們還需要多少，對不对然後呢，我們根據這個State，我們會知道目

前Available的多少，對不对，那目前Available的數量當然就是Total的數量減掉Current Holding的數量，對不对，所以這裡2加3加7嘛，一共10個嘛，所以A還剩3個應該沒問題，以此類推，所以不要忘記是total減掉這邊的數量不是其他欄位，那剩下的我們就只要就像剛才的做法，我們就去scan through就好了，那當然因為它是multiple instance

type，所以就變成一個多維度的問題，你就要三個要同時符合，所以多resource type會更難一點，就是這樣，因為你必須要每一個維度都要match才可以，所以332，對不对像這個就沒問題，對不对可是像這個33這兩個沒問題可是這邊這個當然也ok啦332像這兩個可以對不對但是這個就不符合那就代表即使

把所有resource給最後一個人他也跑不完好那這個情況像這邊只要011啊這兩個都可以就像我們說的你要給誰無所謂反正結果都一樣不會影響你會找到safe sequence or not的那個decision就是你最後的result是一樣你只要找有沒有存在一個save sequence那save sequence的可能性其實不是只有一個可以有多

個只要找到任何一個都可以所以你就跑一樣的algorithm所以122這可以嘛對不對所以我們就把它free掉大家可能自己trace一下就可以所以available那邊就會update嘛對不對就把它加上去就好然後再繼續找剩下的對不對然後以此類推那你如果都可以找到像這邊對不對13420對不對那就

代表這個是一個save的目前是一個save的State好那所以剛才的例子就是Multiple instance type的話你可以用同樣的那個做法去找到save sequence那做avoidance的意思是什麼呢就是像剛剛我們會先檢查過原來的系統狀態是不是Safe的然後咧假設今天有一個Request進來了所以，一樣剛剛的狀態，這是

剛剛的系統狀態我們知道它是Safe了沒問題，但是今天假設P1，它執行了某一個程式嘛；說我要多要這個一個A兩個C，我才能夠執行下一個程式嘛，那這個時候就像一個Metalog或之類的對不對Create一個Objectwhatever 對不對那你需要這個動作的時候我們的OS就要決定我要不要允許他做了；那這邊就是大家

常常搞混的允許他做的話，你要怎麼樣假設同意咧假設同意的方式是這是目前的allocation所以，我為了要檢查我就先假設我同意那我就把這些值把它加上去因為假設我allocate給你嘛 對不對所以這是P1P1原來是200嘛 對不對那如果我同意你了，那當然就是把這個 usage 加上去啊，所以會變成 302對吧；所以我假設同意那我把它換成 302

之後大家再去跑一次剛剛的 save sequence 的 algorithm看你找不找得到一個 save sequence如果你找不到了，那就代表這個 Simon 不能同意因為他有可能就會 deadlock 了那如果你找得到像這個例子大家可以自己練習一下你應該是找得到的就是你把這個值改成302你再去跑剩下的resource你可以找到一個safe sequence像那邊那樣子那就代表沒問題這個assignment我可以接受讓他安心的讓他去使用就算他使用我同意之後未來任何的狀況發生我都還是有借所以

這是可以同意的一個assignment不會有de loc相對的大家可以跑另外一個例子假設呢同樣是原來的狀態但是這一次是P4然後他說他有三個A三個B他才能夠繼續執行那我們的系統要不要同意那同意要檢查的方式就是一樣本來是002嘛那我們就把它加上去變332然後再跑一次該的演算法這邊 3 3 2

這裡維持在 2 0 0我們這個 slice 的例子的話是說假設在這個狀態然後這個 request 來然後這個沒發生這個來了單純把這個值改成 3 3 2假設我同意的話你會發現你找不到 save sequence那所以如果找不到就代表我們的系統會把這個 allocation 的這個動作或是這個程式的動作這個 system。 com 的動作把它 hold 得住或甚至於就直接 reject

就說不進那這樣子就不會進入unsaved的狀態所以這是Banker's Aggression就是這樣就是每一個request來的時候他就去把這個location的值做一個修改假設發生然後跑一遍看看會不會進入unsaved state如果會進入unsaved state就代表你要reject或者hold得住這個request維持在saved state你可以找一個sequence那就代表你可以

approve你可以讓系統真的改變成那一個狀態所以這好多欄位大家不要搞錯了往年每一次都還是很多人搞錯千萬記住max的這個值是永遠不會變的因為這是你的程式的worst case它是given的constraint一樣最多就會用這麼多那這個才是記錄目前这个程式执行的状态那它就可能会因为你的assignment的动作而把这个执作改变那你只是要去检查改变之后会不会造成问题所以这个就是我们这章节非常重要的一个部分就是这个save sequence的找法然后如何用这个save sequence的找法来判断你是不是可以同意一個resource的這個request.