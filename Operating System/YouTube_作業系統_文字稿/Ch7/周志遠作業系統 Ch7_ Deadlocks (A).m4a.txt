undefined
那我們要正式開始第七章，第七章是 Deadlock，也就是說我們在第六章時候介紹過Synchronization對不對？要去解決這個Critical Section或者說Mutuous Cushion話，我們就會 introduce lock 的概念對不對，這樣才能夠保證一次只有一個程式可以去access這個resource或執行這一段程式，但是因為有lock所以反過來也是我們後面看到很多例子，如果你去使用保護的critical section的寫法不對寫得不好的話或使用這些tool的方式不正確的話，你就會有de-lock的狀況也就是你等我互相在等process之間互相在等

然後讓所有的這些process都沒有辦法繼續執行的這個狀況就是我們所謂的Deadlock，所以我們這個章節就來正式來介紹跟定義什麼是Deadlock還有在我們系統裡面去解決Deadlock這個我們會把它分成兩種方式來討論一個叫做Prevention也就是說是以系統設計的角度，我設計一個系統的管理的方式那讓所有的程

式在這個系統上面執行的程式都不會有Deadlock，不管使用者怎麼寫你的程式，因為我系統的管理已經把它考量進去了，所以你就不會產生Deadlock另外一個叫做Avoid ance我們大家會看見那就是指的是執行的過程的當中我們動態的去偵測系統狀態然後來解決這個問題所以一個是訂了一些RULE事先就

把它所以叫做prevention事先就eliminate這些可能性另外一個是在wrong time的時候去detect然後去avoid它那我們這次這張結最主要就是講這兩個部分怎麼樣子有哪些prevention的方式有怎麼樣有一些wrong time avoidance的方式還有deadlock的基本的定義那就是這個章節主要會cover的部分了好所以什麼是DATELOG先從比較high level就是concept角度

的描述就像我們其實前一章節就有遇到一些狀況就知道會有DATELOG的原因就是因為這些process之間對不對他們在執行的過程中需要去使用到一些resource這個resource是很抽象的可以是比如說是一段程式或者是一個memory的content你要把它或者是CPU的這個Physical的這個CoreExecution的Slot也可以就是所有的這些都可以把它想成所謂的Resource總之你必須要佔有它你才能夠繼續執行的東西那程式執行常常會需要這些Resource或是要去佔有這些東西對不對

那可是因為這些東西是系統的是有限的所以你就會發現如果這些東西被別人搶走的時候你就會需要在那邊等待。對不對那如果說你有很多resource或執行過程中你需要dependent很多不同的resource的時候你就有可能造成不同城市之間各自都掌握了部分的這些資源然後會產生互相等待的狀況因此就會卡在那裡了。這就是我們常常會發生deadlock的原因就是這樣因為你會hold resource然後咧你hold的同時因為你會還需要其他的resource嘛

所以你又在那邊wait然後你等不到下一個resource的情況底下你hold的那個你又不願意把它放掉結果就變成卡在那裡的狀況好。一些常見的例子比如說我們以這種比較physical resource像tape the driver的角度你知道你要去寫檔案寫到這些hard drive那你需要去grab resource你要控制這個磁頭你要去call這個driver的code那一次當

然只有一個程式可以用嘛對不對那所以如果今天你有兩個tape對不對兩個drive那你再去執行你的這個程式的時候你是需要同時寫到就是寫到這兩個drive上面去的那就有可能你有兩個剛好有兩個process然後呢各hold了一個然後呢再等另外一個然後沒有拿到兩個你就不願意去release你的lock不願意開始去完成寫的動作

那這樣子就會變成一個互相等待的狀況那你可以想見兩個都不退讓的話當然就是永遠卡在那裡對不對整個系統就像是停住一樣這是Deadlock就會發生了對不對或者是我們之前前一個章節看見的對不對很多Synchronization我們說可以透過這種Semaphore或一些這種機制對不對你可以去控制它的執行先後順序你會去摳一些Signal跟Wait的方式去控制對不对

可是我們這時候也看到很多例子或這邊這也是一個例子對不対有可能你就有AB兩個Sympathone然後呢你一樣是互相的會去等待對方的話你Code的順序如果是Code的不好兩邊都先Graphed其中的一個Sympathone然後呢才願意去這個Coding再把他的手上的Sympathone Release掉的話一樣會產生Deadlock因為你要兩個都有你才願意放掉你手上的Lock那可是你不可能兩個都有嘛對不对

就是一人剛好Grab了一個Lock這樣也會造成Deadlock的問題所以其實這個Deadlock在解決Synchronization的時候非常常發生或者是只要一個程式的執行過程中，它需要AcquireMultiple這些資源然後這些資源又被別人給搶走的話就會造成Deadlock這個狀況好那只是描述所以比較formally地去define怎麼樣子會產生Deluxe的話我們基本上可以把它整理出來就是四個條件而且請注意這叫做necessary也就是說這四個條件要同時發生才會有Deluxe只要缺一不可就不會有Deluxenn那第一個Mutual Exclusive所以

我們都知道了對不對前面我們定義了什麼叫 Mutuous Cushion意思就是一次只能只有一個人使用那所以這是其中的一個必要的條件如果很多人可以同時使用也就是說這個Resource可以Share嘛那Share當然就不會有Waiting的狀況當然不可能有Deadlock所以要有Deadlock第一條件就是要有Mutual Cushionnn那這個條件常常會發生就像是我們在解Critical Section我們就必須要有這個條件對不對才能解那個問題

可是也因此導致了這個Deadlock的第一個條件就因此就產生了所以這其實是很常會發生的一個conditionnn第二個就是這個程式在執行的過程中它會有這種Hold and Wait的behavior也就是剛才看見的它可能要多個resource然後它已經取得了一個，但它還少了一個然後他不取得第二個的時候他沒辦法取得第二個的

時候他會把第一個一直hold在那裡，那這就危險了，因為你hold那就代表你可能就會卡到別人了。所以就是有這種hold然後再wait的behaviour的話，就有可能會產生deadlock換言之，如果是你不hold，你如果只是純粹wait，比如說我需要兩個resource可是我沒有辦法同時拿到的時候我就通通一起放棄要嘛就是全部拿到要嘛就是

都放掉。現在如果兩個有一個resource拿不到我就重新來過，我已經拿到那個我也把它release掉。我不會有hold的話，那這樣也不會有deadlock。所以，hold and wait也是一個必要條件，就是你要已經搶了一個然後你又還要再等另外一個resource，這樣子的一個行為第三個必要條件no preemption也就是說今天這個程式是没有办法被

人家强迫把他的resource給放掉的。那如果这个条件有的话，也才会有deadlock。所以，反过来讲，就是如果今天你可以去做preemption，你可以强迫一个人，比如说，把一个城市给kill掉当然不会有deadlock啦对不对，因为你等的那个人你可以有权利把他說對你直接把他殺掉要求他把他的resource放掉，那当然就没有人会等了嘛，对不对

所以第三個條件就是no preemption，就是拿到的你必須要是這個自願把它release掉，这樣的一個情況那這也常發生啊，因為很多時候譬如說我們說寫printer對不对我們在print這個我用printer print資料，你怎麼能夠preempt它咧，对不对如果我們印到一半你說我可以做preemption，那什麼意思我印到一半才寫到一半的字印到一半然後就

等一下再印嗎， 不可能嘛， 對不对所以程式中一樣有很多的程式的執行是no preemption的，因為它沒有辦法把它的state記錄下來或是記錄下來，它會花很大的cost去做resume的動作，所以很多程式都會也需要這個條件no preemption好， 最後一個最後一個有一點像是結合hold和 wait然後把它延展到多個城市的一個狀態，也就是要有circular wait，所以最後一個必要的條件是要有這個circular wait的狀況，也就是互相等嘛，对不对

因為如果只是單純的你等我，我没有等你的話，对不对那没有變成一個circle，其實eventually這個lock會解開的，对不对eventually會解開當然要花很多時間，你要等很多人但是在定義上來講，他Eventually會解開那就不叫Delock，所以Delock的這個狀態要發生一定是你會發現他有Circular Wait的狀況，也就是這些Process在互相等那最後你可以找到一個Circular Wait的這個狀況，那這四個條件你可以看見這是一個蠻有趣幫助大家記得一個例子就想交通就對了，

所以你可以看見大家一看就知道這就是一個Deadlock，對不對我們有四條路四個方向可是我們的車子剛好就全部卡在那邊，你可以注意到沒有一台車可以去動，這是標準一個Deadlock，那這個情境要怎麼Map到這邊四個類，我們可以看一下Mutual Exclusion，Mutual Exclusion的意思就是說你們可以把這個交流到這塊空間想成就是我們的資源，你要通過你才能夠繼續走對不对，

那我們知道在這個空間裡一次只能有一台車啊，你不能夠兩台車啊，對不对，那就裝在一起了，那就叫Nutrious Cushion嘛，對不对，所以一次一台車在那個位置Hold and Wait，你可以看見它，這就是停在這邊所以它Hold的這個Space然後它在Wait呢，其實是前面的Space，對不对，所以這就是一個Hold and Wait的狀況，那就是第二個條

件，所以我們知道如果真的交通這邊都會畫黃線說不能夠停在這對不對因為你一停就會有hold and wait的狀況那這是一樣的意思所以你不能夠停在那個地方把它hold在那邊。 No prevention也就是說這些車子都是一般的車子這就是為什麼會有消防車跟救護車嘛對不對一聽到鳴笛你要讓那個就是你要pre-empt他可是一般的車子沒有人互相會讓他對不對

那就是no pre-emption對不对所以你不能強迫的叫旁邊前面的人讓開讓你過去對不對你不能強行的通過這個地方這是no pre-emption。最後circular way當然你可以看見的對不对所以他是互相等待的一個狀況。今天如果這一個交友道沒有沒有被這個hold得住的話那eventually大家就可以這個通行過去了所以刚好就是这

四个这个状态好所以当然电脑里是一样的道理就是那个交流道它会是各种resource你可以去想可以map到任何执行过程中你需要去使用的资源可能通常是一个lock或者一个shear memory空间的使用或者一个resource physical resource的使用那就記得這是necessary也就是說這四個都要同時存在才有delock換言之只要我們能夠解掉其中任何一個那我們的系統就不會有delock囉但是當然不會那麼單純。其實這四個都是很常電腦運作的時候會需要的四個criteria。

那知道了這個定義之後呢我們來看一下怎麼樣用數學所以我們之後去解它當然就需要一些數學的基本的模型對不對還有一些用圖示化可以去解它的一些solution那再解這個再去看這個deadlock的這個問題上基本上它就是一個資源使用的問題對不對。所以呢第一個我們會定義的就是resource type請注意這是type而已喔ok所以

就像是一個Type就譬如說對到一個CPU另外一個Type可能是Memory然後一個Type是IoDevice一個Type可能是Lock對不對。所以這個是Resource的Type你可能就有很多種Resource的Type對不對。然後呢每一種Type所以之所以它叫做Type的原因就是因為每一個Type它可以有多個Resource的Instance對不對還有很多的單位就像我們說CPU也不會只

有一個啊我們可能是Multiple Core嘛 對不對。所以應該有四個CPU對不对我們IoDevice關於我們的Hard Drive可能也是有兩個所以這可以是一個可以被Counted的Resource就像我們前面教過的Sympathome是Count ing Sympathome的話它是一個數量沒有人說一定要1或0 對不對所以每一種Resource Type它又會對應到它的Instance的數量我們今天用W啦不過就是記得是有type跟instance那整個程式的執行你就可以把它想像成不是想像成你就可以

把它描述成它需要哪一些resource那每一種resource它可能需要多少個instance然後你在使用的過程中其實就是重複這個過程嘛對不對我要request某一種Resource然後咧去使用它使用完之後我才會把它放掉然後在使用的過程中那個就是這個Resource就被這個Process給佔住別人就不能夠去使用它所以會城市之間可能就會因為Resource的這些Sharing開始有Dependency有關聯性就可能會產生Delock好

那剛剛是基本的幾個symbol對不對那我們同時也可以根據那些symbol我們就可以把它畫成一個圖因為大家可以想見這就是在描述process之間的關係所以關係這件事情最好去理解它就是透過一個graph對不對畫一個圖把它看到他們的關聯性那所以對應到一個graph裡面呢我們就會像這樣子所謂的這是resource allocation graph

這個定義就是說它畫這個描述的狀態用這邊這幾個方式去把它畫出來。首先就是process當然那通常就圓圈假設我們這邊有三個process然後呢我們有一些resource嘛對不對那resource我們就用方塊那裡面的每一個點這就是resource的instance所以每一種type你可以有多個instance所以這應該沒問題對不對。所以數量也可以

不一定對不對。那我們在執行的過程中像剛才所知道的我們Process他可能會需要去為了執行所以他就需要去Request去使用一些Resource那我們就可以在這個圖上面的描述就用一條Edge來表示對不对那請注意這是有方向性的喔。所以我們從一個Process到一個Resource意思就是他需要他所以就是等於是發出一

個Request一樣。我需要這個Resource我才能夠繼續的執行比如說現在這個時間點這個Process需要這個Resource了有點像對應到前面大家學過的Critical Section的話就像是你進去一個Critical Section需要某一個Lock一樣那你要等在那裡直到你取得那個Lock為止好。 那相對應的就是如果你今天拿到了對不对或者你今天已經進到了

使用的狀態的話也就是說有個res源已經被assign給你，那這個呢我們就用所謂的assignment的edge來做一個表示那顏色不重要重點是方向所以只要是assignment你可以從字面上就可以去理解它當然指的就是從一個resource指到一個process嘛，所以代表那個resource現在已經被它是已經被assign給process了，那也就是這個process它現在正在

使用透過這個Resource管理的那個資源這個Instance這個Resource Instance它已經在使用它了所以你就可以畫出這個Request跟Assign的Edge在上面那從這邊你就可以看見我們剛剛說的Hold和 Wait的狀態就會出現了對不對因為你看像是P1他就是hold的其中一個R2的resource instance然後呢 waiting for R1因為這是request所以代表他還沒有取得他

只是要對不對，所以這就是一個標準的hold and wait那因此你就從這個圖我們是不是就可以看到是不是有circular waiting的狀態了對不对所以其實他就可以用一個圖學的概念去圖的這個問題argorithm來去解它了，那當然就是用這樣的方式去描述這個系統目前的狀態，那我們之後就有很多例子看到如何用這一個圖的狀態系統的狀態來判別現在是不是有Deadlock的發生或者是我們現在系統是不是

能夠把這一個比如說Request的動作完成來去這樣去做這個動作，如果讓他做的話會不會未來會造成Deadlock的危險等等，就Based on這樣的一個Model去描述去解問題了。所以就像剛剛說的我們說有Circular Weight四個條件，一個就是Circular Weight。所以從它有沒有這個Circle，如果沒有的話就不用講了。如果說我們把一個系統狀態畫出來，它這個狀態裡面你找不到任何的一個Circle的話，

那一定沒有Deadlock嘛，因為這條件很明顯已經證明有一個條件不存在那我們這邊想要看到的是，如果今天有circular的狀態的話，是不是就能夠證明它真的是有Deadlock。那么這件事情倒不一定。那我們就來看過兩個例子來看一下也就是說，你在這graph裡面如果有circle，它不一定代表它一定有Deadlock，有可能它看到Circle，但卻沒有Deadlock。那

這個例子呢，你可以看見。我們可以看的是Process之間的關聯性嘛，P1跟P2的關聯性很明顯，P1在等P2對不對，因為他要R1，但是R1已經在P2之後，那裡只有一個，所以代表P2,P1其實在wait。 ing for P2的那同樣的道理P2也在等P3對不對因為這一條線很明顯的嘛 對不對所以代表其實他也是在等 P3最後一個條件呢請問 P1 對不對或者說 P1這個 P3 是不是有在等 P1

啦因為 P1 等 P2 P2 等 P3那 P3 是不是有在等 P1 咧那我們可以看見在這個狀況下因為有兩個 resource instance所以只要其中有一個是 free 的其實 P3 是可以執行也就是說他會不會被擋住的意思但是在这个例子你可以看见刚好我们是有两个圈圈的对不对所以这个incidence被P2给拿走了那这个被P1拿走也就是说P3它既在等P1也在等P2那因此你会找到circular weight就是这三个process的确就是一个在等一个在互相的等对方所以

它是deadlock 沒有錯因為你可以透過這樣的一個trace它的關聯性你可以證明出來1等2 2等3 3再等1那類似的但是稍微改變一下我們再來看另外一個例子這邊一樣是有三個我們一樣可以找到一個circle但是它有沒有deadlock勒其實滿明顯的是沒有的對不對因為你可以看見P1P1的話對不對

它需要的是R2這一個它已經有了R2的resource它需要的是R1對不對那R1是P2或者是P3拿到的但只要任何一個結束的話它就可以滿足它的條件就不會被擋住了，那很明顯。如果你走P3當然會繞一圈，但是P2沒有對不對，所以代表這邊意思就是P2 eventually它可以順利的執行完畢所以只要它執行完畢的意思就是這個會被Free掉，Free掉之後P1就可以取得它要的Lock或是資源，它也可以結束掉所以其實並不會有De-lock，所以當然你可以

看P3是一樣的嘛對不對？ P1會等2或者是3那P3的話來講他會等的就是1或者是4，那其實1 2跟4這兩個process並沒有被任何人擋住，所以他eventually會free掉，所以從這邊就可以看見其實這邊同樣有circle，但是他沒有delock所以意思就是說，如果今天有circle也不代表一定是有delock這件事情我們需要更嚴謹一點的solution algorithm來做一個判斷

好，但是我們可以先做一個簡單的conclusion，就是如果我們今天把我們系統用一個graph來表示的話，今天只要沒有circle你就safe了沒有circle代表一定是沒有delock這沒問題，但是如果有circle的話，你其實要考慮到你的問題裡面是single instance還是multiple也就是說，這些resource的type，你可以有多個type，但是每一種type如果呢，它每一種

type都只有一個instance的話，那只要有circle就是 deadlock這個沒問題，因為你一定要那個instance，所以你沒有其他可以繞過去的方式，但是像我們剛剛的例子為什麼會有這個題目為什麼會有兩種結果，就是因為我們是有multiple instanceper resource type，所以就像前面這裡我們的R1跟R2，它是兩個。如果今天我們把它劃掉，變成只有一個，

那鐵定是有deadlock了，但是它有modular instance的话其实不一定会有deadlock这是可以得到的一个基本的一个conclusion那我们之后就会看见这个就很容易，这我们就只要用graph的角度，你只要去做一个这个circle detection大家都知道写个algorithm这都有的对不对虽然complexity蛮高的algorithm complexity蛮高但是还是可以正确判断這一個我們之後會介紹一個argument來去做一個正確的判斷，那麼樣去避免delock那就進到我們這個章節的主題了，那麼樣

去避免或者說解決這個不要讓delock發生的話，基本上我們是有兩種角度來解這個問題第一種叫做prevention我们提過的prevention就代表是never enter deadlock的狀態所以就是事前我們就會把四個條件的某一個在管理整個系統資源的時候把其中一個條件把它拿掉所以代表你再怎麼樣去寫你的程式都無所謂絕對不可能有deadlock因為就一個條件不存在對不對第二個叫做avoidance

就是我們說它是wrong time所以是它是在隨著系統的狀態它要一直去monitor一直去monitor目前大家資源的分配是什麼process跟process的關聯性是什麼來去做判斷現在適不適合可以去允許某一個resource被assign給一個process所以它是wrong time的detection去跟去解決這個問題這就叫所謂的avoidance這邊就要請大

家稍微記一下因為prevention指的就是四個條件拿掉其中一個avoidance指的就是wrong time的時候去做detection這個稍微把這兩個記一下區隔一下因為我知道常常會搞混但這不是專有名詞沒有錯啦但是如果問起來的話大家還是要稍微有個共識avoidance就是這個wrong time的prevent就是指不會發生對不對所以就是完全prevent掉那最後一個所以這是第一種就是說

你怎麼樣可以去避免掉你可以事先或者是wrong time來去避免那另外一種做法就是算了吧我們不detect了就讓我們系統隨便它跑等到發生了再來解決它因為等到整個delock也就是你發現CPU譬如說CPU transition怎麼變得非常非常的低或等等delock都已經發生了這時候你才去做recovery的動作所以這是另外一種比較消極的方式但這樣的話就有兩個條件這件事情第一個你還是要能夠detect detect delock已經發生的這件事情

那第二個問題就是你detect了你要怎麼recover對不對因為最暴力的方式你可以想見的就是kill掉某些process但是你也要去想我要kill掉哪一個process啊對不對誰的process比較不重要的或是影響會比較小這也是一個decision所以這是第二種做法裡面你會是會需要去解決的一些問題怎麼去detect還有到底你的recovery process的stats是什麼好最後一個ignore以系統的角度啦使用者當然不可以ignore但是以系統的角度你可以

選擇最消極的方式就是算了吧就是使用者想辦法也就是就是hen在那就hen在那那不可否認呢其實這個detection還有recovery這些方式系統其實很難做最好的決定或者說他要去發現或是避免他付出的代價其實很高的就是說你要不斷檢查monitor系統所以他的complexity很高所以很多practical尤其是commercial一般的系統他可能選擇是不這個ignore就算了因為你這邊會浪費很多CPU的資源你會讓整個系統變慢乾脆就ignore因為deadlock這件事情其實supposedly不應該太常發生

它會發生都是因為你的系統執行很複雜非常非常多的process然後又沒有很妥善的管理這些process就是programmer的角度啦才造成系統卡在一起了那這個本來就不該很常發生所以如果它發生了既然它不常發生嘛如果真的發生了就算了就看使用者等多就是reboot嘛對不對所以其實很多各位手上的電腦是這個solution就是為什麼說電腦跑一跑欸怎麼卡在那不動了

我後來 大家都知道嘛Control Net Delete對不對最神奇的三個鍵就是這樣解決這個問題就ignore了使用者自己想辦法不重要的系統其實是會學會這樣做的但重要的系統你說武器的Control System當然不可能這樣做啊對不對你說這個核電廠的控制系統怎麼可能叫你reboot勒那你就要去解決到用前面兩種方式

了好， 所以會有三個level，那當然我們這堂課的重點我們這個章節的重點會擺在這兩個那Detection其實跟你會發現跟前面的做法很類似只是它假設狀態它是根據狀態已經發生的情況下去做同樣的solution去做Detection的動作，那這只是在make一些assumption用worst case的情況下去做Detection那這個是已經happened的情況下做Detection所以其實他們的做法是非常像的

那Recovery我們當然不會Cover因為完全Depends on這個使用者對於整個系統還有對於程式的定義了怎麼樣子是Case by Case的所以我們重點還是在Prevention跟Avoidance對這前半段，所以很重要的就是基本的定義然後這四個必要的條件那我們接下來會去講Prevention跟Avoidance的，這個方法是什麼.