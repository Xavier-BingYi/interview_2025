undefined
這個禮拜呢我們會開始進入到檔案系統了，所以我們介紹完CPU Memory所以最後一塊呢我們就是要介紹這個Storage這一塊，那Storage這一塊我想大家都知道儲存的目的尤其是在現在的應用來講最主要就是檔案對不對，所以我們就會先來從介紹到底什麼是一個檔案到底檔案系統要扮演什麼樣的角色它的一些最主要在管理的機制是什麼這一部分那檔案系統我們又會把它拆成兩個章節所以這兩個章節都是比較小的，

那第一個章節就是我們今天要介紹的是在這個file system interface，所以是以使用者的角度來看檔案系統到底是為什麼會需要這樣的一個系統他扮演什麼樣的角色然後我們下一個章節會介紹他的implementation那就是檔案系統本身他的一些實作上面在設計上面的一些考量好，那所以當然就是一開始這個

先簡單介紹什麼是檔案，那其實檔案系統還有檔案這邊大家應該其實也比較容易去聯想因為這個是這個大家用電腦現在就是一直在碰觸的大家，我想都知道有個概念什麼是檔案系統，不過當然我們這邊會更這個仔細一點稍微再介紹一下所謂檔案到底是什麼，那大家可能比較會忽視掉的就是它的access的method，所以

我讀一個檔案到底有哪一些不同類型的方式，其實這會影響到使用者尤其如果你以 Programming的角度來看，它的話然後當然也影響到這個怎麼樣去捨破這個Access Method的這個Implementation跟 Design所以這邊會稍微重點提一下這個Access Method其實有幾種不同類型的，那接下來可以看見就是在使用操作一個檔案系統的時候大家都會接觸到的譬如說什麼是一個

這個 Directory資料夾的概念然後呢通常你在做檔案系統操作的時候最常見的就是會去做 Mounting所以你可以動態的去增加去擴增你的檔案系統的它的這個空間對不對去它的檔案可以把它做 Mounting把它給加進到這檔案系統裡面然後當然很重要的是 Sharing所以為什麼會有檔案系統的出現其實很重要

一點就是除了存資料之外其實更重要的恐怕就是在 sharing所以你的檔案通常是為了要跟大家共享的那像傳統的作業系統的角度來講可能這共享只是儲存在這個發生在一台電腦上面的不同使用者對不对可是像擴展到現在的世界我們知道這個 sharing可能更複雜就是甚至於到跨網路了對不对所以甚至於超過一個單純所謂這種

檔案這個作業系統或檔案系統的這個範圍他要更複雜一些要考量更多的部分然後最後當然就是 protection所以資料是非常非常重要的跟其他的資源管理是完全不同，這個檔案是屬於使用者的所以一些非常基本的這個檔案的管理這種上面要怎麼樣去protect這個file的一些事情好那我們就來一

一的去講所以首先什麼是file那file首先要知道它其實是屬於一個logical的storage unit所以我們講storage則就是只是儲存所以並不care說到底存的東西是什麼反正它就是一堆bytes資料那其實bytes跟資料是可以有很多種形式來去呈現的對不對因為它本來就只是一些bytes那所以file咧其實只是最常見或是我們對我們現在都知道大家最

最常用的一種方式就是以file以檔案的形式來呈現說你這個資料到底怎麼去讀取它怎麼樣去使用它所以file本身它其實只是一個logical的storage unit那什麼是physical呢所以相對真正的所謂的physical就是在指的是儲存這邊的physical的unit指的就dependent你的hardware你的儲存storage這個Hardware它是用什麼樣子的Device什麼樣的方式做儲存呢那以現在的角度來講我想大家都知道最主要的Primary的去儲存資料的的Hardware這個Device當然就是目前為止還是Hard Drive對不對

就是有這個知道是用Disk讀寫頭的方式去運作的。我們常說的這個硬碟對不對，所以我們下我們之後當然有一個章節在講Storage System的時候會特別去講這個硬碟的這個原理。它的一些重要的一個讀寫的方式等等。但是這邊大家就先稍微知道就好，可能大家也都知道就是硬碟買來之後我們知道一個硬碟的這個Hardware這個Device上其實是分成好幾個Plate對不對好幾個讀寫的盤。

然後呢這個讀寫盤上面我會把它做切割讓它變成儲存的 unit所以會有所謂的 track 一圈一圈的 track然後再把一個 track 切成一個一個 sector 一個一段一段那最後這一段一段才是真正在存資料的最小的 unit因為你存最後就是放到這個 sector 上面去，那這個才是所謂的 physical 的 storage 的unit。那 file 只是說把資料放上去的時候的一個 logical 的 unit

然後我們是以file的形式去呈現它，那所以怎麼樣這個logical 的unit它呈現的時候基本上是用什麼樣的方式也就是我們大家非常熟悉的，就是除了去把它的content map到這個physical 的device上的某一個位置之外，另外我們就是為了方便操作，所以我們會有很多的attribute去描述這個檔案那我想這些都是大家常看

到的對不對像是第一個檔名所以檔名它也是一個attribute而已喔因為它是使用者去給的嘛所以只是方便使用者去identify它的一個name而已它真正實際上的當然其實是有它這種non-human readable的identifier就是一個ID這當然其實人是不喜歡去用這一個所以這個才是唯一需要去unique的identifier那包括像是name

資料的型態對不對它存在哪一個位置它的size它的protection的一些機制等等這些就是一個file的attribute所以一個file其實會有很多的attribute方便使用者去讀它去使用它那當然有一些attribute是為了讓OS或者說file system本身自己去manage它的這些attribute那這些都是必須要存起來的那這樣就會形成我們的所謂的file

好那這段我們不需要一一講解釋過去對不對所以我們都知道其實file上面會可以捨破一些operation其實也沒有那麼的多如果你仔細去看它的話對不對但是也是有大概就這邊列的可能10個左右的這樣子的一些operation那最常見的不外乎我們知道就是要去能夠open然後rewrite你要能夠去create去delete對不對然後呢可以甚至於可以去truncate如果大家不清楚的話

troncate的意思就是說把一個file從一個點把它切下去然後後面的就不要了這就是troncate這有時候在做檔案處理的時候常常會去使用的一個動作就是去troncate一個file或者是咧把它這邊沒有列出來但大家也應該要知道就是concatenate就是把它連起來所以你可能會把兩個file用concatenate這樣的一個operation把它接在一起看哪個在前哪個在後都可以就是把它接在一起

那這些都是在處理檔案的時候常常會用到的嘛對不對尤其像concatenate可能是你的系統dump了一些log或者output的檔那可能是因為不同process產生所以它被存到不同的檔案可是你知道其實它們是應該是合在一起才有意義或是比較方便使用所以你可能就會把它concatenate在一起把它連在一起那這些大概就是很常見到一些operation

那當然File System就是要去Support這些事情那為了要Support這些事情我們稍微往裡面看一點的就是要知道的是為了要能夠去Manage我們的File或Operate Manipulate這些File的Content所以當然就會需要一些Meta Data在運作的時候那去知道這個File到底存在哪裡或是我剛刚操作的位置在哪裡等等那最主要的兩個data structure在maintain一個file運作的時候一個是在process這邊也就是在操作這個file的那個process它本身keep一些metadata這個我們稱之為open file table所以為什麼

在操作file之前一定要open是一定要的嗎因為你沒有open你就沒有辦法create這一開始這些需要的information當然不可能去support後面的動作那你開了之後這些資料會存在哪裡就會存在這個Process的File這個Open File Table所以當然每個Process因為開不一樣的檔所以當然會有不一樣的這個Table的Content另外一個是OS Level所以我們的系統OS存在所以OS Level當一個檔案被打開要開始操作的時候它也會把這個檔案的一些資料把它存起來那這些資料就會存在所謂的System-wide Table

那我們等一下就會來有這個圖例來稍微再講一下這兩個table的差異但基本上System-wide table它這個叫做 System-wide 的意思就是說這個table裡面的content當然是share給所有的processes的，所以任何的process要在這個系統裡面一打開那這個檔案的information就會存在System-wide那跟這個Process有關的，所以你打開很多人都打開File嘛，但是Dependent是哪一個Process 打開那個Process 打開的File它跟這個Process 有Dependency 的Information就會存在Open File Table裡面去，那所以這兩個都是必須要去Maintain才能夠維持它整個系統運作的好，那我們

就來仔細看一下這兩個字的道理是什麼，所以咧第一個看到的這個Process這邊的這個Open File Table重點就是它是Per Process的那不意外當然你每開一個檔案當然就是代表是這個Table裡面就會有一個Entry 那這個Entry裡面其實是一個 Data Structure所以你可以存所有你需要的Information關於那個File 的Information就對了那最主要的咧為什麼它叫Per Process 当然就代表說這個

Table 裡面的 Information只跟這個Process是有關係的那什麼東西會只跟這個Process有關那就包括了像是大家常看到的File Pointer對不對所以大家之前的一些作業可能也用過了嘛用Fopen之後它會給你一個File Handler對不對那個Handler其實對到的就是這個Open File Table的一個Entry的位置那那個handler我們知道

他會存的一個很重要的就是他的position對不對所以一個file可能可以被很多的process打開可是呢這個每一個process呢他對於這個file都會有他自己的position對不對所以一開始當然是initial是0可是你一旦對他做read的動作等等他的位置就會往後移動了嘛對不對那這只跟這個process有關所以像這個file的position就會存在open file table裡面了

或者是說像是access right對不對所以同樣是一個file你打開跟我打開我們的權限可能會不同啊對不對所以像這種會造成不同有差異的information我們就會把它存在open file table裡面所以打開之後像你打開你是用write permission打開還是read permission這個就會記錄在open file所以他知道剛出打開的時候我只有write permission或者是我只有read permission對於這個process而言

所以這些information就會全部放在open file table裡面那另外一個table就是我們說的system-wide table那system-wide table同樣是存file我們提到的但它就會跨整個作業系統所以任何一個process打開的file都會在那邊一樣會有一個entry那所以當然這兩個entry的關聯性往往就是會對在一起嘛對不對所以這邊你有a. txt那邊當然也應該會有一個a.

txt檔案那裡面存的資料有什麼不同類所以相對於剛剛說這邊是per process的，它只跟這一個process有關，會有所差異的information，那system-wide當然指的就是那些無關independent的，那什麼是independent咧，所以稍微想一想可以看到不少蠻多的例子對，不對比如說，這個檔案的disk的location我們需要disk的location我們才能夠知道我們去寫一個byte的時候

到底寫到disk上的什麼位置啊，对不對，那畢竟這個file只有一個，不管多少人打開他的content都是一樣的，才對，所以當然只有一個位置，那像這樣子independent information就會存在system外的這個table裡面，還有包括像是access data啊,file size啊，对不对，因為這是單一一個file嘛，所以就算你有很多的process同時去打開A。 txt他們看到的這部分的信息當然是相同的，那麼就可以分出來哪一些就知道哪一些信息應該存在open file table哪些應該存在system-wide的open file table裡面，

那為什麼要這樣子切，如果你稍微想一下為什麼我們不乾脆就把這些Information全部都也都存在每一個Process自己的Open File Table裡面，最主要這是一種Design Decision或者Implementation的考量了對不對，因為資料如果你說在這邊同樣的資料，你把它Duplicate的去做Maintenance的話，實在系統設計的角度是非常危險的事情，因為它應該是一份你確保它做duplication就是copy在很多地方，那麼這些資料是有可能被修改的對不對，

像是filesize如果有一個process對它做了去write的動作，把它content變得更長，那這filesize的informant就會修改，那修改之後，如果你有copy兩份，那怎麼樣確保這資料的一致性就是一件非常囉唆的事情也是我們之前有提過的data consistency對不對，所以如果資料其實它本來就應該是只有一份的話，就是只有一個大家看到的就應

該是相同的資料的話，最好就是不要對它做copy，那如果copy的話，你就要去解決data consistent的issue，那通常是比較麻煩的尤其在這個case很自然的我們可以看到就是會用一個system的這個open file table去maintain這些independent大家看到都應該一樣的資料，那其他會變動的根據自己process會有所不同的當然就是各自去做儲存跟管理這樣會比較efficient實作起來跟運作起來，所以其實是用這兩個data的structure去maintain這個file的操作的，那這兩個table我們就

先簡介於使用者的角度啦，我們下個章節再講Fileset的一些運作會再提及到底怎麼去用它們來操作這個File另外一個就是我們提到的File就有很多的Attribute對不對，所以這些Attribute就是我們剛剛看到的Dependent上它到底是跟Process有關係的。 CESS有關或無關的當這個File被打開之後它就會漏到不同的Table裡面去了

那這邊要稍微提醒大家一點只是這個一點是這些attribute裡面有一個大家其實很熟悉的叫做file type對不對就是我們知道的副檔名那只是要確保大家有一個正確的觀念就是副檔名雖然說每個檔都有副檔名可是副檔名在整個系統運作來講其實它沒有實質的意義尤其對OS而言它其實只是一個hint而已

也就是像我們知道的當一個檔案比如說我們點兩下要去它執行的時候那我們作業系統怎麼知道用哪一個應用程式去執行它呢因為不同檔案不同應用程式嘛所以副檔名的目的其實就只是一個Hint所以看了副檔名我們的作業系統就知道就會先猜先嘗試用那個對應到的應用程式去打開其實只是這樣子而已

所以副檔名它其實OSN它就只是一個Hint而已那所以在尤其像在Linux或是一些這種自己可以控管比較多的你就會發現很多時候檔案可能就沒有副檔名這其實是無所謂的然後這些副檔名其實都是有意義的就是一方面讓人我們自己也好分辨那對於系統一樣他就會知道他到底是什麼樣類型的一個檔案好

好那接下來呢我們就來介紹一下一個file到底有哪一些access的方式所以我想什麼是file大家都還算蠻清楚的那怎麼去access大家也一定會覺得我都是打開 Word Editor 啦或者是我就寫個 Fopen之前的一些小的這些操作讀寫檔案的時候用到的一些 API 對不對嗎？那在這裡來講的話以檔案我們會比較回歸

到它其實整個檔案的 access可以大的比較大的就分成三大類型其他大概都只是一些 variation那第一個最主要的就叫做 sequential access所以檔案它其實就是一個 bytes Array of bytes 而已所以當然第一種 access 方式我們稱之為就叫做 sequential access 的方法那所謂 Sequential Assets顧名思義意思就是說對於這個檔案我在讀的時候我必須要是連續的對不對所以既然它是連續的所以你在設計一個這樣 Assets方式的 API的角度你就知道你需要的東西其實就是一個 Current Precision對不對

然後接下來就是Read就是你的動作其實它就是自然而然就是從這個位置開始接續下去你後面去call read 跟 write 的時候你不需要給我任何的 position 的 information你只需要告訴我你要 rewrite 的長度對不對因為它畢竟是 sequential 對不對那另外一點呢就是這個 position每一次讀完當然它就會隨著你讀的位置就開始移動對不對所以你讀四個 by這個 position implicit 就是你沒有在 code 裡面寫可是其實去負責 access 這個檔案的檔案系統

或是這個Library它就會把這個Position做移動的這個動作那當然你讀寫它就是一直往後移動所以當你今天要到其他的位置的時候呢你就必須要去做Reset對不對或者說是Rewind就是你去移動這個Position either是把它Reset到0或者是把它Rewind到某一個指定的位置所以當你在操作一個file在call API你再去使用一個file的access的時候如果你發現你是follow這樣子的一個pattern這樣的一個方式在使用的話就代表你在做sequential access的method了對吧

因為它就是連續的做讀寫的動作所以這個其實大家是應該是滿熟悉的還記得我們在C的library裡面的fopen fread fwrite 對不對這些都是屬於Sequential Access的method所以為什麼會File System所以如果你想一下為什麼檔案系統會選擇用Sequential Access因為我們下一章就會提到File大部分存在硬碟硬碟它Sequential Read Write rite的Performance會遠快於Random Access因為有磁鐵頭在那邊轉動的這個Overhead浪費時間的事情對不對

所以檔案通常我們就是希望它是連續的去做讀寫所以自然我們在實作一個add methods的method給一個file的時候我們當然會prefer讓使用者用這樣的方式去做programming因為也比較符合下面儲存的資料擺放的位置然後programming起來你就會比較符合它的使用情境就是一個檔案從頭讀到尾這樣子的動作好所以這就是所謂的Sequential Access Method記得這邊則是Access Method就是說

你怎麼去讀或者寫一個檔案那是用這樣的一個API就是Sequential去操作好那有Sequential所以另外一種就是我們俗稱的Direct Access或者是就是所謂的random access所以像這類型就是當你要讀寫檔案的時候你希望是用跳著的方式那就是俗稱的這種direct access直接告訴我們的下面的檔案系統你到底要讀檔案的什麼位置的資料這樣的一個方式所以這樣的

方式你會看他的API的話你就一定會發現你必須要告訴他他的position對不對你一定要告訴他的position到底是在什麼位置然後指定好之後，你在call你的RE跟RI的時候，你就必須要有塞這個parameter argument進去這種時候通常就代表你在做random access，因為你不給一個位置事實上支持這個file access的library也不知道到底要讀哪，因為可以是arbitrary所以就是所謂的這種direct access那

這個Access的方式看似好像比較Powerful，因為你Direct嘛，所以我一個API我就可以指定讀任何一個位置對不對，我沒有受到像剛刚的限制可是為什麼我們還是會有Sequential Access的API跑出來呢，因为你簡單的看一下這兩個實際上的應用的情境就可以發現它各有各的好處也就是說今天使用者如果他在讀檔案

的時候本來他就是有Sequential Access的Behavior這種行為比如說就是想要檔案從頭掃到尾把這個檔案裡面每一個Record把它讀出來我不care它的順序我就是從頭讀到尾那如果今天你用Sequential Access的API其實很簡單大家知道就是Reset之後Read Read Read或是Write對不對你就一直call你的動作自然就會把整個檔案寫完但是呢

如果你用Direct AccessMethod的API去做同樣的事情當然都做得到因為它更flexible，但是你會發現扣變的比較不直覺了。你每一次在做讀寫之前，你要自己去increase這個position的counter，然後再去做一次read，所以變成是使用者自己要去操控這個讀寫位置的這件事情。那以API的角度，使用的角度當然就是一種其實不方便的一種動作了對不對。

所以為什麼會有這兩個API，就是因為depend on你的使用的需求的行為對不對。你就是自然有一些是sequentially的讀file有的時候，你是有ordering你是要去特定的位置讀的那你就應該用不同的API的方式或者說，這個下面提供這個Access方式的他就要定義不同的API給你。那我們提過File System大部分你發現的都是這種

Sequential Access因為檔案的特性就是這樣，所以這是俗稱的Direct Access通常就是為了要SupportRandom Access這件事情。這個Random Assets或Direct Assets的另外一種變形就是俗稱的Indexed Assets，這倒不用退一倍只要大家知道concept就好對不對。所以跟剛剛的這個Random Assets或Direct Assets或Direct Ass ets的差別在於Direct Assets指的是問題就是看你的應用啦像這邊這個Indexed Assets就跟Random Assets其實是類似的我剛才講了這個話Indexed Assets就像Beta Base

所以像database你會找資料的時候我們只會說我要jump the number所以我希望是我不知道這個資料存在哪那我希望但是我只要某一個人然後我用jump這個當作我identify然後去找一個資料所以在很多的第一個在很多在database在你去做data的search的動作的時候你就不希望用sequential access你希望random access因為我希望很快的方式我知道我要是哪一個資料

它出來哪個位置然後我要很快我要直接把那筆資料把它拉出來那這種時候你就會需要用到Random Access然後通常這種例子通常更進一步大家其實是用Index就是像Beta Base這樣我可能不會很清楚它到底在第幾行可是我知道像這個Identifier這個Name那這種時候我們就會用到甚至於是Index那Index當然它是一種Random Access所以像Random Access通常又會再包一層

變成index的這種access那這就很常見了，大家想beta base還有很多資料的讀取對不對有record的這種性質的有data的structure這種性質的資料我們大概都是會用random access的方式好，所以看應用所以我們剛才說檔案它是sequential，因為檔案就是通常是沒有structure通常我們就是從頭讀到尾，但是你可以想到當我們的資料

存得的內容形態越來越複雜的時候，你都可以internally有一些structure有這些record概念的時候，它仍然是一個檔案啊，對不對可是你讀取的方式應用就不太一樣，那你就會用到random s的時候好，然後random s就我們剛才提到的那如果你要找的通常更多時候，就是透過一個指定的另外一個identify那通常就是所謂的index，所以差別就是

在 render as 上面呢，你會再建一個 table 對不對，然後去做 mapping所以這個 John 或者是 Smith或者是 Adams，他到底對到的是哪一個 position，他去幫你做這個 mapping 的動作，那這就是俗稱的這種所謂 indexed access，但是 database 就常常會看見好， 可以嗎，所以 不同類型的這種 access所以這邊指的是檔案嘛，所以檔案系統當然比較多是Sequential但是檔案

也包括了Database，實它也是一種檔案資料啊，对不对，那它當然是設計會很不同那另外一點我們提過Physical的Device就像Disk啦，不太喜歡Random Access所以如果你要Support Random Access的話，你上面那一層Data Managed Layer，如果要Support Random Access通常一定會有Memory Cache，才會夠快對不对，所以就讓我們知道像Database的設計跟Fileset的設計就會蠻不同因為Database需要去SupportRandom Access等等的特性，那一種常見的就是你會把資料一定要

盡量的把它Keep在Memory、Memory Random Access才會快那因此它就需求需要Random Access那它透過Memory的方式去加速硬碟的Access然後去support這樣的一個API好可以齁好，所以這邊就是稍微大家留意一下就是說其實file access有不同的方式那看你的應用情境你應該去support這個file access的這個library他就要去選擇比較適合的access的方式然後另外一點呢，那是對上適合使用者減少Programming的一些effort對下就是我們剛才提到的，你要怎麼樣子讓這樣子

的一個Access Pattern在你的Physical Storage的Device上可以很快的Efficient的去做Access，這是另外一個問題，那所以當你的Access Pattern跟你下面Storage Device它的特性不同的時候，像我們在Disk上做Render Access，怎麼辦？那就是要support這個access的那個library或是那一層management的software，他要去想的辦法就要去解決的問題了好，那這個問題其實問得很好，因為你們作業的時候就會發現，就算是file system我們知道是sequential，但是也會有不同的始作方式，那其實他也就是在考量有些始作方式適合

比較sequentially讀file的動作，些是比較適合random一點的，然後有些適合檔案去做truncate或者是concatenate的動作，一些是比較適合是固定大小的這個系統的方式，所以不同的access method當然你下面的實作方式的選擇也會不太一樣好，不過這邊先從使用角度就是先建立一個觀念，知道有所謂的sequential跟random access兩種不同的使用的方式好.