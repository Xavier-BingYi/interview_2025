undefined
那接下來我們就直接進入到這個 File System 的第二個 Part就是 File System 實際上內部所以我們現在不管使用者就是 File System 我們再去 Implement或是 Design 的 File System 的時候一些一樣基本的 File System 的整個它的 System 的 Structure還有它怎麼樣子去管理這些檔案的方式的這些設計上面的問題尤其最重要的你們會需要知道就是這個 Disk Allocation Method所以作業系統或是系統的角度就是在管理就是在管理各式各樣的資源所以 File System 這邊它在管理什麼資源

就是儲存的資源嘛也就是我們的Disk的儲存空間的問題所以我們一個檔案一個Gigabyte那我到底要怎麼樣擺到硬碟的哪邊的位置我才能這一個Gigabyte我要先把它切割嗎我要把它一次連續的放嗎如果把它切割我又怎麼知道到底被切到放到哪些地方這個就是在做 Disk Allocation所以這一塊就是最主要在的機制的部分管理的機制那這塊呢也就是各位的最後一個作業了要去 implement

一個 file system 的地方要改寫的就是這一塊我到底要怎麼樣去管理把一個檔案map 到 physical device 的位置的這個問題那首先這個我們提過File System其實最主要它就是在做這個Mapping跟把資料把它放到Physical的Storage Device上的一個問題尤其我們通常這邊講的就是Disk啦因為其他當然類似但是情況當然不太一樣那現在主流當然還是Hard Drive這件事情那所以呢File System這邊它在做讀寫就是對下層的這個IO Device或者Storage Device在讀寫的時候

其實它是會有一個最小的單位因為軟體這邊再怎麼走或者說File System這邊它最後再怎麼樣manage它也會有一個最小的unit那那個unit我們通常稱之為block就是data block那這個就是它最小最小的單位但是我們剛才也稍微講到前一章也講到了這個storage physical的storage device這邊它的storage的單位以Hard Drive來講最小的其實是sector所以sector跟block並沒有說一定要對在一起所以當然有可能它剛好一樣但通常也有可能是它的一個倍數沒有說一定要

exactly一樣所以一個block其實是有可能會成為多個sector的所以通常一個sector就是512 byte那一個block有可能是到就是一個kb甚至於到4個kb都有可能但是不可能小於sector因為sector 是 physically 最小的單位了對不對所以當然 logical 只能在它的上面而已好所以這是第一點要意識到的我們這個章節會提到的只有 block但是 block 並不會直接對到 sector其實當然還會再做一層轉換所以這個 mapping 並沒有一定要一對一的事情但是 function

管到最後最後它只能 touch 到的就是一 block 為單位好那另外一點就是File System對於整個作業系統而言其實我們知道一個檔案一個作業系統其實不一定只能夠有一個File System對不對很多時候我們這作業系統裡面的整個Directory它所使用的File System可能是多個的尤其是當我們有不同Variant的時候C槽 D槽我們其實可以把它Format成不同的檔案系統做管理這是可以的

那當然作業系統要跟他配合所以有一些檔案格式不捨破這也常發生對不對所以其實會有很多的file system這是比較傳統像FAT32 NTFS大家去看一下應該可以查到非常多其他的像Mac這邊有他自己的file system那我們其實會講到一些像是FAT32我們後面會稍微講一下他是怎麼樣子管理檔案的那不同的檔案系統最大差別

就在於它的Disk Allocation的方式會不同還有它去Search它這些File 的 Structure的這些Implementation的差異了所以是他們的實作上管理資源的這個方式的差異就會有不同的檔案系統當然它只有使用介面不知道都一樣就是File 嗎然後可以捨破Sequential 的 Rewrite基本上就是這樣好那所以我們剛才提到這個 file system 的設計就是它是對上而言就是它的 interface 有點像我們剛才看見的那所有檔案系統我相信現在 Moreland 的 file system 都有 grid 就是長那樣子你看到的剛剛的 API 還有那些 operation 有 directory

等等的基本概念那個就是我們常見的 file system全部應該都是一樣的那差別就是下面 對下面來講你要去對Disk的管理這邊大家的做法就會有差異所以不同的File System你 Format之後為什麼要Format格式整個把它資料可能要全部都要清掉一次一定會這樣子因為整個管理方式整個大家刷取的不同嘛所以不可能這個互相的去使用的所以就必須要整個格式化了好那檔案系統這邊勒

它其實檔案系統最主要的角色就是在做Mapping 對不對就是今天我們FileSense提供了一個API，那我們知道FileSense的話都是提供Sequential Access Method，就是你有FileHandle的Buffer對不對，然後Size然後就這樣子去讀寫這樣的IO那最後的目的就是要把這個Information對到Physical的這些DevicesStore Devices上的一塊空間，然後把資料從Memory Eventually寫到正確的Story Device的位

置，這個就是FileSense在做的。所以看起來好像很單純，它就是在做Mapping只是說我們把Memory的一個位置，把它對到最後Eventually是你一個這個Disk上面的一個位置，然後當然你要去有Driver去下指令操作這一個Story Device的IO Controller。我們前面有稍微介紹一下，我們最後的IO System的章節會再介紹就是你會透過IO Control上的register嘛對

不對。最後eventually就是把一個一個byte搬過去然後寫上寫到這個Story Device上面那中間其實光是mapping可是其實會發生很多不同layer的mapping這個是一般而言現在File System的設計都是這個樣子會不同的，這個layer就是它的File System，它整個系統的架構就是會把它切成很多的Layer，然後每一個Layer可以比較Modulize，然後比較清楚自己該做的任務是什麼，那第一個

Layer我們俗稱的就叫做Logical的File System，所以它就是File System，但是它是Logical，所以它就是最接近使用者它是把整個檔案呈現給使用者的那一個Layer，所以它決定了那個Logical的長相，那個View到底是什麼樣子，所以就像我們剛才看見的，現在，如果你是檔案系統的話，就是會用這種Sequential Access的API，所以它就會定義這些API，然後去Resolve其中這個Permission的部分，所以剛才的ACL對不對，那個就是屬於Logical File System Layer要做的事情，它只要目的就是要找到這個File，把它Open出來，然後有API

的這個方式提供出去Access的時候去管理這個到底這個Access是有效無效的，這樣的一個任務就是俗稱的Logical File System，所以如果今天你要改什麼ACL的Control這些機制對不對，你其實只要改Logical File System就好你要改它的API，你要增加新的method，那都是在logical access這邊要做的事情好那第二塊咧就是在mapping這邊的最主要就開始做mapping那這邊的mapping咧第一個部分咧就是從你的logical的這個address或者說這個location啊file access position把它轉換到一個physical的位置也就是第幾個block這件事情

那這個就是所謂的FileOrganization的Module就是再進一層所以你現在可以開始Access了那我要Access做Management第一件事情就是把Logical什麼叫Logical就是你有FileHandler所以你有File你知道A. txt然後我知道我要A。 txt的目前的這個Position然後要給它做Rewrite多少Size對不對所以那是Logical的Information那我要對到的就是請問它到底是存在哪一個data block裡面去那就是physical了所以file organization就在做這件事情

所以各位的作業室最主要就是在其實寫的override是在這一層裡面的機制所以我到底要切成多少個block然後這些block到底要放在physical的什麼位置我今天給你一個File的Handler 我已經知道是某一個File了知道它是哪一個Identifier了那我到底怎麼知道它對應的Block到底第三個 第一百個P

osition第一百個Byte的位置到底在第幾個Block裡面那就是FileOrganization在做的事情好 那知道了它是在哪一個Block裡面之後那我實際上我就要對到的是剛剛如果是Disk 對不對我就要知道這個disc的這個block我知道是放在某一個sector上面那到底是哪一個所以如果是hard drive你就要告訴我是

哪一個disc首先因為可能一個partition我要知道是哪一個partition甚至於這個partition是跨兩個disc都有可能然後它是在哪一個cylinder就是在哪一個plate哪一個磁盤上哪一個trap哪一個sector number開始是這個block的其實位置所以就是把它轉換成實際上的這個physical的位置的mapping所以就是從block map到

下面這個physical layer的layout這個呢就是basic file system所以這一塊你可以想見通常大家也不會去碰它對不對一般設計來講這邊呢是也通常也很少碰因為file system大家都有一致的interface了對不對然後這裡呢只要是hard drive那就是這個樣子或許你今天有一個新的IO Device新的Storage Device出來的話你可能就要把Basic File System的Mapping把它重寫但是如果你是就是Hard Drive那不管是什麼

File System這一塊也不用重寫那只有這一塊就是現在大部分一般File System最大的差異就在這邊也就是怎麼去分配Disk的資源也是由這邊File的Organization來做Control好那最後到外面了對不對所以到這邊為止我們就是俗稱的File System其實就是包括了這三個Layer那這個外面這邊你要做Rewrite這就是Driver啦對啊就會沒有啦所以這就會被需要去D換掉了對對對對對

這一塊來講就是他要support不同的storage system那當然driver也要換然後這邊有部分的部分有部分你就要去做extend或者把它就override掉因為這他的定義嘛到最後是到了就是這個physical的位置這件事情那你有了位置你要真的開始做操作re-ride operation對不對這些東西IO所謂俗稱的IOInput Output Operation的話

你就會需要Driver去執行這些動作了那那個就是Driver那是Outside File System我們知道的就只是你要Install這個Device的Driver然後讓他File System可以去下指令開始寫到他要的位置這樣子好 可以嗎所以File System大概就是其實你把它細分就是稍微切的話它的Structure就是這樣子那每一層其實看見它的

角色是很不一樣的這邊右邊這幾個我覺得沒有必要去印去記它什麼Logic File SystemBasic File System但是其實你可以知道一個File System的設計就是分成這三個Layer是最主要它的實作上面設計上的考量那是完全不同目的的所以就會知道今天你要修改的部分其實是在哪一個Layer

那File System另外一件事情就是我們剛才提到的它其實我們的應該不說File System而已而是以整個OS的角度來講其實很重要的一件事情它是要能夠SupportMultiple的File System而且要Multiple的Storage Device因為一般的系統你都很常見看到這樣子的一個設定所以怎麼做我們後面會稍微提一下，

但是基本上你看它整個架構圖應該會變成像這樣，這一塊就我們剛才介紹的這個不用特別解釋這是縮寫而已啦表示的就是一個File System，但是我們整個作業系統的角度來講咧就是我們對於使用者而言他希望看到的是只有一個File System的Manager，因為我們今天寫Code，我們去Code zLibrary fopen就是Assuming只有一個File System存在嘛，我們也只看到一個Directory啊所以其實應該是一個File System而已可是事實上咧我們知道因為不同的Partition你去把它Format成不同的Volume的時候你可以

用不同的File System那邊可能是UNIX File System這邊是NTFS對不對所以它可能是不同的File System可是對於使用者他不需要看見這件事情所以它其實中間是需要一層Interface一個Layer去做Obstraction就是其實就是個Interface啦那你可以把它Depends on你的檔案到底是放在哪一個Hard Drive上對不对然後這個Hard Drive這個Partition是由哪一個File System

把它做Formatting的來去執行那個動作所以你會看見的就是前面必須要一個Interface然後它可以變成不同的File System那這個File System對到的就是你去存這個File的這個Physical的Device那 Dependent它是什麼File System的管理其實都應該是可以去使用的那另外就是同一個File System當然它也可能去使用到不同的Disk對不對那這件事情

其實就是透過Driver而已啦那這File System就不需要特別去做什麼基本上你有不同的Driver就代表你同樣的程式同樣執行的那個Block最後你要去執行它的IO的動作的時候你可以透過Driver然後把它讀寫到不同的Device上面去所以下面其實是透過Driver那上面我們就會介紹就是會有一個叫做Virtual File System的Interface很

簡單的一層很薄的一層Interface在上面當作一個Unified File System的Interface然後在Dependence上面檔案到底是由哪一個檔案系統管理他把它給去Code不同的File System Code就對了好所以就是我們常見到的其實是可以有這樣子很多選擇的一個做法好 我們還有一點時間把這幾個structure介紹完essoite接下來我們就要開始講一些file system它剛剛要去implement這個mapping或者說在做IO的這個動作的時候它所需要的data structure到底是哪一些

所以data的structure我們又會分成第一種 第一類叫做on-disk的structure也就是說這些structure全部必須要存在disk上面因為它必須要永久存在因為我們知道檔案是永久存在的所以永久存在的這些data structure第一個就叫做boot control block就是開機嘛 顧名思義 對不對所以如果今天這個partition它是拿來做開機用的系統槽的話那麼這個partition前面的那些空間我先把它reserve下來就是俗稱的boot這個boot的control block那裡面我們當然不會講detail但是你可以

想像裡面就是存那些你要需要開機用到的code還有data就對了所以就是把它變成一個可開機的partition那接下來勒對於這是一個disk嘛所以它這是一個hard drive所以這個Hard Drive上面我們說過它可以切好幾個Partition對不對所以今天你這個Hard Drive上面它如果成為一個Partition的話，那它就會有一個Partition的Control Block，所以

這個這個Disk上面，它放了這個裡面，就是去告訴我們說，這個Hard Drive上面，到底有多少Block，它有多少空間等等就是這個Partition。所以當我們當作詞區分割的時候，在做什麼勒，就是第一個當然切位置嘛對不對切完之後就要去create這一個partition control block，所以讓我們的OS可以透過這個control block知道怎麼去access這一個partition裡面的content。然後呢，如果你partition完之後，你對它做formatting，讓它變成一個file system，那這個時候呢，你當然就會需要file的control block還有另外一個，就是directory

對不對所以這是我們之前看見的就是你建了一個files之後去管理這個partition，讓它成為Value的條件就是你會去存通常會先存directed structure然後存完之後再去存剩下的空間就是全部來放這些file的block然後就看你怎麼放，就是我們說你有不同的資源分配的方式所以這就是Disk上面就是一個partition，你會看見它

放資料前一定會有這幾個部分就是會有f ile的control block然後最後才是file的content的部分我們今天很整角的所以這就是整個view啦所以這個就是一般而言一個partition你會看見的就是長這樣那第一個是optional因為不是每個都會拿來做開機嘛有開機的就是boot的時候他會註冊所以他會去search他那你沒有不能開機的他就ignore這個file system然後這邊是control block之後就是data block才是真正放資料的部分最後一個那control block裡面存的就是這個attribute所以就跟process control block一樣file control block存的就是一些file permission這些attribute然後就會漏到

Disk Allocation 演算法.