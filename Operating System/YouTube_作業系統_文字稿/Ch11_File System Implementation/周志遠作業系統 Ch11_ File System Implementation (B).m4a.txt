undefined
那今天要教的部分還蠻重要的因為就是教講這個 File System 實作的部分比如說實作應該說就在實作過程中最主要要去考量的設計還有它整個運作方法的部分那當然這也是你們作業室要寫這個檔案系統這一塊的時候怎麼樣去管理你的這個檔案在硬碟上擺放的部分也是在這邊會教的

部分好那要管理對啊一樣這個檔案系統要來管理檔案的話第一個當然他一樣要去maintain一些非常重要的structure information才有辦法知道怎麼去manage這些storage的space還有檔案還有資料夾甚至於還有Variant就是磁區的這些概念那在檔案這邊很重要跟其他的Structure很不一樣的地方就在於檔案是我們說過是Persistent永久存在的它不能遺失的所以這個Structure並不是只是在Memory的Structure我們談的Structure事實上要先從OnDisk的Structure談起也就是哪些Structure必須要存在硬碟上面

那我就提到這幾個很重要的這個structure第一個就是booting的使用的這個boot control block所以就是如果你需要用這一個partition這個variant來上面的作業系統load上面的作業系統來開機的話，那麼在這一個partition的前面就要先reset空間叫做所謂的boot control block那裡面就存著所有我們說過要booting所使用的這些information好那所以最起

碼可以想見，就譬如說他會知道到底你的這個要booting的這個file system它的位置在哪它的OS一開始你總是要去load的一些default的code甚至不用透過file system就要把那些code給load到我們的這個model board上面memory上面CPU上面然後開始運作對不對因為file system你要漏了整個漏起來可能就要花非常非常大的effort那所以

它可能有一些code甚至於像是hardcode一樣直接可以漏進去然後就開始booting了這些information就會存在這個boot control block裡面所以它不只是information甚至於有到一些instruction booting要用的這種最基本的instruction然後慢慢慢慢的讓我們的系統整個boot up起來那再來勒他就要開始去如果這個你的這個partition他被切完了嘛所以他必須要

知道這個這整個硬碟對不對所以他的這個partition到底是在從哪邊到哪一塊區塊對不對他的range到底在哪裡他到底有多少的space那這些information呢就會放在這個partition的control block裡面了那所以讓我們這個OSboot起來之後它可以知道說這個partition到底是範圍在哪裡這個硬碟到底有幾個partition好那在一個partition有了partitioning format之後那接下來

你可能就知道這是一個是一個filesign在管理的partition對不對所以那就知道它到底有哪些file對不對那這邊file指的是Control Block喔所以不是File Content稍微注意一下是File的Control Block所以只是在存我們說過存File的Meta Data的那一個Block而已所以它只是要知道你的File的譬如說Location真的

存在的Location到底在哪裡那個Content的部分還有像是File的Size啊Name啊等等的這是存在File Control Block所以你當然會有非常多因為每個File都會有一個就像每個process有個process control block那f ile就是file control block，那我們也講過除了file之外為了要管理這些file我們就directory嘛，所以當然也會有directory的structure去描述那顆tree或者說acidic graph的那些information，那這樣子就組成了一個在on this上面必須要存的這些structure所以你就會知道這是numbooting然後這是一個partition然後這個partition被formatted之後

它有哪些的Directory還有File的存在所以你切完Partition的時候，所以可以看見當你切完Partition的時候你就會Create這個Partition Control Block，但如果你沒有對它Formatting的話，那這兩個就不存在它就是一個Role Partition，但是如果你Format了然後你說你要拿一種File System對不對，那個File System在Format就是在建置這個File Control Block啊Directory Structure啊這些基本的Information然後就可以

才開始把你的資料放進他的空間裡面然後你create file之後當然就會去修改這裡面的content對不對或是新增然後開始去access那這些全部都是on disk喔所以意思就是他們即使關鍵都會留著或者是你可以想今天當你做了修改之後也eventually你必須要寫回到on disk的structure裡面這樣子才不會遺失好 所以就上次提到的，所以如果你看一個Partition它整個Layout就是像這樣子

然後存完這些File Control Blocks之後這裡才是所謂的Data Blocks就是這裡才是真正存你的File的Content的部分那我們之後就會看見你就是這都是可以使用的空間所以你可以任意的去擺放但是你當然要把擺放的位置要記在File Control Blocks裡面所以你可以找得到它到底在哪裡所以File Control Blocks裡面就是我們說那些Meta Data那更重要的其實就是這個

FileData的Blocks的Location也就是你們作業室要去寫的那一塊其實就是在決定到底要怎麼擺的這個部分要記錄哪些Information用什麼方式記錄好那剛剛是OnDisk的所以咧當整個這個File System被漏的起來或是你開始去Access這個Directory或是這個Volume或這個File的時候你就開始就要把那些Information漏到Memory然後我們的OS或File System才可以開始

去處理嘛對不對所以會漏進Memory的structure勒你可以看見也是相對應的其實是相對應的當然就會都有對不對除了booting因為booting就是只是forbooting而已所以boot control block是不會需要漏到Memory的那只有某些information會keep住啦但主要會當你在操作這個file system的時候它要漏到Memory的structure第一個就是 partition 的 table這還是要的因為他要知道對不對你有沒有 mount所以當我們說你在 mount 一個這個partition 的時候或是一個 volume

的時候他會做什麼事呢其實就是把這個partition table把他 load 到 memory 裡面去所以我們的 OS 就知道這個 partition 長什麼樣子然後就可以直接開始對不對對他做操作所以 mount 其實最主要就是把這個partition table把他 load 到我們的 memory 裡面去好 所以你Mount完之後你就開始Triverse它嘛對不對要去使用它所以你當

然就會需要露你的這個 Directory的部分所以就是這個 Directory 的 Structure那可以注意到它只是 Recently Access對不對或是說其實就是Part你不需要整個露進來的因為檔案系統當然都很大對不對所以說 Memory有限嘛所以你不可能不需要所以主要是你也不需要露的全部因為大部分的使用情境我們都知道你只是在使用某些資料夾或檔案

所以你把它整個都漏進來是很沒有效率的事情很浪費 memory 的事情所以這個 directly 會漏進來但是跟 on this 的差別在於in memory 的 structure 它就只是漏的 entry 而已就是你要的那些部分那當然比較合理你可以想見就是 most recently used 的對不對或者是如果你以 tree structure 來講對不對就是你可能會先 preload 下一個 level 之類的所以就是只會漏的部分這樣才可以加速你的 access 嘛因為讀檔案

我們知道最好就是一次多漏一點比你慢慢一次一次分批讀的漏的會要好一點因為你可以Sequentially一次多一點把它漏出來比較Efficient好那再來就是我們提過的了所以當你找到你的File你要打開它開始對它真的操作某一個等級的File的時候你會需要漏的就是 System-wide Open File Table對不對，那其實這個就是File Control Block，

所以我們說這個table裡面到底是什麼info呢，就是file control block，因為file control block跟使用者是無關，它只跟file有關，所以其實就是把這整個block漏到memory裡面去，這個file的整個block漏到我們的open file table裡面，所以裡面其實存的就是file control block了然後我們也講過根據不同的使用者，所以你打開file之後你的操作上，你必須要記錄一些state，只跟這個process操作有關的，

就像你的handle到底是什麼對不對你的position對不對你的permission到底是你open by write還是read這些information就會存在我們說的per process的open file table了，所以這個就是process打開的時候根據這process的行為去create的信息，所以這個當然就不存在disk上，因為這個跟file就沒有直接的關聯性，而是操作file的過程中產生需要的資訊，所以

就是扣過這四個最主要的這些Structure把它存在Memory裡面我們就可以開始操作這個File了好，所以剛才這幾個Structure如果記住了，尤其是要區分這個OnDisk跟InMemory喔，因為它們畢竟是不一樣的對不對所以有在Memory的Structure有在Disk上的Structure。我們就go through幾個例子常見的Open啊Rewrite啊或者是Create等下有Create，看這整個過程中這

些structure的運作到底順序是什麼，所以我們就從open開始看起對不对。所以我們要open一個file，它會發生的事情是什麼呢。如果知道剛才每個structure的目的，實你就知道第一件事情當然這個你要open的這個file的位置它已經是已經是被mount好的，所以我們就直接從root的這個 Directly 開始 Traverse 對不对去找到是通過這個 File Path

去找說這個 File 到底存不存在。所以你會看見第一個動作當然就是去 Directly 的 Structure，尤其從 Root 的那一個 Partition 的 Direct Structure開始做 Traversing 對不对。那因為我們說過 Directly Structure，它並不會一次全部漏進來啊，所以其實在 Traverse 的過程中如果它沒有漏到 Memory 怎麼辦它會去 Load 的所以就看那個部分的那個Volume是由哪一個File System

管放的在哪一個Partition上他就去那邊去Load他的Directed Structure進來然後可以一直Trivial的下去那所以你會看見的過程其實是先去Memory看但是找不到的時候他會去Secondary也就是On this Structure那邊把剩下的部分依序的再把它Load進來然後繼續做Trivial的動作直到他找到那找到之後我

們說過DeRapid最後指到的東西是什麼勒其實就是File Control Block所以我們說DeRapid他指到File到底指到什麼File其實指到的是File Control Block因為指到File Control Block的時候你就知道這個File說的資訊了對不對還有他的位置等等所以Open其實就是去找到他的File Control Block然後把他的OnDisk的這個File Control Block Structure漏到我們的Open File Table裡面去

所以漏到Memory裡面去然後就完成了一個Open File的動作然後再根據這個Process的Permission等等把Per Process的那個Open File Table裡面的資訊把它填起來你就完成了File Open的動作所以這其實就是它的流程最主要就是要找到File Control Block然後把它漏到Memory裡面去這就是Open File真的要做的事情就是這個事情好

然後呢接下來我們看見的就是 read 跟 write 對不對所以假設你把它 file 已經 open 了那你就會看見我們這邊看我們說的對不對你就會有兩你的 open file table 其實就是有兩層嘛對不對所以這是 file control block那這一個呢就是你的這一個 process 的一些 information所以當你要去做 read 啊或者 write 的時候當然第一個為什麼你用 file handler 對不對為什麼你的 code API 一定要有 file handler因為 file handler 指的就是這個 processopen file table 裡面的

pointer的entry所以他就知道這個file到底是不是有打開打開之後你有哪些permission對不對你當初的這個position到底在哪裡對不對所以他就可以拿到這些information了那如果有permission denied等等問題他這邊就會被regen回來了，好，那有了這些資訊之後確保這個file的確open了然後知道他現在你一個read那，所以從哪個位置開始讀之後你就要開始去找

他真正的位置了對不對？可是那些真正的位置當然是存在File Control Block裡頭而已所以他為什麼說這個per process的這個table他必須要知道這個System Wide的這個open table的entry在哪，因為他必須要去問他真正的位置，到底這個file content到底存在哪裡好，所以裡面呢就會有這些File Control Block Information，他就可以去Access或去找到裡面的Content然後從Disk的位置把它給露出來或是寫進去好！ 可以齁，那至於這邊我們一樣會寫一個這個File Control Block，這個只是說一樣嘛，

它是露的，所以如果真的Block很大也沒有說全部都要露的，我們之後就會看見當你的File真的很大的時候你的這個Location也可能用Linked List或是其他的Data Structure把它串起來，所以你不是也沒有必要一次把整個file block的所有的information都漏進來，因為有時候你的pointer真的太多了，它也是會散落在好幾個這是上面這個data block上面所以它也可能會是分批漏進來的好可以吧，不過這個就是Rewrite的流程就是先去preprocess這個perprocessed table然後去system-wide table然後去用file control block裡面的

location的information去知道到底讀寫位置physically在哪裡，所以完成那個mapping的動作好。那接下來這是create其實跟剛才就差不多這邊我們就是用寫的所以其實大家可以想見這些mega operation這些data structure的操作其實應該是可以知道它的順序的所以如果是create的話可以看當然第一個你就要control file control block因為那是最重要 create file就是在create file control block對不對以為一開始content是空的但是你還是要先create它的control block這個file才會存在

然後呢，這個Control Plot被Create之後當然你要把它放到某一個File Pass啊,對不對所以你要跟Directly做一個連結嘛也就是Directly的Structure必須要做一個Update，對不对那你去Create的那個位置，對不对因為你Create一個File你可以寫任何的File Pass，對不对跟你目前下指令的這個是無關，.對不對我可以隨便Create在某一個地方所以你要先去make sure他的那個file的pass是不是存在所以有時候大家知道create file你說create在某個地方他就說資料夾不存在無法create對不對為什麼

就是因為他要開始先去找這個位置到底存不存在所以在找的過程中一樣跟剛剛這個open是類似的所以你要去traverse這個directory如果他不在memory你就要從disk把它露出來直到你確定他真的存在了這個directory真的在那這時候你在那個Directory下面你要去create這一個filename對不對因為filename本身也是part of directory喔不要忘

記所以它必須要存在就是這個tree的leaf node一樣對不對所以你要去update這個directed structure把你這個filename把它加進去然後把它指到of course要把它指到file control block指到它對應到的這個這是一個file了然後它對到的是這個file control block的位置好那最后呢这边可以注意到这是Memory对不对因为你在Process在操作嘛所以当然

这只是在Memory里面可是必须要确保它不会遗失的话你就要写回到Disk对不对所以说才会Periodically的其实我们的File System可能就会把它Flush回Disk去或者是你关机了当然它就会把它全部Flush回去所以Eventually这个Update的Directory必须还有File Control Block這兩個必須要把它寫回到我們的disk那這樣子你下次開去它才會存在不然它就消失所以有時候我們說跳電哇你資料遺失有沒有

就是這樣為什麼因為其實你只是寫到in memory的structure而已你還沒有來不及寫回到disk去你就跳電了那它有時候資訊就會遺失掉那甚至於不只是像這種create file有時候你去rename對不对你知道做修改都是一樣道理它其實都只寫在Memory而已然後都只到一定的時間它才會把它Flush回Disk那所以就會常常你一個不正常的關機它會先Scan Disk就是這樣它會先看一下

會不會有些資訊不Match為什麼不Match因為它你整個過程可能是改了很多地方對不對可是它Flush回去它沒有它就是只是按順序它只會Flush到一半有可能對不对就很像我們之前在教這個Transaction的概念一樣應該是整個操作要完成可是你沒有真的這麼去保護它所以你可能只寫到某個部分它就沒了所以File System很多時候它會做Logging就是這樣我們也提過嘛跟這個我們之前講Recovery的時候

有稍微介紹過所以其實你這樣寫這邊是只說寫到這些In-Mem Structure其實很多File System你去看他們都會可以enablelogin 的動作就是他所寫到這他會寫 loglog 意思就是他把這些動作全部寫到 file 的一定會寫就是他直接寫到 disk 上一定要 guarantee 呢資訊真的寫到 disk 上然後如果這邊真的 crash 掉他會把 log 把它拿出來然後做 recovery像我們之前教過的提到過的部分好所以總之這是in-memory最後要寫到on-disk他才會真的保留下來

那這當然啦所以如果真的完成了對不對你就你去LS一看你就會看見這個結果所以那就代表它真的是把它給create出來了好那如果你在後面在 rewrite就像我們剛才講的它只是在加它的data block而已然後去updatefile控制 block的它的這個pointer的資訊好可以齁好那知道單一個File大概是怎麼運作之後所以我

們就提到說其實在整個系統裡面你不是只有一個File System對不對我們知道你去Mount不同的這個Variant的時候每個Variant它都可以由不同的File System管理。所以到底為什麼可以這樣子把它們全部接在一起咧？就像我們之前提到主要原因咧就是因為在整個File System的設計上，它前面會加一層Unified Interface，通常就叫做Virtual File System。

所以對於使用者而言，它其實並不是直接的對這些File System的這些API等等去做操作，而是透過這個Unified不會變的這個Interface，所以它其實只是一個Interface而已。所以大家都知道意思就是說其實不同的File System當我們要Mount進來接進來的時候當然它要對應的把它Implement出來，所以就可以做一個操作，那這最大的好

處就在於使用者他always就是透過相同的API在做Programming對不對，他不需要去管下面的File System的Implementation的部分。然後呢？就像我們剛剛提到的其實你在整個File System在Triversing的過程中，它實它是一個Tree嘛對不對，所以並不是說這整個Tree都是屬於某一個File System，而是我們知道Mount所以它其實是接來接去的那，所以你如果

去接到不同的File System其實也沒有關係，因為你還是一樣就是透過VFS的，所以File System之間或是整個系統在Triverse你的這個Directory的時候，它也是一樣透過這個VFS的Interface去使用其他File System的Information所以不會有問題，所以這個是必要的這樣才可以把所有的File System就是用一個相同的Interface去做一個操作好，那這個VFS的這

個概念如果你去看這個Linux的話或者說這個Linux的實作上來講這個VFS的實現呢，其實就是分成這四個這四個主要的Object或者應該說Class啦對不對，這四個Class所以嗎對應到的就是一樣的Again就是Directly還有File的概念就是我們剛才那些Structure的操作，所以最常聽到的就是inode，如果你去看file system的這些書啊或

是code你常常聽到inode inode inode，到底什麼是inode其實inode指的是就是一個individual file就是file control block啦，所以inode其實就是那個file control block，那它統稱就叫做inode所以這就是在VFS這一層，它定義的名字，那不同file system它就會去implement這個inode的操作的這些API還有裡面的這些detail然後呢，你會有所謂的這個file的object那file object，呢跟這個

兩個都是file差在哪就是我們剛才提到的這個是on this structure這個file control block這個file object只是你把它open之後，它的一個這個object而已所以就像是in memory這邊所使用的這一個一個Object，所以這兩個是不一樣的對不對因為這是漏到Memory之後的這個Object然後Super Block的Object指的就是這整個Entire的File System所以如果對到我們前面的話你去看這個就是那個Partition的那個Block裡面會存的資料就是這個Super Super Block的Object，所以它指的就是整個File System

然後最後有一個de-entry的Object子的就是Direct ory所以你就Volume然後Directory然後FileFile又分成只是在OnDisk這邊固定的這個File Control Block跟你把它Active露起來了開始對它操作的這個File Object基本上就分成這四個所以這就是一個操作整個File System你會用到的四個主要的這個Object好那所以有定義的這些當然就每一個Object每一個

Class它當然就是它的Method這就是我們說的Interface的部分然後就看你到底實作是什麼你就去看像Open對不對那它就會是在這個這個FileObject裡面它就要去Open一個File那它就會找到一個對應的Method那你就要去Implement它你要去Read對不對所以你要Read一個File你一定是從一個已經Open的Read對不对所以這個在FileObject下面

就會有一個Reader的API你就要去implement那implement好之後就可以對於上面的System Code而言它就是按照這個VFS開始去對File System下指令了好這是稍微提到就是我們之前提過的在稍微實作上的角度其實這些剛才看到的這些Object 裡面的始作最重要的兩個部分其實一個就是你怎麼樣去 maintain 你的 directory 的 structure因為 directory 我們說它很大嘛所以你要是 traversing你怎麼樣給你一個 file pass你可以很快的知道這個 pass

到底是存在還不存在所以當然就是你可以用比如說 link list 的方式把它整個 tree 串在一起對不對或者是你可能用一個 hash table 的方式所以你可以用 lookup 的方式大家可以想像一下你可以用不同的方式去 maintain 這個 directory 的這個structure information就會影響到你的 search time通常這是一個會影響蠻大的部分對於效能使用

者的效能感覺上影響很大的部分那另外一塊呢就是我們接下來要講最重要的就是你的 data block怎麼擺因為你的 rewrite 是 random 的 access還是 sequential 的 access跟你的擺法當然就有絕對的關係就是對於使用者看見這個 file system效能這一塊來講一個就是 Directly 底下到底是怎麼擺的這些 Entry另外一個就是你的 Data Blocker好所以這個大概就是我們第一個Part所以講完整個Flow System運作大概它的這個基本的流程.