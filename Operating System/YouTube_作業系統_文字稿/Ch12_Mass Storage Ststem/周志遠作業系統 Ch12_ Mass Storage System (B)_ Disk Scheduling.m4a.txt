undefined
好，那我們今天就會把12張的後面還有13張教完那其實大家這個13張的話大家會看見其實比較短啦，所以大概其實應該還好所以也有看到大家這個13章的部分基本上就會考到我們這個slice的前半段就對了好，那我們就接續上次的話我們上次提到Disk的scheduling最主要的目的當然就是要去改善你的這個硬碟的讀取的這個效能就是讀取資料的時間所以第一個就看到時間的部分

其實是由sick time rotation time還有read time三個加起來的那所以最主要這個disscheduling可以去減少時間的部分就是它的sick time的部分也就是這個毒蟹頭移動的部分因為毒蟹頭的移動它是機械式的，所以其實相對時間會比較久好，所以這個disscheduling這邊我們說的最主要就是minimize sick time那這個sick time其實就等於就是它的

這個Sig's Distance也就是磁頭移動的距離那所以Scheduling and Algorithm這邊基本上我們會介紹的是這幾個非常基本的，那當然實際上使用的當然就是以這些為基礎再去做修改好，那我們就一個來先看第一個是First Come First Serve對不對，所以這個最基本的這個Algorithm m always可以Apply在很多的management的問題上，那這裡當然也不例外

那，this scheduling的問題首先要看到的就是你拿到的問題的input就是list of這些reading的location，那這些location可以看見它指的就是我們的track的number，因為我們說這個讀寫位置當然其實實際上是由第幾個cylinder， 第幾個track還有第幾個sector組成的對不對，但是跟這個磁頭移動距離有關的只有Track Number，因為磁頭移動就是在找你

是第幾個Track，所以我們Cured其實也只是它的Track Number的這個部分所以假設像這邊，它就可以看見你可以想見，就像是硬碟的Driver，它這邊看見了，這時候在這個時間內從系統上面不只是檔案系統任何的這個系統執行的軟體，最後要去讀資料的時候，他可能又要讀這123456789這十個位置，那這些就是我要去

移動石頭的時候他看見的request，那當然目前會有一個現在位置就是所謂的head of the point，會有目前的current position，所以first come first serve，所以當然就是不管我現在位置在哪，我就根據這個順序依序的去讀他們，所以當然以這個例子大家可以看见，就會變成像下面的結果，那這個結果當然是Performance的Distance嘛，对不對，所以大家就可以

去看它到底移動了多少距離就是它這個Track Number的Distance那把這些路徑的值全部加起來，當然就是你所要花的時間了。那所以像這個First Converse，因為沒有任何的它就是看運氣嘛，对不對，所以你很明顯會看見它可能不會是一個很好的一個做法，因為因為這個ordering，如果沒有好好排的話，就像這邊看见很多

z-zack的狀況，所以你就知道一定是有很多重複的distance所以當然它所需要的時間就會相對的比較差好，那所以第二種做法大家可能可以想見，就是那既然我要避免去移動太遠的距離，所以就可以用最近的就移到最近的下一個位置為概念的設計的方式，那就是所謂的shortest seek time first，对不对，所以就以

目前距離同樣剛刚這些request，如果我目前是在一樣是53嘛，所以當然就會找98、98、1837有這些選擇那我就會選裡面最近的那就是65，然後以此類推移動到下一個位置之後再來看一次最近的距離是誰，這就是shortest的seek time的方式，那結果出來當然你可以看見觀察到就會比剛刚似乎好一些，那這例子

來講就是236個cylinder就是236個這個distance的距離那這就是shortest-signal的做法好那這個做法其實並不會保證，但是要注意到這個做法並保證它是最好的，因為其實它只是看目前的結果。那這個request不要忘記系統勒其實是不斷是在一個online就是running的狀態對不對。我現在看到是這10個可是我移動完之後接下來

或許就有新的request不斷的下來對不對。所以，如果你一樣看不見未來的話，你只是很這個heuristic的greedy的移到目前最近對不对。那萬一下一個這邊空掉剛好他就移到這麼遠所以這樣他就移到這邊邊了。如果下一個進來其實是在中間的話其實你沒有發現那你就直接移到最遠的距離那一樣不可能

是不一定會是最理想的，因為不要忘記這個系統狀態不斷在改變。所以，這只能算是一種Greedy的做法好那。既然它你不知道未來狀況到底是什麼那你是Shortest的話你可以看見就算是剛剛這個結果你還是有ZZ對不对就像這個shortest因為它是以目前的位置作為決定而已對不对。所以像這邊你可以明

顯看見我們其實還是有一個重複的這個路徑就像這邊其實當初這兩距離其實都很接近所以不管往左或往右它的結果可能都不是最好的。既然你不能做任何保證而且你的磁頭反而容易有可能來來回回的移動所以第三種做法就很單純就叫做scan那Scan的做法就是既然我不知道怎麼移動會是最理想的我乾脆就是先往一邊走再往另外一邊走所以非常非常的

單純他就不管你到底有什麼Request就基本上就在Triversing這個Disk的這個位置就對了所以以53為例來講我們可能53這個位置開始的話我們可能先往各位的左邊開始去Scan到了底之後我們再往右邊去做scan所以他就是一定是只會來回一趍而已對不對所以這就是所謂的scan就非常單純的一個做法

當然他可以先往左後先往右都可以啦但重點是他到底了之後他就會折返往另外一個地方去走那就是所謂的scan那算出來你看是236對不對跟前面這個其實結果是一樣的那事實上有些時候scan或許反而會更好一些因為shortest的signine他可能會根據你的request的位置受到很大的影響很容易會來回擺動的狀況可是scan的話就是不管我就是之後畢竟讀的就是慢所以我就乾脆依序的往左邊讀再往右邊讀不要忘記IO很慢嘛對不對

所以你在讀這些request的時候其實你在queue裡面的狀態恐怕又會多了非常多新的request進來所以你讀完之後其實已經有很多人等著要讀你就慢慢的把它讀過去就對了好這個就是所謂的scan所以它就是往兩邊去掃就對了好那剛剛這個scan的做法呢如果你去看的話有一個問題就是在兩邊的request它的IO或者說在Q裡面等待的時間它的等待時間不平均

也就是在兩邊的話如果你運氣好像這邊對不對我讀到這邊了嘛因為我到了這邊我會立刻折返所以我的request如果在這一邊的話他的石頭剛好也在這個區域的話他讀過來的時候我這request可能還沒來但是他讀到這裡的時候他才過來的話我就可以立刻被讀到對不對所以這邊他等待這邊會有很長的時間在這裡所以我的request可能很快就會被讀到

可是如果運氣不好剛好是另外一個極端今天我request石頭在這邊那我request在最右邊的話那如果我一miss了之後是不是要等石頭移到這邊來再移回去等於是兩趟對不對所以我如果在兩邊他的等待時間要嘛就是接近0因為他剛好還沒來就在這個附近我正要讀有兩次的機會那如果兩次都miss掉的話我就要等兩輪對不對就要等兩次

scan的這個時間才會輪到我所以意思就是他等待時間是要嘛很快要嘛就是非常的慢所以就變成IO的時間變得不穩定等待的Q in的waiting的時間就變成忽長忽短在兩邊的話中間還好因為中間always就是過頭了對不對你就是在等一半嘛所以半個半圈加半圈就是剛好一圈嘛所以為了解決這個wait time的問題

就有另外一個改善的方法就叫做C-scan那所謂的C-scan他的目的就是希望他的等待時間不管我的request現在我讀寫的位置在哪一個位置大家的等待時間都很平均就是等他少過一遍的時間就是平均就是應該要少過一遍的時間那這方式其實怎麼做到呢所謂的C-scan就是標準的run-robbing我們知道 Wrong Robin 是

最 Fair 的嘛 對不對所以在這個讀寫頭的位置的移動如果你想要用 Wrong Robin 的概念的意思就是我走到底之後你不要立刻折返因為立刻折返變成 ZZ我們知道 Wrong Robin 是應該要回到頭的對不对n所以像這例子來講如果我們先往右邊走走到底之後我們要把磁頭直接的移到最左邊那中間這個距離看似很長但它其實不算因為它中間沒有讀任何的資料

所以他是直接就從一邊拉到另外一邊去所以這速度當然就很快這個會慢是因為他慢慢的在這邊等這些讀寫所以到底之後他是直接回到另外一邊然後再做scan所以簡單來講就是他只往一個方向在做讀寫而已然後到底了之後就直接把磁頭拉回到原點開始所以這樣的結果就是他的wait time大家可以看見你的request不管在哪邊，如果你很不幸的

miss掉了，就是你的位置，他讀寫頭剛剛好過了你，你才來的話，你也就是平均，就是等對不對只要等一個讀過去的距離就好，所以不管你的位置在哪，大家等待時間都是相同的好，可以所以這個就叫所謂的C-scan，也就是他記得，他其實是指望一個方向讀的方式好，那解決問題就是希望大家的wait time uniform，

不像兩邊兩側，兩側意思，就是你的讀寫盤的最內圈或最外圈，那個等待時間希望他也是很平均的好，那從剛剛的這個scan的做法，因為他叫scan的意思，就是說他根本不管request在哪對不對，我就是慢慢的慢慢的一個position一個position的移動，移動到那邊之後再看是不是有request有的話，我就順便把它讀出來，這個就是scan，所以你會發現它移動的路徑剛剛在這個scan的路徑的話，其實不管request在哪，你都必須要走到0跟最後一個位置，你可以

注意看我們的request裡面，其實沒有0對不對，但是我們的磁頭是從0開始，然後開始scan，然後尾巴也一樣雖然我們最後一個request其實是183對不對，在這個位置可是，其實我們會travel到199，因為scan的implementation的做法，其實是他不管，他就是每個位置都掃過一遍，就是scan所以叫掃過一遍就叫scan嘛，對不對，所以他一定會走到兩端的極側那這樣的結果光看剛才的這個圖你就會覺得那中間這一塊對不對，

如果request其實沒有在兩側的話那中間似乎就多餘的移動了，對不對。所以另外一種做法被提出來叫做LookLook也分成Look跟See、Look，所以差別也就是你要單一方向或者是兩個方向這邊我們的例子是See Look所以你會發現它讀寫的方向一樣是單方向的，就是先往右邊到了底它直接到最左邊然後再去讀Look跟Scan，看起來很像，但最大明顯的差別

你會看見就是 Look 呢，他不會走到最最極側的兩邊，就是 0 跟 199他只會根據最後這些Request 的位置來做移動，所以他叫Look，所以 Look 的意思就叫做 Look Up，所以他會去看你的Queue 裡面Request 的位置來做決定，他就叫做 Look然後他決定的方式是他看了之後他會往他單一側最近的那個地方去移動，所以就會變成

像這邊所看見的這樣的一個結果，所以它其實跟shortest seek time的implementation非常非常像，其實反而比較像差別只是在於clook的話它只會往單一方向的shortest distance去移動，如果是第一個shortest seek time它不管左右它就是最近的就移動對不對但是如果是look的話呢它就會直往它的clook的話他就從他右邊的shortest sick time的

位置去移動就變成Clook了所以其實Clook大家看這個圖或許這個例子裡面你會覺得他比較像是scan的例子但是實際上如果是wrong time這個request是不斷裡面q的狀態不斷在變動的話他的長相其實你會發現是跟shortest sick time比較的像就是他會是他會是目前最近的他就往那邊移動只是

他只往單側那邊去移動而已那他的好處就是跟Scan比勒他就不會移動到最大的最極端的兩側但他的缺點是其實他的行為behaviour會比較接近shortest sequence就是他會有時候會移動得太快了因為你可以看見他只會根據他Cue裡面的狀態所以從這個點到這個點他中間是不會等的他就是一次

就會立刻移動到這裡來那如果是scan的話其實它是每一個位置它會去檢查所以它其實在檢查過程中就比較容易去如果有新的request來的話它比較容易去在讀的在走的過程中順便把它讀出來因為持動的移頭是需要時間的嘛對不對所以如果你是用look就是從這裡我就直接跳到這裡你可能移動的比較快

但是這個時間內來的request就全部都miss掉那如果scan它就是慢慢的移動但是它移動的過程中只要一碰到有request它就會把它讀出來了好 所以簡單來講這個look基本上它就是用跳的方式然後就根據queue裡面最近的單側的那個request然後直接跳到那個位置去好

所以總結來講我們看見的這個shortest seek time當然是最直覺的做法但是其實它並不會deliver最好的結果因為它移動的實在比較快所以它有可能在移動的過程中會miss掉比較多的request而且有可能因為你下一個request的位置讓它就會左右擺盪結果反而long term來講你會發現它的效能並不一定是最好的

那scan的話看似簡單但其實當你的loading很重的時候什麼叫loading重呢就是你其實到處都有request對不對所以其實你在移動的過程中因為loading重嘛所以你移動一秒鐘之內你就有出現request的機率比較高所以你就可以慢慢的在移動的過程中你其實都是有機會讀到一些request而不會把他們跳掉那像shortest sit time就是在loading比較輕嘛loading輕所以其實

你移動個三秒四秒中間也不會miss掉任何request都沒有人來對不對所以你乾脆就直接跳過去就好所以loading輕的話，shortest seek time這個shortest seek time會比較好，但是loading重，你就scan乖乖的一步一步的讀其實會比較好，且他也不會有starvation嘛，因為他的這個等待時間尤其如果用clookercscan的話，他等待時間是很平均的，那如果是shortest seek time，有可能他

尤其是shortest sit time對不對他有可能就一直卡在某一個區域啊，因為他是最近的先讀嘛，所以如果有另外一側有一個request來， він可能等非常非常久都沒有機會被讀到，因為他的距離太遠了對不對，那我們說這個scan然後c-scan就是變成uniform那，如果是look的話，他比較像是shortest sit time，但是他解決了starvation的問題，因為他只會往

單側移動，所以它就不會像Shortest Sit Night就會一直會困在某一個區間好所以Disk Scheduling我們看到就是它要減少是個Sit的Distance，但是整個這個硬碟的或是說應該說整個這個IOInput Output的角度來看的話，其實大家不要忘記也要跟前面檔案系統Data擺放的那個章節要結合在一起對不对，因為為什麼你讀寫的資料會凌亂會分散對不對

為什麼會需要來回讀寫，就跟file system是怎麼管理你的data是非常息息相關的對不對，所以我們的file system在擺一個data一個file的data的時候，它沒有連續擺的話，那這邊不管在做什麼樣的優化也是有限的那就算file system擺得非常的這個連續，這邊也還是需要為什麼呢，因為不要忘記整個系統，並不是只有

一個使用者硬碟不是只有檔案系統在用對不对，所以當有很多使用者或是有很多的這個檔案系統或是這些儲存系統這些上層的使用者在同時使用同一個硬體的Hardware的這個硬碟的時候，他的Request是會被混在一起的，所以混在一起之後，那當然就要靠最底層最low level的Disk的這個Scheduling的方式來把

它再回復到原來可以連續的這樣的一個Behaviour，所以簡單來講，就是說如果今天兩個人都是同時在Sequentially的在讀硬碟，他們兩個加起來的IO的Pattern到了硬碟的時候，實會變成Rendon的，那Disk Scheduling它就可以把它重組回它原來比較有效率連續的做法，所以這上層跟下層都需要做一個優化跟配合好，所以這個就是Disscheduling，那大家就要記得這幾個基本演算法的做法，那最主要當然其實要去知道他的Seek Distance怎麼算那算的時候

稍微注意一下如果是C-Scan他從一側直接跳到另外一側的那個距離不要算他那個雖然你畫的時候你有看到那個距離但實際上那個距離通常大家是不會去計算它的因為那會當作一個單純的在移動這個很快的從石頭跳動的這樣的一個動作它中間是不會堵的.