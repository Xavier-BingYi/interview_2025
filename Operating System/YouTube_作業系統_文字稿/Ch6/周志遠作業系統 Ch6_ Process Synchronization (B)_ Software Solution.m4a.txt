undefined
好，所以呢、接下來我們這堂課基本上全部都在講Access Session Entry Session要怎麼設計，然後可以去滿足剛剛看到的三個Requirement那我們會先從第一個Software Solution意思就是全部用Coding的角度全部是以Programmer各位在寫一個Multithreader Program像這樣子你要怎麼樣在你的程式裡面做修改可以解決掉Synchronization的問題之後你可以看見還甚至可以有Hardware意思就是說有一些特殊的InstructionAssuming事實上Computer Assistant都有的其實是有一些特殊的Instruction提供出來就是來解Synchronization的問題

所以會based on this instruction然後去解這個問題後面兩個就是一些比較high level的tools事實上在Java或是一些比較high level的平行程式裡面其實都有提供這些solution那你就去call這些API簡單來講好那我們就先來看可能的solution是什麼我們的問題就先從很簡單的只有兩個process開始那就是有 P0 跟 P1 對不對然後呢我們的目的就像這邊看到假設有 P0 跟 P1那我們的程式嘛對

當然度化這只是代表他們會不斷的所以其實不是執行完一次其實是兩邊都會不斷不斷地想要進到他們的 critical section 裡面做他們的 data access這個是remember那這個呢裡面當然有很多statement我們就把它全部包起來就是它都是critical selection就對了那solution第一個就像這邊看到非常簡單的概念用一個像是key

一樣的概念對不對也就是我們有一個token叫做turn我們可以定義這個share的這個variable所以token就是一個turn這個變數那這個變數反正就是0或者1就對了那0的話就代表說你現在是可以進入到critical section裡面的那應該說只有兩個process啦所以我們這邊的設計就是假設如果turn的值是1的話不等於0嘛那麼就代表P0可以進去那如果turn的值是0的話反過來講那就可以讓P1讓他進去所以我有兩個turn嘛turn的值就是0或者1那

如果是這個i的話就是pi所以turn如果是0就是p0進去如果turn的值是1就讓pe進去就輪流就對了就看這個turn的值是多少來控制因為這個turn的值它要嘛是0要嘛是1嘛對不對所以代表就是其中有一個人可以執行所以就是符合mutual exclusion這個是絕對沒問題的對不對，所以我們的寫法就像這樣子

為了讓他們可以輪流，所以你可以看見P0當他進去做完之後，那他就把他的turn換成1，意思就是說他可以讓P1去做的意思，那P1同樣做完要換別人嘛，所以他就把turn寫成0所以這是一個基本solution那這個程式嘛這段statement就是我們俗稱的entry section那這一段，這就是exit section這就是我們填進去的程式嘛，這個solution

其實並不完美其實有些問題，第一個我們就來一個一個檢查mutual exclusion沒問題對不對，因為要嘛是0要嘛是1嘛不可能這個值又是1又是0不可能那，如果是這個progress的話咧對不對進度，所以我們有三個條件對不對，第二個條件是進度，那進度的意思就是說今天如果這個是空的話另外一個要能夠進來，這個程式碼會符合嗎

其實有可能不符合為什麼呢，我們來假設一下，今天這個，因為這是花LOOP所以各位要注意到一點是沒有人說這兩個程式是你執行一行我執行一行這是兩個程式，所以有可能P0執行很多次之後P1才執行一次因為包括了reminder section的內容不一樣第二点CPU Scheduling本来就是Round Time决定所以并没

有说你一行我一行我有可能他一次就执行很多行再执行另外一个人所以有可能会交错那今天如果P0很简单的假设我们P0先进去了对不对然后出来了出来之后呢P1还没有进去P0立刻又执行到这一行的话他是不能进去对不对因为Token的值是1所以他就卡在这所以P0

進不去P1呢他可能不急所以他現在本來就還沒執行到這一行所以就變成沒有progress意思就是說這個solution他一定要是輪流我做完再做你你做完再做我那問題是實際上的時候有可能P0連續要做兩次這是很可能會發生的當這個事情發生的時候其實另外一個人他根本還沒有想要進去那P0卻想要進去

可是卻進不去因為他手上沒有那個key所以progress根本就不符合bounding weighting一定符合因為這是輪流對不對你一個我一個你一個我一個所以連加進去過一次之後p0這個只要p進去過一次之後p0就可以下一個就是換他所以waiting time一定是1而已所以可以符合bounding weighting也符合mutual exclusion但是不符合progress可以齁看出來齁

所以这个是这一个solution的问题三个里面其实它只符合了两个，但progress是不符合的我们可以来看第二个solution另外一个比较其实可以把这个问题刚才把它解决的问题是叫做Peterson的solution这个才是正确的一个解法，那一样延伸刚刚的想法就是用turn来表示也就是一样嘛，就是轮流做就对了，所以turn. i的时候pi就可以

进入critical section这是基本定义但是我们为了要解决progress的问题所以我们再多加一个flag去indicate说现在这个process他到底想不想进到critical section所以刚刚的问题是因為我們不知道大家想不想進去我們只是輪流嘛對不對可是有可能你根本不想進去造成 progress 沒有符合所以呢為了這件事情我們就再多加一個變數叫 flat然後 2 嘛所以這只是兩個 integer

而已那 0 呢就代表是 P0 它想不想進去這個 P1 這個裡面它存的就是 P1 要不要進去所以它就是簡單的 true and false 就好所以當 P1 是 true 的時候就代表這個flag i是true的時候就代表pi他是想要進去的所以除此之外所以我們除了知道這個有這個token之外其實你還可以知道對方到底想不想進去這件事情

好那所以一樣這是critical section對不對那這邊呢是我們的entry section那這邊的條件跟剛剛第一部分其實是一樣就是我們有一個file對不對那turn如果是等於J就是對方的意思就代表對方有鑰匙那對方有鑰匙的時候我就要等所以大家請注意這邊有一個分號所以滿足這個條件是會被卡住的所以被卡住的第一個

條件跟剛剛一樣就是我的turn如果是對方的話我就不能進去但是我多了一個就是flag所以你可以看到flag這邊也必須要是true我才會被卡住所以代表对方如果真的想要进去而且对方又有钥匙的话那我只好等了但是如果我自己就有钥匙那不用讲我就可以进去或者是对方虽然有

钥匙但是他说他不想进去那这时候我也应该要可以进去才对对不对这样才可以满足progress吗你不要进去我要那我就可以进去对不对所以跟刚才的差别就在于用这个flag然后去多加了这个condition那剩下其實是一樣的所以你可以看見它結束之後當然我就可以把flag設成force因為我進去嘛所以我進去之前我當然要把我自己的flag設成true所以代表我要進去那我出來的時候

就把它設成force然後key的部分一樣其實要輪流的對不對所以我們把turn這邊就設成j所以代表說我進去之前其實我要先把key交給別人意思也就是別人執行同樣程式嘛所以別人要進去之前其實也會交過來所以 key 其實還是在兩個人之間交換的那你一定會問我為什麼 turn 寫在這不寫在這差別在哪裡差別在於寫在這裡的話咧為什麼要先把 key 給別人因為現在除了有 key 之外你還會看它的 state 對不對所以說你要能夠

這個檢查這個條件要能夠正確你不會同時進入的條件是代表你不會手上剛好又有key然後又立刻檢查這個所以你在檢查這個條件之前你會先把key給別人讓別人先去判斷一下他是不是要進入到這個critical section裡面所以他必須要先把這個權利讓給別人不然有可能你自己這邊把key給別人之後那給了別人之後對不對

這個進去的時候可能就會有問題了所以簡單講就是說這一個你一定要先讓別人做檢查因為你自己已經知道你要進去了嘛所以你要先讓對方確定對方是不是也想要進去如果對方想要進去他key就不會還你那你就沒辦法進去了所以他會先讓對方先去執行好 所以一直這樣你看因為對方先檢查過啦然後符合條件之後

你自己才能夠再進去這個critical section裡面所以term必須要寫在檢查的前面先給別人有一次檢查的機會那我們就來看一下這個做法為什麼可以保證三個requirement第一個是mutual exclusion那 mutual exclusion的條件我們知道基本上要這兩個你要同時就是假設今天如果兩個城市他們都可以同時在critical sanction裡面這件事情是不

能發生的所以我們的證明方式就是反證所以反證意思就是假設我們今天兩個都已經在critical sanction裡面那如果都在裡面的話你知道它的條件是什麼就是第一個你的這個flag必須要是forced對不對就是對方不想要做對不對那對於P0而言他就是turn剛好就是他自己他才有機會進去那P1就是反過

來對方也一樣是force或者是他自己有這個turn的這個值那這兩個要同時發生的話對不對代表什麼意思呢第一個當然flag0跟1是true的這個當然是要是因為你要進去所以你當然state是true所以這沒話講這個值一定是true對於兩個Process而言如果有一個人是Force就代表有人不在Critical Section所以這兩個Condition雖然說是All可是你可以看見Force的那個Condition絕對不會發生所以那個其實沒有辦法幫助任何一個Process進到Critical Section裡面所以就要條件變成是Turn的值

那t end的值既然它只是一個integer而且我們是用assign的方式如果你注意到它不是用加加或減減它只是assign所以它的值一定是0或1它不可能又是0又是1啊對不對所以tend的值如果是0的話就代表那p0的確它可以在裡面但是p1就不可能啊因為你可以看見它的兩個條件都不存在所以p1是不可能在critical selection裡面的

那你當然可以反過來啦如果turn的值是1的話那就代表P1可以進到critical section但是P0不可能符合它的條件所以不可能在critical section所以我們前面列的這兩個condition永遠不可能同時發生所以這個是反證法的方式就是看它在critical section裡面的條件是什麼然後去看它在这个执行的结果有没有

可能同时满足那很明显是没有办法的好第二个是progress所以progress我们说了它的这个意思就是说假设有一个人不要进去那另外一个人想进去他要可以所以在这边的例子来讲我们假设P0他是想要进去的那P1的話它要嘛就是在後面的reminder section或者是它可能是在執行這些行數之前

也就是它在執行while之前的動作所以它有可能是在critical section的前面或者後面就對了，但是不可能在critical section裡面那在這個時候我們要證明的東西就是P0它進到這一行它一定要能夠break這個while loop然後進到critical section裡面好，那麼我們就來看condition就兩個嘛，就是第一個PE他有可能是他已經執行過critical section他

離開了他不要進去那他如果離開的話你可以看見flag1一定會被設成force對不對所以說對於P0而言他看見他設成force的話這個condition就可以break了對不對所以P0就可以進到critical section所以沒問題所以PE剛做執行才剛執行完那P0是可以進去的好，那麼我們再看這個第二個case對不对第二個case的話呢就

是這兩個人對不对，所以P1執行完之後他有可能很快他會繼續執行嘛，因為他還在同一個CPU burst裡面對不对他沒有做content switch所以P1做完之後有可能他就一路做use a while loop所以他又回到這個時間點來了那進到這個時間點來的時候你就會看見這兩個人他們同時想要進到critical section裡面那同時想

要進入的話你可以看見他的flag一定是都已經被設成true了所以兩個人都ready了，那Turn的值剛剛如果是，如果是這一個人，他執行完進來的話，其實他會執行到Turn等於0對不對，所以0的話就代表P0就可以進去對不对，所以說這兩個人，如果同時要執行的話，其實一定有一個人是可以進去的，因為

兩個都ready了，而且Turn的值要嘛是1要嘛是0，所以他一定有一個人可以進去所以一定是可以繼續執行的，所以我們的critical session不會空在那個地方，所以這兩個情況你要考慮到PE有可能是才離開或者是PE他已經繞一圈回來他又想要進去的話，那這兩個情況其實我們的CREO SET裡面都可以讓其中

的一個人去執行最後一個bounded weighted bounded weighted的話就是我們剛才說的跟剛才有點像一樣是P0想要進去的這個事情，但是跟剛剛不一樣的點在於說P1這個人，如果他才剛執行完的話，我們要更嚴謹的確定P0一定要進去所以為什麼可以去確定P0執行完PE執行完之後一定會讓給P0一樣的我們可以

看見PE這邊可能剛執行完它會設成force今天如果一個contact switch所以它今天執行到這裡而已我們就contact switch就發生的話P0就會去做一個檢查它會發現flag1是force所以PE剛執行完P0會是下一個可以進去的人，所以這個沒有什麼問題，剛執行完flag換成已經被變成force了，所以P0就可以break，即使turn現在還是0所以即使turn這邊是0或是1也不重要，重點是flag這邊一定是force，所以它可以進去執行

跟刚才progress很像，但不同的是說今天，如果P1我們執行完之後，它又繼續執行假設它沒有被contact switch假設P1它並没有被contact switch，所以它又可以執行進來然后它又想要进来這個时候你就会发现為什么我們要把turn寫在前面，因为如果马写在turn 0的话我们就强迫P1它要執行到下一轮之前一定要把权

力讓給另外一個人所以PE它就算想要進去，它的flag是true，但是呢它的turn會在PE0這邊，所以它沒有turn而且呢PE0它在這邊已經在等了嘛，所以它的flag一直都是true的，所以代表PE它就會卡在那裡，所以即使context switch沒有發生PE會發生什麼事呢PE其實會在這個while loop裡面不斷的執行沒有意義的instruction然後

不是沒有意義啦就是一直在檢查這個condition然後都沒有辦法break它然後直到呢它的CPU first的時間用完了我們的OS就會做content switch換到P0這邊來對不對，那P0這時候一換過來它馬上就可以進到這邊執行，所以P執行完一定是P0，因為當兩個都ready的時候，其實我們會把key交給另外一個人對不對，所以說剛執行完的人，他沒有辦法立刻重複執行，因為另外一個在等的人他一定會先拿到Key然後拿到Key之後他就可以

先執行，所以不會違反這個邦迪威脅的條件，所以這個是為什麼我們要把Key是交給別人，而不是說把Key設給自己的差別，所以這其實也會符合直到剛剛那個寫法之後，在寫critical section的時候，第一個大家要注意到的事情就是到底在哪邊去定義你的critical section，就像以這個層次我們之前看到的這個一開始我們那個consumer producer的例子對不對，

那第一個很難易的方式，你可能想好吧，那我就把所有的code都放在critical section裡面應該沒問題吧對不對，最簡單的什麼都保護通常比較好，但答案是錯的，這樣子的去定義你的critical section，你會發現你會產生所謂的delock，意思是什麼呢，就是你會卡住，原因很簡單，你可以看假設我們今天一開始是空的對不對，那就是buffer裡面是空的，

假设consumer这个层次先被扣他可以进入critical section没问题，因为他第一个，但是他会发现buffer是空的，所以我就怎么样while loop在那边等，所以consumer就在critical section里面停住了，然后producer这时候才被扣到，他会被entry section给挡住，因为你说这整个是critical section对吧，所以producer就卡在前面永远都没有机会进到它里面的程式，所以这次程

式会de-lock也就是我们下一章节会讲的de-lock也就是consumer其实在等producer产生资料可是producer却是因为critical section的原因被在等consumer结束他的critical section，所以两个人互相等就lock在那边，所以这其实是一个错的solution，所以这是要跟大家讲critical section到底定义在哪里，其实你要很小心的去做一个判断，那第二个是正确的，但是不太

好的就是意思，就是重点是怎么样定义critical section实际上是定义的范围实际上要越小越好而且不要包到跟risk condition无关的程式像这个例子就是假设我们在这code里面，我们要做一些computation就是完全independent 的一些动作就对了，所以当然你知道 counter 加加減減才是 raise condition 的地方，所以你可以把它包住，且你也包了一

些無關緊要的程式，那這邊當然也是一樣那這會對可是它的缺點是什麼呢，因為你包了這個 critical section所以它有 mutual exclusion意思代表今天這個程式如果執行到一半的話，另外一個程式執行到一半我有可能會做contact switch對不對所以我執行到一半的時候，我們的OS可能會contact switch從這個程式換到那邊換到那邊的時候，因為他們都在critical section裡面，所以換過去了可是他卻沒有辦法執行他會卡在這個entry section的這個地方也就是說這個compute的部分其實本來是可以

whoever被schedule到就可以執行的東西才對可是因為你把它包在critical section裡面所以變成是他就是必須要把這裡所有的程式碼都做完另外一個人才可以做剩下的事情那這也有點其實這也延長了你 critical section的時間對不對，那就等於是讓整個 CPU的效率就會變差因為你很多時候輪到你執行可是你卻卡在entry section然後做沒有意義的waiting，所以你整個程式效率就會

檢查了好所以這個critical section原則就是你要包的是越小越好，然後只有跟會產生race condition有關的程式，所以怎麼去identify出一個critical section也是很重要的好，那這個我們要等到下一次，但我們先把概念給大家，我們剛剛介紹的是兩個process的synchronization的solution對不對就是今天只有兩個process在運作的話，但是你會發現大部分的

問題不是兩個，你都是N個對不對，所以我N個process之間有synchronization的問題，那要怎麼去解決它呢就是我們所謂的bakery algorithm是一個被提出來的一個solution，所以它是可以apply for N個process，不像剛剛那个solution就只能用在两个而已，那它的方式是什么其实我可以先把概念跟大家讲就好，概念就是像是去邮局或者说你去买面包一样，那不是它为什么

叫bakery的原因，那是发明人的名字，但是你就去买东西的时候你就会发现大家结账是同样的问题，只有一个跟你结账的人，所以你为了要结账其实大家会抽号码對不對，所以如果你能夠抽號碼牌的話，你就能夠確保一次，就是一個人在做一件事情對不对，然後即使有很多的人大家可以輪流來而且抽了號碼牌之後呢你就可以保證first come first serve對不對

所以你可以保證他會滿足邦迪威提的條件然後你在service這些client這些client的人因為你抽了號碼牌所以只要有人抽你就知道誰是下一個要去service的人對不对所以你會滿足progress的條件所以簡單來講就是大家去想抽號碼牌這件事情怎麼樣去implement成program就好了所以基本的條件是這樣子我們會看見

就是每一個人會去抽一個號碼牌在進到critical section之前然後這個號碼牌當然是越小的我們就越先可以執行但是在程式裡面會複雜一點的一個事實就是雖然是抽號碼牌但是你抽到號碼有可能會是相同的所以跟生活中你們抽號碼是一台機器所以沒問題但在程式裡面你抽號碼牌這個動

作就是好幾行程式所以有可能你抽到號碼牌如果兩個人同時抽他們的號碼有可能會是相同像是33,555是會發生它只是non-decreasing可是它有可能會相同的問題那為了要一個Piebreaker而且是確定只有一個人是先誰是後的話我們可以做的事情就是透過Process ID所以當他們抽到的號碼牌都相同的時候那我們就來比大家的PID所以PID越小的我就認定他其實是越小越可以先進去的這個人所以就有一個Piebreaker，所以用這樣的方式我們就可以

像模擬去抽號碼牌的結果是一樣的，那esso你會看見我們之後的程式碼在比較的部分它不只比較AC也就是這個抽到的號碼還有B跟D也就是你process ID所以如果相同它會比process ID這先給大家看而已啦下次我們再解釋，所以你可以看見這是完整的solution其實就變得比較複雜，但是我們會一個一個去講解到底每一行的意義是什麼.