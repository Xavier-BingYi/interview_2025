undefined
好，那我們介紹完Critical Section，然後介紹完Semaphore，那麼我們要教最後一個叫做Monitor，高級的所以要介紹Monitor之前，我們就要先看一些比較複雜一點的Synchronization的問題，那這些Synchronization文，你就會發現用用這個Mutex啊，這種Critical Section或者是Semaphore，就還是很難去想怎麼樣去寫它的Solution。所以我們要Monitor，那重點是，實你會發現有非常多Synchronization的各式各樣的問題，所以怎麼樣子去Evaluate？說有哪些好的Solution或者系統設計？怎麼樣是對的，

就會衍生出我們定義了一些所謂的classical的synchronization problem，就是非常非常著名，大家知道，在電腦系統運作當中，你都可以把它reduce成網絡，就可以reduce成這幾個問題。所以一個好的電腦系統整個程式的設計，你就要去看，你會不會發生這些問題，這些問題發生的時候你的程式碼是真的都有處理到，esso就是我們俗稱的classical的synchronization problem，

那這些所謂的classic，就像剛才說的，最主要的目的，就是去驗證你的這個synchronization你現在寫的code你說它已經它有synchronize了可是它到底是不是正確的synchronize它是真的能解決到常見的那些問題我們就會去用這些問題來檢視看你的solution到底是不是對的那哪些是classicclassic當然很多啦那最常見的三個就是第一個

Founded Buffer大家已經看過了這是為什麼一開始用這個例子因為它就是Classic裡面的其中之一是比較單純的也就是那個Producer-Consumer的例子有沒有所以我們就用那個當介紹怎麼去為什麼會產生Synchronization的問題那後面兩個就沒介紹到我們接下來就介紹第二個呢叫做Reader-Writer的Problem簡單來講就是檔案操作常常會碰到的

我們都知道檔案資料的操作你就是在那邊要嘛就是Read或者是Write對不對所以你的程式你就是對它做Read或Write兩件事所以對它做Read我們就稱之為Reader對它做Write就叫做Writer那我們都知道在操作檔案的時候或是資料的時候我們都知道如果兩個人同時對一個檔案做Write會發生什麼事就是不知道結果到底是什麼這是不可以的所以我們知道我們檔案系統只要有一個人用Write permission打開File，另外一個人就

沒辦法用write permission了對不對，就是reader writer的問題可是相對的Reader的話就是大家都可以同時打開一個File只要你是用read only的權限對不對所以因為我們知道檔案內容不會改不會有data consistency的issue就是資料是一致的我們知道它的值是正確的這是Reader Writer，所以我們等一下就會先介紹這個solution那最後還有一個

更複雜的theory會更有趣的一個問題就叫做Dying Philosopher's Problem這一個我們就會demonstrate用Monitor的solution去解簡單來講就是這個Chinese最熟了因為這個例子其實我們在看見就是用我們知道吃飯用筷子筷子的一個問題是你要兩隻才能吃對不對一隻是不能用的所以今天如果我們有五個人我們就只給他五根筷子然

後把筷子放在人跟人之間那你要拿起左邊跟右邊的筷子才能開始用餐所以如果大家全部都只拿起左手邊的筷子其實是大家都不能用餐的對不對這就是Dying Philosopher，所以到底要怎麼樣子每一個人要用什麼樣子的方式去模擬他吃飯的行為讓他們有辦法不會卡住不會有Deadlock的發生，這就是Dying Philosopher那這個就複雜了那我們

就用Monitor去看他的solution好， 可以喔好 這之前講過了嘛所以大家應該很熟了bounded buffer的問題， 對不對，所以有固定的buffer size這個size是limited的然後你一個是producer一個是consumer， 對不對，所以空的時候consumer要等滿的時候producer要等，所以大家都很熟這個就是俗稱的bonded buffer的problem所以這就是可以讓我們檢視critical section到底該怎麼去

運作的一個很好的例子然後我們也說了真實系統很多，我們說compiler的output要放到linkerlinker要放到下面的loader，對不對，所以很多程式是有flow的那就是這樣子中間都是有buffer在那裡去控制或者我們整個系統IO的系統我們最後章節就會看見一定要一大堆的IoBuffer每一個Layer之間都有IoBuffer去做Buffering，那怎麼去用這些空間就是這個問題了好，那我們接下來只能講這個第二個ReaderWriter，我們剛才前面講了他就是標準在做DataAccess的時候的一個問題常見FileSystem或者StorySystem都會碰到

那你就是有reader的process跟writer嘛所以reader當然就是read onlywrite當然就是去update content那我們都知道為了要確保這個資料的一致性writer是一次只能一個去操作這個file對不對那只要一個writer在access的時候所有其他的reader跟writer都不能夠去touch這個file因為他都不知道正確的state到底狀態是什麼但是是reader的話我們就知道如果是全部都是reader的話我們就知道它是可以同時access因為就是read only所以這是它的特色然後我們就知道在操作過程中能夠確保這件事情

那reader writer問題咧它又分成好幾個version從最簡單的problem definition到最要求最高的這種最複雜的problem definition其實有幾種不同的version最簡單的我們稱之為first reader writer problem那他的要求就很單純就是minimum也就是只有只要能夠確定writer在用的時候他有exclusive access就可以那read er他們可以去share這個file沒有關係你只要確定writer在access的時候他一定要exclusive access只要保證這件事情就是我們俗稱的first reader writer的problem那我們不care到底reader要等多久

或者是什麼時候做什麼事情只要Writer他有ExclusiveWrite就好這就是俗稱的FirstReaderWriterProblemOK複雜一點的咧比較符合真的使用應用情境的使用者要求的就是說所謂的SecondReaderWriter那SecondReaderWriter他就不只要滿足第一個條件他又多一個就是這個Reader他的Priority必須要高

一點不能有 starvation簡單來講我們這邊有一些名字就是這個啦但簡單來講就是reader不能有starvation的發生這就是second reader writer為什麼呢我們會介紹first reader writer的solution介紹完之後你就會發現這個solution就是這個簡單的solution它的概念就是只要writer來他就可以acquire lock然後這個我講反了對不起喔應該是

writer要比較高的pri oritysecond reader writer指的是第一個的solution的結果是reader因為他可以同時access file所以說當有一個reader已經拿到這個file的lock的時候他可以pass這個lock去下一個reader因為他們可以share嘛對不對因為可以同時讀一個檔案啊所以reader他有可能會把這個lock的token一直pass上給未來出現的reader所以他會一直延續下去

那這樣的問題就造成Writer如果他其實是很早來的他只是比第一個Reader慢來他其實是第二個進來的人可是因為你Reader的時間比如說是10秒然後第二個Reader他在8秒之後他就來了所以他會插隊所以Writer雖然是第二秒就來可是Reader一開始先站住前面10秒對不對然後第8秒第二個Reader來他就把Token給第二個Reader然後第二個Reader又在後的10秒就這樣一直傳下去那第二秒來的Writer

可能會因此永遠拿不到 lock對吧因為你可以 share 這個 lock那這樣就會造成 writer 的 starvation那 second reader writer講的就是說writer 他不能有這個問題也就是說當 writer ready 了也就是像剛才說第二秒他進來了所以代表說第一個 reader 執行完就要換 writer後面來的 reader如果 reader 比 writer 慢來的話你不能夠優先執行不然他會就像writer被

插隊就會造成stabation所以這個問題如果你也要解的話就是我們俗稱的second reader writer如果大家有興趣大家應該是有需要看一看其實還有third reader writer我們這邊沒寫有興趣的自己去google一下這是classic的問題所以一定找得到那他的要求就會再更多就對了所以這是reader writer那我們就在課堂上看一下FirstReaderWriter的solutionAgain強烈建議大家去看一下

SecondReaderWriter的solution就是他的solution都不長所以你只要去想一下為什麼那樣子設計是正確的一個solution好那這邊呢Again我們是用Semaphore用Counting為什麼要Counting呢因為概念就是我們要去數到底有多少個Reader正在Access這個File就是同時在Access這個File所以我們需要一個Counter對不對

概念就是只要有Access的話就代表它有這個Lock然後咧只要ReaderReader的數量只要是大於1的話就代表這個Lock還是在Reader這邊所以我們需要一個Counter去數什麼時候現在是沒有Reader的只有在沒有Reader的時候它的Lock才可以被release掉所以我們需要Counting的概念所以我們用Semaphore好那首先第一個Writer這邊那Writer的概念

Writer就很難這邊是WriteCode嘛意思就是你的Data去Override的程式嘛就對了那我們說Writer它是Exclusive的Access所以當然它的Write我們就有一個WriteLock我們就叫這個它也是Semaphore但其實它是Binary Semaphore而已就是0跟1因為一次只有一個Writer不過我們說他還可以拿來當Mutase用所以設成1就代表他其實就是個Binary的Semaphore一次一個Writer而已所以一樣這邊有個換喔所以代表這個Writer就是不定期的他去Access就對了那Access之前當然要Wait嘛Access之後要Signal對不對

所以他就是包在一個Critical Section就對了好那Reader Reader類似，但是不一樣一點就像我們剛才說Reader可以Share這個Lock，所以說reader一樣，它這個畫有在外面嘛，重複讀取那你只要read的時候，我們就要去count所以叫一個read count，所以我會知道目前到底有多少個人正在要去做read的這個動作那如果read count等於1因為你先加了，所以如果這邊等於1的意思就是你是第一個reader對不對，他想要去access file，所以他在access之前，他就必須要去跟他競爭

這個WriteLock 對不對，因為如果Writer已經拿了Lock，Reader就要等嘛，所以你就要去Call Wait那，如果今天的Recount的值不等於1，我們就會跳過這個動作為什麼，因為它不等於1的意思就是有人已經在讀File了有一個Reader已經有了，那個Lock有人幫你拿了Lock，所以你當然不要再Call Wait，因為不然就Wait到另外一個Reader，這不是我們要的Behaviour

所以只有當 count 的等於 1，你是第一個 reader， 你才要去強 lock之後的 reader 你就不用擔心你可以直接就去做 reader 的動作沒問題齁，那你讀完之後，當然就是回過來嘛，所以 recount 那就要減減嘛，所以要減掉嘛， 對不對？同樣的當 recount 減完之後等於 0 就代表你是最後一個 reader 了，那你就要 release lock，這樣子 writer 才有機會去 access file，對不對？那如果今天你不是最後一個，你也不用管你就不用 close signal 了，因為你也不應該因為那個 lock 就是還是要保留在 reader 的這個 group

裡面，所以你就直接可以跳掉好， 可以齁。所以其實很像，just只是你要去 count你是不是第一個 reader還有你是不是最後一個離開的 reader，所以你那個時候才要做 acquire lock 跟 release lock 的動作，這是 by group 的意思好，那這層次碼還沒有完全正確跟完成為什麼咧？因為你會注意到recount這個動作這個variable其實是一個share variable，share between readers對不對所以所有的readers他都可能會同時去call reccount++那我們知道這就要保護啦所以為了要去解決recount這個本身這個variable的raise condition，

你就要去再用另外一個你要說Mutex 啊，也好或是這邊就是用Semaphore 啊，對不对？去保護ReCount這個variable，所以我們會再用一個這個Semaphore我們都叫它Mutex了大家不用搞混其實這個單是Semaphore所以就是Semaphore，但它的角色就像Mutex一樣你用Mutex也可以啦那所以你要保護的是ReCount嘛所以你就把它包起來啊對不对，所以recon++一

定要在我们的critical section里面对不对然后当然你要包括这个if的动作，因为就像之前叫condition variable一样你操作完你要立刻检查不然子可能会跑掉，所以这个是要整个包起来的single跟weight嘛好那简简一样嘛，所以就是你要去你有了大的这个框架之后你就要再去检查一次你的程式嘛哪些地方會產生 raise condition會產生的地方你再把它保護住所以你’ll發現一個程式不是說你只要用一個 critical selection或者說只能用一個 mutex這沒有這樣子

其實就是看你有多少需要保護的這個會產生 raise condition 的 code然后它們之間是有關聯性還是沒有没有關聯性的你其實應該要用不同的 lock 去保護對不对，有關聯性的才用同一個像這邊都是 recount所以我們採用同一個Mutex lock那相反的這個Writer這個動作這個Data這一邊的Shared Data跟Recount是不同的Data，所以我們

會用不同的Mutex lock來保護，所以你就看你的需求去使用這個各自的lock才對重點就是Data dependency所以你就看你的程式，你要知道哪些Data是有Dependency的關聯性是什麼然後去各自的去保護他全部寫在一起反而會錯掉也不行或是程式就會很沒效率，所以這就是first reader writer的solution了所以很明顯可以看到writer有exclusive的write，然後reader他可以做sharing但是這個的問題是什麼呢就是writer會starvation因為很明顯的reader他可以把這個token這個lock一直

pass on到後面的reader，所以後面來的reader有可能就會超過之前先進來的writer，然後先執行所以reader會一直插隊，所以會有starvation的問題，所以就有second reader writer啦就是如果我們打開系統寫成這樣就知道有人會不滿意嗎，所以當然實際上就要解決這個starvation的問題，就是second reader writer的solution這個Solution我們今天不會講，所以強力

建議大家去Google一下你一定找得到你會發現它的Solution還更簡短可是你要去思考一下為什麼它會正確的解掉最後一個Dying Philosophers這個Classic的最後一個問題就是我們剛才已經講就是這個用餐然後就是用筷子的這個問題所以很明顯的如果我們筷子的數量其實是可以跟人的數量相同然後咧每筷子就放在人的之間那每個人用餐就必須要把左邊跟右邊的筷子都要拿起來你才有辦法去用餐對不對

然後吃完之後當然你就要把它筷子放回去那因為這筷子都是獨立的resource你要去想它都是獨立的memory的content或是data所以一次只能夠拿一個筷子你不能說我有一個程式magically一個function我一次就可以把左邊跟右邊筷子一起拿起來那這樣就沒有synchronization的問題但事實上很多時候就是這樣它又需要左邊的resource又要需要右邊它需要multiple resource這非常常發生那這種時候就會很像Dying Philosophers這個問題一樣好那很明顯嘛這個問題

你寫的不好就會產生Deadlock所有人都從左邊拿筷子再拿右邊的筷子就會發現死掉了拿左邊沒問題開始要拿右邊全部卡住然後就Starvation所以Again會造成DeadlockDeadlock會再造成Starvation那程式使用者就會認為這是一個錯誤的程式了這個Solution就複雜一些那要去解它的話我們就必須要透過一個叫做Monitor的機制那我們

今天只能很簡單的講一下它的High Level的概念下次我們再講怎麼用Monitor去解這個Dying Philosopher的這個solution那首先就是我們知道為什麼要Monitor因為如果你用Semaphore啊你用MutexLock啊或是這些CreoSection你都要自己在那邊callSignal跟Wait你看到一堆的Signal跟Wait對不對然後呢你的順序

如果不小心寫錯了你就會發現有deadlock然後就死了所以你其實是非常low level的一種synchronization的tool所以很容易因為programming的問題然後就卡住了那所以什麼是monitormonitor呢它其實是一個high level language的這個construct也就是OO的概念說真的其實它就是OO的概念它就把你要保護的resource想成是一個all

我們知道它是分class分object那每一個class它裡面都會有local的variable還有操作這個local variable的method所以一個monitor其實就是一個特殊的class所產生出來的一個object然後你要保護的variable那些會有risk condition的變數就是把它想成是這個object裡面的local variable然後你所有要操作這個variable的就是這個class的method所以你就可以知道所有

人你要去touch他一定要go through這些method才可以所以就像我們OO的概念那但是跟一般的OO差在哪差在一點而已很小的一點但是很重要的一點就是我們知道OO裡面的這些method都是可以同時可能很多thread同時去call他的話他就會同時執行對不對那但是因為我們知道同時執行會有synchronization跟raise condition的產生所以monitor的class它的這些method的一個additional的條件在language當初就是一個special的class的條件就是一次只有一個method可以執行所以你可以

有很多的thread同時去call這一個class的method但是它在language level就會保護這個class的object，讓一次只有一個thread只有一個thread可以去執行它的method，也就是critical section的概念、neutral exclusion的概念對不對。所以你就可以保護了那這樣的做法為什麼容易得多，因為你就是定義behavior而已啦，所以叫higher level對不對。我們只要去想我們的問題

裡哪些是要保護的variable操作這variable的動作有哪些，這樣就可以了，然後咧把它變成一個special的monitor class，所以by default這些method之間是沒有辦法同時執行的，所以就永遠不會產生critical selection的問題，然後你只要以OO的概念知道有哪些這個variable有那些method定義好就可以，然後去那些thread就去call這個class的method來去操作這個整個program的state，然後就不會有問題，所以我們今天只能講到這個概念而已下次我們再仔細講所謂這個概念就是active然後它的solution是什麼.