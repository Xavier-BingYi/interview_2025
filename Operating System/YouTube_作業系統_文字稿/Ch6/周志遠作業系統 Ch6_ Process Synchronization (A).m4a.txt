undefined
剛剛那個我們講很多他運作的方式所以怕大家混淆我想到一個非常簡單的例子讓大家知道有Active Cue跟沒有Active Cue的差別到底在哪裡只要想这个简单例子就好假設你有两个process一个process priority高它的time quantity只有10另外一个process呢它的priority低所以它的time quantity有200這两个process同時進到系統那前面的做法我們知道沒有這個active queue的话結果是當然priority高的先做做了10個time quantity之後它就結束第二個給它200對不对可是它可能只做了100它就結束了

那如果沒有Active Queue的话第二個Iteration來了大家的第二個CPU Burst來了Priority高的人他又會先做然後咧才能做Priority低的所以Priority低的而言他剛剛其實只做了100而已可是他剩下100還沒用就浪費掉了因為他Priority還是會比別人低有了Active Queue的結果是什麼咧就是第一個Burst一樣跟剛剛一樣Priority低的先做Priority高的先做Priority低的再做

那做完之後呢Priority高的人呢他會發現他的攤框可能都用完了，所以他會放到Expired Array裡面去，那Priority低的人他有200嘛，但是他只做了100，因為他框框可能就是長所以很可能就沒做完沒做完就代表他會留在Active Array所以當這兩個Process的第二個CPU Burst同時到的時候，雖然Priority高的人他是比較高的priority，但是因為

他上次就把他的time content用完，所以他會在Expired Array里面，那Priority D的人剛剛他只用掉100還剩100，所以他會在Active Array里面，那我們schedule呢當然一定要先從Active Array里面選完對不對，所以實際Priority D的人就是會先做了，所以就是這兩個有Active Queue跟沒有的差別就在這裡，就是不是完全是看Priority還要看你有沒有把當初的time quantum還剩下多少，你有沒有執行的權利所以你可以看到它最大的好處是什麼

就是某種程度是更保護那些time quantum比較長但是Priority比較低的程式，所以它畢竟Priority低嘛，所以其實它不容易被執行到，所以當它執行到的時候輪到他的時候就應該讓他把他所有的time content用完才不會因為像剛才的例子給你200就你只讓100就結束掉那你就損失很大對不對那對time content比較低的人他用完的他通常就會用的剩下比較少嘛所以當然他沒差可是對 priority 低的人他又很難被執行到然後又不容易把他的time content全部用完

所以一個solution就是引入了這個Active Array的概念所以讓他可以把他的攤框等用完這樣某種程度來講可能是比較fair比較可以對於這些low priority的人比較不容易會有這種執行上效能太過於被影響的一個結果所以這就是為什麼要Active Array的這個設計了

好,那我們就進入這個第六章， हम說最重要的是Synchronization。我們前面一直提到Synchronization，其實是一個很麻煩的事情。你在做這個Shared Memory Programming、Multi-thread Programming的時候，我們就說它最主要的是這個Drawback，就是會造成有Synchronization的問題。我們也提到Scheduling、CPU Scheduling，有分Pre-emptive跟Non-pre-emptive。 Pre-emptive Scheduling一定是比較好的，但Again，它會造成Synchronization的問題，所以我們就來仔細看一下到底是什麼叫做Synchronization的問題還有它可以解決的方式。所以你可以

看到一開始，我們會用一個例子很快就跟大家一起會到底什麼叫做Synchronization的問題，那接下來這個章節全部在討論一些Solution，從這個Critical Section然後到了這個用Hardware的Support的Solution到了一些Semaphore跟Monitor是在這些Programming Language裡面或是OS裡面提供的一些Tools或者是這些API。那我們會一一介紹這些Tools到底是什麼然後如何用它來解決Synchronization的問題好。所以為什麼會有Synchronization的問題呢？它的最主要的這個原因就在於說當我們會發生有一個Shared Data，

然後呢data當然就是一個memory address memory address、memory的content。你有一個shared memory content，然後呢它又同時被兩個以上兩個或兩個以上的這些執行緒，不管是process或thread也好，concurrent同時的對它做一些操作，就是rewrite的時候就有可能會造成所謂的data inconsistency也就是這個資料的值對於這上面執行的程式的這個它看見的這個值的這個

value有可能會有不一樣的結果。 Inconsistent就是不一致所以不一致就會造成上面我們知道程式執行當然都是follow一個邏輯的所以如果說你執行同樣的程式你執行下去有時候它的值是A有時候是B當然就會出錯對不對出錯是指說那個program levelprogrammer都沒辦法寫程式的意思對不對是那種所謂的出错好那

所以為什麼會有這個data inconsistent的最大原因就在於說這個值就是剛才這個被shared的這個memory content的值會因為執行的順序不同因為它concurrent嘛所以代表兩個人都會影響它的值那如果同時去access的時候它的順序不同會導致於它的結果不同的話就會有signalization的問題所以它的solution是什麼咧就代表你必須要去ensure它的ordering

因為不同的ordering會有不同的結果所以如果我們想要維持它的data的一致性的solution就是我們要讓這兩個process或是thread這些執行序之間要能夠cooperate然後make sure它們的執行的順序是一樣的只要執行順序一樣當然它的值自然才有可能是相同的所以這是一個基本synchronization講的就是這個東西就是因為同

時去access concurrent access data的時候會造成你的這個結果會跟它的ordering有關係那所以synchronizationprogrammer要負責什麼呢想辦法就是要常常在你的program裡面有辦法控制它的順序一旦有辦法控制順序你就可以解掉這個synchronization的問題了好那我們直接看例子很concrete的例子就知道這個是我們之前介紹過的

consumer producer的例子希望大家還記得操作一個shared memory buffer做input跟output那時候大家應該回去review一下那時候我們提供的例子是其中一個solution它沒有任何synchronization的問題但是它的缺點是浪費掉了一個buffer的space我們永遠會有一個空間是沒辦法存的那如果你想要把整個buffer space全部用完

然後在這個問題上的話其實solution更簡單你一定會想說我們就這樣implement就好用一個counter嘛那counter是一個shear的counter所以就是兩個程式的process都可以看得見的那當然producer就是++嘛那consumer就是簡簡嘛所以用counter我們就知道buffer是滿的還是空的問題好像就解決了對不對好像一切都很美好就是又簡單又容易懂然後這應該是很好的solution但問題是什麼

counter你除了buffer這個東西是shared之外或許你用counter解決了buffer這塊shared memory的使用了但是這個counter的值本身它又是成為另外一個shared memory content對不對那兩個人都可以對它而且是兩個人不只是讀更重要的是他兩個人對他對他做override的動作就是modify的動作對不對一個是對他的值加加一個對他的值減減所以counter這個值的本身就會產生synchronization的問題了那我們來看為什麼這個會產生synchronization的問題就像我們提過的counter加加只是一個statement是language level的

其實到了CPU的instruction level的時候它會被拆成多個instruction通常的computer都會把它拆成這三個我們知道它要先從memory移到register然後加了之後再移回到memory那簡簡就是同樣的那很明顯這邊register當然可以不一樣這沒問題但是memory就是counter這個memory所代表的那個memory address的counter是兩邊都會用到的好,那

當有這個情況發生的時候我們就來看在instruction level它的ordering會怎麼樣影響到這個memory content的值那這只是一個例子所以我們假設我們就先從producer的code開始執行那它有三個instruction但是因為有context switch因為有preemptive scheduler所以你沒有辦法guarantee它可以一次把它所有的code執行完對不對所以這邊

的例子就假設我們就只有機會執行前面兩個instruction然後context switch就發生了雖然它在一個CPU burst但是我們因為是Premium Scheduler有可能就把它做一個context switch那switch之後就可以開始執行consumer這邊的程式那前兩個其實都沒什麼問題就很單純把memory的值load到我們的register而已那這時候假設我

們再做一個content switch對不對所以一共有三個指令嘛所以我們當然就先回到這邊producer把最後一個做完那你會發現他的結果5先漏進來加1所以ax值再寫回去所以counter值是多少6那這個時候如果他做完了嘛所以當然我們就換另外一個人所以這時候consumer再把他最後一行做完這時候你就會發現consumer這邊他是漏進來是5

減完是4寫出去當然也是要是4才對所以我們現在的Counter值就從原來的值是5然後把它Override成6之後又把它Override成4了那這就執行完所以代表什麼最後我們Counter值在一次加加跟一次減減之後如果我們的執行順序是這樣的話它的答案是4當然不對嘛小學生都會Counter加加減減應該原來是5所以結束應該是5可是

這樣的ordering之後答案就是4這個就叫做synchronization就是代表已經不是跟你的預期是相同的對不對那如果我們今天把這兩個再倒過來所以任何嘛因為scheduling是wrong kind behavior所以假設我們今天有可能是先把綠色執行完再執行紫色答案會是多少是6也不對對不對那如果我們今天是一次把紫色全部執行完再綠色或者一次把綠色執行完再執行紫色的話答案才會是5，

所以這個程式你會發現它跑下去的答案其實有三種，4、5、6都可以當然我們知道5才是正確答案，所以這就是我們在提的所謂的Synchronization問題，就是這個所以，它的data的值不一致，它有時候跑是4，有時候5，有時候是6，而且這是因為它執行序的ordering有關，這個先決條件就是我們說的你一定是要有一個Share the memory的content，因為這個counter，

所以不同程式，如果你沒有Shared Memory Content是不用擔心Synchronization的不可能發生，但是當你有的時候就有可能會像這個例子一樣，結果是Depends on它的Ordering，那這樣當然我們的Program多半就是會錯掉對不對，所以必須要把它截止，那你也看見它另外一個限定條件，就是我們說的Preemptive Scheduler一定要Preemptive Scheduling，因為如果不是Pre-Ending Scheduling的話，

它實會把整個CPU Burst做完，意思就是它對它的Memory是一次做完的，所以就是紫色的一定是全部一次做完，它對Memory的操作不會操作到一半然後被別人給篡改掉，所以Memory的State是會是Stabilized的，所以如果是Non-Pre-Ending的話，就不會有這個問題，但Pre-Ending就是它執行到一半的時候你漏到Register的時候Memory的值卻會被人家去，因為Content Switch然後別人去Touchdown的Memory的Content

結果值就被篡改掉，所以Pre-emptive Scheduling就會造成這個Out of Order的問題，那如果是Non-Pre-emptive的是不會的，因為你漏到Memory你就會運算完就寫回去你才會被Context Switch掉對不對，所以不會有Synchronization的問題所以就是我們為什麼前面講到OS的做法是Kernel裡面我們不想要解這個的一個Solution就是把這個Context Switch這件事情這個Interrupt把它Disable然後把它換成non-pre-emptive的scheduler那code就不會有這個問題了好， 可以嗎好，所以知道什麼是synchronization之後這個synchronization則就是這個

剛才這個問題，那我們跟synchronization另外一個也是非常奇蹟相關的專有名詞這個就必須要記好race conditionrace condition指的就是在synchronization裡面更是特别值的就是你最后的值的结果会dependent你最后那个修改人的程式所以是在竞争然后最慢一个最后一个finish last的人会determine一个value的值这个就叫做race condition所以signalization其实广义来讲它还可以有很多其他的一些状况或是可能会发生的情形

但是 raise condition 就是在 synchronization 裡面又更特別指的就是這個最後 value會是 depends on 誰最後執行的這個condition 這個是一個狀態所以就是這個 condition 就是這個情況我們稱之為 raise condition那 raise condition 發生當然就代表你有 synchronization 的 problem或者說你要 synchronize 你的 processes 了好所以是剛才說的所以prevent risk condition你就是要去synchronize的這些process必

須要被synchronizeok好那solution就我們剛才說的啦第一種很暴力的方式就是我們disable這個inter ruptschedule的interrupt把它切換成non-preemptive scheduling，這就是有一些OS會這麼做，但是使用者的program絕對不能這麼做，因為你一這麼做你影響是整個系統的運作對不對，所以這個影響太大了，所以你也會影響別的使用者所以不違反了整個系統設計的概念那OS因為它很重要，因為它的這個Kernel Code很簡短，Priority很高，本來就很高，所以

可以選擇用這樣的做法，但是對於各位在寫Modest Programming然後你說你下System Code然後去Override Schedule的這個方式，這個當然是不對的做法，但這是一個Solution，但只 for OS 本身有時候會去這麼做，那一般的Programs怎麼解決勒一個標準的Standardize的做法就是把它定義成所謂的Critical Section的一個問題，所以我們就會先介紹這個什麼是Critical

Section好，那什麼是Critical Selection呢第一點，它其實是一個Protocol，因為我們剛才說過你要解掉Synchronization的問題，你重點是要Cooperate Processes，所以就代表大家必須要Follow同樣的一些機制對不對就是我們俗稱的Protocol所以Critical Selection到大家看到Solution的時候就會發現其實它就在制定Process之間的一個Protocol那只要大家都Follow這個Protocol

你就可以让他的ordering可以受到一个control那critical selection他的这个整个这个problem的定义其实很单很蛮简单的就是指第一个你当然要n个processes所以你才有concurrent access对不对然后你要一个shared data这个是risk condition或synchronization问题基本的要素所以你当然有一个shared data然后要n个process去 concurrently 对它做一些 access这时候你才有这个 issue那你的程式如果符合这两个条件之后我们就可以把它 break down 成不同的 segment就是不同的这个 section

定义也就是我们等下会看见的有 share 的这一块部分的这块 code我们就称之为 critical section所以 critical section 指的其实就是那一段会造成 synchronization有 raise condition發生的那一些程式嘛，就我們就定義所謂的critical section，那我們的這個怎麼樣可以解這個問題的方式就是第一個，我們找到critical section在哪，然後呢，我們要去上面要加一些

程式嘛，也就是所謂的protocol，在他進入這個section之前跟離開這個section之後要執行的一些程式嘛，讓他可以確定什麼事情？其實這是有一點暴力的解法，就是mutual exclusion，一次只有一個人可以在裡面執行，也就是說你不能夠有concurrent access，所以他把concurrent access這件事情把它拿掉了，所以就是所謂的mutual exclusion就是有一個城市，如果在critical sanction裡面的話，所有其他的城市都不可以進去，一次只有一個人在critical sanction裡面，那就等於是保護了

這裏面的程式嘛，這裏面的data不會有concurrent access的狀況，所以就把這個risk condition的一個必要條件把它拿掉了，這樣的做法就是我們俗稱的critical sanction好，所以其實簡單的就是這樣對不對我們都有程式嘛，那通常我們例子都用do跟while因為通常whole synchronization發生就是你重複的一直在做某件事情嘛，然後會access到一些shared

的data，那這就是我們刚才說你要去定義出來的這個程式碼里面要去identify出來的critical section的部分，然後其他的部分然remember也可以在最後面有一些可能在最前面不太重要就是其他程式碼就對了，那各位要寫的就是這兩個部分entry section跟access section，也就是protocol的部分，那所有的程式碼所有應該所有的程式 程式的process或是threads它進入critical之前critical section之前一定要先執行這一段entry section的程式，嘛離開的時候

一定要執行這一段exit section的程式，嘛，那只要透過大家都給人替大家都有執行的這樣一個方式，那你就可以保護中間確保一次只有一個人在裡面，這個就是critical section的solution的定義了，所以我們接下來的做法都是在討論entry section要怎麼寫還有 exit section 要怎麼寫才可以去確保 mutual exclusion我們剛剛談的都是 mutual exclusion所以 critical section你要去解這個 critical section 的話其實有幾個條件必須要滿足第一個當然是 mutual exclusion因為這是解決 synchronization 的基本要件如果你沒辦法確保這件事

你就有concurrent access你就會錯但是一個完整的critical section就是很complete的solution的話其實而且是以programmer的角度程式的角度其實不只是這一個因為當你在保證critical section在保證mutual execution的時候你可能會造成一些其他的issue那其他要保證的是什麼呢第二個就叫做progress所以我這邊通常就會喜歡講的一個例子是什麼呢就是大家去上廁所不太健康啦這個但是我覺得

非常好的例子上廁所我指的是一號那種那第一個你絕對不會跟別人共用對不對這就叫mutual exclusion所以共用絕對不行第二個progress什麼progress呢progress就是說任何一個process他不能夠這個只要是裡面是空的話那我就應該要能夠進去簡單的就是上廁所廁所裡面是空的那當然你就要能夠進去上廁所你不能被反鎖在外面說在維修這不行對一個城市的運作的意思就是說

你才可以讓這個城市可以正常的運作，你不会发生risk condition可是你也不能让城市不會動所以progress的意思就是你在城市裡面有critical section你可以保护它而且同時你還要make sure這個城市是可以繼續的運作的也就是cleo session裡面如果是空的沒有人在執行的話要進去執行的人一定要可以進去這個就叫做progress第三個第二個跟第三個是大家最容易搞混的但是我們用廁所的例子就非常容易解釋了bounded waitingbounded waiting的意思就是說

廁所或許一直都有人在用但是你不能讓想上廸所的人無止境的等待最後他就會完蛋對不對所以bounded waiting意味就是你等待的時間是要有限的你不僅仅是要確保progress只是確保說critical section有人要用的時候是有的是可以備用的所以它是always是可以busy的但是bounded waiting是指說當非常多人都要用的時候你也要能夠確保這個等待的時間是要有一個期限在那邊的那這當然定義很就是說

如果大家去看 當然也有一些數學的比如說linear timelinear to number of waiting process等等但是之後我們看見的原則其實很簡單就是你要有一個first come first serve的ordering通常你就可以解掉boundary waiting排隊嘛所以排隊你只要make sure大家是排隊的方式去使用critical selection當然你就會滿足boundary waiting的條件所以boundary waiting指的是這一個就是你可以看見當你的waiting time

必須要是有限的然後很多人在裡面在使用的時候你的等待時間還是要能夠有一個被綁得住的一個狀況不然就會有所謂的stabation就是有人會永遠都執行不到所以說一個正確的critical solutioncritical section的solution其實不只是mutual exclusion其實還有第二跟第三個條件都要滿足這樣子整個有critical section的這些程式的運作才會是正常的才會是正確的所以這三個條件大家一定要記得非常清楚然後要能夠區分這三個的差別.