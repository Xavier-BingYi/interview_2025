undefined
好， 剩下有問題的中午再來繼續找我不過剛剛找我的同學就發現有一個問題大家可以注意一下就是第七題在選說哪一個使用情境下他應該用哪一種page table的方式我題目上的讓你們選擇的寫的是inverted然後hash還有hierarchy所以hierarchical的page table並沒有說一定是one level對不對所以可能有一些同學在選的時候是想說他就是六個level或是multi level的所以他可能會很慢如果你是因為那個原因的話那你下面的選擇的這個B就是第二個情境是要快

然後你選hash然後說要省這個就是比較scatter的你反而用hierarchy的話這樣是可以的所以你們在自己我會再announce啦在我們版上面但是如果你的選擇其實如果你的就是說這C的B的小題如果你的第一個情境你選的是hierarchy,hierarchical page table第二個情境寫的是hash然後說因為hash可以in average它可以一個access然後hierarchy的

話因為它hierarchy嘛所以說你不會用到的thesub的the leaf level的這個page table你就沒有去create它的話也是合理的解釋所以大家再回去看一下這題如果有問題的話可以來找我那我會再看解釋只要是合理的話就可以給你們分數了其他也是所以沒關係你們有問題就來問就是覺得自己的解釋其實是合理的但是被扣分就可以來找我confirm一下畢竟這個沒有標準答案你只要解釋的是合理的你可以confirm說真的系統運作應該是這樣

會去想而做出這些決定的話當然就可以得到分數但這個是當初以為只有一個我以為我寫是oneone level的page table所以當然就沒話講但是如果是hierarchical那有可能是multi level他就會很慢那這就會有不同的選擇了所以有問題沒關係就是下禮拜我不在所以禮拜三就是這個禮拜我們會就是這個禮拜有問題就來一定要在這個禮拜找我就對了好不好所以

考試中考的問題一定要在這個禮拜內來找我不一定要在上課時間或私下約都可以就寫個email到我辦公室也可以好 那就這樣子所以大家還是稍微自己再留意一下自己的答案有問題來問我就是了好 那我們回到這邊說這個Semaphore這邊的Synchro跟Wait的實作方式之前我們看見是簡單用一個while loop的我們稱之為所謂的BZ Waiting的方式

或是spin lock那樣子很浪費CPU所以有另外一種實作方式就是所謂的non-busy waiting也就是它是用這個pull to sleep把它放到sleeping queue的概念所以是怎麼做呢基本上就是這樣子你可以看見semaphore這個仍然是一個semaphore的structure但現在它就複雜了我們不只是有一個value去記錄它的counter我們更重要的是其實它會有一個

queue這個waiting queue有一點像condition variable那樣就是一個waiting queue那只要是在等這個result就是wait on這個semaphore的人我們就把它放到這個queue裡面那這個queue裡面裡面放的是什麼呢就是processes也就是去call了這個semaphore而被卡住的這些processes我們就把它call to sleep我們就把它put to sleep所以它就真的是sleep的state就是remove 完我們的 ready queue 就對了我們在 OS

裡面對不對放到waitingqueue 裡面就變成 sleeping 的狀態然後呢為了要記住有哪些人在等所以這個semaphore 我們就需要有個 queue 把它串起來嘛所以我們就知道哪些人現在是 queue 在這個 semaphore 裡面等著被執行的那這只是實作所以這個實作的定義說這個 value 呢指的就是這個 queue 的長度所以它不一定是它不一定

直接對應到是Semaphore的數字而是說這個Cue裡面到底這個Semaphore裡面到底有多少個在Waiting這樣子所以Initialize其實是把它設成0因為Cue是空的嘛一開始那不同施作方式你當然有可以不同選擇啦我們這一個施作方式是這樣子那就是單純的Cue Length然後這就是Waiting Cue就對了好那

在這樣的data structure我們要怎麼去implement wait跟signal勒就是透過了block跟wakeup兩個system code所以這也是例子而已啦所以我們都知道了system code裡面一定都會有這個block跟wakeup這兩種behavior的system code就對了一個就是把process把它放到waiting queue裡面去OS scheduling的waiting queue然後另外一個system code是從waiting queue裡面把它拿出來放到ready queue讓它可以被schedule所以就是這兩個system code就對了

好那用這兩個 system code 去 implement 的話還要用這個 data structure就是像這邊這個例子就是一個 non-busy waiting 的 solution 就像這樣所以一樣是一個 wait on 某一個 semaphore 那我們 eventual 的目的當然就是可以看到這邊就是當 s the value 是小於 0那就代表我裡面的 q 裡面是有東西的剛才稍微忘記了這個 q length 可能是負數的喔所以可以看到負 3 是指的是

有三個人在裡面所以0 表示沒有東西就代表沒有人在等嘛所以你是可以進去的那如果-3就代表是有三個人在等了那如果一開始的值是 initialize成大於0就代表 simple for counting的數字對不對所以前面的人一定直到被減到0為止其實也不會put to sleep好所以總之這個 s。 value小於0就代表目前是沒有resource

的，所以我們知道就是要把這個process放到queue裡面然後去call sleep，所以這個執行這個function當然就是在等的人所以他就把他自己去call sleep所以我們這不好應該對起來才對回去再改一下這應該寫sleep或者這兩個是同一個東西就是put to sleep的system call就對了，所以他會被放到waiting queue也就是說他會沒有辦法執行了而且他不會用CPU，這就是non-busy waiting的意思，那我們

當然知道你要這個sleep之前對不對你的counter的值一定要去去做修動啊，因為代表你在等嘛，因為Q的長度加1嘛，所以你要減減對不對那你這個執行不能在這之後因為一快按call的這個就不會執行任何事情了，你就沒有機會被執行所以減減這個動作必須要先減掉再說，所以也因為它先減掉，所以你會發現

並不是等於0而是小於0等於0的時候其實代表是原來還沒有原來還有resource可以執行，所以這邊要小於0，因為你剪完之後它變-1了就代表哇，你要到q裡面等，所以才去call sleep才insert到q然後sleep的動作，那signal就倒過來所以跟之前就比較像signal，我們知道就是++但是除了++之外我們就要wakeup一個人

對不對一個process，所以我們就去看裡面這個q對不对看裡面的值，如果是小於等於0就代表有人是在我們的q裡面的，那如果在裡面的話，我們就要把它remove出來然後remove出來只是從這個data structure裡面拿出來更重要就是要wakeup，所以那個thread就會被叫醒，那它就可以break它的這一個function code對不對然後就可以進去執行了

所以這就是利用這樣的方式那這就是non-busy waiting因為你會看見程式碼裡面沒有任何的while loop所以我們CPU就不會去被浪費到，所以這是另外一種實作的方式。 Again補充這裡沒集到，但考試常常會問什麼時候既然我們有兩種實作方式請問為什麼我們always會用第二種嗎？還是我們有時候還是會選擇答

案是看情形喔這兩種實作方式就是剛才看到的spinlock跟non-busy waiting的兩種solution它有各自適合的情境原因是這樣子這一個看起來很棒沒有浪費CPU的cycle對不對可是有一個問題它call system call所以我們說過system call很慢它遠比說什麼S減減或是340刷新都慢你可能要把它想成可能這就4、5、10給你刷新了甚至於更多

所以說呢今天如果你等待的時間其實很短的所以底片長應用情境嘛對不对。如果你今天在等待的時間是很短的話你會用DZ waiting因為反正你只要執行個兩三個extraction就是while loop check對不對是不是等於0兩次之後你就break掉while loop了你就可以開始執行所以它就比較快可是呢這邊來講是如果你的waiting的時間可能會很久

如果waiting時間久的話你就會想要用non-busy waiting因為你等的時間久就是要等個五秒平均等個五秒你才有機會輪到你執行那你五秒這個時間對CPU是很漫長的時間你當然希望不要浪費時間在執行這個程式的instruction你就put to sleep就好把CPU空出來讓別人去做然後五秒之後等著別人把你wake up起來

那這個四聲控雖然比較久但是也是幾個mini second嘛對不對所以就depend on你waiting的時間的長短waiting時間短的我們喜歡用spinlockwaiting時間長的我們喜歡用non-busy的waiting的這個實作的方式所以depend on waiting時間的長短因為不要忘記這是四聲控所以其實代價是很高的你在那邊sleep跟wake up大家都

學過會contact switch rescheduling等等你也不知道什麼時候才輪到你所以會很久那如果是busy waiting你尤其像現在電腦都是兩個core對不對你是Multiple Thread在執行的所以你可能在那邊執行的時候另外一個人也正在執行過程中可能很快你就被trigger到你就可以break出了你的while loop繼續執行，你可能根本沒有被contact switch就有機會break他的waiting的這個這個core

好 可以齁所以 depends on 你的 waiting time去選擇比較適合的實作方式好那不管是第一個實作方式或第二個實作方式我們說一個很重要的條件它必須要是 Autonomic就是這兩個 function code你可以任何方式 implement反正一個必要條件就是它必須是Autonomic因為前面我們說那個值會加加減減這邊不但有加加減減還有Q的Insertion跟Deletion就更不用講所以不可能同時執行所以必須要是 Autonomic那我們就說怎麼去保證Autonomic第一個

嘛最暴力的方式OS可能會做的就是Disable Interrupt對不對那有時候這還沒有用因為甚至於你可能會有Multiprocessor對不對所以你disable一個CPU不去執行還不行你要把整台電腦都把它suspend掉只能有一支程式在整台電腦上執行這才會work所以非常不efficient第二種做法就我們說的才教完的我們可以用hardware support或者是software pure software就寫entry section和 exit section的方式所以這是另外一種solution所以靠近來的話不管是hardware support還是software support

就是我們要把它變成一個critical session就對了所以就像我們剛才看見的這個semaphore我們可以用軟體去寫它但是這個兩個function code就要用critical session把它保護住那因為這邊有if else啦所以大家查一下再去trace來就知道為什麼你要兩個access action因為有兩種case嘛對不對然後一樣wakeup那邊也是就整個要把它包進去就對了但是千萬不要把sleep跟wakeup包進去

因為你一包進去他就是都在裡面就是沒有人可以進去critical sanction因為這裡就是單純的system call不像我們剛才介紹的condition variable他會reacquire lock什麼這裡沒有這就是system call而已但是你不用擔心你反而不用擔心的是那萬一很多人同時call sleep跟wakeup會發生什麼事不會有問題因為這是system call所以OS他會去make sure sleep跟wakeup這兩個東西是

或是說他們不會有Synchronization的問題，但是OS提供System Code當然要保證他的這個Synchronization的問題是解決的對不對，所以他可能就Disable Interrupt了這個裡頭所以很多人同時扣Sleep跟Wakeup沒關係的本來就可以操作我們OS的ReadyCube好 有問題齁所以用這樣就可以達到Autonomic的這個要求了所以我們剛剛說的兩種時座的方式其實就

Depends on他的等待的時間到底是長還是短就像我們之前提到的要同步化的目的一個就是要去解決這種Risk Condition或是說在Counting的動作另外一個就是為了要去Control他們執行的時機點順序這件事情所以semaphore 其實很多時候也是拿來做這件事情也可以拿來去控制程式執行的順序這件事情很fine-grained 去調整所以就像這邊的例子比如說我們兩個 process 對不對然後我們說process2 呢一定要在process1

執行之後就是某一個 statement所以這兩個 process 然後s1s2 則是 statement所以其中一段 code 就對了那我們一定要這個s1 它執行它的 statement 之後s2才可以去執行這件事情要怎麼樣可以去控制它控制勒其實它的方式第一種方式就是用過這個用我們說的Semaphore，那怎麼控制勒就像這邊看到的其實就是這個概念我們

說S1要先做嘛，所以我們就讓S1做然後勒S2，因為要等，所以我們就先call wait然後勒這邊的sync是一個Semaphore，我們把它設成0，意思就是說它一開始是0的值，所以你如果去wait on它，你一定會被卡住對不對；什麼時候他才可以break這個weight勒，就是某一個人去call signal也就是P1這邊所以你可以看見這兩個程

式就算同時跑下去，一定是S1會先執行完這些程式嘛，然後去call signal然後勒P2勒才有機會break然後執行他的部分，所以你就control了對不对，所以一定是S1再S2沒有其他可能性OK齁；所以這是Semaphore就可以拿來做這一件事情很容易的就可以去控制了，那這是個簡單的例子我們就來看複雜的例子其實是完全一樣的概念，所以其實你可以

看見這邊假設我們有一堆的processes然後我們有一個複雜的data flow這個在其實在比較複雜的應用程式常發生我們就是有data flow的一個application都是這個樣子由一大堆process組成然後它的output可能是要餵給另外一個process然後這個process甚至有兩個人的output都可以對不對它會有一個Data Flow把它畫出來那為了要去enforce這個Data Flow我們就follow剛剛那個一樣的原則就好也就是說

我們會create一堆的Semaphore每一個Edge就像我們剛剛介紹完的就是P1跟P2的例子對不對那我們就可以把那個概念把它延伸到就是P2到P4 P1到P3每一個Edge就當作剛剛的一個Case就好然後就create一堆的Semaphore去保護跟控制它的執行順序就對了所以譬如來講就像這樣P1一樣要先執行所以它一定是先

S1就好然後呢每個Edge就是一個Semaphore在保護所以今天P2跟P3要等它那就代表我們有A跟B兩個Semaphore然後全部一開始都是0所以不可能執行對不對然後要Signal所以它就可以Trigger下一個Process開始執行了這就是P1的程式然後P2一樣嘛所以它只要是有 incoming 的 edge我們就 call wait 就對了有 outgoing我們就 call signal對不對然後中間就是你的 statement所以這樣子的話你就會看見 P2

它就一定要等 A所以就是 P1然後它執行完之後它才會 signal C也就是讓 P4 開始執行所以就用這樣的概念你就可以想見我們可以把剩下的程式碼全部把它寫完對不對有點囉唆啦 但其實就是一樣對不對所以就像P4我們隨便挑一個它是wait on C嘛 對不對去等P2然後後面有兩個所

以兩個signal然後像P6對不對P6的話它就必須要wait on F跟D兩個都要被signal之後它才有辦法開始執行它的statement執行完它去signal H以此類推好 OK齁所以這就是可以用Semaphore很容易的去做這個同步化的動作然後就可以控制整個DataFloat的進行所以我們說Semaphore

常常被用就是這樣而且常常其實是跨Process倒不是說跨Thread這一塊雖然說這些Synchronous這些Tools很好用啦但是就像我們剛才看見的我們的程式碼常常會因此變得比較複雜一堆wait一堆signal對不對而且都是使用者programmer自己去control的所以很容易發生的一個問題就是delock也就是說你的

wait跟signal的順序寫的不對或寫的不好造成了process之間互相等待的一個狀況然後沒有辦法前進所以最簡單的例子就像這邊我們有S跟Q兩個semaphore對不對就像剛才的例子一樣，實要先信號才能執行的那，如果我們今天就只有兩個程式，這邊說要先位檔S再Q，那邊說先位檔Q再S，那singular code在後面，所以其實都沒有人有辦法執行他的程式或者說，今天就算一開始我們的

Q跟S的設計是一好了，第一個人可以break可是他break之後，他可能馬上就位檔Q那這邊是先Q所以他把Q這個lock先拿走了，所以會造成P0卡在這邊然後S的話是P0先把S的Lock拿走，所以P1卡在S，所以這兩個人就卡在這邊，不管QS他，如果設計一開始Initial是1那就會卡在這一行，如果是0就不

用講就是卡在第一行就卡住了，他二單就有機會可是知道所以就是會有情況，他會互相等待然後沒辦法前進，這就是我們俗稱的Deadlock也就是我們下一章會教的，Deadlock 就是指互相等待的意思，Deadlock 發生之後造成的結果是什麼咧，就是Starvation，所以相關的不一樣意思Starvation 只是單純的講說以單一一個層次的角度，它永遠沒有執行的機會叫 Starvation，那沒有辦法執行的原因一個就是因為Deadlock

產生了，另外一個就我們教過的Scheduling 也有可能，Probability Scheduling它 Probability 太低嘛，所以它就 Starvation也可能所以有很多原因都可以造成stopation但是synchronization的這個動作過程中往往很容易不小心programmer的錯誤會產生delock然後最後就變成一個stopation的問題好這是我們剛才說的delock跟stopation就是指的是這都是會衍生出來的一些issue所以我們還有另外一個章節特別在解釋什麼是delock好.