undefined
好， 所以跟我們之前在那邊想對不對哪些variable是會造成race condition要變成critical section的想法是完全不同的了對不對；就之前是很多level以memory的角度在看解synchronization的問題這個問題你可以看到我們就是以 method 的角度以 programming 方式的角度然後去解問題當然就好寫而且也會對也不會有這些deadlock 也不會產生因為其實這個 monitor 本身它就會去保證一次一個人去 call而且 eventually 就會 call 到除非你無止境的在裡面等著那個人他自己不會出來而已；

看到完全的Code我們可以看一下怎麼樣去運作Exactly的話對起來就會像圖示一下就更容易了解所以這整個Pickup跟Pulldown這個Monitor到底是怎麼樣被使用的其實是像這樣剛剛那個只是Monitor的Class而已，所以你整個Program應該是像這樣；你有兩個Process或者是Threads那你會去call pick up 跟 pull down在你吃之前所以吃可以是任何的call你可以

嫌複雜任何的 behavior去畫圖都可以隨便你，但重點是這件事情就是會要有synchronization存。在所謂你左邊右邊的人不能同時吃就對了那所以為了保護這一個我們就會去call pick up 跟 pull down這兩個 message代表我完成這件事情我才可以開始吃吃完我去 pull down那另外的人也是一樣所以更多的使用都是一樣就是扣

這樣子的pick up跟put down的順序那一開始就像我們說的全部一開始就是think in the state那假設P1先來好了那他要吃所以我們就知道他會把他變成hungry然後去測試他是不是可以吃那第一個人我們知道測試的概念他一定會成功因為E的左邊跟右邊都在syncing所以他就會順利的test的結果就是成功

所以他的state就會被改成eating對不對所以他就會從原來的hungry變eating了對不對然後呢而且他因為是eating所以他也不會去wait的動作所以他就可以進去到eating的eat的action裡面去了對吧好那所以他就不會被等那這個時候假設他在吃的過程還沒有put down那P2就進來了然後他要pick up那一樣我們就去跑

這個你就會發現他會變成hungry但是他test的結果會什麼失敗對不對所以他的stay仍然會維持在hungry所以因為是hungry不等於eating所以他會被放到waiting list所以P2他就會被在monitor裡面給卡住了好那他就會一直卡住直到有人去把他signal嘛對不對從monitor裡面把他叫起來為止所以什麼時候被叫起來呢像這個例子來講就是等P1去code put down所以你如果去trace我們的code就知道put down的話第一個

就把自己改回到syncing沒問題然後呢他就會幫他的左邊跟右邊測試所以就我們剛才說的P1就會先叫P0去測試他說他只是syncing沒有hungry嘛對不對所以也不是在沒有要吃所以沒有發生任何事那P2就會符合所有的條件那他就會signal P2所以其實是P1去signal P2那P2就會被叫起來所以叫起來之後他就會去break他的叫起來意思就是不只叫起來而且不要忘記他也會同時把他的state改成eating對不對

就是在test裡面做的兩件事情那就代表他可以去進入到他的eat的動作所以P1 call of put down結束之後P2就可以進到eat所以大家就synchronize了好所以這個就是Dying philosopher就這樣就可以把它解掉了所以只有這個Dying philosopher這一個object是monitor所以P 1 P2這些都只是就是它的這個application而已

然後去使用這個class的方法去解好那我們來看這樣的概念在真實的language裡面當然都包裝得到你非常非常好用所以像Java你去看的話呢它就有一個叫做synchronized method的這樣的一個specialized的這個feature那它的用法就跟monitor是一樣但是它更fine grained一點所以你可以看見這都是大家很熟悉

的java的架構對不對那它在它的每一個method裡面它不是整個class當作一個monitor而是它在每一個這個class裡面的任何一個method你可以在前面加synchronized這一個turn那這個意思就是告訴它的compiler說這幾個method它們是有raise condition或者說它有synchronization的issue所以你不能夠同時執行然後也就是說

它很有彈性因為你一個class裡面可以有十個method你可以任意一個嘛對不對所以programmer可以去control哪些method需要被synchronize哪些不要但是你只要是貼上synchronize的字的話那這些人他就是要mutually exclusive的被執行那他導致不能再分哪一個set是就像我們有Mutex Lock有不同Lock你可以去分嘛，這個是沒辦法

的它就是所有你只要寫Synchronized method它就全部包在一起然後就是不能夠讓它同時執行這個就是Java去Support的方式所以很容易用那其實這個概念就是Monitor的概念所以它只是說跟FindGrain讓你有一些彈性不用所有的method都要Synchronized因為實際上應用一定沒有到這麼大的沒有到這麼單純的case都是更簡單一點對

不對好那另外一個Java裡面它support的這個勒這個其實比較接近是這個MutexLock這其實比較不接近Monitor但這也是Java裡面的那剛剛我們看到的這個synchronization是在method的level就是Monitor的概念那Java裡面在support另外一個synchronization的方式勒是在statement的level所以你可以看見它的用法就是你可以把一塊你的程式嘛一段statement把它框起

來然後前面寫個synchronized然後一個variable所以這個意思就是告訴Java Compiler說你的哪一塊的這個variable它是一個share的variable會有raise condition的狀況所以它在compile成你的這個final code之前它會自己去幫你加lock跟unlock的動作簡單來講就是它去passing the statement一看到你說的這個variable它就在前面加個lock然後後面加

個unlock去直接就幫你做這件事情所以幫助programmer啦其實沒有什麼你用MultiXR這些都可以但是它這樣就比較簡單嘛你的program就變得比較乾淨比較容易懂對不對意思就是這個P1就是會產生risk condition的share object或是variable的memory的content就對了然後這一段程式碼裡面就是有可能只要P1

發生的話它的動作就是要去做保護的動作所以它就是比較fine-grained的在statement level的一個synchronization的tool所以這是在language這邊我們怎麼把這些我們教的這些technique這些tool把它放進去的方式就是像這樣子當然每個language都不太一樣不過我們可以看到java的話主要就是剛剛看到的這

兩種方式那Pth讀了我們介紹過了，就有一些MutexLogConditionVariable的這個API可以用LibraryCode可以讓你使用好，所以這樣應該沒問題了所以這就是這些Classic的這些Signalization的Problem所以你可以看見為什麼叫Classic就是我們都是用這些問題來去解釋跟驗證一些Synchronization的Tool到底好不好用可不可以解決這些問題這些問題其實都是在

我們電腦系統一般軟體裡面非常容易見到的一些Typical的問題雖然說我們把它生活化，但實際上在Program的運作是Software的運作當中常常就是這些一樣的事情而已。最後我們這個章節最後提到的是這個Autonomic Transaction那因為為什麼會提到這個呢？ autonomic是非常重要在synchronization的這個問題裡面我們前面其實

用了好幾次這個term我們解釋過它的定義autonomic就是原子意思就是不可分割嘛那這個是一個形容詞那這個autonomic呢這個形容詞可以冠在不同的執行的level所以我們之前有介紹過像是autonomic的function對不對像是我們說這個single跟wait是autonomy的function因為它是一個function call嘛那是autonomy所以那個function

要一次做完或者說我們說autonomy的instruction那也是一樣的意思就是那個instruction反正就是要一次做完所以autonomy是形容詞可以灌在任何你執行的這個單位上那這個autonomy我們今天講的是transaction就是在我們系統這個領域其實除了所謂的這種instruction然後到了function level事實上還有所謂的Transaction layer的這個概念那最常聽到Transaction這件事情

大家可能聽過了就是從Database對不對像是我們再去做提款機這些交易我們都叫做Transaction所以Transaction其實就是變得更複雜了它是整個流程我們都知道提款不是只是扣一個function扣結束了它要到不同的銀行如果轉帳還 involve 兩個銀行的業務操作等等非常非常冗長的事情不過 anyway那整個包起

來就是我們俗稱的 transactions所以它是更大的一個概念了對不對那這個一樣我們也可以把它把 Autonomic 放上去所以這個主要是在 database這樣子類型的一種系統 來講的話，我們就會聽到這個Autonomic transaction 這件事情好，所以這當然跟synchronization有關，因為你只要autonomic我們知道就是為的是什麼就是要避免synchronization所以避免兩個人同時轉帳結果你的錢卻沒有加在一起而是只有其中一個人那完了對不對

或者一個人存錢一個人領錢結果你的錢居然變零塊了這都是有可能發生的，如果沒有synchronization把它解好的話，所以很多時候這些transaction就必須是autonomic就是要避免make sure the transaction的結果是正確的，所以我們剛才其實有稍微講過了什麼是Transaction指的就是這種Collection of Instructions，所以它更loose了甚至於是Function對不對所以說其實它是一種Logic把整件事情

做完的這樣的一個動作的流程就稱之為Transaction，那Autonomic的意思就是說整個動作它要嘛就是一次做完要嘛就是不做你也可以不做對不對但是你不要做到一半就對了，因為你做到一半我們俗稱就是它的State是Unstable的，就是你不知道這結果到底是什麼你也不知道怎麼去接下去或是繼續把它Recover回來那這就是一個問題所以你要嘛就是當作你整個做完或者是你就當作不要做所以我們知道對不對

存錢對不對他可能就把你就跟你講FailFail意思說你的金額沒有動嘛對不對你不能說Fail然後就我多了500塊我當然也希望這樣不然不會所以就是這樣all or nothing就對了就是autonomic的定義所以就我們剛才說的這個問題尤其像transaction這個概念最常見到的就是database當然也不止你也可

以把它想成像是整個file system或是整個OS的運作我們知道OS你整個電腦run到一半你把shutdown拔掉電你再reboot起來它要能夠繼續做下去或是你一發現每次跳電起來你的電腦開機很慢他在幹嘛在檢查他的File System他的State有沒有正確對不對你有沒有檔案遺失就是這個東西這個你

也可以稱之為就是整個Transaction當然Database是最常見的嘛好那對啊所以像我們剛才說的不只是DatabaseFile System Rewrite這件事情也算是一個整個嚴格來講的話你也可以把它說整個當作一個Transaction那其實只要是Atomic Transaction現在一般的做法其實當然也有不一樣的做法尤其是隨著時代的演進。但是最比較傳統比較Regular一般的做法就是透過這種所謂的Commit Abort或是所謂的To Face的動作來去Make sure整件事情是做完的。也就是說你在這個

雖然說你執行了很多的動作在 transition 過程，但是你做完之後你一定要再多做一件事情，就是做commit。你沒有做 commit 的話，前面的一些事情就算你在操作的過程中它似乎是發生了它也當作不承認就全部 rollback這個就是基本的概念。所以有些同學可能有用過 version control現在大家都越來越現代化寫 code有時候大家有些會用github 這些對不對

那你就會去做一些Commit 動作，就是在做這件事情所以 Commit 就是你最後要去確認它整個事情是做完的。如果Commit 失敗，一切就是 Roll Back那 Roll Back 就是 Abort所以它會Abort 的話，它就會整個RollBack 回去當作沒發生了。所以剛才說到對不對，所以這整個你要去保證Autonomic就是代表其實你要有能力去做 Roll Back，因為你事實上你在操作過程中它們是發生了

只是在最後一個 某一個環節他可能沒有成功那這時候根據了他人的定義你就是要有能力去 roll back當作 none 對不對你要嘛就是 oh 嘛 要嘛就是 none所以 oh 是一半其實難的是 none所以你已經做到一半了你要怎麼樣子把它回復到原來的 state那這件事情就是要透過所謂的 roll back 的概念好那Rollback對不

對怎麼Rollback其實一般的做法也一樣這個很general系統的都是這麼做就是你要做Login對不對所以你要Rollback就是你要知道發生什麼事所以一定你就會發現這些系統它都會做Login所以像File System它會做Login我們OS會做Login Database更會做Login那Login的目的就是把這些記錄你做了什麼事情這些步驟每一個Transaction的步驟

把它全部存在一個Stable的Storage所以你的系統可以Crash可以做任何事情但是你的Log絕對不能掉因為你有Log你才有辦法知道到底發生什麼事然後想辦法把它給重複回去所以就是透過這樣的方式你就有辦法去做Rollback的動作好那這只是例子啦所以大家只是這個只是例子概念上而已啦所以Logging你到底在Log什麼

不外乎大概可能就是這些Transaction的Name嘛所以你是第幾筆的交易你要知道它的IdentifyId entity然後時間它的動作然後它的最重要就是Data所以這整個所謂Recover這些東西就是Data的Value對不對所以原來是什麼舊的是什麼新的是什麼你才有可能知道怎麼去Reconstruct或者是把它改回去對不對所以就是把這些Necessary Information全部把它Log下來就對了那Log下來之後當然

你這單都是設計過的所以你要log哪些log太多你會讓整個系統效能變慢就光是在那邊寫log就好對不对nlog太少你沒辦法重建不過基本上就是在那邊去設計哪些怎麼log然後就可以去做rollback的行為了好所以馬上結束所以說這個基本上就是一般怎麼去保證atomic的方式n另外一個方式就是所謂的checkpoint因為剛剛login的一個issue是什麼

呢它沒有時間觀念對不对系統打開就開始做loglog到系統crash或是關掉為止整個時間可能是過了一年很多我們這個financial的server我們只能看到說十年你總不能crash我從元年開始然後去reconstruct十年吧這掉到幾年對不对n所以就會結合所謂的checkpoint這個概念所以 checkpoint 就是指我們都知道系統還原點一講大家就懂了对不对是 checkpoint所以為了不要每次從頭開始我們就會也會做 checkpoint 的動作目的就是我們把一個完整 stable 的 state

把它記下來那我今天壞掉的時候我可以從那個 checkpoint 開始然後開始做 rollback 的動作而不用從頭開始所以通常都是用這樣的方式去實現的那這就沒有什麼所以這只是 checkpoint 的時候它就會這個說法就是從這邊會記錄到底從哪裡開始然後就從那個 log 的地方再繼續接下去好那所以最後這個是補充就是跟 synchronization 有關係然後到比較 higher level不一定只是 OS而是各種這種系統這個 file systemdatabase system

等等的一個很 general 的做法還有一些很其實很多很複雜很花時間的 application都會做這個事情就是會run很久很多application叫你去做大器模擬你可能就要run個三個月才得到結果那你不可能中間一定會有fail嘛system fail那你就會去做這些checkpoint rollbackcommit的這些動作讓你可以減少可以增快你的recovery的時間好所以這也是synchronization相關的部分.