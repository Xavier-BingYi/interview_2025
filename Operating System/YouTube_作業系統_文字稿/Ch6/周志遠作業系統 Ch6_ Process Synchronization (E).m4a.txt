undefined
好，那我們很快看一下幾個題目題目的部分第一題就是名詞解釋嘛所以我想其實大家而且都是蠻基本的，所以我想大家就是回去，如果有被扣分的話就再看一下我們的slides跟課本。那基本上評分的標準就是一定會有些keyword，所以你一定要提到這些turn就對了，像system code就是OS的interface對不對或你說是一個function code去call OS的service，這些必須要有的，它不是一般的function code不是只是一個只是一個function code而已。 Connect switch應該沒什麼問題主要就是在process的

這個execution的時候我們做交換的動作，micro kernel os這邊的話來講稍微改演了一點點，因為想要讓大家記住它的一個非常重要的差異，就是它的這個溝通。第一個當然它是modulized os把它把一個os切成很多的component第二個非常重要的是它把不重要的component全部跑到把它移到user space，所以會要求大家提到說它不只

是Functional而且要把它移到User Space然後透過Message Passing的方式去做溝通，那當然你漏掉了這個Detail的部分可能就會被扣一分，那我相信很多人可能就因此被扣了一分啦，所以就是提醒大家這個非常重要的一個部分，不只是Modulize而已，更重要是它是怎麼被溝通然後這些Module被放在我們整個系統運作的哪一個

LayerHide Sharing應該沒有太大的問題。廣義的定義就是讓我們的CPU的資源做分享，那如果你想寫詳細一點，就是有這些Timer的機制所以定期的會做Content Switch然後Preview Instruction就是只有在這個Kernel Mode才可以Code執行的Instruction，所以其實它的解釋應該都是相當簡短的，所以就是那些Keyword一定要有沒有的當然就會沒有辦法給分

這個應該沒有什麼問題。大家回去自己看就好了，就是這個slice裡面的圖。那扣分標準就是你只要少了一條線或者是它上面的event寫錯的話，那就是扣一分那就是扣到沒有分數為止所以自己大概看一下就知道扣分是被扣在哪個地方了好。 第三題這個第三題第三題其實非常重要，我在上課的

時候還特別特別提醒大家，就是為什麼一般的電腦設計是把segmentation放在上面就是靠近user然後paging放在下面那這是非常重要的原因的話當然就是segmentation其實是比較符合我們的程式的code的organ ization對不對我們有這個code section我們有這個有放code的地方有放heap的地方有放localvariable的地方那每一個就是一個segment它大小不一定嘛所以就很符合segmentation的概念

可是當我們的OS要去管理physical的resource的時候就是這些physical memory的space的時候就希望它是固定大小所以我可以用很簡單的一些mapping對不對page table的概念去管理我們的實體記憶體的使用很快可以找到哪裡有空間然後也不會有external的fragmentation所以一個是以效能的考量那這個是很複雜的就讓底層

這個下面的這一層來處理那接近使用者的方便我們的compiler去compiler程式對不對放到memory的這一塊那就在用segmentation在上層所以基本上就是這樣必須明確的講出來為什麼它這個是這樣子ordering的原因好所以一個各三分嘛所以可以自己注意一下是哪一個部分可能有遺漏的那第三題似乎是被扣分比較多一些的啦不過上課其實還特別講過所以這個大家一定要知道為什麼

這樣子去設計為什麼這樣去應用你們學到的東西好第四題應該還好TLB對不對所以這個應用大家就比較清楚就是Pagetable的Caching就對了對 所以這應該蠻基本的為什麼要flush啊等等因為只有一個page因為很多的page table可是只有一個TLB嘛 對不對第五題dynamic loading linking所以這也蠻標準雖然答案有一點長啦不過大家回去看這個slice就知道就是不要搞反了就是了那所以loading的話其實只能是減少單一一個這個process

或是 program 漏到 memory 的時候它的 memory 使用所以你不用一次全部漏進去就叫做 dynamic loading那 linking 是在 process 之間它們有一些 library 有些 memory content 是 sharing 的話那就可以在 runtime 的時候再去看需不需要把自己的那一份漏到 memory所以它是 runtime 的時候才去 link 到它要去 code 的那個 function 或是 library因為有可能別人幫它漏到 memory 它就不用重複做這件事情

好第六題是Memory Map File嘛所以當然我們也特別有一個slice解釋什麼是Memory Map File然後它的好處壞處所以雖然我們slice裡面沒有明講但是上課的時候就特別提醒大家過它的好處壞處那稍微想一下也可以知道就是放在Memory，它的好處就是比較快，壞處就是它不太reliable，因為我們知道一停電Memory的東西就全部沒了，

那所以這個還有它操作的content有可能很多人去修改。現在正在學synchronization就知道放在memory content就是會有這個issue那你透過file system它就會幫你去保護這個檔案去解決這些問題。所以只要打一斷電打開word你只要按回覆東西就回來。但是如果你是用自己透過這個memory map file去access一個file的話那一斷電之後就自己要想辦法了，很可能就沒有辦法再recover回來了。好，那第三個就是這個memory map file到底會用在實際上對不對，所以學歸學,

但實際上應用到底是什麼那時候我們就提到像螢幕簡單想一想其實就是大部分的IO device其實都是透過memory map file的方式去操作的所以如果有請你去看Linux你就會發現所有的IO device都有一個對應的file然後這個file其實它不是真的file它就是device的memory然後它就是透過這個操作file的概念然後但是是用memory map file的方式去操作這個file然後就可以對那個device做IO然後很適合主要就是適合大量資料的這種傳輸的時候就是透過這種memory map file一次把一整個這個file data的partition把它寫出去的方式好

好第七題是不同的我們集了三個use case然後請大家去解釋這個這三個這個電腦系統適合什麼樣子的page table的方式那這最主要就是你要知道inverted page table的優點還有它的缺點對不對還有就是Single One Level一般的Page Table的優點缺點還有Hash我們要教一個Hash的Page Table它的優點缺點這個當然自己要先掌握

所以看一下Slice應該就會知道重點在哪邊了那不過你可以看到第一個Systems的這個很Scattered User Memory對不对所以說其實它用到的這個實際上它用到的的這個Page其實真的用到的Frame不是很多但是它的Page可能非常的散落第一小題當然我們講過啦就是為什麼要One Level的為什麼要把一個Table把它用不同形式存這是最基本的就是因為我們不希望Locate一個連續的Physical Memory一定要提到Physical Memory因為Page Table本身沒有辦法再做Mapping

所以我們才要把它break down成很多小的piece然後用這種pointer的方式把它再串起來這樣才可以fit in一個single frame也就是通常就是4KB大小而已然後第二部分就是我們說的那三個use case所以第一個case如果大家去看就是很scattered所以代表你有很多的pages但是並不是每個pages你都真的要去查它的它可能

根本沒有被使用到那你用hash我們知道對不對它就可以即使你的空間這個你可能出現的數字範圍很大可是你真正會用到的數字如果很少的話用hash每個bucket裡面的裡面會有的content的item的數量其實是很少的所以你可能就可以減少它的lookup的次數對不對第二個很快的Mem

ory嘛所以當然One Level是最快的最直接了當它只查一次Page Table就得到答案所以一定是最快的但是當然它就很多其他的顯示那第三個很重要的點就是說Large number of processes所以意思就是每一個Process如果都有自己的Page Table那你就浪費掉非常多的Memory空間就在存這些Page Table而已而且我們

又補了一個你不需要考慮page sharing的事情那inverted indexinverted page table壞處就不是一個concern所以當然就是inverted page table是最好的所以應該是還蠻明顯的啦所以其實就是針對這三個做法的好處壞處轉換成實際系統上的代表的意義好那第八題Radi的anonymy對不對所以我們有提到為什麼這個anony

my第一個當然是這個anonymy的意思是什麼所以記得是增加resource計算的資源或者說直接說增加memory frame的數量也可以那他的page的fort的次數不但不是減少而且他是會增加維持都不行必須是增加好然後為什麼這個很重要這個anonymy就是因為如果有這個anonymy的話我們作為系統對不

對所有系統管理者就很難去管理這個系統了因為他不知道我給他resource他對這個整個系統的整體效能是好還是壞那這樣我們就沒辦法做任何決定了對不對所以這是很straight forward的畢竟我們談過系統很多東西都是用tune出來的所以你如果沒有一些特性你要怎麼tune總不能random的亂tune吧對不對完全沒有

不知道會讓他變得越來越好的話就沒有辦法去tune他了好怎麼去解釋這個LRU對不對他是一個Vladi的這個他有這個沒有他是符合這個Vladi就是他沒有這個anonymy我想這個大家簡單來講就是他的定義嘛對不對就是anonymy就是你必須要如果給他越多的frame他可以cover更多的page那LRU其實是我們說往

過去history看嗎所以你給他越多frame他當然可以include越多的pages然後之前include的因為比較近所以當然也會被include進去這邊我們沒有要求到數學或很嚴謹的解釋所以只要把那個概念說得出來就可以那當然如果你覺得你有這個概念但是被助教扣分的話或是有被扣分的話這可以再來找我可以再幫你們看是不是合理的

好所以這不需要嚴謹的證明但至少要把那個概念說出來就可以第九題這個當然自己回去再跑一遍就好我想大部分人也都沒問題啦就是三個算法page replacement algorithm跑過去自己稍微注意一下如果不小心寫錯的唯一一點是我們評分應該算是比較彈性的意思就是說你每次的結果我們只會看你上一次

的為基準然後再去評分下一次所以不會說你前面第一個就寫錯那後面就全部都算你錯你就assume你前面的一個state是正確的那你下面發生的事情的結果是不是正確就可以所以如果你發現有多被扣分的狀況再來找我，那基本上也是反正有一個錯誤，那就是扣掉一分當然要indicate哪些page是會造成page 4的這個也不要忘記

寫上去然後順序沒有關係喔我們提說過的所以你這邊你也可以寫145比如說或是154隨便只要是三個數只有在那個欄位裡就可以了好這個大家回去自己仔細跑一下就可以好第十題這錯比較多那它的概念其實也很單純就是你有一個Program嘛所以我們說他就是只有用到一個page所以不要忘記每一次執行一個instruction其實就會去access那個code segment或者說那個page所以說第一個page當然第一個

page4就是在load這個program的時候發生的然後我們說一共有應該是有三個friends對不對所以第一個friends其實always是被這個code給佔住的他always會被用到因為每執行一個instruction就代表你要去access他一次所以很多人是有些小細節啦但就是部分扣分 部分扣分這樣子但第一點就記住其實Program漏進去之後一直去Access它的Instruction就等於在Access它的Code的部分所以第一個

Page其實Always站住第一個Frame那第一次其實會產生Page4之後就不會了那後面的話。咧其實大家也看得出來意思就是說第一個你要去想你的程式的這些Data在這邊來講就是A這個Array它被放到Memory的時候會佔掉多少個Page。那你當然大家就算一下嘛。 1,000個Element每個Element我們說應該是4個Byte對不對。然後每個Page是1,000個Byte所以意思就是每一個Page你可以放下250個對不对。

所以基本上你這個需要4個Page那當然就依序嘛。所以這題也是很單純就是從依序去讀這4個Page。那第一次Access這四個Page當然也是全部都是Page 4。然後呢我們是所以可以想到Page就是12,34。然後再4,321嘛。因為三個Friend第一個Friend被扣贊助了所以只剩兩個Friend是Available對不对。所以12,34進去之後當你讀回來4321所以43這兩個Access就不會產生Page 4了

對不对。所以一共就是code一次第一次掃過這個array四次page4所以五次了回來掃過來的時候勒43其實是會heat的所以不會產生任何page421這兩個page很不幸的又會產生page4LRU嘛對不对或者說任何的演算法之前都其實是一樣啦。所以21又不會產生 page421會所以再加兩個一共就是七個，所以大概是這樣子。其實程式就是這樣跑的，所以如果你要去分析為什麼

我們常常在說Memory的Layout很重要或是Data的Layout很重要尤其現在的應用都是所謂都是Io bump的，就是說你都是在讀資料的時候卡住，然後大家在處理大資料等等就是指的是你塞不進你的Memory你的Cache甚至你的Memory都塞不下會跑到Swap區。就是在討論這些東西，你去看分析你的程式，你其實是知道你到底

會Access多少Page等等的，那這個Pattern你可以看見，就是它只有兩個PageAccess可以被放在我們的這個Memory裡面，不會產生Page Form然後Code其實會佔掉一個好，所以很多程式啊，它去切資料的時候都用4KB。其實你會發現就是這個 magic number他要 match 我們的 page，然後減少 page 4是非常有效率的方式其實好吧，所以大家稍微知道了所以這是那個概念的一個簡單的一個情境啦。那真實的 program 很複雜，那其實還是會同樣考慮這個問題

好的答案應該是7，那你看到都有些部分給分啦，就是如果你第一個low program錯了就是會少一分嘛，然後後面如果要解釋所以如果你只寫個7那沒有解釋的話助教當然還是會把你的分數扣掉好，那有問題一樣就再來下課的時候可以來找我最後一題看似複雜其實並沒有很複雜啦，只是問的方式就是

多少個memory address的bit啊，所以大家就是根據問題然後從上面的字裡面去找答案就對了對不對，所以address bit不要忘記，就是address的bit的數量，所以這是page的offset嘛，對不對，所以就是page的size到底是多大這件事然後這個size要用幾個bit來表示對不對，所以我們就要找pageSize，我們就會寫欸，找到到了對不對，一KB那

一KB用10個bit嘛，所以就是10個，再來咧，這裡所以這是稍微一些細的大家稍微留意啦，我記得那時候有提醒主教考試前都教大家尤其注意這些播放，所以這個是它的size是整個page table到底要多少memory的空間去存，所以第一個你當然要知道這個page table有幾個entry然後這個entry的數量在乘上一個entry需要幾個byte那是你的答案，對不對，

那所以我們知道這個，一共是12個logic address嘛，12個bit，你用了10個嘛，所以當然就剩下2個bit，所以也就是4個entry然後咧，你要去找一個entry到底用幾個byte咧，我們有講4個byte的page table對不對所以那就是成長4個byte所以就是答案了好conquest switch 對不對這個是要去算你的這個MemoryAssetsTime的重點就是你的這個到底TLB有幾個heat對不對

所以還記得那個算法所以其實重點就是你去看這每一個他到底是不是放在同這個MemoryAssets是不是在同一個page還是不是然後是的話一樣我們的這個size對不對我們的這個entry的數量是只有兩個entry的所以你可以知道我們下面有寫

就是這幾個是miss的第一次access的時候所以這大概是第二個page吧所以這四個會有miss所以重點就是你要去知道它是access第幾個page然後按照它的順序來講的話哪一些會是被cache出哪一些不會那知道了之後就套進我們的公式了嘛對不對如果是miss的話你就是只要去access一次就好那如果是heat的話如果是heat的話只要access一次

你的TLB然後access直接access memory content如果miss的話你會多一個100因為你要access page table然後就算一下就好只要公式對就可以了啦所以如果不小心算錯就是partially扣一分而已啦好好最後一個最後一個就是logical跟physical都給你了那就問你到底他當初這個access page table裡面的frame number到底是多少所以其實也就是還有它是access page table裡面第幾個entry那其實就是把它轉換成physical和logical address的bit之後然後就只要去看前面的frame number跟page number嘛對不对

所以應該沒什麼所以page number一看是0就代表它是access第0個entry嘛然後physical number的前面的frame number是11嘛那就是第三個frame對不对所以只是要去找到答案而已其實就是找到正確的數字轉換成答案好就這樣子有沒有問題的有沒有有同學想要先問一下如果沒有的話就下課自己私下再來找我

雟然說OS有不少是背的跟基本觀念不過你也可以看出來就是希望在考試裡讓大家知道其實你們學這些知識跟程式的執行跟你現實中系統設計是有很多相關性的只是就是要套用進去你才會發現關聯性在哪裡好那上次很不幸的居然卡在一半所以呢我們就很快的先把上次卡住的

地方比較完整的跟大家再review一次然後呢我又幫大家再多補了一些內容所以讓大家可以知道更多一些好所以我們上次在講的是這個我們學到了這個synchronization對不對critical section的概念那在你寫程式的時候尤其就像Pthread這種你用Shared Memory的平行程式它就需要去處理所謂的Synchronization的issue那所謂的Synchronization在Programming的概念來講指的就是說去控制你這些執行序的執行的順序或者是它執行的時間點這件事情

那這件事情基本上目的就是兩大類第一類解決我們說的Race Condition對不對所以就是會結果會沒有辦法預測這個是Programmer不要的所以我們要解決這個Race Condition的事情所以解決的Tool就是我們上次介紹到的T-Thread裡面呢就提供了這個Mutual Lock這件事情所以你就可以用這個Critical Session的概念你不用去擔心怎麼寫這個Entry Session跟Exit它就包成一個方尋扣然後讓你去解決這個Race Condition的問題所以這是第一種用法

當然我們的上課裡面大家就知道了我們更希望去介紹的是進一步看lock跟unlock的施作方式到底有哪一些這是第一類的用法第二類的用法就是我們提到像是critical這個cond ition variable這件事情這個工具_it的目的就是要控制或者觸發這些執行器執行的時機點這件事情所以就所謂的 condition variable這樣的一個設計

那它主要的功能就是一個 variable 就像是一個 waiting queue 一樣就是一個 event waiting queue所以所有這些 thread 或是 process你去 call 它的時候你就可以 wait 就是你把它 block 住然後等某一個 event 發生那觸發這個 event 或是去把人家叫起來的人就是可以去 call signal 或是 broadcast所以你可以一次叫醒一個人或者是一次把所有在 waiting on 相同 event

的人把它全部把它叫起來讓它繼續開始執行它下一件事情所以你在控制它執行的時間點這件事那這就是 condition variable 的作用了那這個這樣子的這個設計在很多 language 裡面尤其是平行的尤其是 share memory 的這種平行像 thread programming 裡面你都會看見所謂的 condition variable那實作來講所以每一個 Library每一種 Thread Programming或是這種

Pyro 的 Language 它去 SupportCond ition Variable這件事情的方式就是它的Library Code Function Code的設計都可能不太一樣，這Depends嘛，因為Implementation，但是概念都是完全相同的所以我們提到的是像以Pthread again以Pthread為例的話，你就看見它就是Wave, Signal跟Broadcast那比較特別就是它的這個wait的部分除了要去wait一個condition variable之外，它還必須要丟一個mutex lock給它也就

是說，在pthread裡面，這個library裡面，它去用condition variable的方式是規定你一定要用像這樣子的寫法，也就是在call的人跟被call的人或是說，wait的人跟single的人兩個人都必須要在critical section的裡面，那原因就是我們提到的主要就是因為這個condition觸發condition的這個變數不是condition variable本身喔，而是會觸發condition variable的一些變數往往它需要被critical section給保護住就像這邊的x，因為你要去比較嘛，所以你也不需要它比較的過程中有人去動它對不對

或者說這邊再去modify這個變數，所以當然一次只能一個人去動它，所以以coding的角度，這個library pthread，它希望大家是follow這樣子的一個coding style去減少一些programming上面無謂的arrow免得到時候debug到瘋了對不對，所以它就規定一定要放在critical section的裡面純粹是pthread認為這樣是一個好的coding style，所以如果你今天去看其他的Thread library像上次有同學就有來跟我提到C++裡面的看到的就不是長這樣所以這是當然是可以的因為每一個language有自己的想法嘛對不對，那我們今天只能請注意是PthreadPthread是這樣子去定義的.