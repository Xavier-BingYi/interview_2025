undefined
好，那我們很快recap一下上次講到非常重要的部分就是兩樣的process的synchronization的solution就是這個Peterson大家應該要這個一定要記起來不用背而是去記住他的概念他的概念其實很簡單就是兩點第一個你有一個TURN這個Token那它的值只會是0或1是一個Bullying因為你就兩個Process嘛那所以0的話就代表Process0可以進去1就是Process1那這個進去之前你就可以想見進入之前咧或者說出來之後所以你一定要有一個TURN等於要把Token交給對方的一個動作因為你進入

進入之前或是出來之後總之在進入或出來之前你必須要把Token做一個交換這樣才會有輪流的作用那但是這樣子輪流的作用的話的一個問題就是你可能會有Progress的issue因為有可能拿到Token的那個人比如說Process0把Token交給1了可是Process1卻不想要進入的時候那Process0就沒有辦法再進入的對不對那這個時候就有Progress的問題

所以為了解決這個solution就再多加一個condition就是這個flag看看他是不是ready了所以說你會發現在等待的條件只有當對方有token而且對方又要進去的時候，這時候這個你才會被卡住，所以不要忘記分號在後面，所以這個實是會被這個block的condition，所以實這兩個條件都要成立，這個要進入critical section才會被擋住，所以這樣就不會有progress的issue了，然後當然符合這個bounded waiting所以因為它是輪流交換token對，不對

那上次提到這兩個程式，所以這只是solution對，不對這個solution，其實也不是說一定要寫成這個樣子一模一樣，那這個flag0等於true，他當然應該是要寫在進入critical section之前，因為就概念我們說他的目的是要說這個process是不是要進去了，对不對，所以你當然不能把它移到remember section或其他地方，因為那不是他的意思，对不对，你如果很早就把它設成這個true的話就會造成對方沒辦法進去，然後你自己其實沒有要進critical section，那就不會

滿足我們progress的那個目的，对不对，所以flag0當然是一定要放在while list最好是前面一行或前兩，一就是在你進入之前去設這個值就對了，不然它就應該是force那至於turn等於e這個動作，這個只是要把token交給對方啦，所以就像剛才說的其實這個你要寫在後面或前面倒是無所謂因為重點是只要token能在這兩個process之間交換exchange就可以

所以如果大家可以看的話前面我們說比較錯誤只有保持mutual execution的那個範例來講其實他就把token交換擺在後面這是無所謂只要能交換就可以但是一件事情你要做就是一定要交換所以如果這邊寫term等於0然後就可以進去的話這個solution就一定是錯的對不對你不能把token搶過來然後說我搶

到的人就可以進去因為如果你去trace這兩個程式碼的話你會發現他進去的時候他要進去的時候如果他設成turn01他一定會可以break這個碼然後就進去那另外一個人他輪到他了雖然說token似乎在這裡可是換到他執行他又把他搶走那這個人可能已經在critical section了那結果process1他又寫turn01然後去檢查這個

當然不行所以重點是token一定要交換就對了進入之前或者是出來之後那更重要的是這個flag0這個flag的ready的狀態要設起來這樣才能滿足progress好那三個證明大家可以概念上來講就是我們說的第一個mutual exclusion其實就是靠反證法所以你會發現月turn它只是一個 boolean值它一定是0或1它不可能同時存在又是0或是1

所以你可以證明他Mitchell's Cushing的條件會成立然後progress的部分就是你要證明的就是假設有一個人要進去那另外一個人他可能是不要進去的或者是兩個人都要進去那這種兩個情形發生的時候你只要能夠看他的condition有一個人可以進得去就好了就代表你的progress條件是符合的那如果兩個都不想進

去當然不用evaluate不是progressprogress兩個都不要進去當然沒有人會進去這是當然的所以這個證明的方式並不是只限於這一個solution而是今天任何一個這個synchronization的solution你要去證明progress的時候你就是要去檢查這一點就是當只有一個人要進去其他人都不要進去的時候那個人是不是可以進去第二點就是你要考慮到有可能很多人同時想進去的時候

你其實也要去檢查一下程式嘛是不是其中一個人會被選中當然不可能Multiple的人因為如果多個人同時被選中你第一個在證Mutual Exclusion就已經不符合了所以這是證明的方式上的方式是這樣子那當然這個Solution你可以看見根據它的Condition你就可以證出這兩個條件都會符合好然後Bonded Weighting呢它比較Tricky的一點

他的這個證明的方式一樣就是當有一個人要進去然後另外一個人是已經進去了維尼就是要要輪流的意思對不對所以這邊要證明一點是說一個在等的時候另外一個人是剛離開critical section剛離開critical section之後在等的那個人是不是可以進去那要去證這個事情的時候呢第一個你一定很直覺會想到是當然剛出來嘛所以他一定就是在執行這一行之後就是這些remember section的部分對不對所以他到remember的時候

P0應該是可以進去的但是第二點大家常常有時候會忘記的事情是其實剛出來的人他有可能因為沒有被contact switch所以他继续执行他下一个loop結果他又想要进去他有可能先执行到这些城市所以当他又想要进去的时候你必须要也这个condition 2的这个状况你必须要去证明去验证刚刚出来的那个人他会被挡住没有机会再进去

那這個solution其實很容易證明他會被擋住因為有token的關係因為有交換token對不對所以當他一離開之後其實他一定在他進入之前所以我們說這個turn可以在前面或後面無所謂但重點是他一定要把token先交給別人就對了所以別人是有priority的，那ready這個因為他本來就在等啦，所以他的ready一定是true

的，所以PE一定會被擋住，就它既沒有Token然後有Token的人又已經是Ready，所以PE一定會被擋住，所以擋住的意思是，雖然說它很快就執行到這裡了，但它會在這個File Loop裡面一直在執行這個Condition的Check，然後永遠沒辦法執行到Critical Section裡面的任何一個程式，這個叫做被擋住，所以它會一直擋在那裡直到我們的OS做了Context Switch.

Eventually所以一定會做Context Switch回到P0的時候這時候P0它就可以滿足這個條件，就是break了這個fire loop，然後進到critical section，所以這就是它一定會輪流的原因了，所以記住這個context switch的點，其實是不是說一人執行一行都，它其實是有可能執行任意數目的instruction可是他就是要被卡在那個entry section裡面不能讓他離開entry section

好，那這當然這個是coding上的一些注意的啦，就是cleo section的選擇，其實蠻重要，就是其實是越小越好，然後有時候你的選擇錯誤是有可能會產生一些delock的狀況像我們下一張也會說的好那剛剛是兩個那為什麼是兩個就是因為注意到那個TURN只能是0跟1嘛所以P0就會把它設成P就會設成1對不對然後交換就好很明確但是如果你有N個人剛剛那一套就不適用啦因為如果是一人一個數字第一個

你要把數字設成多少你要把Token交給誰不知道對不對那谁手上有Token你也会不知道啊所以Under Process的时候就不能用刚刚那么简单用一个传递Token的概念去解它那解它的方式就是我们上次说的其实就是排队所以Again概念其实通常不会太复杂的所以概念就是我们说的就像各位去邮局去买东西一样的就是我们就是排队大家抽号码排人流进去就对了

那只是說我們講到抽號碼牌這個動作本身就有好幾個instruction所以抽號碼牌的時候有可能會抽到相同數字那這個是唯一在實作這個演算法的時候要去留意的部分那它的breaker去把它的type breaker的方式其實很簡單可以用一個PID當然eventually你要定義嘛一個type breaker那PID我們知道是每個process是unique

或說Thread也是Unique的ID嘛所以就可以拿來做Timebreaker但是你還是要處理怎麼樣子可以讓他們抽到相同的號碼牌，然後又可以知道他的Ordering好。 所以這個是Solution看似很長我們把它Breakdown下來，你就會發現其實也沒那麼複雜。所以第一個我們要做抽號碼牌的動作，所以這個大家一定可以想像寫的方式就是這樣，Number i，

所以這就指的是i就是第i個process，所以一樣跟剛剛那個flag的概念是一樣，我們就用一個array然後每個element就indicate每個process目前它抽到號碼牌的數字是多少，這個array當然是一個大家都share的variable，所以大家知道大家的號碼牌現在數字是多少，但是它雖然是share variable,可是有一點是他去改動的人只有hold那個number的人對不對

所以pi只能會改number i這個字就是write的動作其他人都是read而已所以number i這個數字本身不會有synchronization的問題因為只有一個writer對不對其他人都只是read only嘛所以這個數字是多少是很明確的好那就像剛才那個flag我們也有沒有討論flag i他的值會不會有問題沒有討論因為不要忘記他

只有一個人去override他其他人都是read only好那number i這個怎麼去抽號碼牌對不對就是一個簡單方法就是用max嘛對不對所以每一個人的號碼牌那我就先看目前抽到最大的數字是多少加1嘛對不對所以這就是可以抽到一個新的數字然後是supposedly是unique但是其實並不一定為什麼勒就是因為有可能

不要忘記這個max看似一個statement其實是好幾個instructional所以當你有多個process或thread在執行這個statement的時候其實有可能因為context switch然後我們之前的例子可以看到他們抽到的號碼拍最後有可能一樣所以就是為什麼會一樣的原因它不是只是一個instruction其實它是好幾個statementmax這個本身就是一堆if-else的comparison對不對

好但是我們先不管它正確不正確這個是抽號碼牌我們知道我們必須要寫的一個statement就對了好然後呢就follow我們的概念第一個當然就是去比較數字嘛對不對那所以一個process i對不對它要進到我們的critical section之前當然就是去比每一個人所以這是一個for loop對不對跟每一個人手上的號碼牌的數字去做比較那如果是0

代表他根本沒抽啦所以0是代表沒抽所以如果不是么你就根本不用理他，這個人就直接可以跳過去，那如果他不是0的話我們才要去做比較，那這邊0是代表沒抽，所以如果不是0你就根本不用理他這個人就直接可以跳過去，那如果他不是0的話我們才要去做比較，那這邊只是一個我們之前說的就是一個PID先去比Number再去比PID所以IJ是PID

前面是你的號碼，所以這是sudo call了所以已經簡寫過了我重點就是比號碼牌再去比pid就對了那就像我們之前說的你的號碼牌，這個j這個i的這個人一定要比較大嘛對不對如果這個j是另外一個人，如果有另外一個人他的數字是比你大的話，那你就會卡在這個while loop裡面，就會停在這個

while的condition裡面對不对，所以這是在跟j這個人去比，那如果j這個人的數字比i大，我們就會卡住那這個一樣啊，這是while loop是condition所以符合這些是卡住的意思好，所以你抽到這個號碼牌就必須要比它大，你才可以break這個while loop好，那這是first come first serve的意思對不对，所以號碼牌越大的就可以越先去，我

講反了越小的是越先啦對不对，所以數字抽是越抽越大啦所以說數字如果別人，所以J這個人比你小的話，代表他是先抽號碼牌的人嘛對不对，所以他會卡在while loop講反了是數字越小的代表你先抽所以你可以先進去那抽的號碼牌一定是越抽越大所以才會有O的概念所以滿足他有抽號碼牌而且別人有抽號碼牌而且別人抽號碼牌比你小你就會停在這個while loop了對不對所以就會卡在這邊好所以這個是

基本抽號碼牌的意思對不對然後當然你抽你這個如果你可以break就代表輸人的號碼都比你大所以你才可以break所有人的while loop然後進到critical section離開的時候我們就把它設成0就代表他不要進去了對不對所以別的人要進去的話他會看見你是0所以他就會break這個while loop有問題齁所以就檢查有沒有

抽號碼牌抽的是不是比我小來決定要不要等好所以這三行應該是沒問題因為就是基本抽號碼牌的方式那接下來你就會發現了我們卻又多加了三行choosing所以這就像是一個lock一樣他的意思就是choosing i的目的就是去告訴我們process i 這個人現在是不是在抽號碼牌這個動作對吧因為我們抽之前把它設成 true

嘛抽之後把它設成 force所以這個值如果是 true 就代表i 進行抽號碼牌他的目的是要告訴其他人我在抽號碼牌那你就會發現我們在比較之前在跟任何一個其他的這個 j任何一個 process 比較之前我們必須還要 additionally 去檢查這個人他會不會正在抽號碼牌因為他如果在抽的話就代表他的數字正

在改變當中對不對因為他上次原來原來他抽之前數字是0可是如果他在抽的過程他或許現在只是0可是抽完他就不會是0對不对所以說你如果太快在他抽之前就跟他比的話說明他抽完數字跟你一模一樣對不対因為他有可能雖然比你晚抽但他有可能抽到相同的數字完全看Context Switch的點在哪而已對不对

所以有可能抽到一樣數字但是他是比你晚抽的而且比他晚抽不只如果晚抽的這個人他數字跟你一樣而且他的PID又比你小那你就完蛋了因為他比你晚抽你以為他不要執行結果他抽完之後跟你一樣而且PID比你小所以其實他是該先執行所以這個Choosing的目的就是當一個Processor他正在抽的

時候其實我們要等他等到他抽完他的這個Memory的State他的Content的State穩定了Stabilize了我們才能夠去跟他比所以這就是為什麼要加一個Choosing在這邊做Protection的目的因為抽的過程數字會改變所以要用這樣的方式去Indicate然後用一個HotLoop就好對不对所以你可以想見這边就在等等这个Process J抽完之后它会把它设成force，所以这个Process I自然就会break这个condition，然后就可以

跟J它抽完真正的数字去做比较，所以会需要多加这一个机制去保护，所以就是我们说的其实Max这个number这个值它其实它的值是必须要去做保护住的，不是被别人影响而是它的有可能抽完之后，它的数字会改变好，那這演算法看似好像蠻多行的，但其實你看它的概念是很容易去證明它一

定符合Mutual Exclusion因為一次只有最小Number的人可以進去嘛，所以Number 是 Unique而且你用PID去做 Type Breaker所以不可能同時有兩個人符合條件那它還符合Bondi Weighted因為First Come First Served所以其實Bondi Weighted是蠻好證明的就是只要是First Come First Served的演算法一定都符合那progress也沒問題啊，因為你可以看見你會有個for loop對不對for loop，所

以任何人只要裡面他的值目前的確是最小的那個人他一定可以break這兩個while loop然後進去到他的critical section對不对所以也沒問題所以其實證明反而是比較直接的好，那這是我們剛刚說的那個例子啦就是choosing為什麼一定要因為，如果一個很concrete的例子，你看到是像這樣子，如果沒有choosing就是沒有那個

locking的機制的話，你有可能是現在號碼牌假設是5，最大的holding這個number，這個值假設是5的話，那假設你有1跟4兩個process正要進到他們的critical section裡面，那P1所以這是PID喔，所以1代表其實是PID小的喔４４比較大的，所以其實P1有比較高的priority，那抽之前我們知道它的值一定都會是０，所以P1跟P4其實一

開始都是０那如果P4它先抽完，就是先做完那個number的動作進到它的while loop裡面去檢查的時候，它的值是６，那它會發現它就是最小的，然後P1的值是０嘛，所以它就不管它 對不對，但是他進到Critical Selection之後P1這時候他才把他的號碼牌抽完結果一抽完發現我也是６啊對不對，那６跟６根據我們的Time Breaker１跟４都是６可是P1的PID比他小，所以P1也會進到Critical Selection所以你的Mutual Exclusion的這個Condition就被Violate所以兩個人其實都會進去所以這是一個

比較這個要仔細去看的時候才會注意到的一個issue這就是為什麼s同步化有時候不好寫不好驗證，因為的確有很多conditions它的ordering對每一個instruction都有可能做context switch，而且如果你有N個人這個combination是無止境的對不對是它要學會complexity它不是這個P的問題所以說其實它是很難被證明所以說theoretically然後就要去檢查這些detail好那如果有locking你就會知道其實P4會被擋住對不對所以P4他會等到P1抽完抽完他就會發現1跟4答案都是6所以P4會被擋住所以P1才是正確的選擇這樣才會是一個正確的演算法好可以齁所以這個choose.