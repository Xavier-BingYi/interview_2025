undefined
好，那接下來我們就要介紹這個Directory就是資料夾了。我们都知道檔案當然是最主要是存資料的這個Logical unit，但是當檔案很多的時候我們要怎麼去管理這些檔案那所以當然就會有所謂的資料夾大家都知道檔案是放在資料夾下面。所以我們方便去找同樣的對人是這樣對整個系統的運作角度

也是一樣。那再講多一點呢，大家需要做一個區隔的就是其實除了Directory之外，我們還有所謂的Partition跟Variant。就是在存一個檔案的時候，那Partition跟Variant在中文的角度或是大家常常就是所謂的槽嘛磁區跟槽。所以Variant就像你是C槽D槽然後Partition就是你的去對一個硬碟或是儲存的device做切割的那個動作。切出來的那個part，那個就是說成了Partition。所以真的在儲存把

檔案map到story device上的時候其實還是會有這三個我們用這三個這個方式去做管理。那尤其呢，partition跟variant大家要記住他們倆其實指的是完全不同的東西。就是Variant指的就是在Partition上面格式化之後有了檔案系統之後的那個詞區。我們就稱之為Variant了。所以我們來買一顆硬碟來對不對我們要去灌系統或

是說要去開始存檔案之前，我們大家知道第一件事情，你可能就會做partition，就是把它做切割。我到底要切多少個，這個空間出來是當作一個儲存空間對不對？然後呢，我們就開始對它做formatting，也就是格式化。格式化格式化在幹嘛呢，就是在這個partition上面去建立一個檔案系統，所以我們就可以開始以檔案

的方式開始做儲存了。那，這時候這塊空間就從Partition變成所謂的Value，那這個Value之後就是指的重點就是它是指的是有File System的一個Partition好，可以齁那所以這個Partition或者說Value同樣的嘛對不對，只是用檔案系統沒有在現在的電腦應用來講，實是非常有彈性，因為軟體其實是可以做非常多的事情，包括我們之前聊到像虛擬化等等對不对。所以.

partition它甚至於像我們知道它原來的話當然是指的是一個physical硬碟或device，你把它做切割可是現在甚至於你可以是你也可以變成quad，所以一個partition你也可以是group of multiple disks或者說storage device這個也是做得到的所以，我們其實可以每一個硬碟只有兩題嘛，那如果我們想要一個檔案系統，它一個槽就十題怎麼

辦？其實，我們現在也都做得到對不对，就是在上面用這種透過network方式的partitioning然後把它把五個硬碟全部串在一起變成十個那就變成一種分散式的概念所以這個其實也做得到所以partition並沒有說一定要對到一個硬碟它其實可以跨也可以做部分的切割那當然呢受限於這個Storage的Device下面硬碟硬體啊畢竟各式各樣的IoDeviceStorageDevice特性也都是不一樣的所以也不是說所有的StorageDevice它都可以被Partition對不對

像是我們知道一些Floppy或是CD-ROM這些東西它是沒有辦法被Partition的它就是一個Partition你沒辦法去動它當然也有這樣子的狀況好所以這就是所謂的partition跟valid所以記得partition就是一個road的這個valid那format之後它就變成了一個partition format之後它就變成valid了所以重點就是有沒有檔案系統的差別所以補充一下像我們剛才竟然提到檔案系統跟database嘛對不對所以像database

它也是一種跟Filesense的角色很類似只是它捨破Random Access Behavior的應用對不對那Database它當然也需要把資料放在 Storage Device上啦那Database它用到的Storage Device就有時候其實很多是沒有做Formatting的它要的就是一個Row Partition然後你就直接在上面就可以建立Database因為管理方式不同嘛你可以想建它要建Index啊等等

所以他根本不想要用File的那樣的形式像是我們知道Table通常常見的我們傳統的Database用這種Table的形式我們都已經知道每一個Raw的大小是多少所以何必在那邊還要考慮幾個File勒我就是直接我要怎麼使用就直接切了那就直接用這種Raw Partition當作Database儲存的Device就不用Format沒有人說一定要透過File System

包括我們最後也會提到的像我們之前提到那個swap的space的管理對不對那個也不需要透過file system他也是只要給他一塊raw partition就好不需要八連了好那最後就是directory當然大家就非常熟的啦對不對只要講所以最主要就是在這個檔案的管理上怎麼樣把它用這種切割分類然後比較容易去找到你要的file的位置

這個位置指的只是說它的logical的位置就是它的file的一個pass而已所以這只是剛才的示意圖啦，所以我們知道這邊Disk12所以這是physically的storage device，但是我們談到的Partition或者說partition變成一個Volume之後，它其實是可以存在同一個Disk或者是它也可以跨這個沒有一定的然後當然，這個Partition裡面會有哪些這個data

structure我們之後當然會講介紹更仔細一點下一個章節的時候，那。但基本上，你可以想見一個Partition當我們把它Format變成一個Volume之後的最大差別就是一個Volume一個File System就會記錄這些所謂的Directory還有File的這些data structure對不對，那所以你會看見通常會把directory的資料先存好然後再從裡面你找到了你要的檔案位置之後

他去再找看看這個File的content是存在哪裡的那Directory所以現在當然大家其實都很清楚知道Directory其實就是一個樹狀的結構對不對，那可是在早期的時候當File System這個這樣的System還在去想第一個先知道我們好像真的需要File System然後第二個呢去想說File System到底應該怎麼去管理File的時候其實也是一個過程所以最早的時候的這個directly的想法尤其當使用者不多file不多的時候，

其實是很單純的就是你可以說沒有directly或者說他就叫做所謂的這種single level的directly就是一個這個一個directly的名字對到的就是某一個file，所以這個Directed名字其實它就是像File的Name一樣然後對到了這個下面的FileName才是它真正Machine的Unique的ID，因為大家不可能記Unique ID對不對記這個Human Unreadable這些Number，所以我們第一

個就是去建立這個Directed的目的，其實單純只是為了要能夠把你的FileName對到某一個Unique的File的這個位置而已，這個Content這個Object，所以這是Directly一開始的目的其實就只是要去找這個mapping而已那當然這兩個mapping很重要的一點就是跟我們之前介紹的都不同就是file它是必須要是persistent的就是永久存在也就是說你今天斷了電，我們知道檔案不能移失嘛對不對，所以說不只是file的content必須要存在我們的硬碟裡面Directly的information一定也要存在硬碟的裡面要寫到硬碟

對不對，不然如果在Memory裡面，它可以當Cache暫存等等。但是，Eventually必須要寫到硬碟，不然它就會有遺失的問題。所以，Directly跟File其實它們都必須要是存在硬碟的，只是在運作的過程中會被load到Memory、load到我們剛剛之前介紹的這種System-wide Table或者是Open File Table裡面去方便我們的Process去操作而已。好，所以這當然就directory動作

當然就更少了。所以，directory可以用哪些operation當然就是這些。你可以create file，所以create file也是part of directory operation，因為你要加到這個directory的這個structure裡面去對不對，所以才能夠知道這個file的存在。所以，delete、 create其實也算那當然rename大家都知道的也是那另外一個大家可能會忽視掉的是list directory就是當然大家都知道那是什麼意

思，就是把它秀出來對不對。但是大家可能不知道的事情是這個動作勒在現代的file system的設計來講恆常是一個bottleneck，就是它是最耗時間的那個operation，因為一個directory裡面一個很大的檔案系統其實裡面的file會非常非常多所以今天如果你要list一個folder裡面是有一萬個file你可以去想想看你要吃掉多少

memory然後花多少時間才能把那個資訊給全部撈出來從disk那你更不用想其實現在的這個檔案系統很多是tree因為tree還很深或是很多使用者所以在真實的一些很大型的系統裡面如果你隨便下個ls說把整個檔案系統資料全部撈出來我只想看一下哪些folder跟file等等你恐怕會卡得非常非常的久所以其實它是一個非常非常耗時的動作因為它等於把整個directory把它給dump出來一樣而且是從這個disk裡面讀出來所以這件事情

其實是在設計整個fileset的時候就是在這個directory這邊的時候一個蠻大的一個考量另外一個當然就是你怎麼找了所以像是我們給一個file pass對不對比如說home下面的jump然後下面的homework1然後對不對在a。 txt你怎麼樣子可以很快的去traverse這個directory或者是甚至於它不一定要用tree的形式存嘛！它其實還

可能用hash的方式啊等等怎麼樣可以在這個directed structure下很快的找到你要的那個位置？這個是這邊設計的另外一個issue好！那這個Directory像我們剛才提到，它的設計最早的時候是非常單純的就是只要找Mapping因為我們不想要記這個Human Unreadable的這個ID所以我們希望有些File Name還可以Rename等等對不對？所以Name裡面往往都是有含義的，所以讓我們知道到底是什麼檔案對不對？那所以最早的時候只是為了一個這樣的單純的目的所以就是所謂的Single Leveled Directory

也就是你可以說它好像沒有一樣也就是它就是一個root下面然後就全部都是檔案名稱就這樣沒有folder！但那也是一個directory，因為其實那就是第一個level directory，你的filename直接就是對到那個file，這就是俗稱的single level雖然它沒有folder，但它是一個directory好！當然在這樣的架構下，我們知道它的file name當然是unique因為我們

都知道同一個資料夾下你不能有重複的名字嘛對不對？不然怎麼去做mapping所以它就必須是unique，所以這就會是一個問題了，因為當我們的檔案越來越多的時候，而且如果是很多使用者在share同一個這個資料夾或檔案系統的時候，那當然很可能會使用到相同的名字啊像A. out好像每個人都用A. out對不對那你就overwrite掉或者是就沒辦法產生因為他說已經exist所以就比較難去維持它是unique的這件事情

另外一件事情就是剛才說你要去dump你要去list你到底有什麼file的時候它的efficient會非常差因為它既然沒有選擇它就是scan through 對不對那很多的當然不是你的檔案等等就會非常的沒有效率所以這當然是skill小的時候 早期的時候只是為了要解決magging是ok但是大家發現當我們的使用者越來越多然後檔案越來越多的時候就開始不行了所以當然很直覺的囉那既然是一個level不行就用multiple level嘛那這個multiple level

指的就是folder的對不對所以我們就有資料夾的概念就跑出來了對不對所以除了檔案名字我們在這個direct裡面我們還會加入資料夾所以有user1 user2等等對不對那就會比較好去解決剛剛第一個是找我就可以list也只會list我自己的file我不會list跟我毫無相關人的一些information然後我要找我現在可以開始用 traverse 的方式了對不對

所以就 pass 的概念就跑出來所以就會比較容易的去尋找到你要的檔案了因為最後 eventually我們要找到的就是這個 link其實是這一個那這個是這是 unhuman readable 的嘛對不對所以 file name 我們都知道可是這個到底對到哪一個 id這個就是 directory才真正的目的是這個部分好好那有了這個Multiple Level接下來呢就像我們知道就開始越長越大就變成為什麼

一定要Multiple Level為什麼要Two Level或是Fixed Level我們就可以變成Tree了嘛對不對所以就把它變成是可以是任何的這個Level每個使用者可以自己去Create我想大家都很熟悉就是現在的檔案系統的方式就是這樣子那在這樣子的這個架構之下我們知道的就是你會有所謂的絕對路徑跟相對路徑對不對所以所謂的相對就是你目前你在這個在 file system

裡面你其實可以去切換資料夾意思就是你在 traverse 這個 tree 了然後在你的目前位置然後相對於目前位置的這個檔案的位置我們就稱為 relative相對路徑對不對所以很多時候是為了方便啦另外當然就是因為我們這樣子就可以在這個整個資料夾裡面我們就可以使用者也可以在這tree裡面做triverse的動作然後就方便使用最主要最主要其實是方便使用而已因為eventually其實系統在process的時候

多半還是會把relative的path先換成absolute path然後再開始做剩下的動作不過這就是現在的structure就是用tree那tree的話就會有這種所謂absolute跟relative path的概念好那有了tree之後我們在使用上呢為了有一些需求再進一步把它generalize一點就有所謂的acillic graph的概念因為tree只是你必須對你只有一個node只能有一個parent對不對可是在我們實際上應用的時候慢慢就會開始有些case是你希望有不同的人去share相同的檔案對不對

那所以這個時候我們就會有建立這種所謂的Aesthetic Graph的方式那就可以像下面這邊所看見的對不對所以我們可能會有不同的檔案名字所以Direct Count然後這邊是Spell下面的Count可是這兩個不同檔案名字其實勒是對到相同的這個File的Content這個同樣的一個File那這種時候就是所謂的Aesthetic Graph了

因為 Aesthetics 嘛所以這個是稍微放鬆可是還是你可以去加 Edge 了但是你不能讓它有一個這個 Cycle 跑出來那加的方式呢可以幫大家補充的像在 Linux 裡面有興趣的可以自己玩一玩然後就是去用所謂的 Symbolic Link指令就在那邊稍微查一下就知道就是 LNS 這樣子那它有分 Hard 跟 Soft意思就是

說因為當你deleted掉某一個file的時候這個到底還要不要存在有兩種選擇嗎你要嗎就是因為有兩個人指導相同的啊所以有可能是你deleted掉一個這整個就真的deleted掉另外一種是你是deleted掉全部的那那個content才會消失所以會有一些不同的option所以有分soft hard的一些定義上的不同那不過這些做法就是為了要去create一個acilic graph的structure跑出來所以這種時候咧

你就變成甚至於有Multiple的這種Absolute Pass的出現那很多軟體在因為當初Coding的原因Design的原因有需要這樣的需求你就可以用這樣子建立Symbolic Link的方式不需要在那邊Copy File了因為跟Copy File最大的差別是什麼就是如果Copy的話第一個你浪費你的儲存空間嘛你真的就浪費掉空間了

第二個就是我們剛剛才講的資料如果它應該是一份的話你把它做Duplication你要怎麼維持它Data的一致性這是非常討厭的事情，所以你就可以建立像是Symbolic的這種方式，就可以去讓一個File在兩個資料夾下都出現，但是其實是同一份，所以就是有人只要一對這個File去修改，其實另外一邊會立刻看到他們，是Exactly就是同一份好，

那講到這個，所以我們下一個課，那所以，但是雖然說我們的資料一份，但畢竟還是有兩個，就像我們在寫Programming的pointer的概念一樣，所以你還是有兩個這個file的名字，把它point到同一個檔案，所以當今天我們把它砍掉的時候，一樣會有所謂danglery point的問題，对不对也就是其實這個檔案已經根本不存在了，但是你這個對應到的這一個pointer這個名字卻還來存在，

那這樣當然在你access上，你就會發現，比如說file not found，对不对，這其實是個error 对不对，這也不是not found，它是存在，但是content卻lost，所以這其實是一個fail的狀況，不只是說它不存在，它根本就是一個fail，所以為了去避免這個dangling pointer的存在，在acilligraph所以為什麼是先只談acilligraph就是因為它比較容易解決這個dangling pointer 的問題，因為它沒有 circle，所以我想大家知道，就是你可以用 counter 的方式你就可以 detect 對不對所以只要有一個 file 的名字對到這個 file那這個 file

上面的 counter 就會變 1 了，兩個就變 2 了，那直到它變 0 的時候它才會被殺掉，不然它不是 0 的話代表有人是指到它，我們就可以把這一個file就應該要把它 keep，所以就很容易判斷什麼時候我要真的把這個file從我們的storage device上面把它 remove掉了好，那我們就先休息十分鐘，我們再把最後一個structure這個 general graph的 structure介紹一下。.