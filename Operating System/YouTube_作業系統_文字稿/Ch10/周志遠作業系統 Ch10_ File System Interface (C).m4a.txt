undefined
剛剛下課我又想到一個例子是random access的例子所以我們剛才給sequential access這種master的例子就像各位C programming裡面every f write對不對那index的這種random access我們提到就像是database的case那random access direct access的話應該說direct access的話是什麼例子勒就比較像是一些比較高階一點的語言會提供像是matlab大家可能有用過對不對你可以load一個file那裡面就用行當作它的row當作用common就是用這些逗點當作或是space當作它的column對不對

所以你漏一個file進來之後你可能想要的東西就是請告訴我array A33位置的data是什麼對不對這個就是一個direct access了你直接跟他講第三個row第三個column的那個字你不用index他也不用明他就是位置嘛對不對33這個座標coordinate的data那這就是一個direct access的例子所以就有不同這種所謂

的Access Methods的就是個API啦那重點哪一個好哪一個不好其實當然是要看使用者囉就是Application它的Behaviour需求嘛，所以你自然會找到它對應的這種Access的Message。那以API的角度的差別大概就是可以看它的Argument。你就可以觀察到對不對你沒有給Position的那一定是Sequential Access。你給的是一些Position的Information像我們剛才說

A33我要write到這個位置Read到從這邊讀出來這個就是Direct Access。那如果你直接就說Jump或是某一個這個名字你自己去取得的然後你用這個當作Position去Reference到去Refer到你要的資料那個你就在做Indexed Access。那Implementation大家當然可以相接你看像Database然後File System或是你加一層這個Language當然就是Mapping上面對不對還有這個mapping上怎麼處理這是一件另外一件事情

就是它的access pattern到physical device上的pattern會亂掉會有怎麼樣的行為它一定會不一樣。那怎麼樣確保它的讀寫速度快那方式就不一樣了。 sequential你也知道資料behavior就是sequential那你就盡量把它串在一起如果是會跳的如果你有index，你可能就會建一些對不對directory內部的一些data structure去Track或者是能夠Search讓你很快的知道到底要從哪裡讀才是盡量減少一些redundant資料的IO嘛對不對。

等等的做法好，不然那就是Access Method好。 那我們這邊回到我們剛才介紹這個Directory有Single Level Two Level都變成Tree那最後最General當然可以就是變成General Graph 對不對。所以我們就完全不受限，你在這個directory的這個structure上這個graph上你可以任意的去加edge任何的direction任何的位置那這樣的結果就會就會產生一個general graph就是任何

的可能性都會出現那跟剛剛最大的差別就是它就有可能會有cycle的跑出來那我們知道有cycle之後的最大的issue當然就在於怎麼樣去解決dangling point的問題那解決的方式其實大家以前應該也有聽過了因為其實這個問題就像pointer在處理pointer是一樣的所以我們知道像pointer更是容易會發生這種有cycle等等的issue那怎麼做勒當然就是第一個你可以去你當然就是可以把它移掉之後你就把它拿掉對不對

那就像這邊的例子本來可能有串在一起的從bin到g2那你delete你就直接把它拿掉那拿掉之後的問題就在於那剩下的就有可能你其實也應該要delete掉因為它根本不可能被access到嘛所以其實就等於是把這個資料給整個砍掉的意思是一樣的但是你怎麼知道勒這時候你就沒有辦法只用counter這件事情

因為像這个例子很明顯就看到這要移除的G2跟T1它們上面的counter值還是一樣互相reference那所以當然第一種你就是可以去做一些circle的detection對不对去看看是不是有circle然後有沒有連接那最常見的呢就是用像 garbage collection 的概念了所以你可以 periodically 你就從 root 這邊開始一直 label 下來對不對 traverse 看看它是不是可以reachable對不對等到 label 完之後然後你發現沒有被 label 的人當然就是unreachable就他可以把它給 delete 掉所以就是最常見的這種 garbage collection

兩個 pass 的方式你也可以把它解決掉所以你不care它到底有沒有circle了反正unreachable那就是要被deleted掉的恩，那當然你可以想見這些overhead都是比較大的，然後不要忘記file system更不喜歡做這件事情因為它的使用者通常大型的系統使用者跟檔案數量是非常驚人的，所以你的priority在那邊做也是非常不efficient的，所以很多的file system它就不支持這樣子general graph的directory structure，

所以當你會加了一個link他會create circle的時候他可能就把你擋住，就跟你講這是一個invalid的動作了去避免掉這後面的maintenance的這個issue，因為實在太耗費時間了，而且以使用情境來講大概也沒有那麼necessary對不對也是蠻少見應該是很special case的，所以你可能就要用別的方式去處理好，所以這就是directory所以什麼是directory

其實就是在處理這個mapping的這件事情去找到你的file的真正的這個ID好那接下來我們就要介紹mounting跟sharing這兩個在使用檔案的時候常常會做的這個動作好那第一個是mounting所以什麼是Mounting呢？我也不確定，在入嗎? Anyway， justo像我們所知道基本上你要去使用一個這個檔案系統的時候你要去使用這個儲存空間的時候你第一件事情就是要把它Mount到我們俗稱Mount到我們的

這個系統裡面也就是讓我們的系統可以Access到哪一個Service Device上面的資料這個動作就是俗稱的Mounting。那當然我們這邊指的又指的是File System這邊的Mounting，因為畢竟整個系統的角度來講我們最後使用者要能夠使用到的話或是程式對不對要能夠Access到那個Data或是File的話都是要透過File System也就是要透過我們剛才的那個Directory的Structure然後可以找到它。所以在Mounting的時候

呢第一件事情你要決定的其實就是Mount Point。所以我到底要把它Mount在哪裡，因為整個系統或許是很龐大很多檔案資料夾，但是我們剛才看到的現在的刷學都是所謂的Trip或者是Aesthetic的Graph，你就是會有一個Root對不对。所以你必須要從這個絕對的路徑上你要能夠知道它到底位置在哪那那個Mount上面那個節點就是我們俗稱的Mount Point了好，那Mounting呢就像我們所知道其實它是分成有可能是這三個Case的其中就是什麼時候會發生Mounting這個動作

那第一個當然就是bo ot time所以也就是你一打開機它就已經Mount好那最好的例子就是你的系統吵了對不對所以不要忘記你的檔案系統也是存在檔案整個不應該說你的作業系統也是存在檔案系統裡頭所以說那個系統那個檔案系統如果不先Mount起來根本沒辦法load你OS的Data到Memory開始執行所以當然by defaultSystem的那個Value它是一步子

比如說它就是Mount起來的那再來呢就有這種Round Time的你在自動的去Mount這個現在就非常常見了幾乎所有的Device都會Support這件事所以我們知道一插上去它就開始自動的Search甚至於你沒有Driver它就開始自動幫你Download但總之結論就是使用者不用做任何事它就可以Mount好當然是Round Time一開始沒有但你插進去之後它就可以Mount好這就是所謂的這種Round Time的自動的Mounting的動作

那最後當然用Manually啦對不對所以當然比較早期或是你比較特殊的一些Device或是你找不到Driver沒有這些沒有辦法自動化最後當然只能用手動這當然Eventually當然也是可以的所以你當然可以在Run Time的時候用手動的方式再把你要的這一個檔案的這個或是儲存的這個Device把它Mount進到我們的檔案系統裡面好，

那所以這只是一個例子啦！就像我們原來的系統原來的這個File System，它可能就只有這樣子而已，就只有Local有些檔案然後這個User跟Home其實都還沒有東西那，你可能就Mount了第二個這個Value或者Partition進來到我們的檔案系統裡然後再掛載在USR下面對不對，那這就把它這個USR就是我們所謂的Mount Point不同

顏色如果就是不同的這個File System我們把它Mount進來的話，那就會像這個樣子，就可以每一個節點就是所謂的這個Mount Point，所以甚至於你可以Recursive的對不對所以你Mount完之後，你也可以在被Mount的這個這一個Value下面再去掛載其他的我們知道的就是可以一直這樣子下去，那這個動作在Windows你可能比較感覺不到，因為我們知道Windows它比較

它自己的管理，它比較沒有那麼彈性嘛對不對！它想要減少使用者的這些effort，那也因此可能也有比較限制所以像我們知道一掛載進來就是C槽 D槽 E槽也就是你只能掛在root下對不對，但事實上不然，所以整個系統的角度來講沒有說沒有這樣的規定，所以尤其像在Linux或Mac這些大家知道的其實你就可以自己選到底要掛載在什麼地方只要它是存在的一個這個

點你都是可以掛進去的也就是像你要掛這個gans只要降這個folder已經存在你可以掛在他的下面那就可以有這樣子recursive的一個結果那當然他們這些就可能是不同的partition所以這個顏色只是folder而已所以這邊是一個partition不過當然像這個可以掛在這下面我們也可以把它切出來這邊第四個partition掛上去也是可以

所以其實當然是可以任意的去延展這個tree的structure就對了那到底實際上我們大概下章就會講更多一點但實際上當我們說mount point的時候到底在data的管理這個metadata管理上的角度來講到底發生什麼事勒稍微看進去一點其實就像這個樣子所以當你去mount一個partition的時候或是一個variant進來的時候我們的OS都會maintain一個這個mount table

所以你就會知道有這個partition的存在然後呢當它是屬於同一個file system的管理所以你可以這樣去使用它的時候你去透過file system去access不同去mount的這個partition的時候發生的事情其實就是在第一個當然是在directory這邊的structure做修改也就是像這邊看到的。如果這個一開始root下面有三個folder對不對那、usr或者mnt這邊來講它是

掛載進來的話，那它其實不屬於同一個partition所以P1這指的是一個partition所以這個physical把它切割出來的partition然後P2 P3假設就是這個新的其他獨立的partition然後我們要把它掛載在同一個這個file scene的這個操作下，那它在註冊了這個derive之後，它就只要寫一個m就好就是mark起來就對了啦。所以當你在去traverse這個tree你想要去找這個file的時候，

它的方式其實一樣就從ROOT開始，就是你的SYSTEM DRIVE然後這個SYSTEM FACTORY開始照USR它是一個Mount那它去看Mountable這個到底是對到是哪一個Physical的Device對不对那裡面當然會存那些Information它知道在哪一個Port上面接到這個DRIVE用什麼方式的Protocol等等然後？重點就是透過那邊的信息，你可以去Access另外一個Partition然後這把地址下就一樣它這邊是root可是知道從這裡開始的所以root就相當於就是usr然後它就繼續在traverse所以你就可以

一直接著去找到你要的檔案的資訊那找到了你的檔案名字之後當然content也就依序存在後面嘛你就可以把資料讀出來了。所以基本上是這樣就是有一個mountable然後它會在它的這個directory的structure裡面會去mark起來。所以它知道也要去另外一個partition讀了然後會有一個partition table存著access那個partition需要的資訊。所以就可以

切換到另外一個partition繼續的去找你的file的content。所以這是mount會發生的事情。那另外一個我們也非常常見的這個是比較重要的就是sharing了對不對。所以檔案系統我們那時候一開始也介紹過檔案系統的存在。其實是在當你有multiple user的時候才會是最需要的。就是因為我們要用透過檔案會做人之間的user之間的sharing。分享當然不可能是我們都知道他的permission非常重要對不對。所以如果我們放在各位的作業方我們的

這個workstation上我們的server上。如果大家可以隨便看到的話那不是問題很大嗎對不對或者是你的檔案可能不小心就被overwrite掉，那這個issue是非常嚴重的，所以這些sharing上面在file system的做法是非常重要的那就像現在大家在使用檔案系統的時候一樣已經看見就是現在的形式演進下來就大家的做法就是現在這個樣子也就是第一個我們要能夠identify使用者對不對，所以使用者勒當然有user ID可是除此之外我們知道其實還有一個group ID

使用情境上很多時候同一些使用者相同的需求share相同的file所以我們有所謂的group ID所以一個使用者他當然有一個unique的user ID但是他也會belong在某一個group ID下那-by default如果你稍微看一下你在自己的Linux系統上打一下也會看見Default的group ID就是你自己啦所以一個使用者進來他也會create一個自己的ID自己的group ID然後只有你在下面所以你沒有感覺

但其實它還是存在著的那當然很多的應用尤其在系統管理的時候你就會可能我們就會create一個group叫做students然後把它全部放下去那students就只能access某一些檔案那就會很好使用管理了再來就是file所以那file這邊一樣它去access的時候我們怎麼知道一個使用者他到底有什麼樣子的權限那現在的

管理方式就是把它分成三種三種的這個level第一個就是owner所以它對應到就是user所以我們知道一個file它只會有一個owner那所以這個owner它到底有什麼權限我們就可以去定義它再來咧因為使用者有group嘛所以一樣的file這邊的權限我們就把它變成是group了所以第二個level就是你不是owner好吧但是如果你是

我所這個file所屬於的這個group的話那它的權限就可以另外的再去設定所以跟owner可以rewrite然後甚至於可以整個去執行它那group的話可能只能讀而已或者它可以執行這樣子最後勒就是others所以使用者你要嘛就是owner要嘛就是同一個group的使用者要嘛就是其他case其他case我們就把它全部丟到所謂的others

所以今天任何一個使用者他要去操作一個file的時候其實我們按照這樣子的一個方式就可以知道他是屬於哪一個一定會落在某一個裡面對不對就是落在某一個這個level裡面然後就根據那個level他的權限我們統一去做一個設定跟管理所以就讓這邊看見的啦所以雖然說你可能會有很多使用者你可能會有很多的group但對file而言

其實他是反向思考他就是只有一個 owner然後呢看他是屬於哪一個 group 的然後所以這 group 他可以有很多 group但是所有的這些 group 他的 permission 都是相同的就沒有辦法再細分了只要是他擁有是真正擁有同一個 group 的人他的權限是什麼然後最後就是都不符合那就是 others

好那所以分成了這三個之後那到底所謂的這個Promission我們剛才說的權限到底是什麼類那它的權限叫我們大家看基本上指的就是它可以做Rewrite或者是執行或者是去只能Rewrite還有執行這三類型而已那這就是所謂的Privilege所以每一個Level會對應到就是不同的Privilege那當然是只有這一個file的owner或者是

root是整個系統的管理者他可以去修改這一個file他的group的權限還有他屬於哪個owner等等的資訊所以其他使用者是不能夠去動去改變這個file的privilege或是permission的其他人只能follow他規定的policy而已那通過這樣的方式你就可以一定可以對到其中的一個permission就是說privilege的這個permission然後來操作這個file好那

所以剛才這個per mission到底是怎麼去描述它那這個問題勒其實在一樣當初很早期在設計整個檔案這個整個作業系統然後檔案系統這一塊的時候演變下來的結果大家或者說這個問題勒本來大家這個定義勒就叫做所謂的access control的問題對不對因為我到底一個使用者一個file我到底他有什

麼樣的權限那最後的結論呢是或者演變到現在大家所看見的就是他變成一個control的list所以我們就只要用一個list來control每一個使用者到底對一個file有什麼樣的權限那這個list的方式咧如果是很單純的話你可以想的就是one to one就是每一個檔案他會對到一個list然後list上面是每一個使用

者然後它的權限到底是什麼可是這樣的話當你的問題最大問題在於說當你的使用者增加的時候因為系統使用者其實隨時都來增加那你不就要一直在那邊修改這個list然後這個list的長度會非常長所以光是存這個access control的information可能就已經耗費掉太多的信息或者耗費掉太多的storage space尤其這些資訊

多少 memory 才能夠去判斷嘛所以當然不是一個可行的方式所以咧像現在的做法就是我們剛才看的就是把它變成三個 class就是 owner然後 group就是同一個 group 的然後還有 others然後呢privileged這個 permission 這邊咧也把它就是限制在很單純的這邊看見的三個動作就是 read就是 r 就是readW就是writeX就是executable所以就是你有

沒有對它的獨特權利修改的權利跟執行的權利就這三個而已所以呢這個ACL suppose是一個很長的list我們就可以把它簡化成很簡單的三個bit這也就是現在的形式就這樣應該說每一個是三個bit所以加起來對不對也就是也就是在乘上三倍而已所以就是很少很少的儲存空間那所以這個list

你可以看到他的這個這邊如果是owner是111那就是代表只要是owner的user他就是有這三個權利那如果0就代表他對應到的那個那個動作就沒有去執行他的權利了所以像這邊owner他可以rig可以rig可以execute那group的話他可以rig跟rig但不能執行那如果其他人那它就是只能夠做read的動作所以就像

剛剛說的這個file的owner或者是這個system的root它就可以去透過修改這幾個bit的設定它就可以控制這個access control所以這部分也一樣大家這個回去其實可以對照一下看一下自己的folder去玩一些這些指令你就知道這個差別所以其實像在這個在我們的在我們這個寫作業的工作站一樣大家如果

按LS然後當然還有-L啦就把它所有的Information列出來的話你一定會發現前面就是這些東西奇奇怪怪的一堆符號這是什麼這就是Access Control List所以這每一個對應到的就是這個Folder或是File它的Access Control的設定然後你可以對過去第一個當然不屬於 xml 只是說它是 directory 還是 file 而已可是接下來你就會看見會有三個 symbol一共有九個其實對一道就是 owner group

跟 others然後呢它只要 r 就代表它是 enable如果 dash 就代表 disable所以這一看就知道這是一個 file然後 owner 可以對它做 rewrite 但不能執行然後呢 同一個 group 也就是這邊看見的話來講就是 step 這邊那這個 group 就是可以 read 可以 write一樣不能執行然後其他找不到的不屬於任何的使用者那就只有 read所以這樣就很清楚的知道怎麼去 control 它的 access 對不對所以這就是現在 ACL 演進下來最後我們在 file system 這邊所使用的 solution就是這樣的一個

Access Control List的方式然後就用三個class然後用三種這個privilege的operation的這個控制來決定你怎麼去做sharing好那所以很多時候這個大家像你去traverse啊所以像如果是一個folder execute的意思就是你能不能traverse進去看到那個file下面有哪些counter所以你如果發現有時候Access permission denied為什麼你可能要去看一下你去access那個file它上面一路上面它每個parent在這個pass along這個file pass的這些parent的folder它是不是

或你那個使用者是不是有executed的這個這個權限因為你能夠才代表你可以access那個folder所以這個access control常常會碰到一些arrow大家如果這個概念有的話你就可以知道怎麼去解決了好那當然不同group之間你就可以控制大家加到student的group然後對不對所有人就只有譬如說read但沒有write然後只有owner有write等等你就很容易的可以去控制了那這點在Windows是相同啦只是因為他用介面嘛對不對

這個Windows的介面所以大家去找一下但Linux如果在comment line下面的話你一list出來你就知道了那指令在這裡大家忘了提一下指令是HMOD所以這個就是你去修改assets control list的指令那644剛才就是對到這些所以一樣嘛每一個integer就是對到一個class然後就是你的file你要把它修改成modify改成什麼樣子的permission所以這自己的file可以自己試試看

好那最後勒是protection所以protection當然非常的重要就是兩個層面啦第一個指的勒就是大家在access的permission在同一個server上面同一個file system裡面大家到底怎麼樣子你到底是屬於誰的然後他可以做什麼動作然後不同的使用者不同的group的差別那就是我們剛介紹的ACL其實也是part of這個protection的機制所以你不能隨便的看別人的檔案那另外一塊咧更重要的咧當然是這一塊第一個damage對不對

所以你的file絕對不能遺失那怎麼樣子可以讓檔案不遺失咧這個我們到應該是第12章介紹storage system的時候會再跟大家介紹那一種方式就是用RAID就是用很多硬碟所以當一個硬碟壞了我們資料可以cop y在很多硬碟上，所以一個硬碟壞了我們還是有辦法可以把資料從另外一個硬碟讀出來的這種方式用多個硬碟來增強你的資料的reliability，它的可靠度的做法這個我們之後會專門再講一下，

那另外一個呢比較麻煩的人，所以這個是資料遺失，所以是Data Corruption，這個指的是Privacy、Security就是你要怎麼樣去Make sure你的資料不會被別人給偷走那這個問題當然是非常大，所以我們知道資安是一個很大的另外一個獨立的領域，所以最基本，最基本的我們知道的一個單一系統來講角度其實就是用Password，也就是你

只要登入進來，你是一個合法使用者我們知道你的ID了我們就可以透過你的Access Control List知道什麼事情你可以做什麼事情不可以做，那當然這個是當初我們電腦設計以假設使用者必須用Login的角度才能夠去Access File的時候所做出來最基本的Protection就是用Password，但現在當然完全就會crack掉對不對，因為你

根本不用login，我可以透過程式各種方式、web的服務、web的程式對不对，我就有辦法用各種方式去侵入到一個電腦，那當然這就是現在很大的自然問題，這一塊那包括了password有沒有可能被人家偷走對不对，當你把當你當有網路什麼事情都變得複雜很多，所以我打一個password傳到這台remote的電腦，在傳的過程中我的封包會不會被偷走

被人家偷聽、 監聽那如果看了被人家截走之後，那你的password也被人家偷走啦，所以就要加密等等，就很多很多的issue跑出來，那這塊就是當然屬於protection但是，就另外一個層面就是你的privacy跟security，這邊那至於資料怎麼不遺失，這個就是以儲存資料的角度，那我們後面介紹儲存系統的時候會介紹這個RAID的solution，所以這就是一個簡單的overview，就是file system這邊，以使用者的角度，在sharing、mounting、protection上面的一些concern.