p.4
好，那所以上次我們提到存在Memory的意思就是，實它裡面組成的必要的幾個部分，這個Memory它的這個幾個部分第一個就是它的程式碼，第二個是它的Data的部分也是Global的Variable。你只要這個程式一漏到這個Memory，它就知道要幫你去Allocate的然後去存放的這些變數Global Variable；然後有Stack，就是各位的Function Code，這種Local的Variable只要Function Code一Return，那這些Variable就會消失的。我们就放在Stack裡面，以及Heap所以Heap就是這些Malloc用Pointer去把它Dynamic Allocate出來的這些Memory的Space，那這個空間大家知道的就是，用Programmer自己去管理的對不對。你要自己去記得要去Deallocate，不然的話，你可能就會有所謂Memory的Leaking，這個大家很討厭，實很嚴重的一個問題。那這就是放在所謂的Heap裡面那當然還有很多的資訊尤其是作業系統需要知道的資訊來管理這個Process；尤其各位在之後Choice Code的時候就會看見，它需要去記錄這個Process目前的State還有一些Information。像是它的Program Counter目前執行到這個Program Code的哪一行對不對還有它的Register因為我們說我們等一下就會介紹到Process在執行的過程中他是會被所謂的contact switch就是換人對不對我們都知道我們是一個time sharing這是一個sharing的system所以你不可能一直站著這個CPU不放所以當你被switch出來的時候那你register裡面的狀態必須要存下來所以這些其實也是每個process自己在memory要allocate一些空間去存放這個狀態的部分

那最後呢就是一些resource對不對像各位去open一個file啊或是其他跟OS去要一些resource的hardware的control的時候都會有一些token等等的東西那這個需要被存下來

---

p.5
好所以我們這個一個process其實在OS的世界它就是一個memory'space所以可以看見基本上的架構這只是一個例子所以當然每個作業系統的管理方式有一些不同，所以像這邊來講這邊是0嘛,所以它是下面先放這個text,也是你的code然後再來是你的data那heap跟stack在上面，那很重要的是大家都知道heap跟stack它是runtime會變化的對不對,因為它是runtime,就是allocation的那text跟data呢,則是固定的所以可以看見空間流的呢,其實會在中間一個往上漲,一個往下漲對不對,這樣才可以有效的利用這整個memory space的空間，所以你常常會遇到有時候你allocate太多memory對不對，它會說out of memory或是這個stack這邊你一直在recursive的扣了，最後它會說你一樣會out of memory的時候就是因為你這個長得太多了，要不然就是整個空間都用完或者是stack或heap本身它有一個限制的大小，你把它用完了，它就不讓你繼續做allocation了，好所以這就是基本上一個process在memory裡面的樣子就是這個樣子

---

p.6
好，那所以大家可能也都有聽過了，除了process之外我們常常用另外一個turn叫做threads，那process跟threads其實是不太一樣的，但是很多地方又很相似，我們下一個chapter當然我們會跳過啦，我們會先教memory再回到threads的這邊會講更多，那大家先稍微知道就是這個Thread，我們又常常給它另外一個名字叫做LiveWay的，這個Process也就是說其實它跟Process的管理跟長相是完全相同的，但是我們知道很多Thread其實它可以共用一些Memory的空間，那包括了我們之前提過的Shared Memory的溝通，我們用Thread Programming為什麼因為它有一塊Memory空間By default是Shared的，所以他們就可以直接利用那塊空間去做溝通，那相對的意思就是當你在Create一個Thread的時候這些共用的空間你就不用重複再Create了，因為這些Thread的他們的Parent的這個Process在形成的時候就已經幫你Allocate好，所以它在管理上跟Memory的Allocation上相對它就少了一些動作，所以我們說是比較Lightweight的，那同時這些Thread實際上在運作的時候，它是我們在電腦系統裡面最Basic的執行的單位就是在CPU在執行的時候的單位，其實是Thread，因為我們知道Process其實下面我們會把它切成可以把它切成很多的Thread，算是只有單一一個Thread你也可以把它想成一個Process就只對到一個Thread，所以Eventually Thread其實才是最小的去執行這個去使用這個CPU的一個單位

所以右邊這個圖就可以看得更清楚就是 process跟thread的最大差別在哪？那其實就在於說這些只要是同一個Process下的這些所有的Threads，他們其實有些Memory空間是共用的，就像右邊所看見的By definition當我們電腦系統在設計的時候，我這個系統在設計引進了Thread這個觀念的時候，我們的定義就是只要它是Thread的話，同一個Process Thread它的Co-section、Data section還有OS的Resource這三塊Memory的空間是共用的，所以其實就像右邊所看見的雖然說我們這邊一個Process有很多很多的Threads可是，它的Code、Data跟Files比如說你開了一個Open一個File只要有一個Thread開另外一個直接可以拿這個File的Pointer直接去對這個File做Read或Write的動作，那但是他的register還有stack可以看見其他的部分他就沒有share了那因為沒有share所以，你可以想像register為什麼不能share，因為每一個Thread其實在執行的時候，我們知道他執行的位置可以不一樣你可以執行甚至於執行不同的function code，所以每一個人執行的instruction不同也就是他在Code segment裡面的位置是不同，那還有他執行當時的狀態當然也是獨立的，所以這些register是另外去記下來的。那另外stack也就是他的function code local的variable，所以每一個thread其實他可以執行在不同的Code section，Code不同的function code所以他當時的狀態在Stack裡面的狀態也是不一樣的，所以我們知道不同Thread的Local Variable就是互相是看不見的，可是可以注意到Data的Segment，Data的Section它是Shared的，所以我們才說，在寫Multithread Programming的時候，我們就用Global Variable來做溝通，因為By Default只要是Global Variable你一allocate或者是Ear Locate在Heap這些Dynamic Locate的地方，你只要有Pointer任何一個Thread都可以去讀裡面的資料。我们的OS不會去擋你，它都在同一個Memory的Space裡面，所以這個Thread跟Process的差別就在這個地方，但是就像我們剛才說，因為它其實重點就是它要能夠獨立的去執行，所以它的Program Counter Register，Thread的ID，所以其實OS是知道你是這個Process的哪一個Thread所以他也會多存像是Thread的ID、Stack這些就是獨立的了。

---

p.7
好那我們這章來講的話，我們會介紹是Process。但是其實管理Thread的方式在不同的OS的Implementation其實有一些不同，但基本上

它的大的concept來講的話，管理Thread的方式跟管理Process的方式是一樣的。只是說Thread可能是Process下的在一層而已，所以接下來我們介紹的都是Process這邊在OS裡面的管理。但其實相同的概念，你可以把它Apply到Threads甚至於我們後面會提到，在像Linux這樣的File System，它其實事實上對OS而言，它沒有Process的概念，它就是Threads每

一個process他就當成一個thread他只有知道說這些thread之間到底他們的哪些memory的content是share還是不share他看到的世界跟這個programmer看到的是不太一樣。他把它做一個簡化好那甚至於各位在trace這個notches的時候也會發現應該有些人已經發現了為什麼他都只叫做threads thread他都不用process這個名字，因為其實是不用刻

意去做區分的很多時候為了去Simplify它整個OS的架構就把Process當Thread或把Thread當Process那用哪一個名字其實是次要的管理的方式其實是把它視為相同好那我們這邊來講就用Process這個名字那Process的話我們這邊會先介紹一下它在OS裡面它整個Life Cycle怎麼被OS管理的那它在OS裡面當它被一個process被launch起

來之後整個執行的過程呢它是分成這五個state就五個狀態第一個就是new就是當這個process它被create出來的這個時候那在這個face裡面呢其實要做很多事情的就是要把我們的program load到memory裡面把我們剛才看見的這五個segment這些memory的content把它全部把它locate出來然後做一些Initialization的動作甚至於我們後面下一次我們會講到Memory那邊的時候

會看到Memory那邊也要去做分配哪些Memory是給這個Process的會有一個Table這些都要去把它做Creation的動作所以New指的就是把這個Program load到Memory然後把它整個這個狀態把它Initialize的這個Stage。所以今天如果你比較早期的電腦啊Memory可能比較少那你Launch太多Process有的時候它連New一個Process都會遇到困難因為它沒有辦法Allocate Memory了Out of Memory了那在New的過程它就直接把這個Process給Kill掉了就直接Fail掉說因為沒有Memory去Allocate這個Process這個是

會發生的尤其即使在現在的話一些Embedded或是比較特殊的Device上對不對你的Memory空間很有限你可能New都沒有辦法New因為你沒辦法在Memory OK這些Resources第二個步驟指的就是Ready因為我們等一下會看見其實在電腦裡面什麼都要Share所以Process要去競爭的資源就是CPU那我們知道也就是CPU裡面的Core所以一台電腦裡面的Core是有限的

所以我們要看見管理的方式就是會有一個queue我們之前也提到過所以其實你被allocate完之後存在memory你要等著要去使用CPU的Core之前會被放到一個ready的狀態也就是被放到一個queue裡面然後等著被我們的OS去把它排成進入到我們的CPU去使用的動作這就是ready就是它在等待使用CPU的這個時候它就叫做Ready State，

第三個就是Running，那就是你在被選中了然後你可以真的開始送你的instruction到我們的CPU裡面去執行的時候，就是我們俗稱的Running state，這時候才是你真的在執行程式那執行的過程中。其實我們知道我們也提過一個Program，它在整個計算過程中不是只是使用CPU它除了CPU也會做IO對不對比如說你call一個printf或是你call一個scan說要讀資料或者是這些做一些IO的動作就是不是CPU其實就來做IO所以當你在做IO的時候

你就會需要進入到所謂的Waiting state因為你不需要CPU可是你又在你也不是ready你也不能立刻執行你就在等某些動作這個時候就會被放到所謂的Waiting的State裡面去等到這些事情完成了你需要使用CPU的時候才會被放回到Ready的State那最後當然沒什麼就是Terminate對不對所以這個就像New一樣反過來就是把所有的資源把它release掉

順利的把所有的這些資源放掉讓我們的OS可以重新的來使用這些資源給其他的Process就是TerminateState所以其實蠻單純的對不對可以看見就是五個這個狀態好那所以這邊只是這個 Diagram大家可以把剛才這五個State用這個Diagram把它記起來因為這個就會知道它整個在OS裡面Life Cycle的過程就我們剛才說它會先去New

New 之後呢其實 OS 還有一個 Admit 的這個動作所以就像剛才說的可能他的 memory 不夠那我就不讓你去做 New 的這個動作或者是說你可能沒有 permission 啊因為我們知道數位系統要做 protection所以每個 account有些程式你根本沒辦法去執行它因為你沒有執行的權利對不對那所以這時候我的 OS 就把你擋掉那你就沒辦法進入 Ready State 了

但是如果一切正常的話那順利你就會進入所謂的Ready的State那就像我們剛才說的其實ReadyState裡面是一個Cue它就是一個Cue那等著被我們的OS做Scheduling的動作所以如果你Schedule到了之後Schedule輪到你那我們就會做所謂的Schedule只是說我去選人的動作Dispatch是指的是描述的是我選到之後我要讓你load到我們譬如說我們的

CPU裡面去這個把它分配出去的那個動作所以你把它schedule了schedule之後做了Dispatch之後到了CPU裡面你就可以進入running state那簡單一點的程式嘛你只有在做計算就寫一個for loop i++就結束那當然執行完你就直接離開了但是我們知道OS整個運作不只是計算所以第一個就算你是純

計算你有可能會從Running State回到Ready State的原因就在於你被Interrupt了所以這個Interrupt有可能是你自己丟的但通常是因為你是直接回到Ready所以這個就代表了像是Timer被File出來了我們覺得是Time Sharing的System所以多少mini second固定的我們說為了把你的主控權回到OS所以會有一個timer它會launch

會fire那所以就會產生一個hardware的signal或是inter-run那這個時候OS或者我們整個電腦系統就會切換回到OS這邊所以原來在執行的那個running process就會被迫的做一個switch然後回到它的ready state那switch給誰勒你們作業三就會看見Switch給OS的Scheduler所以OS Scheduler我們說他永遠他隨時可以掌握誰

在執行在這個電腦上隨時可以換人的原因就在這裡了那另外也還有很多其他的Interrupt就像我們說的你可能自己要做IO所以當你自己要做IO的時候那你就會放掉你的CPU的執行權所以Again讓OS可以去換到別的需要CPU的程式執行那你原來這個程式就會被Process就會放到這個WaitingState裡面所以當你在做IO或者你自己call一些像是Sleep這種的這些API這些System Code的時候那你的Process就會進入到WaitingState了那所以

Waiting等到你的這個IO的Event結束或者說Sleep十秒十秒到了那這些Event完成之後那這些Event的完成其實都是靠Interrupt啦所以OS會知道什麼時候哪一個Process的什麼Event完成了那完成之後它就會把這個Process的狀態從Waiting把它移回到Ready所以這樣的話它就有機會再次被執行了所以可

以看見在這整個cycle裡面我們的scheduler我們之後會介紹的scheduler他要做的事情就是什麼時候去從這些ready queue裡面挑程式把它放到run link就好了只要在這ready state就代表它一定是已經可以執行的了如果不行就會被放在所謂的waiting state所以這個圖非常的重要大家需要把它記好尤其是這五個

State之間轉換的這個動作的原因是什麼？需要這個把它記起來的所以就像我們剛才說的，實際這裡的Ready跟Waiting這兩個其實是用Queue來做管理的，因為同時間整個系統裡會有很多的Process進到Ready State然後等著被Schedule，所以會被放在一個Queue裡面，那Waiting也是一樣，所以會有很多的層次在做IO或是這些Event那

它們就會全部被放到Waiting Queue，那等著這個Event的完成再回到Ready Queue裡面所以，在這個OS的世界裡很重要的是，它要能夠掌握一個Process，剛剛我們描述剛才，那個是一個我們的Concept的邏輯，我們的電腦系統OS要用剛剛那個邏輯來管理這個Process，那這個邏輯要怎麼被實現呢？實現的方式就是我們每一個Process會幫它去Create一個Process Control Block也就是在Memory裡面我們要記錄剛剛的這些Information所以我們的

OS就會隨時可以知道誰在Queue裡面你在哪一個State等等所以這個Process Control Block是非常非常重要的當一個Process被Create的時候我們的OS就會幫它去allocate一個table就叫做PCB然後裡面存著右邊的這些資訊那這些資訊大家一定要稍微知道一些非常重要的第一個其實它有一個pointer所以其實這些PCB Process Control Block它是屬於OScreate出來的一個物件所以Process是使用者create的對不對可是OS幫使用者create的時候它自己

會去create出這一個物件出來做管理那這個物件當一個process我們說被放到queue裡面這到底是什麼意思？車子是個抽象的概念實際上的意思就是我把這些process control block放到一個queue裡面而已是這個control block放到queue而不是那個memory的空間所以我們會用link list把它串起來放在queue裡所以它就會有一個pointer直到如

果今天他被放到queue的話他的下一個process control block會是誰所以會看見一個這個PCB的部分那另外呢就是我們剛才說的我們說記錄一個process的狀態其實process的state指的就是剛剛的他在waiting queue還是在ready queue裡面還是他在new的狀態就一樣會有一個field去記錄這件事情還有program的counter所以我們剛才說一個 process 它要記錄這個但其實這個資訊是 OS 幫它去記的使用者或是 process 的 memory space 裡面其實裡面是沒有的OS 因為只有 OS 需要知道所以它需要知道這個 program

目前執行的位置還有 CPU 的 register其實都是放在 process control block所以這個東西是放在 memory 裡面而且是 kernel space 的 memory 是 OS自己的Memory空間裡面那剩下的對不對就是其實裡面可以塞很多啦所以比較複雜的OSProcess Control Block裡面你會看見非常非常多的Information在裡面因為任何只要是你為了ControlManage那個Process的Information我們就是統一把它放在這個Block裡面那這樣你在做不論在做Scheduling

Memory的Location或甚至於在做IO的時候全部都是背上這個所以像CPU Scheduling你可以想見像是Priority你們作業室當然會ImplementPriority Scheduling所以一個Process的Priority在哪裡你要怎麼改就在Process Control Bra裡面你也需要知道Mem或對不對我們一開始就介紹Memory，你要去做Protection就是你要知道你的Base跟Register

跟這個 limit register 的值對不對，但是這個值什麼時候才會被漏到我們的 hardware 裡呢—is只有當這個程式在執行的時候對不對，因為 hardware 的 register 只有兩個三個嘛對不對可是 process 在執行就要去用這些去輪流的使用，所以當你一個 process漏到這個被執行的時候進入 running state 的時候，它才會把這個Base 跟Limit register 的值從Memory裡

面load到Hardware的register裡面然後去做checking，就像是我們說CPU的register一樣所以這些Memory的這些也是存在這個block裡面，那IO當然就是你現在是在做哪一個IOdevice的IO，所以我們之後後面會看見不同IO device，實有不同的waiting queue管理起來方便嘛對不對，所以你找才會找得快所以這裡面都要去存這些，你到底是哪一個IO

的waiting queue，所以它還有accounting，所以你開了多少個file，它也會存在裡面，所以為什麼它知道你開了超過400個file，因為這邊會記錄，所以這個process control block是非常重要的OS在管理process的時候需要的keep的一個information那記得它其實是存在kernel自己的memory裡面那有了這個Process Control Block之後我們剛才提到它除了去在C

ue之間移動有一件非常重要的事情就是它要能夠在CPU跟Memory使用的過程中做Context Switch跟其他的Process做交換的動作那在交換的過程中很重要的這個動作我們在OS裡面有個專有名詞叫做Context Switch所以不只是Switch這個是專有名詞沒有得替換當我們在講contact switch指的就是我們要把load

er從原來在CPU上執行的process把它switch成另外一個process的動作就叫做contact switch這個動作非常重要因為我們知道整個系統在sharing CPU的時候就是靠這個動作那這整個動作的流程OS去實現這個Content Switch的流程就這邊有一個簡單的一個Diagram讓大家看所以假設我們Process0原來是在執行的也就是說它的所有狀態都漏到CPU的Register那當我們說Content Switch會發生的時候一定是因為什麼勒有一個Interrupt

或者是自己這個Program去Code一個System Code所以它才會要切換到別的程式去，因為如果沒有Interrupt或System Code我們知道CPU的Behaviour很簡單，它就是Instruction Instruction Sequentially再讀原來那個Program的Instruction而已，所以它會一直佔用那顆CPU永遠就是把它卡住，那只有當這個Program的Code裡面自己原來在這個Program Code裡面，他自己Code了一個System Code像Printf所以

他自己去呼叫OS幫他做事，所以OS是一支程式喔，所以代表他要換到OS那邊去或者是有一個Hardware對不對InterruptSignal進來有人按一下Keyboard，那我們電腦要去處理這個Signal所以打斷了這個Process要OS來處理，所以either way這個process當它被打斷之後，它被切換的時候你可以看見它必須要idle因為它要等到這個事情處理

完然後OS重新讓它執行它才能夠回來使用CPU所以當它要把這個CPU讓出來的時候呢，它要做的事情就是我們剛才說的contact switch那其實這個動作是蠻單純的啦！大家可以想見簡單來講就是要把在CPU裡面的State全部存到我們的Process Control Block對不對，所以這樣子我才可以把我的狀態把它記下來，那記完之後你還要去run新的Process，比如說是一個P1，這個P1有可能是OS也可能直接就是另外一個Process或者是另外一個User的Process都有可能，不過不管是什麼

Process為了讓它執行我們就必須要 load 它的 state，那這個 state 當然 again 是存在 process control block只是是新的那支 process 的 control block 裡面所以必須要有一個這個動作，那這個動作你可以注意到對於P1 或者是P0 而言其實都是使用者而言它都是在 idle 的也就是它沒有在執行這些程式的程式碼它只是在執行OS做Contact Switch的動作，所以我們會看見右邊其實在做Contact Switch的動作的時候

它也是Idle的，那當然只有在Contact Switch完成之後那PE才可以開始執行所謂的執行就是執行P1的這個它裡面的程式嘛Instruction所以我們會把Program Counter設到那個Program要執行的位置開始做fetch ing的動作然後開始執行那，這邊我們的例子contextSwitch回1之後我們又再做一次contextSwitch所以這一個動作就叫contextSwitch，所以這邊其實我們

做了兩個contextSwitch所以假設我們P1執行完它又想要把它讓回這個執行權給P0的話，那這時候我們就會重複做這個動作那，這一樣的意思嘛所以我一樣會要做save把State裝到Process1的PCB裡面然後load P0的State好，那load完之後當然P0才可以換它執行，所以這個就是我們俗稱的Context Switch，實際就是整個過程中，就是扣了透過這個Process Control Block去幫我們實現這個交換的動作讓我們的Process可以回到原來的執行狀態好，所以對啊這只是定義所以大家應該這個

應該還可以了解，所以就是content switch是一個專用名詞指的就是這個kernel在做這個switch的動作，那其實就是在做process control block的load還有save的動作而已，那這個content switch大家必須要知道一點是，實際它是一個我們俗稱的overhead所謂的overhead的意思，就是它是浪費多餘的我多餘需要花的時間原因就是我們剛才注意到我們所謂content switch的過程中

兩個Process就是任何的Process其實實際上都在做Idle的動作所以就等於在浪費有一點以使用者角度它等於是在浪費我們的CPU Cycle純粹是為了管理跟Sharing需要做的動作而已所以其實Context Switch通常我們是要盡量去避免這其實是一個Trade-off我們希望它越快越好但是我們沒辦法去避免它我們沒辦法避免的原因是因為我們必須要靠這個動作

來讓你的CPU可以Share給所有的Process然後有Response Snips我們說Time Sharing你每多少個Minisecond你就會做一次Contact Switch所以其實是非常非常頻繁的動作那也沒有辦法避免所以在實際的系統當中你要必須要去改善這個狀況的問題就是你需要去減少這個Switch的時間那這就包括了譬如說Memory的速度因為你看見這個動

作其實在做Memory的Read跟Load跟Save的動作嘛 對不對所以如果你Memory快一點它這個動作可能可以快一點第二個呢Number of register 對不對所以可能是希望你把register數量減少那我需要存取的數量就少了嘛所以時間減少，但這件事情在現在的電腦系統也不太容易做到，因為我們知道我們希望越多register越好，它可以之後計算的話，它可以更快對不對

寫這些program可以更好寫所以大部分的現在的CPU的register其實是變多的至少數量其實並不少大家也不太希望去減少它那所以能夠去解決的方式就是後面這兩個可以看見的通常就是第一個在software這邊剛剛看到的這個把register follow memory你可以把它當成一個簡單的register control的instruction那可是你就會可能下好幾個instruction對不对

才能夠去完成剛剛這個動作所以有一些這個電腦的系統OS跟這個CPU這邊合作，它會有一些instruction它是可以call一個它就可以知道要把load跟save這兩個動作全部一次做完，所以它可能中間可以省掉一些步驟讓它快一點那更多的方法其實是這個Hardware支持又聽到了所以Eventually software還是有些Limitation所以Hardware這

邊Support的方式非常常見的是什麼呢就是我有好幾個Set的Register也就是說我們知道像CPU在運作其實它只需要一個Set的Reg ister就好就是正在執行的這個Process可是這些CPU它會就有多個Set三個四個甚至於更多意思就是我可以把它的這些執行的程式我可以一次就記四五個程式的狀態在我的Hardware的

Register裡面所以當我們在做Context Switch的時候它只是把它從一個Register的位置搬到另外一個Register的位置還是在Hardware裡面不用把它直接寫到Memory所以當然速度就快了對不對那這當然成本相對會比較高一些啦因為register是比較貴的儲存的component嘛所以可以用這種方式去解決那很多的你可以執行同時可以執行很多的process的這些CPU的設計通常是透過這個方式就是有好幾個set的register去避免盡量去避免減少memory的access

因為Memory還是比Register慢很多所以這個ContextSwitch大家需要知道這是非常重要的一個東西各位在Trace Code的過程中尤其是在作業三你就會看見它會去扣OS裡面的ContextSwitch的這個Function Code然後去做剛剛的這些load跟save的動作然後你一定會看見Process Control Block或是在N ACHOS裡面叫做Thread Control Block那它就會在裡面去access這些資料了所以這邊大家稍微在自己review的時候可以看一下尤其是這個五個State它們之間的轉換。.