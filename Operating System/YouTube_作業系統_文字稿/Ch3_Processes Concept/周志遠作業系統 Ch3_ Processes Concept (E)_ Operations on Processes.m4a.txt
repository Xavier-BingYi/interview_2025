undefined
所以剛剛三個不同type的scheduler大家就略微知道記者有三個CPU的部分就是他一定要很efficient。 Long term的部分就是去控制這個degree of multiprogramming那這個meeturn的部分就是在做swapping的動作。所以這就是三個scheduler的角色。那現代電腦當然他變得比較複雜。所以他會跟其他的機制綁在一起等等。但原則上他們要做的事情就是這些memory上面的控制

好那接下來我們要進入到這個process的本身了。所以剛剛是指的是OS怎麼去管理這些process。那接下來我們會回到使用者就是user programmer他到底怎麼樣去create process還有怎麼樣子可以讓這些process之間可以溝通那首先你可以看見在我們的電腦系統裡面process是一個entity。所以我們大家去認它的話就必須要一個unique

的ID對不對。那這個ID我們就稱之為process identifier或簡稱PID。所以這第一件事情很重要大家知道process只要被create出來它就會被assign一個PID那這些process在我們的OS裡面其實我們說過process要怎麼產生它不是一開始就全部都跑出來的其實Process的產生，它是要必須要Create而且是有Parent-Children的關係，就像人一樣，所以一開始

的時候我們整台電腦在執行只有一個Process而已然後透過這個Process才會去Create其他的Process，所以它整個Process之間呢任何系統在任何狀態的時候你一定可以畫出像右邊這樣子一顆Tree出來不管什麼樣電腦系統沒有例外的其實就是一個所謂的Tree of Processes的概念，所以如果它不像Pointer所以你不可能說你用

任何的手段Create一個Process然後它的Parent是不存在可是自己就在那邊像一個Dangoli Pointer這是不可能存在的，在OS管理的電腦系統裡面，它一定是一顆Tree，如果它的Parent不見了，那下面的很抱歉全部砍掉，因為他不然他不知道怎麼去管理它，所以它其實是一個treader的概念，那這個部分呢大家可以在我們的電puter的server寫作業的server自己去看一下，

你可以用這個指令PS然後AL就是list出所有的process，那你會看見它會列出來所有的PID然後裡面或許是哪一個程式所create的process還有一點它會告訴你它的 parent 是誰，所以每一個 process 它會告訴你它的 parent 是誰所以你其實可以把這些數字自己就把它串起來去重建那顆 tree其實是可以做得到的所以尤其是剛把 system booting 起來裡面 process 還是沒有很多的時候大家可以去簡單的去畫一下這個 tree 出來你會發現它其實就是一顆 tree

所以我們剛才說Process的Creation它其實是Parent跟Children的關聯性所以說我們這邊就來看一下在現代的這些作業系統裡面Process跟Children這兩個程式到底差異在哪它到底是怎麼產生出來的一個過程首先你要先知道是因為Parent跟Child它們是兩支不同的程式可是又有關聯性因為它是它產生的

所以這個關聯性的定義呢有我們會分成下面三個比較重要的這個不同的部分那到底是什麼關聯性由這個OS的設計者可以自己去決定的那第一個關聯性就是它的resource之間的sharing的關聯性也就是說原來這個process你一開始只有一個process嘛比如說你open一個file好了那我今天create了一個

新的file的話那這個filecreate一個新的process的話這個process是不是也可以繼承剛出的這個file的handler直接去access這個file還是不行這就是所謂的resource的sharing也就是我們的一個process我們知道它有很多的memory的content像是file的handler甚至於是它自己的memory的space這些global variable甚至於是動態

allocate的variable那我今天create一個新的process的話這些資源這些memory的content他可能是第一個就是share all也就是說他們完全是看到一模一樣的content或者是subset所以說可能是global variable看得到但是動態的variable你看不到或者是node全部都不一樣所以你就是你我就是我我們分家了所以就是直接就是切割我只是把一份copy給你可是我們兩個人是完全不同的memory上的address這是另外一種可能性所以會有三種那我們等一下

會看Linux的話是什麼不過你可以先知道其實是有不同的可以去定義它的關聯性的第一個到底有什麼東西是share的什麼是不share的第二個執行順序因為本來一定是 parent 這個程式在執行執行到一個 instruction 說告訴 OS 扣一個 system code然後說我要去 create 這個children，所以 children 被 create 出來的時候那就有兩個人可是我們的 CPU又只有一個對不對我們要做 scheduling所以說當我們的 OS 完成了這個 child 的 creation 之後

那這兩個人到底誰有優先執行的權利這個其實也是一個選擇對不對所以execute concurrently的意思就是說那我們就讓OS自己來決定scheduler來決定這就兩個只是就想成兩支程式而已誰先誰後都OK看OS的scheduler決定哪一個好就可以這就是concurrent另外一個叫做wait until children terminate對不對所以就是Children就是有比較高的這個Priority就是Children這個程式一定要

執行完我們的Parent才可以接下去執行這個是另外一個可能性所以像這個可能性就是我們之前提到為什麼一個Process它做了Fork之後它會進到Waiting的Queue裡面因為如果我們的OS是這樣定義的話當你Create一個Children之後它就必須要等嘛那就到Waiting Queue啦也不是在做IO也不是在做Sleep就是只是在做一個Child

Process的Create ation所以就有可能會被放到Waiting Queue好那最後一個就是這些Memory的Content也是最重要的部分所以像這邊指的是一些Resource就是一些File的Handler那這邊指的就是我們之前提到一個Process它都是有自己的Address的Space裡面就有不同的section的這些memory的content對不對那所以最後一個部分就是這整個memory的content它到底是

duplicate的就是完全複製一份還是說新的那個程式它就重新去load一個它裡面的這個code的部分也就是你今天create一個新的程式新的程式它如果是duplicate的話裡面的執行碼就會長得一模一樣但是如果是load的意思就是我一create完我就順便也把程式碼給它跟大家講這個program新的process要讓我拿一個program那

我直接把那個program的code直接load進去到它的code section然後把它的program counter也重設所以就是一次就把它變成一個完全不同狀態的一個程式所以會有兩種可能性就是複製複製的話就代表它執行包括了Program的Counter就是你目前執行到第三行那我這個時候去Create一個Children的話，那麼這個Children它在執行的也是從

第三行開始，然後所有的狀態都維持一樣，就是複製，所以你會分不出來這兩個程式會長得一模一樣，然後行為會完全一樣，但是它們的Memory的Address其實是不一樣的位置，因為它只是一個Copy而已，所以只是看起來一模一樣可是其實是兩隻不同的程式所以會有這個第三個可能性，它的這個程式碼的部分要不要是一樣的還是就重新再 reset 過好，那剛剛這個比較抽象很多可能性碼對不對，所以我們就直接看一下真實來講，在 Linux 或者 Unix 這樣的 OS

的話，其實 Windows 也是類似啦，大部分的所有系統，他們定義的這個process creation的定義，那像Linux裡面要去create的話就是叫一個fork的system code，所以你只要code了這個system codeOS就會去幫你去create一個你的這個child出來，那另外還有兩個我們等一下會提到，那這個create的child根據我們剛剛在討論的這些可能性，這個OS的設計的design是說

他用duplicate，也就是說這個children它裡面的memory content會跟parent長得完完全全一模一樣，也就是你當初在call fork之前你有哪些global variable你有哪一些在heap裡面dynamically allocated memory有什麼樣子的content有什麼樣的值我的children我的這個create出來的這個child他會完全都有那些資訊完全一模一樣你有variable A我就有variable A

你有dynamic locate一塊空間出來之後有動態塞進去的值只要是在你call這個system call之前我就通通把它記下來全部copy一份變成我自己的內容然後甚至於我執行的這個program counter的位置都完全一樣所以就等於是完全一樣的兩次程式就對了它就是duplicate然後呢他選擇是 concurrent execution所以說這兩個長得一模一樣而且也沒有先後順序所以有可能create出來之後child是先被執行的也有可能是parent看OS決定

無所謂也就是他不需要被放到waiting state了parent不用等就對了大部分的使用者的需求跟希望也是比較符合這樣那這兩個唯一不同是什麼呢我們等一下以程式碼的例子大家就會看得很清楚也就是Fork這個System Code它也是一個Function Code所以，它會Return一個Value這個Return的這個Value就是它Children的PIDProcess ID，所以當你執行完Fork這一行，那如果你是這個Child的Process的話，這個Function Code的Return值會是0，

因為它是被產生出來的，所以它沒有自己的child，所以它的值就是0，代表不知道它是誰就對了那parent，它知道，所以return值，如果是parent，這次程式的話，同樣執行完，那個程式，它會return的值就是它新create那個child的PID，所以它知道它是誰這跟人也還滿像的對不對，所以父母一定知道小孩是誰可是小孩不一定

有些人比較不信的對不對他從來就不知道他的父母是誰所以，在這個OS管理的世界裡，也是這個樣子，就是扣完之後，parent，他一定知道他的children是誰，因為扣完之後，他就會拿到他的child的PID可是，child，是什麼都沒拿到的，所以他是不知道他的parent是誰他可以再去扣別的system code然後去問OS啦可是，他自己的這個return function不會告訴他

所以，你的程式碼，我們都要有範例，你就可以用這個值，這個Return value來判斷你到底是child還是parent，child雖然不知道parent是誰可是他知道他是child他知道他是剛剛被create出來的人所以你就可以對他做不同的事情了好那call完fork之後呢在Linux這邊的programming的話你通常下一個就會去call這個clc的exe的clp

這個指令在做什麼咧因為我們前面講到heron跟child他們是duplicate所以裡面的content完完全全一樣包括執行碼可是我們今天create一個新的process的目的當然不是要做同樣的事因為一件事情一個process做就好我叫他create出來一個新的process一定是希望叫他去做不一樣的事情對不對那叫他做不一樣的事情也就是說他要執行不同的binary code

也就是程式所以這個execlp它的這個system code的目的就是你可以把它塞一個finary file進去也就是program那它就會把新create出來的process的code segment整個replace掉然後heap stack這些全部清空然後program counter也設成0也就是把它reset的意思所以這樣子的話就可以讓新的這個 child process去等於是在執行完全不一樣

的一支程式了所以你就可以看見它去做不同的事情那不要忘記這邊destroy的意思只是把這些memory的content把它做reset的動作可是為什麼你還是要先create呢因為譬如說你要去Allocate你整個Memory的Space跟OS去Allocate譬如說要跟OS先註冊這個PID所以這個Creation的動作還是要的但是裡面執行的Memory的內容你可以把它清掉重來一遍就像重跑一樣但是這兩個是不同的動作所以這邊指的是我們OS裡面知道有一個新的程式

本來 by default 它會執行跟它 parent 一樣的事情但是你可以去 call 這個 system call那這個程式它就可以把它自己給 reset然後去做不一樣的事情那最後個人也常用到的是 wait那 wait 的目的咧就是因為在 Linux 裡面我們說是 concurrent 執行嘛所以 parent 跟 children 他們執行的這個他們執行的順序你沒辦法控制那如果你想控制是

可以的但是是使用者透過像是wait這樣的system call來控制也就是你call了wait的時候他可以去指定說現在這個程式你要去等待你的哪一個children的程式結束之後他才去執行也就是強迫把parent自己放到waiting queue裡面的意思可是這是programmer自己下的指令不是OS所以如果你想要讓他們做一個這個同步化的

話你就會去call這個wait好那當然其實有還有很多就是children跟parent可以去控制children的一些指令像他可以去cue對不對可以去suspend所以parent當然還可以做對children做很多事情，但這三個是最基本的大家要稍微知道的尤其是前兩個，你可以看見它對Behaviour的影響就是為什麼要先Duplicate那因為是Duplicate所以它必須要去做這個Reload的動作才能夠讓它執行不一樣的程式碼，那我們看範例程式碼不一樣我們先看一下Memory裡面的長相這樣大家可能更串在一起

也就是為什麼 Duplicate我們剛剛看到的這個把它 Reload的動作到底在 Memory裡面是什麼樣子的一個圖像化來講它會發生什麼樣的事情所以像這邊舉例來講我們說 Process 就是 Memory裡面的 Counter所以A這裡就是A這個程式的 Memory的Space這是另外一隻 User的這個程式，這是我們OS這可能是一間空的空間總之是我們系統假設一個目前的狀態

那當使用者去摳fork的時候會發生的事情就是他會把比如說A這個人，他去摳fork那他就會產生一個child那他就會佔住一塊空間，且裡面的continent一樣的顏色，就代表他們長得其實是一樣的，所以就有一隻新的程式跑出來，且在做的事情跟原來這個A是一模一樣的，就叫A-plum或是他的children那這就是創

造出來這個人咧你會發現這個大小咧比這個稍微小一點的原因是在實際上的實作的時候，其實有兩種選擇，第一種是比較naive的選擇，就是exact copy，所以當我們說duplicate，那我就好吧，我就乖乖的copy，所以我就真的，這次如果占了100個MB，我就再LK100給mega半然後把裡面的東西全部copy分在這裡這樣就是duplicate，但這樣做的話，你會想見的是裡面compton完全一樣，所以其實在浪費我們的

memory空間對不對，裡面的資料，其實長得一模一樣，我何必兩份對不對，所以我們在第九章下章的時候，就會也會介紹更仔細怎麼樣可以做到現在比較常的實作方式是所謂的copy and write，也就是說我copy過來的時候，我只會去copy一些它的值，一定會被改掉的部分像是這個program counter的位置或者是一些initialization很基本的variable，我必須要copy的才能夠讓它執行的我會對它做copy可是，如果我不影響執行的我就直接用一個

Pointer你之後會看到就是你其實可以去share這兩個memory的content就是你要讀a的這global variable的話如果它的值沒有被改變那我就直接去讀它parent的值就好可是，畢竟實際上它們是不同的值啊所以copy和 write的意思就是說一開始因為大家都相同所以我讓你們去做sharing的動作但是當你去修改他的值的時候，不論是 parent 或是 child對這個值去做修改的時候，那他們就要分家了，所以是 wrong time

的時候他發現你去動到他的 memory 的值而且這個 memory 值是兩個人在 share 的時候wrong time always 才幫你做 copy 的動作所以這個 a 會慢慢慢慢的長然後最後長到會跟原來的這個人長的是大小一樣但是裡面的content值會不一樣這叫做copy和write，所以說在我們說duplicate的時候啊，一種做法是exact copy很浪費空間那實做實際上的系統做法其實是透過copy和 write那一樣我們介紹memory的時候

就會跟大家再解釋到底是怎麼做到的也就是memory其實它可以做一些sharing像po整體的概念一樣，OS偷偷地幫你去審一些不必要的這個Memory的使用，但是基本上對於使用者重點是對於使用者看到的這個Process而言，他們的Content是長得一模一樣。實際上，OS會偷偷動一些手腳去省掉一些Memory的空間，但是這兩個長得一模一樣。所以，當我們新的產生這個Process，我們想要讓它撞不同層次的時候，我們就會call exe-clp

這個時候，我們就會把C整個把它replace掉就是我們的這個call segment會把它load別的任何一個程式碼，然後，它的heap等等會reset。所以，這一個空間，它的大小還有它的內容就會跟A完全脫鉤了就完全無關，就對了這就是為什麼我們還要再去call execlp的目的，所以這樣，他們就可以執行不同的程式碼.