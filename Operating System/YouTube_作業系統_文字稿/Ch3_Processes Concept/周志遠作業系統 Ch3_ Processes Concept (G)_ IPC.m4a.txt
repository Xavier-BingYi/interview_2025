undefined
好，最後一塊最後一塊我們要介紹的是Inter-processed communication，俗稱IPC，也就是process process，我們現在可以create可以cure了嘛，所以接下来你在真的在使用這些process的时候並不是很單純的自己做自己的事很多時候你需要去讓他們之間要溝通然後去兜一個比較大的一個系統所以你就會需要一些communication的這些method在那邊所以這只是定義啦，所以IPC的定義指的就是在

這個多個process甚至於說threats因為我們說在OS的世界裡，OS自己看到的話，有時候process跟threat不分的使用者當然知道什麼是process什麼是threat，但OS它有時候並不是那麼嚴謹的在做區隔，所以當它離內部它要去溝通的時候，這些統稱都叫做IPC就是這些溝通的機制所以我們會介紹一些在OS裡面，它有提供

的這些溝通的service或者說這些system code啦，好，這個不需要背啦，這是independent process，就是process沒有溝通的這種process，那corporating process呢，這個其實很常見的喔，如果你在implement比較大的系統比較大的程式的時候就是process跟process需要扣過IPC才能夠完成的那其實比較大的甚至你說所有的網路啦所有網路的這些程式它都是Cooperative的嘛

對不對因為你都要有溝通的那溝通的目的大概可以想見到Information sharing啊對不對像是所有的網路的程式都是這樣所以並不限制於一台電腦喔這種甚至於我們等一下會看見Socket也是屬於IPC裡面的一種Message再來呢 平行程式如果先生有注意到的話我們研究所有開大家大事的話或許可以考慮就是透過很多的process或很多threads來解決同一個問題做同一個計算所以可以加速那因為他們是解同一個問題當然難免都會需要溝通第三個

方便所以就像web server像web server的話他因為很多user進來嘛那他有很多不同的事情所以他就會希望那每一個人就對到一個process或對到一個threads所以他會很容易的去管理這些connection最後modularity指的是什麼呢最標準的例子就是microkernel對不對所以我們介紹過microkernel是modulize的一個OS它把所有的component放到user space透過IPC來

做溝通，所以我們的kernel它可能只需要提供IPC的服務，然後讓這些module的這些component自己去溝通，所以實際可以想到蠻多的例子，其實是都會需要用到這個IPC這件事，那怎麼樣讓它溝通呢？這個我們之前介紹過了，所以我們現在再把它強化，重新講更多一些。所以在OS中，它提供的communication或是溝通這一塊，基

本上你用memory的概念來分的話要嘛就是叫shared memory要嘛叫做message passing。我們之前講過可能不用repeat。 shared memory就是你有一塊memory空間，它是shared的兩個人都可以直接用pointer去access它同時做rewrite等等，不違反就是programmer自己去用它就對去管理另外一個就是透過memory的copy，所以這個copy的概念其實就像是一個message在傳遞一樣。所

以，在一台電腦裡面或許你會比較覺得像是memory copy可是這個概念，如果我們把它擴展到跨電腦的時候，那就比較像message的passive對不對，所以你就會更覺得是一個訊息然後在傳遞就像email 對不對。所以，其實像所有的網路的程式，這些socket programming大家有聽過的這些，實際都是透過message的passing的 對不對，然後把封包透過網路傳到甚至於是另外一台電腦上面的程式來做溝通好。 然后這兩個做法其實是蠻不同的 對不對。所以，Share Memory這邊咧最討厭的就是它的synchronization。

我們會有一個章節好好的幫大家來講一講等一下我們有一個基本的例子啦先看一個solution那這是它的最大的缺點所以很難解它的好處就是快嘛。我們講過了然後呢，它是透過memory的address來access你的data的，所以其實你在programmer自己也可以感覺出來，你在用Share Memory的方式在做programming還是Message Passing，如果你用pointer那你就在用Share Memory了。

如果你call一個function code上面說send receive或是什麼setup connection，那個就代表你在用Message Passing對不對好。那Message Passing就反過來，就是基本上它這個用send跟receive的message的方式，所以它必須要透過這個system code然後又要做copy所以通常會比較慢一點那，但是如果你的資料很小或是說你不會去不需要去碰到這些synchron ization的問題的話因

為你不需要去做locking後面講一些很複雜的東西的話有時候message passing反而會再快一些就是當你溝通的太複雜的話你用message passing可以去避開synchronization的問題它的效能有時候是可以比較好的所以也是depends你要做的事情是哪一種模式是哪一種model比較適合但是基本上如果你要跨電腦當然沒有選擇啦跨電腦通常都是要Message Passing但是如果你在同一台電腦像你在寫那種Multi-thread Programming的話有時候或許你也可以

考慮用Message Passing不過現在一般來講大家判別的就是你一台電腦還是多台你溝通的人數是多還少多很複雜你就會想要Message Passing人少資料傳輸很少這個Communication Pattern很簡單很容易解你就用share memory可能就會比較快了好但我們這邊要介紹的是這個根據兩這個model在上面所以我們的OS就提供這兩種但是你要用message passing我到底要怎麼passing對不對

share memory就是thread programming我們會教啦那message passing這邊來講的話你當然不可能直接call system call所以我們就像OS有API所以會一層一層的把它包起來讓使用者比較好用那樣子的方式溝通，但又不用扣一堆System CodeOS就喜歡做這種事所以Message來講最常見的大家都聽過的Socket我也講了好幾次。 Assuming大家聽過了，因為現在網路太頻繁大家應該都有接觸過了另外一個叫做RPC

或許各位可能還沒接觸過，但事實上很多大型的比較大型的系統尤其是需要跨電腦的分散式系統都是用RPC這樣子的一個method做Programming的。就像有所謂的Socket Programming那也有所謂的RPC的Programming不同的用這些API去做Programming就對了好 Socket大家可能比較熟的對不對或是非常建議大家，因為這很基本如果不是很熟一

定要去修一下網路的那個基本的Programming寫一下Socket Programming的程式。那 Socket的重點就是它去identify一個使用者的方式，就是透過IT跟Port純粹網路的角度。所以我們知道IT通常指的是什麼在電腦世界裡指的就是一台電腦不難想像Port什麼是Port我們知道HTTP都是80、88然後FTP就是21嘛所以都有一個port numberport number指的是什麼port number指的是process其實port number就是process所以你會發現任何一個網路程式他去用Socket programming的時候

他第一件事情是他要去bind到一個port上因為這樣OS就知道這個port來的風暴就是交給那個process然後那個project自己再去做剩下的事情所以其實你就可以看這兩個就在identify在我們的網路世界裡哪一台host然後上面的哪一支程式所以絕對不可能有兩個process可以綁到同一個port的case因為那就沒有辦法做分別了對不對所以這件事情絕對不會發生的所以他用這種的方式就可以讓任何地方的兩支程式透過SAC可以開始做溝通了

那溝通的方式呢Socket的溝通方式是非常low level的意思就是說你就是給一個message非常標準的一個message裡面就是一堆string of bytes而已所以沒有資料型態所以大家如果寫過一些HTTP的就知道那個content裡面body裡面message body裡面就是一堆bytes而已sender receiver自己要溝通好才能夠去解讀裡面的內容

所以並不是傳一個Integer或是傳什麼一個Data Structure給你對不對這個就是Socket Programming因為它很low level你要有Data Structure你用其他的方式好 這就是Socket我們當然這堂課沒辦法去寫這個Programming啦但是大家要先知道這就是IPC裡面的我們OS有提供出來的一個方式Message Passing的包起來的一個服務了

另外一個呢其實也是非常非常重要的就是我們說的remote procedure code所以跟Socket的最大不同exactly就是這句話講的Socket很flexible它非常的low level就是string of bytes可是大家都寫過Pro1都知道我們喜歡寫function code對不對我們總是在找function code所以今天其實兩個這個不同電腦上甚至兩個不同電腦上或是不同process之間

要溝通的一個方式你也會希望的就是用 function code也就是說我們知道每個 program 自己有自己的 function code那我們今天要用 inter-process 溝通如果我能夠直接有扣你的 function code那就溝通的話是最好的對不對所以為什麼它叫做 remote procedure code就是這個意思就是你可以去扣一個 procedure code而且這個 procedure code 是 remote也就是說它是在另外一個 process 的

甚至於是另外一台電腦上的process這個就是RPC的目的了所以這其實當然是一層API啦所以是based on system OS的一些system code然後再去搭上去的然後最後explode出來一個RPC的API讓使用者做programming所以它的這個如果用RPC的好處就像右邊這邊看到的所以我們的server呢指的就是provide這些method的那一支程式就要定義一些 function code那我們當然沒有 detail但是透過這個 package 這個 library你就可以去告訴你就可以 register

說哪些function code 是 RPC是可以提供讓人家去 code 的然後當然跟 socket 很類似你要去 setup 一下你的 port還有一些東西啦那重點是你的 client 端用了這個 RPC 之後你就可以直接 code某一個 server 它上面的 function code而且重點是這個input跟output的argument它是有data type的所以它不是一堆bytes而已，所以你會定義它是integer還

是floating point是有type的這個上面的然後你可以去return一樣是有type所以就比較像programmer就不需要去care了它到底是在哪一台電腦或是在哪一個process反正就像code一個function code一樣的方式去溝通這個就叫做RPC了，所以剛剛是這個RPC的部分那Shared Memory這邊我們說其他主要就是用Thread Programming的方式那這個Shared Memory它的基本上你要用這個方式的話

你要的條件就很單純也沒有什麼API因為它就是Memory Access就是Direct的所以它唯一要用這個方式的唯一的條件就是你要有辦法去Create一個Shared Memory的Region出來就是你要有一塊Memory的空間是這些Process跟OS都知道它們是可以共用的那這件事情呢其實By Default是不會發生的因為我們知道OS的Protection的機制嘛所以

不同process是不可能會有shared region跑出來的，所以說呢我們等一下會有簡單介紹system code可以做到這件事啦，但基本上這個要去溝通的這些process他們要自己去call system code去create出這一個region出來叫OS幫忙去create出來而且呢透過這一個region這個memory region去溝通的這些process同樣也要再扣另外一個system code叫attach然後跟OS講

我去用這一塊空間這樣子所以全部都是在OS的管理之下簡單講就是你不要這些system code去告訴OS哪些memory的空間是可以被share的那扣完這些system code之後這個region被create出來之後OS就什麼事也不幫你所以這個使用者咧必須要自己去決定怎麼樣去使用這一塊空間因為它就是一堆bytes而已嘛所以你要locate什麼樣的data structure或怎麼樣

用這些pointer來去access這些data是兩邊溝通的process自己要鎖好的OS都不負責了對OS而言上面的content是什麼它都不管反正你們要去access它不會去檔就可以了它只是負責這件事所以使用者要自己去決定到底要怎麼去管理跟使用這塊空間還有一件非常重要的就是我們剛剛說的Synchronization也就是說如果有兩個以上的兩個或兩個以上的Process同時想要對這塊Content去做Write的動作的時候通常會產生Synchronization的問題也就是你不知道結果是什麼啦

這個蠻直觀的對不對因為一個人說比如說我們把一個counter來為例子一個counter的這個variable放在這個空間讓大家知道裡面到底有多少element一個process負責把東西放進去所以他會做counter加加另外一個人把counter拿出來所以他就會做counter減减加加减减大家覺得好像沒什麼5加1就變6嘛再减回去就變5

可是當兩個人同時執行加加减减的時候我們後面會有singlization會有很仔細的例子答案不是4喔就是5加了1再減1答案可能不會回到5它可能會跳到3或是6我們之後會講register sharing的一些問題同時write的時候那個值其實是你是無法去就是它的可能性不是你program statement看到那樣子因為我們知道statement加加其實會變成好幾行assembly code對不對所以這些assembly code混在一起的時候

那同時又share同一個memory content會出問題所以其實這些部分重點是使用者要處理就對了就是synchronization這很討厭的東西使用者要自己想辦法好我們就直接用一個例子share memory of programming的感覺怎麼樣去addresssynchronization會是什麼樣子我們用一個最標準的例子叫做consumer跟producer就是我們剛才說的一支程式負責

去產生information另外一支就負責把它consume把它拿掉就對了那具體的例子就像這樣假設我們有兩支程式所以這兩支程式不一樣的程式但是我們在共用這一塊memory的buffer怎麼create那個我們就跳過了反正system code你有辦法create就對了那producer他的目的就是他會不斷的放這些content進去所以這

邊顏色深的就是有東西的那就是producer就是不斷的寫就對了那consumer呢他就會把資料把它拿出來所以就會把資料讀出來所以他會把一個一個拿掉那為了要去透過這一個buffer這個buffer你要注意到他的size難就難在這他的size是有限制的只有b個element可以放進去因為buffer通常都

是有限的嘛是常發生的可能很大可是還是有限所以當我們兩支程式比如說透過這個buffer他們在做溝通溝通就是把資料放進去拿出來的動作的時候，那你要去管理的至少像我們這邊這個例子來講會需要的方式就是我要定義這些東西第一個我要有in這個pointer，這個是給producer的，所以他

知道他要寫到什麼位置那consumer會有out所以就是他把資料讀出來沒問題，那難就難在有限空間，所以你必須要判斷兩件事才不會讓你的buffer overflow或者是做錯誤的事情。第一個你要知道什麼時候這個buffer是empty，因為如果buffer是empty的話那consumer就不能夠再繼續移動他的這個pointer然後拿資料啦，因為是空的嘛

空的你不能拿資料嘛，所以你要等對不對所以他必須要等producer所以empty是必須要能夠判斷出來的一件事情，負也是必須要判斷因為就是反過來的case，就是當我的consumer他的速度可能比較慢那producer一直丟資料有可能buffer就滿啦滿了你不能再繼續寫嘛，因為如果你再繼續寫就會override原來的資料，那就完了資料就lost掉了對不對，

所以對於producer而言他必須要知道什麼時候這個buffer是滿的對不對所以就必須要empty跟負兩個概念這兩個人才有辦法去共用這個buffer，你不能自己一味的就一個wire loop一直在那邊寫然後一個就wire loop在那邊讀你要有判斷那在這邊這個solution你可以看見我們這個例子來講我們透過in跟out的判斷方

式就是如果是empty的話in跟out的值會相同因為很簡單你看這邊對不對我們把它拿掉的話out會往下移一個所以全部拿光in跟out會都在這一個相同你就知道是empty對不對滿我怎麼知道是滿的就是大家可以在這邊一直加加加加加回來之後當我們的in的值加1然後ma的筆月它可以回啦 回去了所以這是一個run rapid的一個架構對不对所以它會等於out的時候我就知道它是滿的了那你可能會問我為什麼

如果你去模擬一下這個狀況是什麼時候就是當我的in的值在這裡對不対所以意思代表說這一格永遠是空的因為如果我in這邊雖然有一個空的然後我的這個producer它繼續寫的話會發生什麼事會發生這個in的值會等於out對不对可是所有都填滿喔所以in等於out它有可能是empty有可能是負那我就完蛋了我們兩個人溝通就不知道到底發生什麼事了對不对所以為什麼我這邊負的時候它要加1因為加1的目的就是

我會事先停住我不會真的寫滿因為如果我真的整個寫滿你會發現in的這個pointer值又會等於out那這樣這一個condition就不成立了或者不知道到底是什麼了，那就完了。所以這邊為了要synchronize兩個process，實我們犧牲掉了一個儲存空間才能夠去定義這個relationship。所以這個是他的這個solution的缺點。 kitaue未來會介紹locking

的機制，就可以解決掉這個問題了。就不會浪費掉一個空間。然而大家可以看見，這個就是我們剛才說的share memory programming。你要去programmer，要負責的。你要定義我這個是一個buffer，我有多少的size。我用這兩個方式statement來知道他到底是滿還是空然後我就可以用這樣的方式去寫program。這是我們剛才說的。實會浪費掉一個

空間，這個solution我們應該可以很快看這個程式很直覺。所以根據我們剛才的定義，這兩邊要溝通的programming會長得像這樣。 producer就是wire它是一直在寫，但是我們會利用我們剛剛說的判斷它是不是滿的。如果是滿的話，那我其實注意這邊是一個分號在這所以滿的話他會等，即所謂的BZ waiting一直在那邊loop這樣子。只有不是滿的時候

他才能夠去寫然後移動他的pointer。那consumer就是不斷在consume，但是要小心。如果in等於out就代表是empt yempty我就不能夠再把資料讀出來了對不對，所以我就會大家注意一下分號在這邊，每一次都每一年都有很多人問我怎麼回事，注意一下分號在這，所以會卡在這一行好不好，那只有當這個condition這個沒有發生的時候，你才可以跳出來然後去做這個寫出去的動作

那中間你可以看到像BufferSize除了要去這塊Memory這個SharedMemoryRegion裡，除了存這個Buffer之外，其實我們還要去存In跟Out的Pointer的值，還有這個Buffer，所以這三個這些就是你都要存在SharedMemory裡面的資料了，所以這就是一個標準的SharedMemoryProgramming就會像這樣子，那這個例子我們當然沒有看到任何locking所以我們到了第七章的時候就會用介紹其他的locking的方式然後重新來看這個example然後可以使用到所有的memory的這個buffer的空間.