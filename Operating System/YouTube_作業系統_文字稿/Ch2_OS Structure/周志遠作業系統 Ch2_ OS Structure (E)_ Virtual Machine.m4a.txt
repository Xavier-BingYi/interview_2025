p.22
我們後面介紹了好多個不同的Architecture，所以大家也要稍微知道它的定義到底是什麼它的好處跟壞處，像Simple就是很簡單，所以說Developer有很多的自由他可以用任何方式去建構他裡面這整個OS的架構，但缺點就是因為他沒有分任何的區分，沒有任何的概念，非常自由沒有任何的規則在裡頭，所以很容易有bug或者是很容易被hacker給侵入，因為他可能設計不是這麼的嚴謹，那會不會造成一些這個Maintenance上面的問題，Layer就把這些OS所有這些Component這些程式，把它去做區隔變成從最底層的到最上層的，那每一層裡面的被定義在每一層裡面的這些component或者是程式，就只能往他下面call而已不能往上，所以當發生問題的時候你要去maintain的時候，你知道你的影響會是誰你修改一個function call，你知道你只會影響你上面的人不會影響你下面的人或者有bug debug你可以一層一層layer去做debugging

Micro Kernel請大家一定要知道因為這個是非常特殊的就是它的概念是把OS最核心的部分定義為必須要的Kernel，其他的部分它盡量都把它變成一堆的Module，就是變成這個Module可以去做替換的動作，所以它就是希望這個OS是可以Configurable，它可以去替換這些Module的，而且還有一個非常重要大家一定要記得是這些Module是Run在User Space，所以OS的概念裡面你要清楚Kernel Space跟User Space的差別，所以很重要的一點是不只是把它Modulize，而且是把這些Module要放在User Space，那因此他在溝通的時候就必須要透過Message Passing的方式對不對，這個Service Communication的Service提供你核心OS的這個Service去做溝通，所以就會比較，效能上來講可能就會比較慢一些，因為這個去call Message Passing的System Call Interrupt非常slow對不對，但是很modulize，所以非常的flexible可能更reliable，因為它的kernel的核心很小，所以出錯的機會當然自然就小，所以大家光看名字就知道，microkernel意思就是kernel要非常非常的小能這麼小不是沒有原因的是因為他把它全部變成user space的module，不把它當作kernel的一部分了

那module的OS就是現代的OS比較這個主要的這個架構就是從這邊來的當然也有衍生所以我們說它就會跟其他區域做合併啦，但大部分都是所謂的這個Modular的OS，也就是一樣希望有Modularity，所以變成一堆Module，你可以Plug in，但是它全部都在Kernel Space，所以可以運作得更有效率一點，那我們也給大家一些這個link，所以其實有興趣的同學自己可以玩玩看。 insert一些kernel module那可以去玩一下，其實是很容易，可以去動到OS的，就是因為它是module，所以其實可以去用insert kernel module這件事情來去修改OS，好，那我們今天最後就要講這個virtual machine的部分了

---

p.28
好，所以相信大家都聽過Virtual Machine聽過的舉一下手好了。我稍微知道一下應該不少吧，對啊，所以大家一定都聽過也非常非常的popular那我們等一下也會提到為什麼這個Virtual Machine其實並不是這一兩年才出來的，不要以為或者說十年，其實它已經出來了四五十年所以大家不要surprise其實Virtual Machine在四五十年前就有這個技術了，因為早在大家在想說OS設計是什麼的時候就有人提出來。我應該用Virtual Machine的概念來管理一個Hardware，也就是一個Hardware電腦上，我有很多使用者，所以為什麼我只要一個OS，為什麼我們不是每一個人有一個自己的OS，這會不會是更好的去使用共用一個硬體的方式呢？所以很早就有人提出Virtual Machine也真的做出來，那真的會work所以有非常好的isolation，因為自己有自己OS，所以你完全不用怕任何使用者對你有任何的影響，當然當時並沒有這個非常popular非常成功的原因是在於計算的效能太差了，硬體沒有那麼的厲害我們的CPU還沒有那麼的快，我們的Memory沒有那麼大，所以說每一個人不只run自己的application還要再run一個自己的OS，那個負擔太重了，所以讓整個電腦的效能沒有辦法很理想不符合當時的應用跟需求，所以沒有那麼popular，但其實那個技術是早就有的

好，那所以什麼是Virtual Machine呢？所以你可以看見Virtual Machine的概念就是它把下面的東西整個抽畫，我們說OS本來就有這個特性但只是它抽畫的這個定義更general一點，也就是下面即使是已經有一個作業系統了，或是已經有別的軟體存在，它仍然有能力把它抽象成就像是Hardware一樣我們等一下就有圖就知道那個意思，所以它的特別點在於說其實你灌一個OS我上面還可以透過Virtual Machine這樣的技術再灌一個OS，然後把下面的這些OS或是已經既有的這些軟體這個系統電腦的系統把它抽象成為就像它不存在，就是原來裝在一個Physical MachineHardware上面的狀態一樣，所以它是這個Attraction是更進一個Layer的

那其實我們在介紹NACHOS的時候也就，大家就看到了，那就是一種去virtualize一個這個computer system的方式透過translation，然後去轉換指令然後去做這件事情，那當時我們看到的像NACHOS它很單純是它只負責去轉換instruction這件事情，可是其實我們知道在電腦系統運作不是只是CPU instruction，它還要去做IO等等很多的動作對不對

所以在這個Virtualized的Technology裡面這個技術裡面，它為什麼困難如果你今天只是Translation你會想沒什麼嘛翻譯嘛一對一，反正不會差很多，它很難就在於說其實我們的Software在設計的時候OS自己在設計的時候就有一些Assumption對於Hardware上面，其中一個造成很大困擾的事情就是所謂的Critical Instruction

---

p.29
那什麼是Critical Instruction呢，這個在Virtualize的時候我們直接看圖就知道了，所以這個就是Virtual Machine的定義，原來是Hardware，上面就是OS了，那如果我們所謂的VM的意思就是Hardware上可能還有一個本來的OS或者是有一些管理的軟體，然後在上面我們可以去create virtual machine每個virtual machine它自己又有它自己的OS，當我們說虛擬化的時候指的東西並不是修改這個kernel而是這個，就是你怎麼樣可以加一個layer讓它變成在這台電腦上我可以run很多個virtual machine同時run，可是卻完全不知道彼此的存在然後每一個人都認為下面這整個Hardware是只屬於它的，這個就是Virtual Machine的目的跟不一樣的地方了，那困難點就在於Again, User Space, Kernel Space這個不要小看它,它是Fundamental的架構，所以我們知道Kernel在運作的時候，它的假設是它在kernel space所以它才可以去執行像是privilege的instruction。

但是在這樣子的設計下，大家有沒有發現，如果這個是真正的kernel的話，這個kernel其實是裝在user space，對於這個最後最底層這個系統而言，這個kernel其實是一個run在user space的kernel。所以這個kernel我們必須要讓他是假的嘛，所以他應該以為自己下面沒人，他應該要以為自己在Kernel space，可是實際上他不是，所以當他執行privilege instruction的時候，問題就來了對不對本來他可以執行privilege instruction，因為你call他的code的時候，他就已經應該要在Kernel裡面，可是在這樣的架構裡當你去call這個他的system code的時候，他的privilege instruction其實他還是在user space，所以變成他沒有辦法執行，所以這就是為什麼沒有那麼辦法直接去所謂translation這麼簡單的事情，因為你就算translate成下面的instruction，可是如果它是privilege instruction你在它的user space執行會fail掉，所以這個方法其實是很容易就解決的，就是當初第一代Vertical Machine大家討論的時候的solution就已經很快的知道的方式就是還記得interrupt了嗎？對不對?所以當你privilege instruction無效在user space執行的時候，是一個無效的東西所以我們的電腦會丟什麼勒?丟出一個signal說這是一個exception，這是一個非法的指令對不對，會被擋掉可是擋掉的時候呢畢竟這個interrupt他會回到哪裡呢，他會先回到下面這個OS所以這個OS會先接到這個interrupt，那接到這個interrupt之後，他就知道原來我上面的這一位他想要執行privilege instruction可是因為他在user space不行執行，好吧我知道他是Virtual Machine
所以我幫他執行，所以他再去Call了一次他應該要Call的那個Instruction再幫他丟一次，但是是在這邊丟，因為已經到了kernal Space了對不對，所以他就可以幫他再重複執行一次但這一次就會過了對不對，因為這是他執行的而不是他，所以這Instruction就像沒有Virtual Machine的時候一樣，我們知道要說User Space的Code還是Kernel Space的Code對不對，這裡也一樣，這邊Kernel他去Code，在User Space的Code privilege instruction之後會被擋下來這是一定的，可是擋掉之後呢你就會進入他的Interrupt Handler也就是這個Virtual Machine的Layer那他只要加入一個Handler的一個Module一個Routine直到被Notify之後他就去無條件的去幫他執行，那其實這個會go through，然後就可以回去了，所以Virtual Machine可以run的一個很重要的概念是這樣，它其實是攔截了interrupt之後，再幫它執行一次，才可以讓你在user space做kernel space的事情，實際上是下面有人幫它做啦，不是它真的直接做，那當然你就會發現這樣的做法比較慢，因為System call本來就慢或者說這執行本來就慢，那原來是做一次你現在就做兩次了嘛，下去上來再下去所以我們就說VM有時候Virtualize效能為什麼差，就這個原因，因為至少在計算這邊你只是做兩次不是一次Kernel是privilege Instruction，如果不是privilege Instruction這會直接go through這都沒問題，所以只有Preview Instruction他會做兩次那你就有聽過啦有些VM說Hardware support大家去買這個CPU買電腦的時候你可以注意應該留意一下電你花錢花在哪，他會寫說這個CPU有沒有支援這個Virtualization的Technology這什麼意思，代表那個CPU是Hardware Support我們提過Hardware Support的概念嘛，其實電腦設計常常會有用到這個，代表那個CPU，它是Hardware Support，也就是它裡面其實加了一個bit，它知道還有除了Kernel Mode、User Mode還有VM的Mode，virtualized Mode。所以當它看到privilege Instruction，是User Mode，當你RUN了這個時候，它其實會知道這一個指令，雖然是privilege Instruction，它不是來自User也不是來自Kernel，而是來自這個VM，他就會讓他go through，就是他會特立，就這樣的話CPU自己就能判斷就對，他自己知道是真實的這個layer還是虛擬的這個layer，還是真的是使用者的code，它可以分，所以這樣的話，你的程式嘛，對不對instruction就可以一次下去，不用上來了，我CPU自己會知道到底是可以執行的還是不可以執行。

所以這是基本概念，為什麼會有hardware support這個東西會跑出來這樣，它就會變得比較快，可是這樣看起來很美好，好像問題解決了，但是有個非常討厭的，就是我們剛才提的這個critical instruction，critical instruction是什麼呢？這個當然課本上也不一定有了，大家當作補充知道就好這個考試也不會考了但是知道比較好，critical Instruction 的意思就是這 Instruction 很妙，critical Instruction 不是privilege所以 User Space 也可以執行但是很奇妙的是這種 Instruction 的特性，它在User Space執行的結果跟Kernel Space的時候執行的結果會不一樣，不要問我為什麼，問那些X86 Instruction的Designer ，For some reason它有這個需求，就會有這種Critical Instruction，意思就像是同樣是加，在同樣一個Instruction叫做加，它在User Space執行它就是加，A加B；它在Kernel Space執行，它會變成A加B加B就是A加2B就對了，像這樣它的Behaviour是不一樣的，這種Instruction就叫做Critical Instruction這種Instruction當沒有Hardware Support的時候，問題就來了，會變得非常複雜，就是純用Software要解決這問題就很難，因為什麼呢它不會被Cache就是它不會被我們下面的Hardware發現它會丟一個Interrupt，因為它可以做，所以它就會幫它做可是它不知道做的結果到底是對還是錯。如果是Critical Instruction，我們說Hardware會直接攔截，所以它可以幫忙執行。可是，如果是Critical Instruction，比如說我們說在這裡執行，它就是A加B，那在這裡執行，那我們的Hardware也會go through，所以它就真的幫它執行了，但是它執行的結果就是A加2B，所以變成是你必須要有辦法知道什麼是 instruction 是 critical instruction，然後這個要知道的方式不能夠再靠我們原來這個下面這個定義就是 privilege instruction 的這個定義，來去來去判斷了，用其他的方式就變得很多說了，所以反而变得麻烦了，也就是说这个太自由我們说的就是，如果你就像我們没有kernal Mode,User Mode的话，其實电脑是没有办法正常运作的，那critical instruction就是这种case，就是你直接去执行的话，实下面的人没办法分别他也就不会通知上面的去做不一样的Handle，所以 critical instruction就是一个很讨厌的事情，所以 Software虛擬化不是那么簡單有很多issue，instruction這邊就是要去handle critical instruction的存在

---

p.30
那high level對不對,為什麼這個VM會這麼popular呢?有幾個原因，因為它有很多好處嘛，有很多對帶來人使用電腦時候的好處。

第一個，它可以Protection，這就是我們一開始說的OS設計的時候，一開始就有提Virtual Machine的原因，是因為它認為這樣比較好的Isolation，不同的使用者可以供應一台電腦不會互相的影響也就是不會互相的去，就是可以Protect這些使用者。它是更Aggressive，你就算去Hack一個OS你也不能Hack到另外一個OS，這是完全不同的系統了，所以基本上是Completed的protection，所以這是一個，當初一開始的時候很大的一個原因，現在當然一樣大家還是有用這樣的方式

第二個compatibility，這個尤其在現在大家在關VM的原因，大部分其實是這個看起來很很繁瑣什麼叫compatibility呢？意思就是為了一個software，software所謂的legacy的software什麼叫legacy software就是說它在灌的時候，它一定要那個環境比如說這個software我就是要Windows98或是Windows更早以前的，就是很早因為它比較老的software，所以當初它就是那樣開發，很常見，那它就一定要在那個環境裡那問題時代變遷我還有很多其他軟體啊，我在我的電腦上我要讓很多應用程式，那每個人要的環境如果不同那我怎麼辦，那我不是買很多台電computer嗎，這台電computer是這個系統這個是這個系統只能讓這個application，這件事情尤其在業界非常非常常發生對不對，可以想見他們用很多Tool也不是專家你也不能叫他去灌自己去修改OS所以他們就會被迫變成一個環境一台電computer然後買一堆電computer然後只run一個application是非常浪費錢沒有效率的事情，那有VM，對不對，欸，不一樣了，我今天就買一台電computer，我就灌一個作業系統對不對，我最常用的或是我覺得是最有效率的，那這個我可以巡邏到這個環境，簡單，我就開個VM嘛，然後就去執行它，對不對所以相信有些同學有玩VM的可能也是這個原因我們譬如說上課的作業必須要在Linux環境你只有Mac,或你只有Windows怎麼辦那你就灌個VM上面去run就好啦對不對所以這叫compatibility這個在業界的需求是相當相當大的帶來他們很大的好處雖然pure engineering，但是這是很real的一個問題

好再來第三個VM常常被拿來在academy這邊用的東西是做research跟開發，什麼意思，所謂的research開發就像是我們說開發程式尤其是你做更系統做到kernel裡面的一些開發的時候我們說Kernel只要有bug它就會crash嘛對不对所以可是我們在開發在做研究的時候當然常常寫一堆buggy的code啊對不对一堆問題這一定的，那如果今天你沒有VM，你就實體機器OS你就改它，然後去run，第一個你deploy很麻煩你就沒寫好一個版本的OS你要重新再裝一次那個OS對不对，然後如果有bug，哇是整台電腦就crash掉就整個關機重新開機重新開機關機這樣子恐怕Hardware也馬上就壞掉了，對不对，所以是非常痛苦的事情，但是有了VM之後這件事情就完全不一樣我就去改VM嘛，VM再怎麼crash這個OS再crash也只不過其實是一個Program而已啊沒什麼，我們常常control C嘛，所以就變成這樣子你可以去devaluate，然後不用怕這些會有bug可是不是整個系統損毀，甚至於你可以藉此就可以把一些資料可以，可以寄下來等等，State有可能寄到它下面的那個真的Machine上面去對不对，所以就可以做很多事情，另外一個非常有趣的應用非常非常常見的應用很好玩的叫做Honey Fund，在做Security的人最常喜歡用做這件事情，什麼叫做Honey Farm就是一個蜂巢，你知道做Security的人，他們最需要是什麼？知道人家怎麼攻擊，我才能夠去Counter Attack對不對，所以你要研究一台電腦是如何被攻擊的或是被攻擊之後它會發生什麼事情。如果今天你要去蒐集這些資料，那你沒有VM的話那就是開一堆有問題的Physical Machine在那裡，然後讓它被攻擊，可是因為被攻擊了會非常的危險也是這台電腦會整個就crash掉，或被整個影響然後呢，影響之後很可能你上面的資料就全部都沒了所以你根本沒辦法收集因為就整個被破壞掉了對不對。但是如果是VM的話，我只是開VM所以我就開VM是假的讓你去攻擊，那就像剛剛，比拜有點像，所以就可以把它被攻擊的東西可以把它記錄下來，因為其實那就只是一個virtual的machine而已所以就是假的讓你去去攻擊的一個OS而已，所以就可以透過這樣的方式去蒐集這些attack的pattern跟behavior，然後做研究，所以這是非常好用就像個honey farm去吸引這些蜜蜂進來，然後去在上面使用一樣，所以其實是有很多研究需要VM這樣的一個技術，

最後了，之所以大家會聽到這個可能只有特殊的領域這可能只有業界對不對為什麼現在大家都知道，Cloud computing雲端計算對不對，也就是其實現在大家講求的東西是資源的共享，並不是用自己的電腦在那邊做計算，因為電腦自己的resource是很有限的，所以五六年前已經很久了，所以這很成熟了。雲端計算的崛起就是這些大公司Google、 Microsoft對不對還有其實最大的是Amazon，賣書的，這故事我們就不講為什麼是Amazon，不過他基本上就有很多的這個Data Center，很多的電腦資源，所以他就想辦法讓大家只要能夠連進來來使用就好，就像大家在寫作業也是連到我們的server嘛，所以其實你只需要是什麼，能夠送SSH的連線連過來就好，你是用手機，你是用什麼device無所謂，你手上只要能連線，能下comment能下指令就好，其他事情其實都可以在一個遠端的機器，所以Cloud computing就是像這樣的概念出來的，所以你不用再去買你自己的硬體了，你就來用我的就好，然後用租的方式，這有非常非常多的好處，有興趣的未來大家再去修Cloud Computing或是Programming的課，所以變得非常非常熱門，但這個技術的一個重點就是Resource的Sharing，而且不只是要讓大家共享還要Make sure資源的使用率是高的，因為以一個Provider的角度，我買的實體機器，如果所謂的sharing只是一人，我給你一台實體機器的使用權，我根本很難賺錢或者成本很高嘛，因為一個人使用大家用的量其實很少，所以會有很多空的CPU的cycle在那裡，那透過VM就是一種資源管理的方式啊，所以他就可以把它做切割，實體機器很大，但我可以把它切割成很多小的Virtual Machine，使用者根本不知道，反正他只要login他Server有OS在Running就好，到底是Virtual的還是Physical的無所謂，所以Cloud Computing這邊尤其是剛開始大量使用VM去實現這個理想，當然也要澄清。 Cloud Computing跟所謂的虛擬化沒有一定要透過VM，Sharing有很多的方式，只要提就好。你們有興趣自己再查，現在更多人是使用所謂的Container，就是容器，有興趣再去查就好。比VN在LiveWay一點可是可以達到相同的目的，就是很多人共用一台電腦就對了。而且要有一定程度的isolation，這個是重點。大家共用電腦，如果你看到我，可以看到你，那就跟我們的Linux Server一樣，方便，但是沒有人這樣，你不會覺得是你自己的電腦，雲端是要讓你做到你認為那是你自己擁有的電腦，沒有人在跟你共用，實際上是共用的

---

p.31
所以知道為什麼要有VM之後我們來看VM這邊，它的技術就是Virtualization技術，其實也可以分幾類型幾個比較主要的第一種我們稱之為所謂的Full Virtualization，所謂的Full Virtualization的意思就是當然還是一樣，只要在這個虛擬化的世界裡，你就會有下面的這個原來的OS，我們通常稱之為Host的OS跟上面，其實是在User Space然後ROM的這個假的這個OS，我們叫做Guest，所以它只是暫時來的那個OS，那當我們在裝這個整個Software stack的時候，如果是Full Virtualization的定義就是，上面的Guest OS的程式碼完全不用動，就是這個OS如果今天可以裝在一台Physical Machine，它就可以拿來裝在這一個環境裡，然後去run一個作業系統，那這件事情當然是所謂比較ideal，所以我們叫做Full就是它完全渾然不知自己是裝在虛擬的世界上，所以我們稱之為Full Virtualization，那做到這點當然就會比較困難一些，又要去handle我們剛剛說的那些issue，因為上面完全不改意思就是你只能靠下面這一層，你裝的所謂的virtualization layer，這個software或這個kernel的module或者是Hardware support來做到，這叫full virtualization，那早期的時候VMware大家都聽過為什麼它是VM這邊的最大的一個公司，就是因為其實它能夠做到full virtualization而且沒有靠Hardware喔！因為早期的時候CPU是沒有提供那些我們說的Hardware Support，那VMware就做到，所以這是它的厲害的地方，它能做到Fulfillization，然後不靠Hardware，那當然其他部分它也有很多它自己的Unique的地方，然後比較Powerful Complete的一點，但是它是一個Fulfillization，所以你在用VMware的這個方式Solution的時候，你可以拿任何的OS的image就是CPU的這些直接去裝，它可以Round的起來這叫Full Virtualization

---

p.32
另外一類型叫做Para Virtualization也就是一半的意思或是說是平行同時，為什麼叫做平行同時呢？它的意思簡單來講就像右邊的圖，大家知道概念就好，也就是像剛剛一樣。上面這個Zone，這個就是Guest OS，那下面就是Host OS，差別在你會看見左邊有一個Global Zone，或者說我們就叫他就是Master或者是這些Manager啦，也就是說呢，這邊其實會再run一個OS或是程式，但這個是一個Special的程式，他其實是知道所有的VM的存在的，然後這邊裝的Glass OS重點是他要被修改，所以他不是說你隨便拿一個就可以裝上去，這個叫做Para-virtualization，只有一半，所以它只有一半的把它虛擬化，你的 guest OS其實必須要被修改，所以它就比較有一點限制，這個就是所謂的 parallel virtualization，那因為用這種方式大家可以想見就比較容易實現虛擬化的概念嘛，因為你像開後門嘛，對不对，所以你就可以做到一些事情，就像 hardware 你可以開後門，那就是所謂的 hardware support，所以重點是 guest必須要被修改到，好這兩個比較沒有重要，大家只要記住這個turn就好了，就是guest會被修改到，那就效能而言，就是說這樣子你多了一個master，它的效能到底會好或快跟前面比，這個沒有一定，而且甚至於有些情況下大家的研究比較發現這個效能反而比較好，為什麼呢，原因是因為，這邊有很多的VM，我們知道OS都有很多的管理策略，像我們這堂課慢慢會講的CPU啊Disk等等，它都是在Under一個Assumption，這個Hardware只有在我的前提下，我這樣去設計我的演算法跟管理方式，一定的嘛，然後達到最佳效果，但是在這個環境，這件事情是錯誤的，因為其實大家是共用簡單來講就像如果說Disk的Access你讀檔案，我們說Sequential的Access比較快這我們已經講過了對不對，所以這邊的File System的設計，他可能會故意把使用者讀取的順序Reorder，讓他變成Sequential他就覺得快了快了，結果很不幸的是不是因為大家共用這個Disk，所以你是Sequential，我是Sequential，加起來叫做Random，所以沒用，所以你做老半天，Optimize半天卻不是得到最佳效果，那在Full的Fertilization的時候，一定會這樣啊，因為你沒有下面的管理者，但是在Pera的話，這是Administrator所以這些功能他們其實會去這個人才是最後做決定的人，所以就是他會拿了他們的Pattern過來，他再重新優化一遍，然後再下去，所以有Manager有Master他就可以有的時候他就可以做一些這種更Global的優化，當然缺點大概就是他們要跟Master溝通所以會多加一層，所以當然也會有一些Overhead，多餘的這些花費，所以並沒有說哪一個一定比較好，當然現在有Harvard Support等等，比較熱門的可能還是Full Fertilization如果大家想要試full virtualization的software，這邊我們有講Para叫做Xen，這是最有名的大家可以download，叫做Xen這個軟體。 Full virtualization的VMware很貴，非常非常貴還有它的技術啦！那如果你要open source，大家可以去download一個叫做KVM，就KVM這還蠻好記的，那個就是full virtualization，那邊的open source的solution。那By Default新版本全部都Support Hardware Support，就是Fulfillization一定要Hardware Support才會快或者是Software做到很好像VMware那樣子。那Xen就不用它，他其實裝在有Support沒Support它可能不會差到這麼多，可是KVM會差很多。

---

p.33
最後一個Java我們之前提過的，Java是一個很特殊的language，因為它是based on virtual machine的概念而設計的，至少不是它的interface，是它裡面執行的部分，它是以這樣的概念設計的所以我們常常知道這個Java virtual machine大家也聽過，就是因為它其實執行的方式就像是run在一個virtual machine上一樣。那它的virtualization就相對單純比較多因為它只是要執行instruction這件事其他它都不管，也就是就跟我們的NACHOS非常接近了，所以我們知道它的NACHOS就知道Java是用類似的方式，也就是它的重點是code translation而已，就是它有一個by code我們知道，這個Java其實compile完之後它有它自己的binary code，這個Binary Code呢既不是X86也不是MIPS也不是任何一個Hardware的，它就是所謂Java Machine上面的By Code，因為它自己在裝自己的Instruction，那所以這個當你要裝到不同的電腦的時候怎麼辦呢，它就會去做Translation把它再Translate到下面的Host Assistant，可是差別是因為這是一個OS，像OS一樣類似的啦，所以說它對於這個Code使用的Memory等等，它會有非常好的Isolation也就是你再怎麼樣去寫你的程式嘛，它仍然只會去使用一個Virtual Machine裡面的Memory，所以對於下面的這個Host OS而言裡面的程式的Run的執行，不太可能會影響到其他人，再怎麼run都不可能，因為它就是在這個虛擬的環境裡在run，所以它可以很secure，所以很多網路這邊的人很喜歡用這個，因為你再怎麼樣寫bug，你再怎麼樣去attack，可能都不會影響到我下面的web server等等所以就會比較的好

那Java這邊厲害的地方在哪，在於說translation這當然是一定要的solution，但是它很慢我們都知道因為它是一個一行一行在那邊，一個instruction一個instruction在翻嘛對不對，所以會很慢所以Java這邊最厲害的是它有所謂的Just in time的compiler，也就是說它在執行的時候它其實會做很多的事情，它會記錄下來譬如說，它翻譯過的instruction是什麼，所以當出現同樣的 instruction啊，或者它同樣的 function code 的時候它不會再翻了，它翻完過它就 dictionary 一樣把它記下來，那我只要一看我就把那塊全部 copy 過來丟到下面去就好，所以它做了很多的優化去讓這個 translation 的部分可以盡量的快，所謂的盡量的 real 或是 just in time，那很大一塊就是它去 reuse 啦，所以並不是重複的它會一直在那邊翻，所以可以省下一些时间但没办法你可以想象它的效能还是会跟C阿这些就会差一点，这个trade-off，好这个就是大家所在用的这个JVM了，其实它也是一个Virtual Machine

---

p.34
好那我們這個章節就到這邊，那後面問題對啊大家回去好好看一下，尤其Michael Kernel，注意到一點細節它是放在user space的差別，跟modular的差別就是一個在kernel space一個在user space，那VN para-fluidization這個就當作補充吧，不過大家應該要很清楚的知道VN的好處是什麼，那它為什麼大家會去使用它，所以未來你們或許有機會，有適合的情形的時候，你們可以來用一下VM，Open Source都有嘛，KVN跟Xen大家可以去裝起來去用.