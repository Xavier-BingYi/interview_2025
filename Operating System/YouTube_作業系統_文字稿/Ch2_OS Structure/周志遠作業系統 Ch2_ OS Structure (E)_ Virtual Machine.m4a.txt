undefined
我們後面介紹了好多個不同的Architecture所以大家也要稍微知道它的定義到底是什麼它的好處跟壞處像Simple就是很簡單所以說Developer有很多的自由他可以用任何方式去建構他裡面這整個OS的架構但缺點就是因為他沒有分任何的區分沒有任何的概念非常自由沒有任何的規則在裡頭所以很容易有bug或者是很容易被hacker給侵入因為他可能設計不是這麼的嚴謹

那會不會造成一些這個Maintenance上面的問題Layer就把這些OS所有這些Component這些程式把它去做區隔變成從最底層的到最上層的那每一層裡面的被定義在每一層裡面的這些component或者是程式就只能往他下面call而已不能往上所以當發生問題的時候你要去maintain的時候你知道你的影響會是誰你修改一個function call你知道你只會影響你上面的人不會影響你下面的人或者有bug debug你可以一層一層layer去做debuggingMicro Kernel請大家一定要知道因為這個是

非常特殊的就是它的概念是把OS最核心的部分定義為必須要的Kernel其他的部分它盡量都把它變成一堆的Module就是變成這個Module可以去做替換的動作所以它就是希望這個OS是可以Configurable，它可以去替換這些Module的，而且還有一個非常重要大家一定要記得是這些Module是Run在User Space，所以OS的概念裡面你要清楚Kernel Space跟User Space的差別所以很重要的一點是不只是把它Modulize而且是把這些Module要放在User Space

那因此他在溝通的時候就必須要透過Message Passing的方式對不對這個ServiceCommunication的Service提供你核心OS的這個Service去做溝通所以就會比較效能上來講可能就會比較慢一些因為這個去扣Message Passing的System Call Interrupt非常slow對不對，但是很modulize所以非常的flexible可能更reliable因為它的kernel的核心很小，所以出錯的機會當然自然就小，所

以大家光看名字就知道microkernel意思就是kernel要非常非常的小能這麼小不是沒有原因的是因為他把它全部變成user space的module不把它當作kernel的一部分了那module的OS就是現代的OS比較這個主要的這個架構就是從這邊來的當然也有衍生所以我們說它就會跟其他區域做合併啦，但大部分都是所謂的這個Modular的OS，也就是一樣希望有Modularity，所以變成一堆Module，你可以Plug in，但是它全部都在Kernel Space，所以可以運作得更有效率一點，

那我們也給大家一些這個link，所以其實有興趣的同學自己可以玩玩看。 insert kernel module那可以去玩一下，其實是很容易，可以去動到OS的，就是因為它是module所以其實可以去用insert kernel module這件事情來去修改OS好，那我們今天最後就要講這個virtual machine的部分了

好，所以相信大家都聽過Virtual Machine聽過的舉一下手好了。我稍微知道一下應該不少吧，對啊，所以大家一定都聽過也非常非常的popular那我們等一下也會提到為什麼這個Virtual Machine其實並不是這一兩年才出來的，不要以為或者說十年，其實它已經出來了四五十年所以大家不要surprise其實Virtual Machine在四五十年前就有這個技術了，因為早在大家在想說

OS設計是什麼的時候就有人提出來。我應該用Virtual Machine的概念來管理一個Hardware也就是一個Hardware電腦上，我以為有很多使用者，所以為什麼我只要一個OS，為什麼我們不是每一個人有一個自己的OS這會不會是更好的去使用共用一個硬體的方式呢？所以很早就有人提出Virtual Machine也真的做出來，那真的會

work所以有非常好的isolation因為自己有自己OS，所以你完全不用怕任何使用者對你有任何的影響當然當時並沒有這個非常popular非常成功的原因是在於計算的效能太差了硬體沒有那麼的厲害我們的CPU還沒有那麼的快我們的Memory沒有那麼大所以說每一個人不只run自己的application還要再run一個自己的OS，那個負擔太重了，所以讓整個電腦的效能沒有辦法很理想不符合當時的應用跟需求，所以沒有那麼popular，但其實那個技術是早就有的

好，那所以什麼是Virtual Machine呢？所以你可以看見Virtual Machine的概念就是它把下面的東西整個抽畫我們說OS本來就有這個特性但只是它抽畫的這個定義更general一點也就是下面即使是已經有一個作業系統了或是已經有別的軟體存在它仍然有能力把它抽象成就像是Hardware一樣我們等一下就有圖就知道那個意思

所以它的特別點在於說其實你灌一個OS我上面還可以透過Virtual Machine這樣的技術再灌一個OS然後把下面的這些OS或是已經既有的這些軟體這個系統電腦的系統把它抽象成為就像它不存在就是原來裝在一個Physical MachineHardware上面的狀態一樣所以它是這個Attraction是更進一個Layer的那其實我們在介紹NACHOS的時候

也就大家就看到了那就是一種去virtualize一個這個computer system的方式透過translation然後去轉換指令然後去做這件事情那當時我們看到的像NACHOS它很單純是它只負責去轉換instruction這件事情可是其實我們知道在電腦系統運作不是只是CPU instruction它要去做IO等等很多的動作對不對所以在這個Virtualized的Technology裡面這個技術裡面它為什麼困難如果你

今天只是Translation你會想沒什麼嘛翻譯嘛一對一反正不會差很多它很難就在於說其實我們的Software在設計的時候OS自己在設計的時候就有一些Assumption對於Hardware上面其中一個造成很大困擾的事情就是所謂的Critical Instruction那什麼是Critical Instruction呢這個在Virtualize的時候我們直接看圖

就知道了所以這個就是Virtual Machine的定義原來是Hardware上面就是OS了那如果我們所謂的VM的意思就是Hardware上可能還有一個本來的OS或者是有一些管理的軟體然後在上面我們可以去create virtual machine每個virtual machine它自己又有它自己的OS當我們說虛擬化的時候指的東西並不是修改這個kernel而是這個就是你怎麼樣可以加一個layer讓它變成在這台電腦上我可以run很多個virtual machine同時run

可是卻完全不知道彼此的存在然後每一個人都認為下面這整個Hardware是只屬於它的這個就是Virtual Machine的目的跟不一樣的地方了那困難點就在於Again, User Space, Kernel Space這個不要小看它,它是Fundamental的架構，所以我們知道Kernel在運作的時候，它的假設是它在kernel space所以它才可以去執行像是previous的instruction。但是在這樣子的設計下，大家有沒有

發現，如果這個是真正的kernel的話，這個kernel其實是裝在user space對於這個最後最底層這個系統而言這個kernel其實是一個run在user space的kernel。所以這個kernel我們必須要讓他是假的嘛，所以他應該以為自己下面沒人，他應該要以為自己在Kernel space可是實際上他不是，所以當他執行previous instruction的時候，問題就來了對不對本來他可以執行previous instruction，因為你call他的code的時候，

他就已經應該要在Kernel裡面可是在這樣的架構裡當你去call這個他的system code的時候，他的previous instruction其實他還是在user space所以變成他沒有辦法執行所以這就是為什麼沒有那麼辦法直接去所謂translation這麼簡單的事情，因為你就算translate成下面的instruction可是如果它是preview instruction你在它的user space執行會fail掉所以這個方法其實是很容易就解決的就是當初第一代Vertical Machine大家討論的時候的solution就已經很快的知道的方式就是還記得interrupt了嗎？對不對?

所以當你print instruction無效在user space執行的時候是一個無效的東西所以我們的電腦會丟什麼勒?丟出一個signal說這是一個exception這是一個非法的指令對不對會被擋掉可是擋掉的時候呢畢竟這個interrupt他會回到哪裡呢他會先回到下面這個OS所以這個OS會先接到這個interrupt那接到這個interrupt之後他就知道原來我上面的這一位他想要執行prep instruction可是因為他在user space不行執行

好吧我知道他是Virtual Machine所以我幫他執行所以他再去Call了一次他應該要Call的那個Instruction再幫他丟一次但是是在這邊丟因為已經到了Terminal Space了對不對所以他就可以幫他再重複執行一次但這一次就會過了對不對因為這是他執行的而不是他所以這Instruction就像沒有Virtual Machine的時候一

樣我們只要要說User Space的Code還是Kernel Space的Code對不對這裡也一樣這邊Kernel他去Code在User Space的Code through instruction之後會被擋下來這是一定的可是擋掉之後呢你就會進入他的Interrupt Handler也就是這個Virtual Machine的Layer那他只要加入一個Handler的一個Module一個Routine直到被Notify之後他就去無條件的去幫他執行

那其實這個會go through然後就可以回去了所以Virtual Machine可以run的一個很重要的概念是這樣它其實是攔截了interrupt之後再幫它執行一次才可以讓你在user space做kernel space的事情實際上是下面有人幫它做啦不是它真的直接做那當然你就會發現這樣的做法比較慢因為System Code本來就慢或者說這執行本來就慢那原來是做一次你現在就做兩次了嘛下去上來再下去所以我們就說VM有時候Virtualize效能為什麼

差就這個原因因為至少在計算這邊你只是做兩次不是一次Kernel是Preview Instruction如果不是Preview Instruction這會直接go through這都沒問題所以只有Preview Instruction他會做兩次那你就有聽過啦有些VM說Hardware support大家去買這個CPU買電腦的時候你可以注意應該留意一下電你花錢花在哪他會寫說這個CPU有沒有支援這個Virtualization的Technology這什麼意思

代表那個CPU是Hardware Support我們提過Hardware Support的概念嘛，實電腦設計常常會有用到這個，代表那個CPU，它是Hardware Support，也就是它裡面其實加了一個bit，它知道還有除了Kernel Mode、User Mode還有VM的Modeirtualized Mode。所以當它看到Preview InstructionAs User Mode當你RUN了這個時候，它其實會知道這一個指令，雖然是Preview Instruction，它不是來自User也不是來自Kernel，而是來自這個VM，

他就會讓他go through，就是他會特立，就這樣的話CPU自己就能判斷，就對他自己知道，是真實的這個layer還是虛擬的這個layer還是真的是使用者的code，它可以分所以這樣的話，你們程式嘛，對不對你刷群就可以一次下去，不用上來了，我CPU自己會知道到底是可以執行的還是不可以執行。所以這是基本概

念為什麼會有hardware support這個東西會跑出來這樣，它就會變得比較快，可是這樣看起來很美好，好像問題解決了，但是有個非常討厭的，就是我們剛才提的這個critical instruction，critical instruction是什麼呢？這個當然課本上也不一定有了，大家當作補充知道就好這個考試也不會考了但是知道比較好Credible Instruction 的意思就是這 Instruction 很妙Credible Instruction 不是 Preview Instruction所以 User Space 也可以執行但是很奇妙的是這種 Instruction 的特性

它在User Space執行的結果跟Kernel Space的時候執行的結果會不一樣不要問我為什麼問那些X86 Instruction的DesignerFor some reason它有這個需求就會有這種Critical Instruction意思就像是同樣是假在同樣一個Instruction叫做假它在User Space執行它就是假A加B它在Kernel Space執行它會變成A加B加B就是A加2B就對了像這樣它的Behaviour是不一樣的這種Instruction就叫做Critical Instruction這種Instruction當沒有Hardware Support的時候

問題就來了會變得非常複雜就是純用Software要解決這問題就很難因為什麼呢它不會被Catch就是它不會被我們下面的Hardware發現它會丟一個Interrupt因為它可以做所以它就會幫它做可是它不知道做的結果到底是對還是錯。如果是Credible Extraction，我們說Hardware會直接攔截，所以它可以幫忙執行。可是，如

果是Credible Extraction，比如說我們說在這裡執行，它就是A加B，那在這裡執行，那我們的Hardware也會go through，所以它就真的幫它執行了，但是它執行的結果就是A加2B，所以變成是你必須要有辦法知道什麼是 instruction 是 critical instruction，然後這個要知道的方式不能夠再靠我們原來這個下面這個定義就是 previous instruction 的這個定義來去來去判斷了，用其他的方式就變得很多說了，

所以反而变得麻烦了也就是说这个太自由我們说的就是，如果你就像我們没有Current Mode,User Mode的话，实电脑是没有办法正常运作的，那Credible Structuring就是这种case，就是你直接去执行的话，实下面的人没办法分别他也就不会通知上面的去做不一样的Handle，所以 Credible Structuring就是一个很讨厌的事情，所以 Software虛擬化不是那么簡單有很多issueinstruction這邊就是要去handlecritical instruction的存在那high level對不對,為什麼這個VM會這麼popular呢?

有幾個原因，因為它有很多好處嘛，有很多對帶來人使用電腦時候的好處。第一個，它可以Protection，這就是我們一開始說的OS設計的時候，一開始就有提Virtual Machine的原因是因為它認為這樣比較好的Isolation不同的使用者可以供應一台電腦不會互相的影響也就是不會互相的去就是可以Protect這些使用者。它是更Aggressive你就算去Hack一個OS你也不能Hack到另外一個OS這是完全不同的系統了，所以基本上是Completed的

所以這是一個當初一開始的時候很大的一個原因，現在當然一樣大家還是有用這樣的方式第二個compatibility，這個尤其在現在大家在關閉宴的原因，大部分其實是這個看起來很很繁瑣什麼叫compatibility呢？意思就是為了一個softwaresoftware所謂的legacy的software什麼叫legacy software就是說它在灌的時候，它一定要那個環境比如說這個software我就是要Windows98或是Windows

更早以前的，就是很早因為它比較老的software所以當初它就是那樣開發很常見那它就一定要在那個環境裡那問題時代變遷我還有很多其他軟體啊我在我的電腦上我要讓很多應用程式那每個人要的環境如果不同那我怎麼辦那我不是買很多台電computer嗎這台電computer是這個系統這個是這個系統只能讓這個application

這件事情尤其在業界非常非常常發生對不對可以想見他們用很多Tool也不是專家你也不能叫他去灌自己去修改OS所以他們就會被迫變成一個環境一台電computer然後買一堆電computer然後只run一個application是非常浪費錢沒有效率的事情那有VM，對不對，欸，不一樣了，我今天就買一台電computer，我就灌一個作業系統對不對，我最常用的或是我覺得是最有效率的那這個我可以巡邏到這個環境簡單，

我就開個VM嘛然後就去執行它，對不對所以相信有些同學有玩VM的可能也是這個原因我們譬如說上課的作業必須要在Linux環境你只有Mac,或你只有Windows怎麼辦那你就灌個VM上面去run就好啦對不對所以這叫compatibility這個在業界的需求是相當相當大的帶來他們很大的好處雖然pure engineering但是這是很real的一個問題好再來第三個VM常常被拿來在academy這邊用的東西是做research跟開發什麼意思

所謂的research開發就像是我們說開發程式尤其是你做更系統做到kernel裡面的一些開發的時候我們說Kernel只要有bug它就會crash嘛對不对所以可是我們在開發在做研究的時候當然常常寫一堆buggy的code啊對不对一堆問題這一定的那如果今天你沒有VM你就實體機器OS你就改它然後去run第一個你deploy很麻煩你就沒寫好一個版本的OS你要重新再裝一次那個OS對不对然後如果有bug

哇是整台電腦就crash掉就整個關機重新開機重新開機關機這樣子恐怕Hardware也馬上就壞掉了對不对所以是非常痛苦的事情但是有了VM之後這件事情就完全不一樣我就去改VM嘛VM再怎麼crash這個OS再crash也只不過其實是一個Program而已啊沒什麼我們常常懂說是C嘛所以就變成這樣子你可以去devaluate然後不用怕這些會有bug可是不是整個系統損毀甚至於你可以藉此就可以把一些資料可以

可以寄下來等等State有可能寄到它下面的那個真的Machine上面去對不对所以就可以做很多事情另外一個非常有趣的應用非常非常常見的應用很好玩的叫做Honey Fund在做Security的人最常喜歡用做這件事情什麼叫做Honey Farm就是一個蜂巢你知道做Security的人他們最需要是什麼？知道人家怎麼攻擊我才能

夠去Counter Attack對不對，所以你要研究一台電腦是如何被攻擊的或是被攻擊之後它會發生什麼事情。如果今天你要去蒐集這些資料，那你沒有鼻咽的話那就是開一堆有問題的Physical Machine在那裡然後讓它被攻擊可是因為被攻擊了會非常的危險也是這台電腦會整個就crash掉會被整個影響然後呢影響

之後很可能你上面的資料就全部都沒了所以你根本沒辦法收集因為就整個被破壞掉了對不對。但是如果是VM的話我只是開VM所以我就開VM是假的讓你去攻擊那就像剛剛比拜有點像所以就可以把它被攻擊的東西可以把它記錄下來因為其實那就只是一個virtual的machine而已所以就是假的讓你去去攻擊的一個OS而已

所以就可以透過這樣的方式去蒐集這些attack的pattern跟behavior然後做研究，所以這是非常好用就像個honey farm去吸引這些蜜蜂進來然後去在上面使用一樣所以其實是有很多研究需要VM這樣的一個技術最後了之所以大家會聽到這個可能只有特殊的領域這可能只有業界對不對為什麼現在大家都知道Cloud computing雲端計算對不對也就是其實現在大家講求的東西是資源的共享，並不是用自己的電腦在那邊做計算，因為電腦自己的resource是很有限的，

所以五六年前已經很久了，所以這很成熟了。雲端計算的崛起就是這些大公司Google、 Microsoft對不對還有其實最大的是Amazon賣書的這故事。我們就不講為什麼是Amazon，不過他基本上就有很多的這個Data Center，很多的電腦資源，所以他就想辦法讓大家只要能夠連進來來使用就好，就像大家在寫作業也是連到我們的server嘛所以其實你只需要是什麼

能夠送SSH的連線連過來就好，你是用手機，你是用什麼device無所謂，你手上只要能連線能下comment能下指令就好其他事情其實都可以在一個遠端的機器，所以Cloud computing就是像這樣的概念出來的，所以你不用再去買你自己的硬體了，你就來用我的就好然後用租的方式，這有非常非常多的好處，有興趣的

未來大家再去修Cloud Computing或是Programming的課，所以變得非常非常熱門，但這個技術的一個重點就是Resource的Sharing，而且不只是要讓大家共享還要Make sure資源的使用率是高的，因為以一個Provider的角度，我買的私底機器，如果所謂的sharing只是一人我給你一台實體機器的使用權我根本很難賺錢或者成本很高嘛，因為一

個人使用大家用的量，其實很少，所以會有很多空的CPU的cycle在那裡，那透過VM就是一種資源管理的方式啊，所以他就可以把它做切割，實體機器很大，但我可以把它切割成很多小的Virtual Machine。使用者根本不知道，反正他只要login他Server有OS在Running就好。到底是Virtual的還是Physical的無所謂，所以Cloud Computing這邊尤其是剛

開始大量使用VM去實現這個理想，大家也要澄清。 Cloud Computing跟所謂的虛擬化沒有一定要透過VM，Sharing有很多的方式，只要提就好。你們有興趣自己再查，現在更多人是使用所謂的Container就是容器，有興趣再去查就好。比VN在LiveWay一點可是可以達到相同的目的，就是很多人共用一台電腦就對了。而且要有一定程度的isolation，這個是重點。大家共用電腦，如果你看到我，可以幹到你那，就跟我們的Linux Server一樣

方便，但是沒有人這樣，你不會覺得是你自己的電腦雲端是要讓你做到你認為那是你自己擁有的電腦，沒有人在跟你共用。實際上是共用的，所以知道為什麼要有VM之後我們來看VM這邊，它的技術就是Virtualization技術，其實也可以分幾類型幾個比較主要的第一種我們稱之為所謂的Full Virtualization，所謂的Full Virtualization

的意思就是當然還是一樣，只要在這個虛擬化的世界裡，你就會有下面的這個原來的OS，我們通常稱之為Host的OS跟上面，其實是在User Space然後ROM的這個假的這個OS，我們叫做Guest，所以它只是暫時來的那個OS那當我們在裝這個整個Software stack的時候，如果是Full Virtualization的定義就是上面的Gas OS的程式碼完全不用動，就是這個OS如果今天可以裝在一台Physical Machine，它就可以拿來裝在這一個環境裡然後去run一個作業系統，那這件事情

當然是所謂比較ideal，所以我們叫做Full就是它完全渾然不知自己是裝在虛擬的世界上，所以我們稱之為Full Virtualization那做到這點當然就會比較困難一些，又要去handle我們剛剛說的那些issue因為上面完全不改意思就是你只能靠下面這一層，你裝的所謂的virtualization layer，這個software或這個kernel的module或者是Hardware support來做到這叫full virtualization那早期的時候VMware大家都聽過為什麼它是VM這邊的最大的一個公司就是因為其實它能夠做到full virtualization

而且沒有靠Hardware喔！因為早期的時候CPU是沒有提供那些我們說的Hardware Support，那VMware就做到，所以這是它的厲害的地方，它能做到Fulfillization然後不靠Hardware那當然其他部分它也有很多它自己的Unique的地方然後比較Powerful Complete的一點，但是它是一個Fulfillization所以你在用VMware的這個方式Solution的時候你可以拿任何的OS的image就是CD的這些直接去裝它可以Round的起來這叫Full Virtualization另外一類型叫做Para Virtualization也就是一半的意思或是說是平行同時

為什麼叫做平行同時呢？它的意思簡單來講就像右邊的圖，大家知道概念就好，也就是像剛剛一樣。上面這個Zone，這個就是GuestOS，那下面就是HostOS，差別在你會看見左邊有一個Global Zone或者說我們就叫他就是Master或者是這些Manager啦，也就是說呢這邊其實會再run一個OS或是程式，但這個是一個Special的程式，他其實是知道所有的VM的存在的，然後這邊裝的Glass OS重點是他要被修改，所以他不是說你隨便拿一個就可以裝上去，這個叫做Paradvirtualization

只有一半所以它只有一半的把它虛擬化你的 guest OS，實必須要被修改，所以它就比較有一點限制這個就是所謂的 parallel virtualization，那因為用這種方式大家可以想見就比較容易實現虛擬化的概念嘛，因為你像開後門嘛 對不对，所以你就可以做到一些事情，就像 hardware 你可以開後門，那就是所謂的 hardware support所以重點是 guest

必須要被修改到好這兩個比較沒有重要，大家只要記住這個turn就好了，就是gas會被修改到那就效能而言就是說這樣子你多了一個master，它的效能到底會好會快跟前面比，這個沒有一定而且甚至於有些情況下大家的研究比較發現這個效能反而比較好為什麼呢原因是因為這邊有很多的VM

我們知道OS都有很多的管理策略像我們這堂課慢慢會講的CPU啊Disk等等它都是在Under一個Assumption這個Hardware只有在我的前提下我這樣去設計我的演算法跟管理方式一定的嘛然後達到最佳效果，但是在這個環境這件事情是錯誤的因為其實大家是共用簡單來講就像如果說Disk的Access你讀檔案我們說Sequential的Access比較快這我們已經講過了對不對

所以這邊的File System的設計他可能會故意把使用者讀取的順序Reorder讓他變成Sequential他就覺得快了快了結果很不幸的是不是因為大家共用這個Disk所以你是Sequential我是Sequential加起來叫做Random所以沒用所以你做老半天Optimize半天卻不是得到最佳效果那在Full的Fertilization的時候

一定會這樣啊因為你沒有下面的管理者但是在Pera的話這是Administrator所以這些功能他們其實會去這個人才是最後做決定的人所以就是他會拿了他們的Pattern過來他再重新優化一遍然後再下去所以有Manager有Master他就可以有的時候他就可以做一些這種更Global的優化當然缺點大概

就是他們要跟Master溝通所以會多加一層所以當然也會有一些Overhead多餘的這些花費所以並沒有說哪一個一定比較好當然現在有Harvard Support等等比較熱門的可能還是Full Fertilization如果大家想要試full virtualization的software這邊我們有講Para叫做Xampp，這是最有名的大家可以download叫做Xampp這個軟體。 Full virtualization的VMware很貴，非常非常貴還有它的技術啦！那如果你要open source，大家可以去download一個叫做KVM，just KVM這還蠻好記得那個就是full virtualization，那邊的open source的solution。

那By Default新版本全部都Support Hardware Support，就是Fulfillization一定要Hardware Support才會快或者是Software做到很好像VMware那樣子。那Xen就不用它，實際上有Support沒Support它可能不會差到這麼多可是KVM會差很多。最後一個Java我們之前提過的Java是一個很特殊的language，因為它是based on virtual machine的概念而設計的至少不是它的interface是它裡面執行的部分，它是以這樣的

概念設計的所以我們常常知道這個Java virtual machine大家也聽過，就是因為它其實執行的方式就像是run在一個virtual machine上一樣。那它的virtualization就相對單純比較多因為它只是要執行instruction這件事其他它都不管也就是就跟我們的NACHOS非常接近了所以我們知道它的NACHOS就知道Java是用類似的方式也就是它的重點是code translation而已就是它有一個by code我們知道這個Java其實compile完之後它有它自己的binary code

這個Binary Code呢既不是X86也不是MIPS也不是任何一個Hardware的它就是所謂Java Machine上面的By Code因為它自己在裝自己的Instruction那所以這個當你要裝到不同的電腦的時候怎麼辦呢它就會去做Translation把它再Translate到下面的Host Assistant可是差別是因為這是一個OS像OS一樣類似的啦所以說它對於這個Code使用的Memory等等它

會有非常好的Isolation也就是你再怎麼樣去寫你的程式嘛它仍然只會去使用一個Virtual Machine裡面的Memory所以對於下面的這個Host OS而言裡面的程式的Run的執行不太可能會影響到其他人再怎麼run都不可能因為它就是在這個虛擬的環境裡在run所以它可以很secure所以很多網路這邊的人很喜歡用這個因為你再怎麼樣寫bug你再怎麼樣去attack我可能都不會影響到我下面的web server等等所以就會比較的好那Java這邊厲害的地方在哪

在於說translation這當然是一定要的solution但是它很慢我們都知道因為它是一個一行一行在那邊一個instruction一個instruction在翻嘛對不對所以會很慢所以Java這邊最厲害的是它有所謂的Just in time的compiler也就是說它在執行的時候它其實會做很多的事情它會記錄下來譬如說它翻譯過的instruction是什麼所以當出現同樣的 instruction

啊或者它同樣的 function code 的時候它不會再翻了它翻完過它就 dictionary 一樣把它記下來那我只要一看我就把那塊全部 copy 過來丟到下面去就好所以它做了很多的優化去讓這個 translation 的部分可以盡量的快所謂的盡量的 real 或是 just in time那很大一塊就是它去 reuse 啦所以並不是重複的它會一直在那邊翻所以可以省下一些时间但没办法你可以

想象它的效能还是会跟CR这些就会差一点这个吹斗好这个就是大家所在用的这个JVM了其实它也是一个Virtual Machine好那我們這個章節就到這邊，那後面問題對啊大家回去好好看一下尤其Michael Kernel注意到一點細節它是放在user space的差別跟modular的差別就是一個在kernel space一個在user space那VN para-fluidization這個就當作補充吧不過大家應該要很清楚的知道VN的好處是什麼那它為什麼大家會去使用它所以未來你們或許有機會有適合的情形的時候你們可以來用一下VNOpen Source都有嘛KVN跟ZEN大家可以去裝起來去用.