undefined
好、第一件事非常非常重要作業意義已經announce了其實是上禮拜就announce了所以有注意的話有留意到我們課程網頁的應該知道其實已經announce了那作業的內容。我在這邊就稍微跟大家講一下，尤其比較重要，我想是NACHOS我們所謂的simulated OS到底是一個什麼樣的架構。你們清楚的話比較知道自己到底在做什麼，而不是只是完成我們作業的內容而已會比較更清楚一個作業系統的架構

好。那我們來看，這個dayline很重要的是，我記得是兩個禮拜之後嘛，所以其實時間沒有那麼的多，所以大家應該從今天開始，就要開始花每天花一些時間，開始要看裡面的內容，開始trace code了，千萬不要再等了。那這個slice也都已經放在課程網頁所以大家就自己上去download仔細的去看裡面的內容我這邊只會講比較重要的部分提醒的部分所以大家裡面都寫得很清楚大家的作業的要求是什麼

為什麼要寫這個作業跟上課教的章節到底關聯性在哪裡那我這邊要講特別去提醒各位的是NACHOS到底是一個什麼樣的作業系統我們說它就是一個完整的作業系統可是呢大家都知道它是run在並不是一個Hardware上而是run在Linux對不對就是各位一般的Linux甚至於你可以裝在

Mac上應該也可以它應該有那些版本也就是本來你就有一個作業系統在電腦上可是你在上面卻又加了一個作業系統而且這個作業系統要跟真的作業系統的運作是完全一樣的所以這件事情到底是怎麼做到的这跟我们等一下要开始讲的第二章节的内容也有关系其实就是Virtual Machine

的概念所以什么是Virtual Machine其实NACHOS本身就是某种程度的一个Virtual Machine所以它在上面又模拟了一个真实的作业系统那有几件事情大家可以注意到的第一个你会发现就像真实作业系统一样你上面要让任何程式你要自己写个user的program那這UserProgram可以看見是一個C++的這個程

式因為它現在有C++的Library在上面所以這大部分這個我們這堂課的重點也不在那所以裡面的C++程式大概不會超過十行都是最最最基本的所以一定不會有問題我們也有Sample Code你要在這裡面做調整一定是非常相當容易應該是沒問題的好那你會發現就像我們之前上一章也提

的這個一般的user program要能夠run在一個作業系統電腦上透過作業系統去執行的話他一定要call什麼system call也就是NACHOS的這邊來講就是NACHOS的system call所以你會看見你的程式上面必須要include syscall。 h所以這樣他才會連到這個NACHOS的system call那這個code include之後會發生什麼事情尤其你code一個system會發生什麼事情就是你們作業宜要完成的部分

你們要去Trace它現在已經有最簡單的System Code的架構也就是我們上一堂才講過的Interrupt的流程你會實際上看見它怎麼被實作出來的然後會要求各位去加兩個System Code一個是Hardware的一個是Software的因為我們說過不一樣修程很像但還是有些不一樣所以這就是你會看見的Part 1跟Part 2Hardware跟Software好,那這個要提醒的是這邊include之後我們知道接下來

你就可以做compile跟link開始執行在這個作業系統上對不對那這邊你會發現當然你可能不會發現因為這個作業就沒叫你看那麼進去但是你應該要知道的是其實NACHOS上模擬的instruction不是x86 instruction所以還記得我們說下面它會run的是Linux Linux run是X86的instruction修過Architecture的課應該會知道所以這是不一樣的instruction是長得完全不一樣的所以它並不是run X86它是run MIPS另外一種的instruction它會選這instruction是因為這instruction簡單所以它比較容易的去generate那些instruction set

那可是這就是Virtual Machine的妙處了你的程式碼其實是MIPS的instruction可是卻可以透過NACHOSrun在一個X86的Hardware上發生了什麼事情你就會看見其實NACHOS裡面它有一個Simulation CodeMachine Simulation Code也就是你的Code餵給了NACHOS這個Simulation Code之後它會做Code的Translation所以當然它們畢竟都是Machine Code所以Instruction它的目的是類似只是不同的Instruction Set就像我們有

CUN Java對不對那這個Simulation Code的目的呢就在於它去模擬一個MIPS的CPU的動作然後把它轉換成X86的Instruction再送到下面的Linux去執行直接就是Assembly Code然後就叫Linux執行了所以我們說的Virtual Machine到底怎麼做到其實同樣完全的概念，它就是在做Instruction Set Translation那所以你的程式碼看到當然只看見綠色這一塊囉也就是到了我們這邊看到的MIPS的Instruction這一塊

可是因為NACHOS的設計它當然就有不同的版本我們說你可以裝不同版本那如果你是裝了這個Linux版本的話它就會把它translate成Linux instruction的x86的執行然後執行在x86的machine上面所以這個是大家知道的其實NACHOS本身它就像是一個簡單的virtual machine一樣所以這就是virtual machine的基本架構那這邊呢你會看到的是當然

這整個作業系統這整個電腦這個假的這個電腦要能夠運作當然還是要有人再去控制它所以你會看見NACHOS這邊它還有一個這個NACHOS的這個Kernel的code所以這個Kernel code才是真正的這個NACHOS的OS的程式所以這邊看到這邊只是compile而已對不對然後這邊只是模擬一個機器而已那這個機器上面Run的作

業系統其實就是所謂的這個Kernel Code的部分就是Nachos Kernel Code那所以呢這個Nachos Kernel Code就會跟這個假的這個Machine在那邊做互動所以你只要下任何的指令過來它會送到這個Simulate Code這邊模擬這邊好像有一個MIPS的這個CPU在執行可是它沒有啊所以真的誰在執行將來是你真正的CPU可是它是其實把它轉換了之後

把這個指令送到下面然後下面的CPU甚至於是下面的File System讓他們去做該做的事情然後把它再傳回來所以讓你以為Synacho這邊這台機器在做其實都是下面這一個實體的這個機器在做實際的事情所以當然還是其實是變成X86指令然後當然是需要真實的CPU在執行只是你會模擬好像這裡有一個MIPS的

這個Processor在這裡然後在做運作那中間這當然就是Machine跟你的OS對不對所以這個就是那個模擬的那一層OS跟Machine的運作就跟你真實的裝一個譬如說Linux的OS跟你的實體的Hardware的Behavior是完全一樣的OK所以這個是NACHOS的基本架構其實是這樣它裡面藏了一個Machine Simulation Code的

部分而它的instruction其實是MIPS所以你在compile你的user program的時候這裡面後面都有step by step instruction你一定會發現compile你不是只是用一般的就是GCC這個東西你一定要follow我們slice裡面的指令也就是NACHOS裡面的compile的指令為什麼因為他Compile是把Compile成一個Mixed Binary Code並不是你的機器

上的Binary Code所以你會發現你如果自己用了那個指令Compile出來的東西如果你不透過NACHOS你就直接在你的機器上RunFail他會說我根本看不懂因為那根本就不Match或者是你如果用你GCC一般的Compile你本來Machine上的Compile在這邊Compile這個Code然後想要用NACHOS來去Run的話

他也看不懂你會發現同樣會fail掉其實他根本就是不同的這個作業系統跟做不同的電腦其實是他這是模擬的所以這個大家follow那些你刷群不一定會觀察到不過今天講了回去的時候你就可以稍微留意到這一點其實是這樣運作的一個為什麼它可以模擬它不是它是真的是模擬一個真實的作業系統也就是今天如果你有一個真的MIPS的Hardware的話你就可以

把Nachos關在上面當然可能還是有遺漏一些東西啦因為它不是完整的它其實很多部分沒有implement每implement的部分它就全部丟給下面的那個Linux就是真實完整版的OS幫它去做那因為他只是一個educated的嘛所以他當然可以把這個重要的部分留下來就可以了，但是他整個OS的架構是完全相同

的喔好。再來各位把這個NACHOS download之後你會看見一堆資料夾，一開始裡面一大堆的檔案，可能第一次你們看到這種，所以可能會覺得這個無從開始會很多東西沒看過這樣。其實不用太擔心我們來看一下它裡面每個folder，並不是每個你都要去看的，只有幾個folder是比較重要的，尤其是其實你們真的要改的檔案助教我們都有hint都已經告訴你了。所以你如果不清楚這個部分也可以問一下助教。我到底看的

檔案對不對這個很基本的。我們助教可以提供一點協助免得你們像無頭湯一樣，這個非常多的檔案在這裡，它是一個完整的系統，所以會太複雜好。 但基本的幾個你到了這個NACHOS這個打開之後會有幾個folder，第一個是Lib，這個你完全不用理它這裡面放的東西就是一些utility function，也就是為了實作NACHOS這

個整個系統剛剛看到的系統，它自己裡面總是要code一些方便自己coding的function，reuse的function等等，所以這是它自己內部用的，這跟OS，它想要模擬的OS上面的那個也毫無關聯，它就是整個系統裡面自己使用內部的一些code而已第二個machine這個當然是很重要，但是呢你們只有作業一會碰到因為machine就是我們

剛才說的machine simulation，有沒有，所以它其實這code structure是非常清楚的，這個就是那一個simulated machine了，那你們作業一會通到一個檔案，因為你們要去加一個hardware的signal對不對，那hardware所以是在machine裡頭，所以你要先在裡面加一行讓他這個知道會產生這樣的signal，所以會第一次會碰到，但是之後我們接下來要去修改，比如說這個檔案系統Memory的Management還有這個CPU的Scheduling全是OS裡面的，所以其實跟Machine一點關聯性都沒有，因為你們是要

改作業系統這個軟體對不對，Machine這下面你的任何程式碼改的意思就是你在動Hardware，所以你當然可以加一行而已，但實際的意義就是你在把你的Motherboard上面鑒了一個Synchronous或者是做了一件事情或許這個全是Hardware的動作所以不是OS好，還有Thread的部分，那Thread的部分那Thread的部分就很重要了，所以其實這畢

竟Nachos本身它就是一個Program對不對，在這個Linux真實的我們Server的OS上，其實Nachos就是一個Application而已，所以它本身也是一個Program，所以這個Thread裡面就是在寫這整個Program的運作的方式，所以你們倒是要改的，其實就會在Thread的這個下面為什麼是Thread就是因為，其實它本身也是靠Modified Thread的方式然後去run這個OS，這個我

們第三章就會介紹到了，其實OS本身OS也是一支Program嘛對不對，本來事實上也是如此，只是它有Private Instruction等等一些特權的Program，那這個Program來講，其實它也不可能只是一支Process來形成的真的運作的時候，它也是有比如說File System那是一個Process在負責Memory Management是另外一個Process，所以就像你booting之後開了機，你會發現我的電腦裡怎麼一大堆程式已經在RUN了其實很多都是從OS來的，因為它也是本身是Modulized的等等我們今天跟下一張都會提到，再來是Testing也就是User Program，

所以大家去create這些file等等的時候，touch這些file的時候千萬也要follow這個structure不要把檔案亂放那完全不make sense對於要有一點稍微有一點系統的概念跟costructure的概念所以test這個字意思就是user program還記得說剛才的右上角user program各位會發現我們所有的testing的這些檔案都會放在這個地方然後在這邊做compile跟執行的動作

你當然可以放任何地方它都可以做這些動作但是那就破壧了它整個Code Structure所以請大家就是注意就是User Program就是在Test下面那User Program那就是最主要的OS的Code了所以跟Thread的差別在於Thread是去執行這個User Program裡面這些Code那這個User Program裡面就是OS的Code那剛剛那個Thread是等於是像是把整個OS run起來的

那一些程式嘛那真正的OS program其實在這個裡頭所以你會發現你改的code基本上都在這但是你的tracing的時候當然你會trace到user program也可能會trace到Thread的那個部分尤其是你們作業一比較早期整個它的基本的運作的時候當後面的作業二三四那就是在改user program裡面所以有File System、Scheduling、Memory Management全部都在裡頭

了最後就是一些所謂的Subsystem所以我們知道尤其在IO我們知道IO就是很雜的東西所以Network這邊其實這個NACHOS它是可以模擬很全面的所以它甚至於可以模擬到Network層所以那些Socket Programming、TCPID Protocol全部都在裡頭Network就是这一块那我们这堂课是完全不会touch到所以大家不用太在意那会touch到的是File System最后一个作业那这里面你就会发现作业试的时候你一定会第一件事也会提醒你们在Notches里面的File System它有两种不同的方式去support它

第一種就是真實的real的file system就是真的在NACHOS因為它是一個作業系統一定要先有一個file system的存在你才能上面去access file不然你根本連放你的program的資料夾都不存在對於NACHOS而言所以real就是真的一個file system但是這個當然就比較複雜而且你們作業室你們其實才要去implement它所以在沒有real file system的時候Nachos怎麼辦勒他用第二個

version第二個version其實是假的就是我剛才說的這個它是一個不完整的virtual的OS的原因就在於它很多地方可以偷吃步像這邊file system它根本沒有根本沒有implement一個file system那今天Nachos上的program說我要open一個file的時候怎麼辦很簡單他就直接把你的這個指令Redirect到真實的就是下面Linux你們這個Server上的那個File System然後就只是教他處理所以你會發現我作業123的時候我Nachos裡面可以Access檔案就跟我在我Login這台Server看到的File System的是完全一模一樣的你可以

看到什麼在Nachos上也可以看到什麼在一個真實的Virtual Machine或是真實OS上當然你不能依靠另外一個OS你要完全獨立所以這其實是不會發生的但是因為它並沒有implement real的File System所以它借用了下面那一層的檔案系統讓你們方便可以去做所以這個是它第二個所以它只是一個Stop意思就是說它只在幫你

FORWARD你的這個指令然後到下面的File System叫File System下面的File System去處理並不是真的，那現在的Version就是這個樣子所以作業四，你們會implement real的一些部分部分的File System Code也不是全部，那作業一？你們會用到因為你會發現Part 2說你們要加入一些這個Software的System Code，那其中的呢這個system code我們指的其實就是file system這邊的system code也就是open跟close那所以呢

其實你並沒有implement file system，你只要接起來就好了，你只要去trace code之後你就會知道還有它原來其實有一些範例啦，所以你其實只是把它接起來就是把fopen這個其實它本來就已經幫你都寫好只是他沒有把它expose把它給在這個systemcode. h那個layer打開來而已所以其實你們動的東西是很少的那只是把它

解起來解起來之後你就會發現你有辦法在你的user program裡面call fopen了如果沒解起來你會發現是沒辦法call的他會說這個system code不存在總之大家玩一玩去寫的時候你就會知道這些事情了所以作業一你會看到File System不必太緊張跟你們寫作業其實是無關你們只要把它的Code Pass接起來就好

而且也不是Code一個真實的File System其實是假的這邊就我們剛才說的指令其實應該寫得相當清楚了所以大家就Follow這些指令然後先把NACHOS給DownloadCopy到自己資料夾然後把它裝起來然後知道怎麼去compile這個example code然後知道怎麼去run起來好所以這應該都沒問題所以你可以看到像這邊我們剛才說run有沒有在這個程式裡面在NACHOS上面你要run一個程式其實一定要

透過它的這個NACHOS這個指令然後-1才能夠去執行一個user program你不能直接就點斜線就執行不一樣因為我們剛才說過了這應該沒問題所以這就是要求你們要加這個printint這一個code進去然後後面是file system就是open跟close的部分所以我們都寫得應該蠻詳細的就是怎麼樣子對不對什麼

樣的話你才會看見你的結果是正確的這個Counter必須要改這個Counter的意思因為Nachos畢竟在模擬的時候它有一個壞處就是你會搞混到底是Nachos在做這個OS在做事還是Linux那個真實的OS在做事情因為你看到螢幕的output都在那嘛所以你也不知道是哪一個OS print的啊對不對所以你要留意的就是像剛剛說的執行的方式其實不一樣，

然後檔案系統這邊其實一開始是他串在一起的，其實是真的沒有差別，但是你如果是一個stop就代表Nachos還是模擬過了，所以他最後其實會看到這邊，他會有說你在Nachos上執行完這個user program的一些counter，就像你去想Dump你的作為系統的一些counter。所以，這边alright一定要有数字要出来才代表他NACHOS真的执行

了你，不要只相信你的眼睛，因为你的眼睛分不出来，你都是看到结果都有printf，这到底是哪里来的，你根本分不出来，所以你就要一定要透过counter才能确信他是不是真的是NACHOS做的事情好。所以你看Rewrite好像很多啦，但其實各位不用緊張，你們只是把它接起來，它裡面的程式碼其實都在那裡了好，对啊

這邊就特別要請大家的有沒有不要用Standard的這個IO的部分，因為那些你就是其實不是透過NACHOS，所以Standard就像你平常自己寫C語言，你一定要按照我們Spec裡面的方式去Print去write跟open這些動作，不要直接有pref發現怎麼答案出來了，我什麼時候都還沒做，因為你真的沒有做那就是什麼都沒做這常發生，這應該沒問題所以我們作業裡面其實你會看到有demo的部分主教真的會去問你一些基本的到底interrupt怎麼樣的基本的運作

所以其實也就像review你們前面兩章什麼是interrupt什麼是system call因為就是同樣的東西所以你要嘛就是上課聽得很清楚要嘛就是希望其實是你trace完之後自己也發現這兩個流程是一樣的這個是大家就是可以很清楚到整個運作然後實作的部分對不對那deadline 10月16號所以其實只有兩個禮拜並不是太長

所以還沒開始動作的麻煩就加快了好對這個很重要Hint嘛所以也不要太急急忙忙的自己就開始每個檔案開始從第一行開始看 Trace Code的定義就是不是那樣子就是你要一定要先有Code Structure知道這到底是一個什麼樣的系統然後每個資料夾在幹嘛然後你再去看那個資料夾裡面或是最主要實

行的那個起始點在哪裡然後開始再trace下去那所以希望剛剛講了一下這些基本的架構大家就有一些idea那這裡呢我們就方便大家所以把Exactly你要改的檔案全部列在這了所以當然從這邊開始看一定也是一個方式那這些就是你一定會需要去trace的如果有任何問題這邊是OK可以問我跟問助教的如果不知道到底從何開始這件事情好那這邊呢最後你會留意到一件事情

我們馬上就要開始講了這個有一個檔案你要改可是你會發現它不是C++的檔案就是NACHOS本身它是C++寫的那但是呢這有一個點S是什麼呢assembly code所以你居然要改一個檔案是assembly code那當然裡面很簡單就三行四行而已而且你就copy paste然後知道每一行的定義所以你就把一些fill

替換掉就會work但是為什麼這是assembly code我們等一下馬上就要講就是system code勒其實是用assembly code寫的的這是他基本的他其實用assembly code並不是用一般的C語言等等好那應該就是這樣子所以如果有什麼問題大家再問所以你看我們累積了前幾年的一些經驗所以甚至於把一些FAQ都列在這

了所以希望大家可以幫助大家這樣子尤其像Linux不熟等等的我們這也都我們這也都最後都有給這個VIM就是一個Editor所以你要在你熟悉的Windows的環境下寫程式在FTP過去是一種方式啦但很麻煩很那個很慢當然所以還是建議大家直接在這個就lock in這個server然後在上面開始修改然後修改完就compile然後這裡面其實有提到你在run之前一定要

make clean就是記得要把一些之前compile的東西把它全部砍掉然後重新再compile一次因為有時候你沒有touch到一些檔案，你會link到舊的版本，這個也發生過好幾次，學生就會一直問說我明明就改這麼這麼簡單，他怎麼就是沒有動不可能啊，因為你沒有make clean然後你link到舊的，所以他搞錯這個檔案了常發生所以裡頭有些細節請大家就是多留意然後盡量step by step的follow那esso對於VIN是什麼

就是Editor啦，所以你會像這個作業一樣啊只要login進去把這些檔案就是打開來啊然後就看然後加一些程式碼關掉Compile很單純的所以大家只需要多學一個就是像這個記事本一樣這東西在Linux的環境上最常用的就是VIN這個東西那你們也不知道幹嘛只需要去知道怎麼存檔案然後基本動作就好那TA都有給你們

那些輔助的slice那這些其實都是非常open的所以你一定可以其實大家應該上網自己去查一下也可以VIN到底有哪些指令有些人學了會還蠻有成就感的因為會非常非常快因為它裡面有很多快捷的動作所以用起來會好像瞬間可以開很多檔案做很多事情就是他很熟那些環境跟這個VIN的一些指令其實非常非常方便的所以還蠻鼓勵大家順便也把VIM這個基本的這個editor的這個這個tool把它學起來.