undefined
上一次我們提到在介紹幾種不同分配硬碟的空間的方法，我們提到第一種是contiguous，所以就是連續擺放它的好處就是我們提到它的連續讀sequential的或是random的讀類都會非常的快，因為基本上只要這個使用者告訴了我們下面的這個檔案系統他要讀的這個檔案是在第幾個byte這個第幾個position他就可以用算的方式直接知道到底他physically的那個data block的location在哪裡所以就直接可以對disk做IO了。

第二種方式就是我們說的link的方式，link的意思就是把每一個data block就像link list這樣把它串起來。它的好處就是只要有空間，它都可以使用，不像前面contiguous的相對它唯一的壞處或者說最大的壞處就在於這個檔案大小如果改變或者空間有破裂的時候它就沒有辦法做一個擺放。但是link呢，它只要有空間你就可以去使用，然後就用link list的方式把它串起來就好。可是它的壞處呢，就剛好就反過來sequential的話也不錯， sequential access反正就是順著link list讀，如果你

不是從頭開始讀還是有一些overhead，因為譬如說我從第五個block開始讀到第十個block，那前面四個 block基本上你還是得要讀出來才能找到第五個block的位置對不對，但是如果是random的話那就更糟了，因為如果是random access那根本就是跳來跳去，你甚至於會有重複在那邊讀的問題，那最大的這個原因為什麼會這麼沒效率就是因為這個pointer它是散落在disk上面那些data block上面，所以每一次你要去讀出那個pointer的位置它就是一次IO，所以這是它最糟糕的原因，

所以我們上次就提到其實這樣的方式還是有被採用的，那要去解決剛剛這個很多random的時候的這種很多IO request的方式其實是有的，而且其實很單純就是把它的pointer全部收集起來然後呢只要留pointer的information就好然後把它存在這個前面的幾個block就用幾個data block然後把這些pointer全部收集在那個地方，那所以這些pointer可以在一開始你在Mount的這個File System的時候

就把它load到Memory那一旦load到Memory之後那其實你的這些Triversing這個動作還是有的，但是因為在Memory所以它不需要在那邊一直在做這個IO的動作就一開始的時候把這兩個純pointer的DataBlock load到Memory然後就可以開始去運作所以就解決了剛才的問題所以這個LinkedList其實也可以變得很efficient如果你這麼

做的話但這樣已經不是傳統的link list所以如果這個考試的時候如果問這個link list的事情的話我會稍微註明一下就是大家留意一下FAT32它並不是傳統的link的已經是一個改善版的那傳統的話random是一個問題那改善它最好的方式就是像FAT32或64這個做法把pointer收集起來然後把它漏到 memory 裡面好那第三個做法咧就是 index所以 index

跟剛剛的差別在於說一樣有 pointer但它不是用一個 linked list 的概念而是就像這邊看見的是 direct access 的概念對不對所以一樣這一些因為它是 direct access所以這些 pointer 當然一定是要存在一起的所以存在一起的這個 block就稱為 index block所以他是用一個data block因為這些是pointer嘛還是要存在硬碟啊disk上那所以

他們他也要存在一個其中的一個原來的這個block的上面去但因為他就只存這些pointerindexed pointer所以我們就先就把它稱之為indexed block那其他指導的這些就是所謂的data的block，那所以可以看這個例子就可以知道你只要要找到這個file的任何一個位置要開始讀的話你的這個首先你的Directory裡面存的檔案名稱然後只要一個pointer對不對

直到就是你的index block在哪那到了index block一樣你要把它讀出來然後你就看你是第幾個block找到它的entry之後直接就可以去access那個對應的data block所以這樣的做法就叫做index block了好，這是index的allocation的方式啦好，那所以就像剛才提到的他的做法就是把所有的pointer就把它全部bring together對不對，那這個又是一個special

的block，所以叫index block那因為這樣的做法所以direct對不對就是這種random的access就會變得非常的efficient當然這個sequential的access也是一樣就是他都可以一次就可以找到位置，那另外呢他也沒有external的這個Fragmentation因為只要有空的位置我都可以使用就跟link的是一樣的那它也很容易去create file，因為基本上它只要有一個free list知道有哪些data的block是available的它就可以去找到空間去extend一個file或者是create一個新的file

那它的缺點一樣就是因為是pointer嘛一堆pointer所以說這個要去存這些pointer你就會浪費掉一個index block而且它比這個傳統的我們剛才說的link的方式的話來講它只會浪費的是你每一個data block你就浪費4個byte那這個做法的話呢因為它是index block所以說這個block它全部都只能存index所以

萬一今天他浪費的情形會更嚴重一些可以想見因為如果今天你譬如說這個file很小好了對不對那他可能只有兩個data block所以代表你只要兩個entry四個只要八個byte就好對不對可是因為這個做法他是把index跟data完全切開所以你只要用八個byte可是這個index block對不對假設就是512byte這麼大

你還是得要allocate一個一整個512 byte的index block來存只用了8個byte所以剩下的空間就浪費掉了對不對所以說它的這個浪費的情形又會比這個link的方式又再更嚴重一些因為不只是有pointer而且它是完全把data跟index切開對不對所以你當然就會浪費得更嚴重好那另外一個勒在index block這個做法EMH必須要去克服的一件事情就是

那萬一應該是太少就是如果file很小你會浪費空間那如果今天file非常大那代表你要存的pointer的數量是不是也相對就會變得很多多到也有可能超過一個single的data block可以儲存的空間這也是可能的對不對所以像如果一個single的data block是512 byte那你今天一個block只需要4個byte對不對所以如果你超

過128個這個data block的話那你就存不下一個index block對不對那你就需要多個index block來去存這些資料那所以如果有很多個你需要很多index block的話那要怎麼樣去做一個extension呢所以就可以看見這邊其實也是會有這些三種做法三種不一樣的方式可以去解決這個問題的好第一個做法叫做 Linked Index Skin所以你可以看到這些名字有一點因為都是用 Linking 或是 Indexing 的做法所以大家要稍微留意一下這邊是 Index

後面所以說它還是一個 Index Skin但是它是有 Link 的方式在裡頭去解決 Index Block 不夠大的問題那解決的方式勒是什麼勒就是你可以看到一個樣我們一開始只能存一個index block嘛對不對那可是萬一他可能會不夠對不對所以19那當然就是第一個原來的index block那裡面當然就是我們傳統的做法對不對裡面就只到一個一個的data block那存不下我檔案長得超過了這個size了怎麼辦我需要一個新的index block嘛一定要

所以我就把這個file存不下的繼續存下去的話那我就要去create一個新的index block然後裡面就存他的pointer那畢竟這是這兩個必須要能夠連在一起所以我們就用linking的方式所以就在index block之間我們去留pointer去指向他下一個index block對不對所以就link list把index block串起來這就叫linked的index skin了所以其實蠻好理解

的但就是名字上大家稍微留意一下這link的index skin指的是其實是index的做法但是把這個index block把它用link把它串起來所以它是一個index的做法所以以此類推我file一直漲那我就一直create index block那我就相對的我就去create這些link list就好當然你就可以看見這時候如果你有些runden的access對不對你有direct access跳到一個file

File如果真的很大跳到很遠的地方那麼其實你要讀寫的次數就會開始變慢了所以檔案越大它開始要 traverse 的時間就開始變長因為你也要去 look up 好幾個 index block所以這是第一種做法第二種做法第二種做法其實就非常像各位大家已經學過的在 memory 做管理的做法就是 multi-levelhierarchical 的 index對不對所以其實就跟那時候我們已經教過的這種page table怎麼樣去把它做延伸的做法是一樣的所以咧這邊 index block

指到的所以這一樣是一開始當然就只有一個 index block那裡面我們就可以存一些 pointer但這邊是 hierarchy 啊所以大家就知道這每個 pointer 其實存指到的咧不是 data block 了而是index block所以就每一個pointer都是index blockhierarchy嘛所以就2 level你要加3 level等等都可以對不對所以就可以用這樣的方式每一個所以這

16這個16知道是這個index block裡面寫第一個1919知道的這個block勒我裡面還是存index所以你可以看見這裡面每一個poインタ知道的才是最後才是真正的data所以這就是hierarchical的方式那這個做法最大的好處是什麼呢就是你可以看見如果今天檔案真的很大如果因為你Hierarchy嘛所以我們剛才說

最大的問題就是當檔案很大的時候你要Random Access而且是Access到尾巴的地方的時候它會很慢對不對尤其前面的做法因為當檔案很大那就很抱歉你要一直Traverse對不对如果我有十個Index那你就要Lookup十次好不容易才找到你要的位置所以你的讀寫的速度就會很不平均檔案前面的很快啊後面的很慢對不对但這個做法的話因為是Multi-level嘛所以如果你是很後面沒關係

我就直接跳下去對不对所以其實它的這個速度就會比較穩定其實檔案很大對不对可是你在前面在後面的位置它讀寫的速度都差不多當然你也可以說它差不多慢但它也是差不多就是比較平均通常平均穩定這是對系統的效能管理等等來講使用者來講通常是比較prefer的啦好那不過相對的對不对它的缺點就是當然一樣就是它浪費space的情況會比較嚴重因為hierarchical嘛對不对所以它等於是指數的在那邊成長對不対

所以當然檔案非常大的時候就會適合用這種hierarchy如果是median size可能就會適合前面的那個link的做法，那如果真的很大的話，那當然你就會需要這種方式很快速的把你的能夠指到的空間用這種exponential的方式去把它做一個成長倍數的方式成長那這個就是所謂的multi-level的做法啦好， 可以齁所以記得這只有leaf node才是那些data block的pointer好

好，那最後一個combine的也就是D4的這個unix inode的一個做法這邊的combine其實指的是說它就是用multilevel，但是因為我們剛才說過了檔案大小之分對不對，如果今天你的檔案很大你就要用很多個level對不對，那如果你今天檔案很小那其實你就用1 level或2 level就夠，實這個概念大家如果再回想Memory關於跟這個

是比較接近還記得我們那時候介紹過Intel的Page Table的做法嗎可以用4MB 4KB的Page Size在Change對不對，那這邊來講也是一樣一個折衷的方式，所以一樣它給你Option所以這個是我們說過了嘛I Know就是存一個這個File它的這些Information包括了很重要的就是它的data block到底在哪裡那所以這個例子裡面可以看這個做法就是前面呢就是當檔案很小的時候我最好就是ind ex直接指到對不對

那所以說這邊就是這個direct blocks就是這邊直接就存的是我的data block的pointer了，所以我的第幾個block我直接這邊就可以找到那。如果今天這個因為這畢竟我們的這個iNode這也是個data structure而已嘛，所以它的size一定是有限的，那這邊我們可以知道這邊的每一個entry，它能夠指到的那就是只有一個data block的size而已對不對？那假設我們這邊這個是

例子而已嘛，所以說假設我們今天一個block是4KB這麼大的話，那一個entry就只能指到4KB對不對？所以這邊就算你有1,000個entry好了，那整個file最大你也只能存到4MB那4MB很小，所以大家知道根本就塞不下對不對？所以說塞不下怎麼辦呢？那就是後面我們就用剛剛的Multilevel這樣的做法，所以這邊的single indirect所以indirect意思就是它已經加了一個level了，所以這個pointer指到的並不是data block而是指的是index block，所以這一個pointer指到的就是一個

當然也是一個block，但裡面存的就還是index那所以假設是4KB嘛對不對？所以block的大小就是4KB？那假設一個pointer就是4個字节所以就代表光這個裡面我就可以存1,000個entry了；然後當然每一個entry就乘上data blocks的size那就是你當然又可以多增長多少了對不對那以此類推，所以如果今天這還存不夠對不对超過了

這個四個MB這邊基本上是四個MB嘛約一千個對不对這邊當然更小那如果超過還不夠那我們就用double對不对所以就代表它是two level那就dependent這個pointer你從哪裡開始找他當然就知道這裡面的資料到底要把它translate成是一個data還是一個index，所以他就知道到底是該怎麼去translate這些value好所以當然就以此類推所以當然到Triple當然就已經檔案大小就已經在更大了嘛，所以這就是一個所謂Combined是這樣

就是說把Module Level這個做法你會把它分成不同的這個Level那這個最大的好處是什麼呢就是在於你的Performance嘛對不对所以當你檔案小的時候當然大家都喜歡Direct約這樣我只要一個Lookup我就找到我的檔案了對不对那你約後面就是Multi-Level的缺點你可以看見幾個Level你就要 Lookup幾次當然IO次數就開始變多

了那Size就是它的TRADE-OFF因此，這邊的Performance非常快，但它的Size以這邊這個例子來講，假設這裡有12個Entry，那每一個只能存4KB的資料，所以就只能到48KB很小的檔案，你可以處理當你的檔案長超過這個Size，我們就會開始用到Single Direct single 的indirect那就變成當然就是這邊光這個地方就存到4GB當然你還要加上48kb啦，才是total的file size，所以只要小於這個檔案size，我們就只需要用這個前面兩個Entry所以前面兩個部分就好還不再不夠對不對

就可以漲到4gb，那當然最後一層可以想見當然就是4個tb嘛，對不對，所以通常那個就已經非常大了，因為我們整個disk也不過就只到Terabyte好，那當然還是有個極限所以當檔案當真的檔案非常非常大的時候很多東西也是要改寫的一些File System也會沒辦法handle好，所以這個就是index的做法，那大家特別留意最後一個作業就是會你可能就會運用到剛剛的這樣的概念去知道怎麼樣子可以去

Manage Create一個更大的File就是你要自己去Manage那個Data Structure去把這些資訊存起來好，那介紹完怎麼去Allocate最後就是這個Free Space的 Management也就是剛剛是要使用的檔案的這些內容、 方案那當然我們也是要管理哪裡可以去找到我們的剩餘的空間我們才可以去做Allocation那做法其實就可以分成這四個尤其後面的三

個這些名字看起來不太一樣其實大家不用特別再去看它了它就是剛剛說的方式、我們現在這個link list這就是link allocationgrouping其實就是指的就是link的index的做法那counting指的就是contiguous的做法簡單來講就是大家可以把free space想成是一個file那我把它全部串起來嗎我們要去而且這個file很簡單這個file因為是一

個Free Space的file所以它只會需要SupportSequential Assets就好因為我就知道找第一個有空的位置然後用完我們就把它在起始位置換一下然後就每一次都只用第一個有空的位置就好所以我們也只是需要某一種Data Structure把它串起來而已那所以這名字不一樣其實大家去看課本裡面描述的就完全一模一樣就是

這三種做法那當然這個這三個名字大家也不用刻意去背它了就不會特別去強調這一塊做法一樣大家知道就好好所以唯一比較特別我們等一下稍微講一下是這個 bit-ficted這是另外一種做法就是我不把它串起來，我只用 bit 的方式去做一個判斷那所以就是這樣，所以 free space 其實就是把它想成是一個 file，所以當然做法是相同的，那Big Victor，所以什麼是Big Victor呢?

所以很簡單講就是這邊可看見我們可以把一整個Disk的空間對不對我應該說Partition這樣比較好啦，因為一個File System管一個Partition，所以我們就把Partition空間這些Data Block就把它每一個文字都要知道它是有空或沒空有用到或沒用到對不對。現在是空的free的或是不是，所以我們就用一個 bit 表示就好了嘛！所以你有多少個 block我就有多少個 bit然後每一個 bit 對不对就看 0 可以當作是 free然後 1 是 occupied所以我只要去找欸，

只要是 0 的我就可以找到那這樣的話我就可以去知道哪些是可以做 allocation 的好，那所以這個做法跟我們剛剛看到的這種其他另外一個做法就是把它當作 file 然後串起來這個就沒有把它當等法 這就只是0 1 01它想要知道有空或沒空就好而且它可以知道exactly哪些是空的一次它就可以看到很多個，所以它的好處是什麼呢就是第一個很簡單嘛 0 1 01 對不对而且？

它的判斷會比較快比你在那邊 traverse 一個 link然後在那邊判斷數字要快，因為我們知道電腦其實是 bit所以說其實對於這些0 1 01的計算它是更快的我們的哈維爾來講它的logic是更簡單的而且它一次就可以讀64個bit或32bit它一次就可以讀很多的bit，所以它的速度處理會比較的快那它的缺點主要就是在於說這些如果今天檔案這個partition長得真的非常非常大尤其像我們的硬碟現在真的是越來越大

那這個bit的數量真的也是會越來越多多到如果你超過了我們CPU的cache的大小的時候那就可能開始slow down了就沒有辦法發揮它最大的這個優勢，所以當真的很大的時候它當然它的performance就不會這麼的理想所以這是它的好處跟壞處，那為什麼你會說這個0 1 01這樣子為什麼我需要通常我不是只要隨便找一個

有空的位置就好嗎為什麼我要一次把所有的零的位置都可以找到這有幾個原因第一個大家也看到前面幾個contiguous link或是index像contiguous它也不能隨便找對不对它要連續的零那這個你就要0 1 01這種做法它就會才會work對不对才會比較有效率因為它可以一次找到你有多少個連續十個零的位置出來那你用big vector就會比較快

那如果你是用link list雖然說，實際上是啊，你可以隨便擺它，但是如果你可以擺在比較近的地方，如果能夠連續在一起你的disk的磁頭的移動位置還是會減少啊，对不對，所以說當然，它實際不管是什麼樣子的做法都會希望盡量把同一個file放在相近的physical location上，如果你想要知道我要檔案，我要知道哪些鄰近的有空位，這個問題的話，那你就不是很單純的說一個link list就解決了，对不對，你有一個0-101的你才有辦法去找到對不對，

而且你可以load哪一塊位置對不對，所以在這塊範圍內有哪些地方有0，你可以做更好的判斷，所以當然，他給的information更多，在做allocation的時候，他就有機會去選到更近更好的一些位置，那如果是link list的這個做法，像我們前面這些前面看到的這種三個其他的這些做法，事實上，我們有看過一些fusion code比較少真的直接這樣用其實是蠻複雜的，他們會把這些一段一段的把它切斷然後去做有點像binary search的動作，所以其實

比較少真的是把它串成一個single file，大部分的file system為了performance，其實比較會需要知道更進步不只是找到一個free空間，它其實希望找到我今天給你某一個position，你可不可以很快的ret urn給我離那個位置最近的0在哪裡然後甚至於它會再多一個condition最近而且大小要超過或至少某一個size這是比較常在做allocation的時候

file system它要求的criteria那你看把這兩個condition加進去前面那些做法就也是需要去修改那big picture就不用修改它基本上很容易判斷對不對所以這個是它的差別所以這其實也是一個蠻有效率的做法這有圖啦但是大家稍微看一下就好就知道對不对link list就是link list所以跟之前我們介紹的是完全一樣的然後 grouping

跟 counting 的描述在這裡但是其實大家看描述就知道就是我們之前介紹的那兩種管理檔案的方式所以這是這個章節後半段這是滿重要的部分就這幾個 location 的方式一定要知道它到底是怎麼運作的另外一個就是要去思考去想一下這些不同的Allocation的方式對於你不同的IO Pattern到底它會產生多少

個IO的Request才能夠完成一個動作我隨便講說一個File它按三角是10存在某些位置請問它要怎麼用任何一個方式去把它串起來然後我要讀這個檔案的第10個Block的第3個Byte到底需要多少個IO的動作才能夠完成這件事情這個是大家需要去把它套用在模擬下實際上運作它的行為知道它

的效能的好壞那當然這些名字有一些會有一些類似大家當然就要稍微去把它分清楚一下那這個就conclude我們這個file systemimplementation的部分了所以file system可以看到它最重要的東西就在做mapping就是NAND space一個file path怎麼樣對到一個I know的或者說是一個file control block的那個mapping第二個就是這個file control block裡面mapping裡面它要存的這個file的location到底要怎麼map到physical的location有哪些location的方式其實就是這兩塊是最重要的部分.