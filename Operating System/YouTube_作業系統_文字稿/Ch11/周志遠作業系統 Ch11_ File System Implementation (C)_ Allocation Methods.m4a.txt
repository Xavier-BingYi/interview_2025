undefined
好，那接下來呢，就全部我們就要focus在這個allocation method指的就是我們開始進到一個file，那它有很多的content啊那我們知道最小的管理單位叫做data block對不對那所以我們的資料到底要怎麼map到這些data block上面這些data block到底要放在physical的disk空間的哪些位置怎麼放當然就會影響到你讀寫頭的順序對不對跟路徑的長短那就是你的performance了好，那所以

首先當然就我們說過對不對什麼是allocate我們這邊講的就是這個就是到底這些this的blocks到底是怎麼allocate給這些file讓他去存資料的那基本的做法可以看見就是透過這三種不同的data structure第一個contiguous顧名思義大家看見就是連續擺放嘛對不對第二個呢linked所以指的就像是link list所以大家都知道這些

data structures就像link list你就把這些block把它串起來用一個link list串起來我就可以至少可以找到它對不對最後勒是用index所以index不外乎其實就是你可以想一想就是把每一個data block它的pointer的位置把它收集起來那你就直接去查表 lookup然後就找到那個pointer_directly跳到你要的位置所以其實當然就不外乎這三種做法當然有些變形我們就會仔細來討論因為你要考慮到disk space是有限的而且file它的長短第一個它的長短是會改變的對不對所以你是不是

能夠找到足夠連續的空間這就是一個issue所以你要考慮到file它的size會改變第二點大家特別要注意的就是存了這樣的file的layout之後那我在讀寫的時候我是sequentially的去讀這個file跟我跳著讀的file它的behavior的差別你就會發現它各有它的好處跟壞處好那我們就從第一個solutioncontiguous location可以想像它應該是最直接然後最簡單的做法所以所謂的contiguous location是什麼意思

就像這邊所看見假設我們有五個files對不对所以你會這邊看見可是他看不夠清楚然後回去印出來就會比較清楚這邊我們有把它圈起來是灰色的這就是一個file然後這是一個file這是一個file所以你會找到五個file在這裡那它是contiguous的意思就是說不論我從哪裡開始擺它就必須要接著嘛就是連續對不对所以你會發現它如果從這裡開始存TR開始存對不對它從4

那它就要存1415issue下去所以它就是所謂的contiguous就是這個樣子那這樣的概念我們就來看一下file control block裡面我們要存的information是什麼就是怎麼樣我可以找到比如說我今天說我要找TR的第1000個byte那我知道一個block size可能是200那我就知道我其實可以算我就知道我要的是第五個block第一個位置的資料可是我要知道第五個block在哪裡對不對

所以因為它是contiguous所以你會發現你要存的資料就很簡單就是starting point跟長度嘛對不對所以就是這個檔案存在我們這個整個disk上面的哪一個位置然後它的長度是多少那我當然就第五個我就從0開始加或是tr是14那我知道加5 19就對了對不對所以你就可以找到它的位置了那By the way 這個 number 從哪來就是你在 partition

的時候就會出現了所以這是當然在 partition 一個 files這個 disk 的時候它當然就會去 create 這些它的 data block 出來然後去 應該說是 抱歉應該說是 format 啦因為這是 file system 在管 對不對所以你在 formatting 的時候partition 就告訴你這一塊 disk 空間可以讓你使用然後 formatting 的時候file system他可以選擇他要的data block size因為他可以管

理嘛對不對那他就按照這個他就會去做labeling所以他當然知道block size是多少ok那最後是這些number但是file你要放在哪這是另外我們現在在討論的部分好這個就是contiguous allocation沒問題齁所以這應該是蠻蠻蠻基本的一種方法那重點呢就是看他的好壞處了對不對所以你可以看見第一個就是他

的這個如果你今天要去找任何的資料的位置他的這個去找的這個effort是最小的也就是他不需要去traverse整顆硬碟或者說不需要traverse這整個file對不對因為你給他任何的position我用算的我就知道他到底在第幾個data block裡面然後我只要打一個single的io request到我們的Disk Drive上面去把資料

把它讀出來所以它的Sign Time是最小的不管你今天的讀寫勒是Sequential或者是Random都沒差對不對因為Sequential當然你就知道嘛下一個位置在哪然後Random這都一樣你都會知道given它一個Position它不需要Se arch它直接算一下立刻就知道在哪裡所以是非常的Efficient好然後勒它的Directly Entry相對也是很

小的因為你只要存兩個值Starting的Data Block在哪你有幾個Data Block就這樣兩個Information而已兩個Integer結束了所以這當然是又簡單又Efficient那它當然就有Tradeoff了它的問題在哪就是你會發現的很容易會有External Fragmentation對不对問題這也很嚴重對不对因為就像我們前面看見的這些檔案不要忘記它是來來去去的所以你當

然就會開始有越來越多的fragment跑出來然後糟糕的是這些檔案如果他會增長這就是最大的問題他如果把他剩下的空間用完了那這個空間他沒有辦法再增長的時候你就要把整個file全部搬到另外一個位置才有辦法所以這就會變成一個非常大的issue了所以它最大的缺點就是它會create很多

的external fragmentation就是越來越難使用這個disk space所以disk space的使用率可能會開始下降然後甚至於當你要去檢查的時候你可能會撞到一個別的file沒有空間了那這時候根本就會fail掉或者它就要整個file去做copy那這個努力非常非常大，所以這是他最大的這個缺點那解決方案不意外嘛，fragmentation always就是這樣尤其是我們在講external的話，就像memory管理一樣，我們可以做compaction對不對所以你會看見，有時候說大家說你的系統運作很慢是不是

應該把你的硬碟整理一下清理在幹嘛，在做fragmentation的處理就是這樣子， questo問題當然對這個是最明顯可是對於其他的，我們等一下介紹的location的方式多多少少當然都有影響，所以對硬碟我們常常就是需要去清理就是這個樣子，它會開始越來越慢當使用空間變小的時候，那這個問題不能 grow 的問題導致有一個折衷的 solution就叫做 extended based 的 file system簡單來講，就是跟 linked list

結合嘛，所以基本是我們說的configure link 跟 index，但是等一下我們會看過程中，實很多就是boundary hybrid 做結合來去克服對方的這個結長不斷的這樣的一個效果，所以在contiguous的這個file system的做法上，最常見到就是用這種extend based的 file system，所以也就是說你當你不夠的時候，對不對，所以你一次allocate咧你不會allocate一個block你會一次就給它allocate一個extend就是像5個就是一個單位啦所以一個send你可能比如說定義成就是5個他們contiguous的block一次給它5個

那5個用完不夠怎麼辦你又再給他5個但是這兩個5個這兩個extend他可以是在不同的地方然後用一個link list把它串起來什麼叫link list咧不要忘記這是on disk structure所以我講的link list的意思是說在第一個extend的尾巴留4個byte然後去記錄下一個extend的data block的location你要把那個extend把它漏到那個data block存在那個number的data block

漏到Memory之後你才知道接下來我該去哪裡所以是這樣子的一個做法所以這就是所謂的Extended Structure所以你可以看見一個Extend對不對它就會有這個開始的Block然後它的長度所以這Extend可能是5個這是固定的你甚至於當然可以變動啦所以如果有變動長度沒Extend不一樣那你可能就要記錄這個Extend長度到底是多少了然後咧最後就是這一個

你必須要記錄下一個Extend到底在哪裡就算沒有你要解怒我嘛對不對這樣才可以把它串在一起那這樣的做法它犧牲掉了什麼所以它解決掉了這個Fragment的話如果你這個Length是可以動態當然也可以解決掉如果你還是固定就是5個Continuous Spark這個Size是固定的話它還是會有Internal 你可以想對自己

變化一下Internal Fragment 就可能會跑出來因為你一次給他五個嘛我用不到五個所以當然依據你的定義會相對有一些其他Fragmentation的問題可以相對被減少但可能還是會存在那他最主要犧牲的部分勒其實是在於Random Assets的Performance就會沒有了這是什麼意思勒所謂Random Assets就像剛才的例子假設我們要讀的是第七個block好了那我每一個extend

它只有三對不對它就只有三個長度所以我知道第七個其實是在第三個extend裡面對不對可是我怎麼知道第三個extend的位置在哪你必須要traverse這個link list對不對我才能知道喔到底因為你要traverse的意思就是你要把每一個extend它的這一個最後這個information從disk露出來露到memory你才知道下一個位置在哪所以說今天你讀的可能我只是要讀第七個位置這樣一個IO request可是為了要 travers我們看了第一個extend要露出來第二個

extend不是整個extend但是最後其中一個block的information要露出來對不對所以你的IO request其實是第一個要讀第二個extend要讀然後最後才是第七個所以你變成三個IO request所以本來只要讀一個IO request把資料讀出來可是為了要去 travers and index變成兩個additional的IO request去找它的extend的位置所以你的random的效能當然就變差因為disk就是這樣你讀越多次它就越慢嘛對不對

每一次的lookup都很花時間好那另外就是我們剛才說的internal external這都還是有可能對不對internal就是尤其當你的lens是一個fixed size的時候那external勒也是一樣就是如果你是fixed size那external也是有可能的那如果你這邊是任意長度當然這個問題就可以解決了好所以這個是所謂的extent-based它其實就是contiguous加上linked的做法好所以那看到剛剛的這個做法之後我們第二個基本的這個類型的做法就是全部用link了

所以這是另外一個極端就全部用link所以從剛剛的這個例子我們其實就大概可以感覺到link大概會長什麼樣子那全部都是用link就是所謂標準的linked allocation那做法就是這樣子每一個block全部用link把它串起來這極端的例子對不對所以我想很明顯所以每一個file一樣我就是存的部分也是蠻簡單我只要存的就是起始跟結束

為什麽要結束因為他知道他不需要再 traversed了所以他知道最後結束的那個data block的ID是什麽那只要存一開始起始的位置因為後面就像剛剛的做法一樣所以每一個block他最後會reserve一個幾個byte去存下一個位置所以你頭就只要存一個就好linkedist嘛所以你就要 traversed了所以這就是標準的link的做法好那這樣的缺點一樣知道這怎麼做的之後一樣我們就來看一下

第一個它的Size就是很沒問題嘛因為你只要找任何有一個Available的DataBlock你就把它加上去就好所以當然你很容易的去Grow或者是Shrink你可以Free掉DataBlock很容易去Reuse這是它最大的好處對不對那但是它的PerformanceIO就是Re跟就是不要想Re-Write就是只重點是Sequential還是Random這樣你可以看見，如果是Sequential其實還不錯，因為Sequential就是Traverse嘛，所以你沒有你要你不會有多讀的IO Request出來對不對。就像我們剛才的例子，你要讀的是如果Sequential則就是從頭開始讀所以你讀完16之後你自然

讀完裡面的data你自然也就把下一個pointer的位置一起load進來了，所以你沒有extra的reading對不對；然後咧你早就繼續traverse，所以你不會花任何的extra effort去load那個pointer的動作。如果是sequential那；但是如果是random就像我們剛剛看到就像前面講的意思是一樣，你就會非常的慘，因為當你要去random的時候你就要去traverse找到那

就看你的其實位置在哪，因為後面的你讀的資料就越多你根本不要那些data block的資料data，但是你要那個data block裡面的pointer那你就會花非常久的時間這是他最大的確定好；另外一個當然就是他會浪費掉一些空間去存那些pointer對不對，所以他浪費的空間當然就是每個block都會犧牲掉幾個byte所以多多少少就會有一些issue好

那 <link>這邊為了解決剛才的issue其實跟剛才是一樣所以當你<hybrid>的時候就開始blurry了所以當link它不想要做這麼多的traversing它不想要存這麼多<link>的時候它怎麼辦呢其實跟extend block是一樣啦就是把它group在一起嘛我就把很多的blocks把它cluster group在一起 對不對然後當作一個以上是extend所以這邊

的改變其實跟剛才是一樣所以link加上contiguous加起來就是我們俗稱的extender好那另外一個缺點用<link>的要注意到就是它的reliability了所以今天制定list所以我們都知道只要有一個<link>斷掉了這整個file就完了後面就全部lost了所以這個是非常大的一個issue對不對你只要一個資料壞鬼或者是你在斷電你修改過這個file過程中沒有把它修好這metadata它整個file可能就collapse掉所以這個是

<link>的另外一個很嚴重的問題但是它的資源使用它最大好處就是資源使用非常有效率我去找使用空間free的空間之後order one我根本不用search我就一個free的data block list最上面的那個block pop up出來管他有什麼ID我就存進去對不對所以他是最快的一個做法在create的時候好那剛剛這樣子的link的這樣的這個allocation的方式在真實的這種file scene裡面其實你也會看到就是有名的FAT32那FAT32他其實就是用link可是為什麼

他可以解決避免到剛剛的問題勒他最主要的做法勒就是要去解決這個random access還有 traversing 的這個 overhead他不希望每一次你都要去look up 這個 disk一個一個去 look up 對不對所以他的做法其實很簡單就是把這些 linked list 對不對這些 pointer我把它全部收集起來所以它其實是一種 metadata所以他就把它全部收集起來然後再把它變成一個 single 的一個 data一個 table 去把它存起來就像這邊寫的

這邊其實只是pointer的information而已所以就是第0個它指到的就是從像這個file217嘛它指到的是168然後168你可以看這只是一個table而已喔所以它裡面沒有data content然後就168你就是存339這個entry我就寫339所以就是把它整個抽出來另外去存就對了那這樣做的好處是什麼就是你可以把它當你在load的這個file system的時候mount它的時候

他就把整個table漏到memory了所以他當然要讀這些pointer但是這些pointer其實它的大小並不是真的那麼多跟data比所以他可以把它存在比較小的一個空間裡然後一開始就把它全部從disk sequentially把它全部漏進來這個大table整個漏進我們的memory的structure裡面然後做triversy所以到底今天的讀寫就算是random access其實沒有關係因為你在memory這邊有lookout可是不要忘記這是memory所以沒有disk IO

我Memory裡面去找到它真的Block ID了直接去對我們的Disk下指令所以它的Lookup Time就變1了就跟Configure是一模一樣所以它的速度也可以變得非常快好所以這是Link的解決方式那為什麼叫FAT32很簡單32指的是什麼就是這個Paper Entry而已用了32 bit所以大家其實去看的話現在你會看見所謂的FAT64那到底是什麼?

沒什麼啦就是bit變64bit而已但就是這個做法所以這個也是很多facets是這麼做的那最主要就是只要能夠解決那個random access問題就OK至於fail recovery那當然是另外一個issue對不對所以當然有其他你用log等等的做法你可以去做recovery好所以這個facts其實它是一個cache簡單來講我們就把它收集起來然後變成存在

存在一起在data裡面存在臨近或是連續的data block裡面然後咧把它整個load up memory當作cache所以最重要就是render assets變得非常的快就變成minimum seek time啦ok好ok齁所以這個就是所謂的FAT32這個file system的做法它就是用linkedBy the way第一個如果contiguous大家好奇的話它的file system叫xfs反正是一

個很基本的但是很多OS都會Support這個File System因為為什麼說Support呢因為知道有些File SystemOS不Support的就是有些像Microsoft它可能不Support一些Open Source Community的File System對不對那XFS是一個滿基本的很多OS都會Support的File System它就是用Extend而已就是Extend based的那個做法好最後一個最

後一個是index那就是我們知道的index的概念就是全部把它的pointer收集起來跟剛剛不一樣的是沒有triversing，所以它還是pointer可是不要忘記這邊的pointer指的是它直接就去存的是第一個entry第二個entry，它不用triversing對不對剛剛那個就算我們把它收集起來，你去找你還要trivers只是在memorytravers所謂的index就是完全就是lookup所以就是第幾個

你這個file的第幾個data block它是存在哪一個physical的位置就直接這樣去存它所以你今天一樣你要找的是我要找這個file的第三個block的位置，我直接查表第三個entry1我就直接去使用了這個就是index了那這所有的這個information可以看見就是它會把這些index全部存在一個data block所以這個data block存的不是檔案的

內容裡面存的就只是這些pointer的位置而已然後這些指道的這些data block裡面存的只有data完全沒有pointer所以這是最大的差別然後還有這個還有一點是你可以看見這邊來講這個index block是每一個file它一個嘛對不对因為是獨立的但是前面這一個我們看見的這一個table它是整個f ile system的所以你可

以看因為它是只create一個look youfile system有多大的空間嘛它只是一個single table然後它就直接在這邊要做tribusing所以裡面其他的entry可能是存的是別的file的pointer所以這跟剛才也是不一樣的所以很像不要搞混這邊還是用link的概念那當然這個table是存在其中的一個data一個這個data block裡面然後會整個露出來的

但是它是存所有的file所以它可能很大會連續存好幾個data block那這邊沒有這邊是你的只要存的是index block的ID所以在file control block裡面它只存的就是第一個這個index block然後裡面才會有所有的資訊只有這個file的然後就直接就lugar去access其實已經下課了所以我們今天就只能先講到這所以我們下次很快就會講完它的好處跟壞處然後我們就會move on到第12章開始講storage的system的部分.