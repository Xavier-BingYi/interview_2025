undefined
好，所以我們剛才講了幾個turn跟定義，如果大家很難跟現實的電腦連結在一起的話，我們重新來看看一次。如果今天去買一個電腦的時候什麼樣子，你會說它是一個Multiprocessor的Computer System；什麼時候會說是Multi Core；什麼時候會說是Many Core。所以，Multiprocessor的意思就是你買了一台電腦，如果你們打開來把機殼打開來看見裡面有多個CPU或者是可以計算的像我們後來講到的GPU的插槽的話，那個就是Multiprocessor Computer System了，

也就是說，每一個買來的這個CPU或GPU也好或是任何Processor的這種最新的Processor的這些Unit也好，如果你可以在上面插多個，你可以看見，可以很多個插槽的話，這個就是俗稱的Multiprocessor；所以，它還是在你還是一台電腦嘛對不對然後，你還是這個Motherboard上連接起來的那這個就叫Multiprocessor了。那所謂的這個Many Core的意思呢，指的就是只是單一一個Processor喔 對不對，所以，就像我們電腦，我們可以插兩個CPU

四個CPU，但你一個CPU裡面如果就有多個計算核心的話，這個就叫做Multi Core Processor所以它本身還不能算是一個Computer Assistant，它只是這個Processor裡面有Multiple Core，那我們就稱之為Multi Core Processor了，所以兩個結合起來就是你可以有一個MRT Processor的Computer System上面，你再插MRT Core的Processor在裡頭，那你的核心數就可以不斷增加了所以當然就更緊密啦，因為它是在同一個Chip上面，就有這些計算核心了那到了這個Many Core的Processor的意思就是你可以

講，就像CPU一樣，所以它就是一個Single的Processor那，但是這個Device，這個Single的Device裡面，它就有非常非常多的Core，它自己本身就像是一個小型的電腦系統一樣，但是它在整個電腦裡面，它仍舊是你看見的，就是這邊看見的對不對，一張卡然後你就可以插上去，所以我一個電腦裡面，現在最新的對不對，你可能可以插八張GPU的卡片在上面幫你做計算，那每一張GPU卡，

它並不是只是Multi-Core這樣子，它當然也不是一個Chip，它是一個整個，就像一個對不對，就像自己一個小型系統一樣，但是它裡面就可以整進100多個Core在裡面那，這個就是所謂的Many-Core了，它就可以這個擠進非常非常多的一個Single Processor，但它的數量是遠比傳統的要多那之所以多就一定代表什麼咧。它的Hardware Design

上其實是有非常大的Revolution，即整個是其實是重新做過的，或者是它的Instruction的這個方式處理的方式，其實跟傳統的我們俗稱的General Purpose的CPU是不一樣的。那這個就是Mini Core的Processor，那這個其實是很新的。所以你會看見它的形態是很多樣化的，就像我們說有些人最早期就是直接用GPU，你就把它當作一個Many Core Processor到了Intel 對不對

他們設計了這個Xeon 5出來那甚至於這個我們剛剛還沒講到是這個Tel64這也是這幾年開始新的完全全新的一些Architecture。所以你會看見它裡面放的真的是傳統的CPU，所以根本就沒有做調整可是呢它在它的Interconnect就是這個chip上面的Network上做了很大的功夫，所以讓這些Core，它在同時運作的時候，它的這些

Bus Line，這些溝通的時候讀取資料的時候，它不會撞在一起，不然你把很多東西塞在這麼小的一個空間裡面其實你很多會Share，但是Share當然可以減省很多成本，可以讓譬如說距離變短可是你相對要處理的問題就是怎麼樣可以讓它的Congestion可以減少不然你會發現大家你等我我等你根本就是

只是在Idle而已所以你以為你跑64個CPU在裡面搞到最後等於只有一個CPU在運作一樣那就沒有達到效果所以這是非常複雜的東西但這個是這幾年來很多很多的研究跟未來的發展在這邊所以這個就是Mini-core的Processor你买来就是单一一个Processor而已所以一台电脑可能还是可以

通常还是可以插入非常多的这个Processor在里头好那我们刚才是从这个Processor的角度对不对去看一个系统的建构从一个很单纯的一个到变得非常多个的各种形态那这边还有另外一个方式可以去看这个电脑的系统的运作到底是长什么样子那就是从Memory因为我们知道计算就是Processor

的Memory所以以Memory这边来看的话我们这些Multiprocessor的Computer System它的系统架构在Memory这边通常就是会分成这两大类U码跟NU码也就是差别在于像我们刚才看到的这些系统一定都有多个CPU那你的Memory呢當然也要Share囉因為這是基本定義對不對但是當你的這個CPU越來越多的時候

你要怎麼樣讓這些Memory在這些CPU之間Share那它的架構就會分成這兩大類，那所謂的Uniform就像看圖上就是很明顯意思，就是大家都接上去就對了所以不分任何的區隔也就是所有人都用同樣的方式接到這個Memory上面去，那這個就叫做Uniform Memory Access或者簡稱就是UMA，那這樣的系統呢當然最適合的就是我們常見的這些SMP啦對不對，

因為就是大家都一樣啦簡單來講，所以當我們說Uniform的時候指的並不只是說連接的方式，重點是他Memory的Access Time，這個才是重點，就是Memory Access Time必須要相同也就是說今天的這個程式，我不管是RUN在CPU哪一個CPU甚至於哪一個CU的哪一個Core上面，它的Memory Access的速度是相同的，那就叫做Uniform，所以它用的叫Uniform指的其實是這個速度是相同的所以大部分的電腦比較單純基本的電腦當然都是用這樣子的形式，

這樣的電腦還有一個好處就是你在程式執行的時候，其實使用者不必太在意我的程式到底執行在哪一個CPU，因為他們都會看見的是相同的效能，所以這就是一般的U碼各位的電腦還有手機，我相信都是這個樣子就是這種很基本的架構Again當你的 scale 變大當你為了這些效能你要增加更多的計算核心更多的 CPU 到你電腦系統的時候你就會發現你的 memory

開始是有 bottleneck 了因為如果是這樣的接法意思就是你所有的人可能都要去搶某一個 memory 的 channel或是 bus所以很容易就一樣的道理當你的 CPU 這些東西增加的時候它就會開始有更多的 contention 在裡頭那就會變慢所以所謂的NUMA Non-Uniform 的概念Again 就是在這個圖看到的這是什麼意思呢Hier

archy 對不對所以當我們要管理東西越來越多的時候最好的 solution 就是 Hierarchy 對不對所以你就會看見在這樣的電腦系統裡面我們會把 CPU 就切成四個區域在這個例子裡每一個地方我就有一塊 Memory 在那裡這塊 Memory 就等於是這些 CPU 的 Local Memory 一樣那其他的方案就是Remote的Memory所以這是一個Hierarchy意思就是說

這個CPU同一個區塊的他Access這個Memory的速度一定會比較快啊對不對因為他是直接嘛對不對那如果你要連到其他的Memory還是可以因為這個電腦是Shared所以Memory大家都連得到但是差別在於這邊或畫條線的原因就在於這個CPU要Access這塊Memory的時候它要先跟這塊Memory的Controller先溝通才能夠去Access所以它不是直接也就是間接的意思那這樣的

好處很想而知因為Hierarchy所以你可以建構更大的電腦了就像這邊例子這邊只有4個CPU我下面就有16個所以自然你可以想見它是可以Scale變得更大但是缺點是什麼可以說是一個缺點因為你要remote access所以你的路线比较长所以你会发现你的access time你的memory的access time变得不同了

也就是non-uniform对不对也就是local会比较快remote比较慢所以这就变成non-uniform的原因了那这样的话的结果就变成你在执行程式的时候或说你在allocate memory的时候其实你要注意到如果你想要你的效能达到最好其實你擺在哪邊是有差別的對不對如果我今天程式讓在左上角這邊那我

Memory去LK在右下角可以啊會喔有可能喔尤其是OS用不幫你管理的話只要看到有空間我就丟過去的話就會變成Remote Access那你的速度就會一定會變慢對不對那如果你知道這個系統架構的話執行程式的時候好的OS它就自動幫你管理了或者是至少它有一些flag control的方式讓使用者在執行你的程式的時候

它可以告訴OS然後指定我的程式要run在哪或者說我在allocate memory的時候我只能allocate memory從我的local memory這邊要空間就是我寧可就是等到這邊有空間我才需要做allocation的動作這些都是可以的那所以你就可以去控制它來去得到make sure你在這個電腦上支線效能是達到最好的所以這個NUMA各位當然可能不常見對不對但是其實在所有的高效能計算系統多半是這個樣子多半是用NUMA的架構只要非常講究效能然後scale大的電腦都是用這樣的

架構在run所以其實未來或許各位也有機會用到其實要注意一下到底這個Computer Assistant是NUMA的架構還是UMA的那NUMA的話其實OS要做的事情或使用者對這個程式執行效能上就要更加的注意其實會有很大的差異在那邊好那我們剛才這就介紹完所謂的Tightly Coupled所以雖然好像很多很複雜但其實它都是在同一台電腦

這個box裡面的就是你買來大概就是一個server那裡面就有那樣子形形色色各式各樣的架構好那接下來咧我們就介紹distributed system所以也就是所謂的loosely coupled的電腦系統那所謂的loosely對不對定義是什麼？簡單來講就是它是透過網路，所以就是透過internet對不對去連接的，所以就是把很多電腦透過網路線，把

它連結在一起所以這個，實以一般的像學校我們常常去做的事情，就是這樣子我們把電腦把它串在一起去做同樣事情的一個電腦系統，就變成一個所謂的分散式的系統就像我們說Internet廣義來講，如果你把Internet看成一個系統是可以的，而且它就是一個分散式的電腦系統透過這些Cable去把它連

接起來的這樣子的連接跟之前的最大差別，一個是連接的方式不同，另外一個很重要的，就是它的Memory Memory的定義，它就會變成全部是Local的，也就是每一台電腦都有Memory可是它們是不會Share的，就像我們今天透過網路可以連到別的電腦，不代表別人可以直接去使用我電腦上的Memory的空間，一定要透過

我的程式我的OS，我才能去使用，所以其實它們是分開的，所以這就是Distributed System跟之前我們看到的系統最大的差別，這樣子的電腦系統的目的也跟之前也會滿不一樣之前我們都講都是效能Performance所以一直增加計算核心，但這個方式雖然也可以增加計算核心可是更常見的主要原因是在於這些幾個像是Resource Sharing為什麼我們會上網其實是為了在SharingResource或者是Information對不對，所以我去你那邊去抓照片，我去抓東西、

抓檔案等等這都是Resource Sharing，那第二個原因就是要做Load的Balancing或是Sharing所以今天我有很多台電腦的話，我有很多台電腦的目的就是因為當有一台電腦的工作量太多的時候，我可以把這四個工作讓另外一台電腦幫我去分擔也就是直接把它移過去就對了，所以我就可以讓大家不會有人太多的工作量然後在那邊等很久可以讓大家可以平分所以大家可以同時把事情做完，

那第三個我們剛才說Payroll的System也有提到Reliability啦，但是其實Distribute System才是真正最注重Reliability這一塊什麼叫Reliability呢也就是同樣就是讓我的系統不會因為有一些Fail的發生而Crash掉讓它很可靠很Reliable像資料不會掉或是我程式不會被Kill掉，那為什麼分散式系統比较容易做到，因为每一台电脑是独立的嘛对不对，

所以我們知道相對之下電腦跟電腦之間其实它只是连接在做这个资讯的沟通而已所以當一台電腦坏掉的时候其实通常是不会其实是不会影响到另外一台電腦的，所以現在很多分散式系統或是大家有聽過什么Cloud Computing对不对就是用很多台电脑的目的是什么就是要实现Relevability所以任何一台电脑坏掉没关系

我就把他這件事情交給另外一臺有一臺電腦壞掉我就把這件事情交給另外一臺或者說我的資料我可以備份在很多臺電腦對不對所以很多臺電腦同時壞掉機率這其實是蠻低的那如果是Terror Processor的系統畢竟是同一臺Machine所以你可以說如果Memory Box比如說壞掉那當然就真的整臺電腦都毀了

所以它的 reliability 能夠做到的程度是很有限的但是如果是一個分散式系統它根本就是不同的電腦每一個人有自己的 memory 有自己的 disk所以當然它的 reliability 就可以做到比較高所以很多分散式系統現在也都是為了這個目的那分散式系统的架构呢它简单分就比较单纯一点就是所谓的peer-to-

peer跟client-server那这两个大家因为太常见了所以大家应该要稍微知道一点因为其实一定大家常在用了那client-server简单来讲就是master-slave嘛对不对所以一看大家就知道也就是这整个系统的运作有一个server在那里其他人呢都是所谓的这些client或是worker也就是透过ser遙控制他才能知道他要去做什麼事情所有事情都必須要透過server的centralize的一個control這就是所謂的client server那這個大家很常用到啊比如說FTP對不對

大家常常在傳FTP都知道我要先我是架FTP的server還是我是架FTP的client對不對所以是很明確的一個人是server一個是client至於資料的流向那是另外一回事但是它整個運作是有一個是server它是能夠控制這個整個連線是不是能夠去運作的這台電腦就是server那這樣的架構通常就是很容易比較容易去建起來像大家如果去學一些網路的課可能有些作業就會請大家寫這種這種溝通的一個network的系統出來對不對

但是這樣的系統的壞處當然也很明顯就是server往往就是一個bottleneck所以很多分散式系統他們當然還是選擇了用client server的架構去建尤其是我們說雲端計算那些Google啊Microsoft的那些Cloud去管一個data center的時候因為方便所以他們還是用client server但是他們會下很多的功夫譬如說server沒有人說它只能是一台電腦我其實也可以

用10臺電腦當作server也就是說他們的角色是server但是這個角色這件事情我還是可以用分散式的方式讓10臺電腦或20臺電腦去做處理所以比如說有一臺server如果毀了我可能有一臺master的server它壞掉了我可以立刻把它這個職權交給backup的server那這樣我就可以達到reliability但是我還是

一樣其實是server client的架構所以中間有很多中間的solution在那邊啦但基本上他這種方式是比較容易架構的但是value這個怎麼樣去make sure因為server嘛所以意思就是說如果server沒了那真的整個系統就不能動了對不對所以我必須要處理這個問題另外就是這邊畢竟是所有的workload都進來所有的工作量都要透過server所以server成為效能的一個bottleneck那有沒有

什麼方式可以把它至少減輕它的工作量比如說能做真的需要計算的部分可能還是都讓這些client去做然後server它要去溝通要去處理的事情都是最重要但是都是最簡短最輕鬆或是最快可以做完的事情所以這就很多設計在裡頭了那相對於client server在分散式的系統裡面另外一個做法就叫做peer to peer也就是沒有server所以叫做peer to peer因為意思就是每一個人都是peer，就是同僚或同仁的意思，所以大家都是相同的角色，就像各位

同學之間同一個學會同一個課，那大家都是peer的這個角色，所以並沒有做區分誰是master誰是slave那為什麼他們還能溝通呢那就是代表你在寫peer to peer的這個系統上，你會制定一些protocol或者是rule或policy讓他們follow這個protocol，他就可以溝通了，那這樣的做法最重要的就是沒有single point of value所以今天任何一台

電腦死了或離開這個系統，peer-to-peer的系統一定都可以繼續的運作，因為它也沒有什麼特別的嘛大家都只是來來去去都可以，它沒有任何一個人是必要的，在這個系統裡甚至要兩台電腦在這裡，它就成為一個peer-to-peer的系統，所以它非常的reliable基本上它就不會因為任何一個電腦而會影響整個系統的運作，那它的loading通常也就很balance，因為大家都

可以共同的去做同樣的事情，那這樣的系統呢其實各位也常常在用尤其是去網路上，如果你去抓看電影啊或是streaming的service對不對現在這個網路實在太發達了，我相信大家去要去看球賽或什麼一定都去網路上找一找就有了對不對，那這些系統全部都是P2P所以你可以想見那些影片的量是很

大的然後全世界的人比如說都在看奧運或是看世界盃然後大家都要看同樣的content所以當然不可能每一個人都從一個server那邊把資料給copy過來囉其實是大家互相去share就近的點然後就去讀取那些檔案那去分擔這個load那所以很多的streaming的 尤其網路上的streaming的系統都是peer to peer那尤其啊其實againinternet我們說你就把internet想

其實它的確是一個系統它的確就是一個分散式系統那internet就是標準的peer to peer所以其實internet我們知道它是大家不知道早前有沒有看過這個電影阿諾言的這個魔鬼終結者嘛對不對所以這個他的敵人是誰SkyNetSkyNet是什麼其實就是Internet啊那真實就是如此Internet是不會被下當的真的是並不是任何一個國家任何一個organization對不对在管理Internet可是到處你都可以上網對不对然後這Internet它最厲害的地方就在於它永遠不會break對不对你可能你自己local

你可能沒辦法連上Internet各種原因但是Internet永遠存在你唯一把Internet消滅掉的方式就是把連在一起的所有電腦全部把它給拿掉，但這當然是不太可能的，所以從這邊就可以看到Peer-to-Peer其實是非常Powerful的，所以大部分的網路上的其實很多是透過這樣的架構去建立的根據連結的方式是剛才那兩種常常

在分散式系統這邊大家也還會聽到的幾個Term我們稍微介紹一下第一個就是Cluster對不對，所以我們知道衝擊電腦就是所謂的Cluster System，那Cluster System它其實是屬於一種分散式系統，因為我們知道Cluster它其實就是把很多台電腦連結在一起，所以符合分散式系統的定義那但是它又在分散式系統裡面呢比

較這個它算一個subset比較特殊的一種系統，那這種系統特殊的點在哪就在於它的網路的連接通常是local area也就是說，它的網路比如說它的網路的bandwidth或是它使用的網路線是比較好的，所以它的溝通可以再更快一點，因為我們知道Internet可能很遠嘛、 從臺灣連到美國至少也要delay相對就會比較久送

一個訊息的delay那cluster它當然它在同一個通常它就在同一個區塊區域那同一個機房比如說，所以它們都是會非常近的在一起所以你就可以去建這些所謂的local area的network所以它傳輸速度重點就是傳輸速度可以再更快一點，因為畢竟傳輸還是很花時間的，這要稍微知道就好，有興趣的自己去查怎麼樣可以讓它最快。勒目前最新的Technology叫做InfiniBand，這已經用了過去十年了自從它出來之後，我知道大家在宿舍你也可以

Build Cluster，因為大家都用Ethernet對不對。我相信大家都有經驗，但是這些比較High Performance的Cluster或是Supercomputer，他們用的就是InfiniBand。大家自己去查速度就會快個十倍價錢也是十倍以上，這是相對的嘛，但是有付出他真的有得到他真的是很快所以真的很講求電腦這個效能的電腦。你去看幾乎都是用InfiniBand那為什麼InfiniBand快呢？其實我們這堂課會教就叫做這個RDMA，就是我們剛才提到IO嘛。怎麼樣快有一些技巧在裡面，InfiniBand就用了

這個大家已經很常用在電腦系統裡面的這個所謂的DMA的這個技術，但他把它擴展到跨網路線那所以當然IO就快好那這大家看一下就好，這沒有那麼重要Cluster當然也有分Asymmetric跟Symmetric就是很多台電腦十台電腦有一台可能是Master那或者是Symmetric就是所有的人就是沒有區分這個稍微看一下就好，這個

比較不重要所以統整一下我們剛介紹了各式各樣的一些名詞其實是非常常見的，所以希望大家對於系統這個領域如果有些基本了解的話，剛剛介紹這些名詞要稍微記一下然後它的定義它的意義要稍微知道能夠區分那。我用個圖來統整簡單來講就是一開始我們看見的Single Core的Computer System就像最早期的PC然後你把它擴展一下就變成擁有Multi-Core的系統所以你可能只有一個CPU但那個CPU就有很多個Core就像手機那你可以再擴展一下就變成

現在比較常見的PC或者說Server這些伺服器你會發現你的主機板上不會只有一個CPU的插槽其實你可以插好幾個甚至於你可以插GPU插CPU或插不同的一些Core Processor這些就叫做Multiprocessor的系統所以它不是只有一個Processor它可以插很多樣化然後很多數量的再往外走你就會發現一台電腦是有限制的我的

主機板再怎麼做也就是那樣的空間所以如果你想要更多的計算量的話怎麼辦那就是用cluster，所以我就把很多台電腦把它湊在一起那就變成我們常見的所謂的cluster那cluster通常還是我們剛才說的就是它至少都還是用local area就是比較近然後比較好的網路去把它串起來而且通常 cluster做的事情就

是它所有上面灌的軟體跟管理者是單一的所以就像我們實驗室很多實驗室都有建自己的cluster去做計算那上面灌的OS可能都長得一模一樣然後可能都是用同樣的方式在做管理，但是如果你在往外走就會變成最general我們說的分散式系統，那就完全沒限制反正電腦跟電腦之間能夠溝通去完成一件事情，

那就是分散式系統，就像Internet或是說我們說雲端計算這些Data Center，我們聽過這個資料中心，它整個是非常大的一個Scale那就變成所謂的分散式系統了，所以電腦跟電computer之間的差異性簡單來講就會變得非常的大所以我們剛才說的Tightly Coupled，Loosely Coupled簡單來講就是你在一個Box裡面還是多個BoxBox就是一個Machine的意思所以如果是 tightly 的話就是你把它放在一個 box 裡面的 machine， Loosely 就會垮網路了.