undefined
不好意思耽誤了大家一些時間，那還記得上一次我們這個Chapter 0從最早的電腦系統開始介紹起，那提到最早的電腦系統非常非常的單純，那它能夠去支援的計算的方式就叫做Batch，這個Batch這個Term希望大家可以記起來，因為其實這個是就算現在這個資訊的我們這個做系統的處理的時候也常

常會用這個字Batch指的就是一次處理一個Job，那所以因為這樣子很單純整個系統它一次處理只能處理只能處理一個Job，那所以說它的作業系統基本上是不需要做什麼特別的事情除了基本的把這個程式漏到使用者的Memory還有就認得得這些Instruction讓CPU去執行然後處理這個基本的Input把卡片的

資料讀進來跟Output寫到這個印出來Printer基本上這樣就結束了，所以這是很早的這個時候的作業系統就是這麼的單純，那我們剛才提到很重要的這樣子的一個系統很明顯是不太實用的，尤其你想想現在的電腦系統來比較起來的話最主要的第一個他一次只能處於一個Job嘛，对不对就是所謂的batch第二個

咧沒有interaction對不对，所以說在處理這個執行的過程當中沒有任何機會讓使用者去跟這個program做任何的interaction，這跟我們現今的電腦當然是差最遠的，尤其你想想現在的手機啊等等講求就是interactive對不對你都在跟電腦互動或者透過電腦跟電腦另外一端的使用者或系統在互動那最後最嚴重的部分就我們說的這當時電腦是很昂貴的設備但是他這樣子的處理系統來講

它的支援使用率非常低尤其我們指的就是CPU因為你的IO很慢嘛對不對我們說即使現在電腦你也感覺出來大家都知道CPU遠快於IO所以如果呢你一次只能處理一個工作的話我們之後就會看見任何Program你一定都可以把它Breakdown成兩個Face要嘛在做計算要嘛在做IO絕對沒有特例就是只有這兩件事情

那一個Program組成你一定是有計算跟IO的啊那所以如果今天你一次只能放一個程式在這個電腦裡那當你在做IO的時候CPU當然是毫無選擇只能IDLE對不对因為只有一個人在做嘛那他不要CPU當然CPU只能IDLE那就造成很明顯的一種浪費的結果好那所以這三個問題要怎麼去解決它呢那這樣就是因為我們OS什麼都不做了

當然才會造成這樣的一個結果好那我們就先來看下一代的這個OS第一個先解決的問題就是在於怎麼樣讓我們的資源的使用率可以提升或者更準確地講更精準地講就是說怎麼樣可以讓我們的CPU可以不斷地做事情即使我們知道Program它就是有做IO的時候但是我還是希望讓我們的CPU可以不斷地在做計算那怎麼樣可以讓它不斷地在做計算呢。

當然是很明顯，你可以看見就是希望讓我們的系統裡面可以放多個Program對不對，因為如果一個Program你是沒有辦法解決這個問題的，但是如果我今天可以放兩個Program三個或者是甚至於現在一千個Program對不對，那當一個Program在做IO的時候，我就可以讓別的這個Program來去用CPU對不對，那所以大家就可以輪流去使用CPU，自然我的CPU就不會Idle了。

所以這樣子概念去設計的這個最愛系統我們就稱為所謂的Multiprogramming的System，雖然叫Programming啦，就大家想Program就對了，意思就是說，我系統中，我讓多個Program，那為什麼要這麼做勒，就是因為我希望讓多個Program之間的CPU跟IO的時間，我可以Overlap對不对，我可以把它重疊，所以說今天第一個程式在做IO的時候，我就做第二個程式的CPU嘛，

那所以說我的這個CPU就輪流在做第一個Program，第二個Program甚至於我越來越多Program，我就可以保證Always有人想要用我的CPU對不对，那麼我的CPU就不會Idle了，所以就是用這樣的方式，我可以增加我的CPU。的使用率這就是第二代要解決的問題那這個想法說得很容易啊實際上你要真的要實現的時候你就會發現第一個很重要的問題了

我到底要怎麼樣讓它overlap也就是說我們的電腦是有Io的device沒錯也有CPU可是它正在執行的時候我怎麼樣可以讓這兩個時間我的這個Io在做device在運作的時候CPU也可以同時在運作其實這件事情並不是你想像這麼的簡單的因為Io device它其實是很單純它是很被動的它通常都需要用CPU在那邊給它下指令

不斷的去下指令跟監測他的狀況才能夠完成一個IO的動作那這樣的結果就有點像是我們說這個你有一個這個主管對不對要下面屬下做事情這屬下他只是寫一行字他就問主管接下來我要幹什麼那請問這個主管真的能做他的事嗎不行嘛對不對因為他不斷的不斷就被這下面的下

屬叫他去下指令那結果就是這個主管就是等於就在一天到晚的下指令教他怎麼做而已根本就沒有再成為多工所以呢這個電腦的系統要讓他能夠IO跟CPU能夠多工的第一個先決條件就是要有這種Spooling的概念那所謂Spooling的概念也就是說要想辦法讓我們的IO在做事情的過程中IO很慢嘛像我要搬

一個Giga的Files從Disk到Memory這要花很久的時間大家都知道那在這段時間內我必須要讓我們的CPU完全不需要Involve在裡面就是不需要去下達任何指令或者是去被這個去負責任何事情，那麼CPU才可以真的去做它的事情那所以就這邊可以看見的所謂的Spooling就是希望讓我們的在計算的

過程中我們的CPU能夠繼續的做事情，那麼我們的CPU就必須要用一種Notify的概念對不對，所以就是你做完事情你再告訴我搬一個KiGa的File可能要花個好幾分鐘那你就等你做完了你再去Notify我們的CPU叫我們的CPU回來去做剩下的事情所以才能夠實現像這邊看見的這樣的一個概念就是Disk跟CPU可以是同時的在做運作的，

那這樣的一個這個系統的概念我們就稱為所謂的 Spooling那這個Spooling 要怎麼實現呢，就是這是一個概念Spooling 只是一個概念，那真的要能夠實現的話就是我們等一下下一個章節 Chapter 1我們會教 Interrupt 這個東西非常重要的一個東西就是整個 OS 的概念就是Driven by Interrupt被打斷這樣的一個機制那這個是我們Chapter

1的重點，那邊的時候大家就會很清楚知道怎麼樣去利用Interrupt就可以實現像Spooling這樣概念的一個系統的運作，但是這邊就大家先稍微知道就好就是Multiprogramming的第一個先決條件除了要把很多的Program能夠讓在系統之外其實是要靠Spooling這樣的一個機制讓我們的CPU跟IO的時間是可以重疊就在做IO的時候

CPU是不需要Involve進去它只要被結束的時候被通知就可以了好那所以當你如果有放多個的時候就會像這邊看見了對不對所以我們的Memory裡面除了OS之外跟第一代的差別就是我們現在有Job 1 2 3 4或者是不同的Progress那為什麼都要在Memory咧因為我們知道CPU要執行的

話它只能夠去讀Memory所以你要讓它執行就必須要先把東西漏到Memory裡面去那我漏了這麼多的目的是什麼當然就是希望大家可以輪流的使用CPU所以只要有一個人他說他不要用這個CPU要去做IO的時候我就可以去調另外一個Job的程式在CPU來使用所以當這樣的時候你就會看見幾件事情了

那尤其是我們知道其實Program啊一開始並不是在Memory要Load嘛所以都是Load from什麼Disk啊對不對因為大家的程式寫完也就是大家寫完Compile完的那個程式嘛當然一開始其實在Disk所以你的第一個問題就出現了我要Load哪一些Program到Memory然後讓在Memory之後才可以開始執行，因為我們Memory還是有限的嘛對不對尤其比較早期一點的話，

那所以說你不可能把所有要執行的Program全部都漏到Memory那當然現今事實上是如此這麼做啦，但比較早期一點或者說你去想一些比較Embedded的Device或是一些比較特殊的裝置的話，這個還是不一定always true的也就是說還是你會通常有一個第一個決定就是要漏的哪些Program到Memory那落到Memory，你當然要管理所

以你看有這麼多四五個啊，那所以到底每一個人每一個Job每一個Program他可以得到多少的Memory的空間對不对是評分嗎還是動態我們知道現在很多程式都是動態你可以去Allocate Memory對不对所以又會把事情弄得更複雜所以Memory Management那邊我們就會講很多，那到了Memory之後要去做執行要放到CPU那CPU的數量

當然就更有限啦對不对就算是現金可能也就才64個可以同時執行64個程式就很了不起了那，但是我load memory可能有幾百個所以要挑哪一個job去讓在這些CPU的Core上，這又是一個Decision了，所以你可以看見這個Decision呢就是我們說的CPU的Schedulin因此系統裡面有很多scheduling的問題那你可以看見最後這一層放

到Core的CPU上的這個叫做CPU的scheduling也是各位的作業三特別就會去知道一些基本的argument然後去implement它那從Disk到Memory我們通常稱之為Job Scheduling就是哪一個Job它可以變成Active然後可以去做執行的動作這個叫Job Scheduling那job scheduling現在當然比較沒有那麼的重要因為一般general的computer的話memory是真的蠻大的所以通常是可

以全部漏進來不過你就可以看見scheduling的問題跑出來memory management的問題跑出來然後還有怎麼樣可以讓就是實現spoolling就要透過inter-run這個機制實現spoolling的問題也會跑出來了那要結合這麼多的事情你才有辦法實現我們說的Multiprogramming的作業系統所以你可以看見MemoryCPU的Scheduling就是我們後面的章節就在講這些部分然後還有就是IO的部分對不對所以怎麼樣子可以實現Spooling怎麼樣子通過Interact怎麼樣透過不需要CPU involved的方式可以做IO

甚至於大家可能多少知道一些現在我們的電腦它之所以效能這麼快或是說你可以看到CPU真的可以使用率很高的原因是因為我們的電腦裡不是只有CPU一個人會做計算其實很多IoDevice你買來它上面就有小的一些Chip對不對然後那些Chip就會幫忙CPU去做這些Io所需要做的計算所以可以讓我們的CPU就專心的在算這些

instruction真正最複雜最耗時間的部分那IO這種很慢的通常就是用其他的方式甚至於其他的這些co-processor小的processor去幫忙去實現所以在IO Devices這邊就會幡大家介紹現在使用的一些方式好所以剛剛是這個Multiprogramming這個希望大家記得很清楚Multiprogramming是什麼樣子的一種系統然後它解決的問題是什麼那另外一個系

統就是有了這個Multiprogramming的這個作業系統之後大家就發現CPU的使用率是提高了但是我使用者用起來還是覺得不是很好用因為它的受限還是很大因為最主要原因是什麼他沒有Interactive嘛對不對剛剛就算很多Program同時執行他只是說讓系統的使用率增加可是就單一那個Program而言他的行為還是一模一樣那甚至也可能還變慢了一點，因為他還要理讓他要讓這些Resource給其他的使用者，因為CPU有限嘛，所以你很多人同時在執行的時候

有人就會被Delay對不對，所以以單一使用者的角度，這個系統並沒有真的變好啊對不對，那所以真的使用者，他想要什麼呢，他想要是Interactive就是說，我可以隨時的跟我這個Program去做互動也就是很頻繁的在IO跟CPU之間做交換，然後我也希望有很多的使用者可以同時的使用這台電腦可是很重要的是不能夠感覺到受別人的影響，所以就是很多人同時在使用這台電腦可是卻以為他是唯一的使用者，那原來的做法

剛剛的這個run很多program沒有辦法實現的原因是因為它仍然是batch一次一個對不对，所以我今天要嘛就讓另外一個程式做要嘛就讓我做所以我跟這個如果別的程式在前面先執行的話就會影響到我我就會被delay到後面去所以並沒有真的感覺到有shearing的這個感覺，那要解決這兩件事情咧大家想出來的solution就是需要一個

time sharing，所以 multitasking 這個 term 比較混淆一點，大家直接記 time sharing 會更清楚意思，就是說，我這個系統不是一次只執行一個 job，我是讓所有人一起執行然後我用時間的觀念去切割大家來使用的這個資源這就是所謂的 time sharing所以為什麼可以用Time Sharing的方式就可以實現Indent Active呢原因是因為所謂的Time Sharing就是我呢這個CPU在做執行的時候它可以非常的

這個平凡的你只要有一個IO進來什麼是IO呢這邊指的就是使用者的Activity就是透過這些IO Device對不對早期就是當然就是Keyboard囉那現在大家都知道手機嘛都是Screen了但無所謂這些就是IO Device就對了所以Time Sharing就是它可以很頻繁的去交換在CPU跟Device之間去做交換所以隨時可以去看說這些IoDevice是不是有Input進來或者是有東西要Output出去所以如果很頻繁的在這個之間交換的時候

使用者只要按下一個Keyboard鍵立刻如果我們的CPU或系統可以Detect到立刻去處理這樣子你就有interactive的感覺了嘛對不對所以他必須要很平凡的去一直去detect這就是time sharing可以實現的所以你可以一有input我就可以去react那你就會有interactive的感覺了那第二個咧更重要的就是這個sharing對不對所謂sharing的意思就是我每一個程式咧並不是我一次就把你所有的instruction所有的計算全部做完，

因為你全部做完你可能要花個五分鐘對不對，那五分鐘其實也是一段很長的時間，大家大概有耐心可能就是十秒五秒而已對不對，那可是電腦因為很快啊，所以它可以做的事情就是time sharing的意思，就是在每一個program之間，我只執行幾個mini second，我就換到另外一支程式去，所以你會覺得每一個程式

似乎是同時在執行的，因為每一個程式都輪流的在執行它的指令那，雖然它會變慢可是你會覺得整個就是所有的人可以同時在用這台電腦的感覺而且，因為你有interactive的意思，就是你的程式可能在等使用者input的機會是很多的對不對，所以其實你會有很多這些小的IO在程式中間所以只要一

碰到這個時候我立刻去做切換的話，我就可以讓所有的使用者好像同時在使用那可是又沒有感覺到它會變慢的感覺，所以這個Time-Sharing就是可以實現讓整個電腦系統是Sharing的概念然後可以增加Interactive的這個Behaviour那，所以跟前一個作業系統最大的差別呢，其實就在於這個部分就是什麼時候它會去切換Job呢，

原來是做完才切換對不對，有程式做完我才把CPU讓出來可是Time Sharing就是我會把我整個CPU的執行變成一個一個Time Slot，每一個人就是幾個Minisecond然後所有在這個系統裡的程式，我就輪流的去使用這些Time Slot所以它變成只要有一個很短的時間每一個Time Slot到的時候，它就會去做一次Switch，就換另外一個程式來做

這就是後來的Time Sharing System，也就是各位現在的電腦，所以現在電腦，我們知道同時在上面RUN的程式可能都有10個甚至於幾百個，但是你會感覺他們好像同時在執行為什麼，因為就是因為我們的CPU的Scheduling，實是Time Sharing的，就是固定每到一個時間，它就會換一個人，然後讓大家都可以有一個進度，讓這樣可

以共同的去使用這台電腦，所以這個Time-Shared System就是以使用者的角度出發了這樣的作業系統它又必須要多出一些問題了，第一個Virtual Memory什麼叫Virtual Memory，我們之後就會介紹簡單講就是我把Disk當作Memory，因為我們知道Memory是有限的再了不起100GB好了，那如果今天想要更多怎麼辦，我是不是就可以用Disk假如Disk Disk都是幾個Terabyte一千倍，所以如果今天Memory不夠，我可以把這些資料存到Disk就以為它算Memory一樣，那麼我的Memory就會擴大了對不對，

這就是Virtual Memory也就是這些Memory其實是假的，其實是用Disk的空間來取代的，那為什麼要Virtual Memory為什麼要把Memory擴得更大呢，因為我想要塞更多的程式到Memory，因為Interactive是程式之間頻繁的切換所以說我很短時間我就要換另外一個程式，所以如果想要讓我的CPU繼續在做事的話，我一定是希望更多的人大家可以一起輪流的來使用

我，並不只是要讓我的這個CPU或者我的Memory塞滿而已，我希望能夠越多人來Sharing越多人來動棚的使用，且還有IO很多Interactive的IO在裡面，所以我會需要更多的計算量從更多的程式的計算量裡面來做彌補，所以我就需要漏更多可能比以前是10倍或100倍數量的程式在我的Memory，我才有辦法確定我的CPU是不斷地在做執行，

所以就需要更大的Memory就是Virtual Memory第二個部分就是大家跟電腦的Interactive現在最常來做什麼大家都一定有體會就是讀檔案對不對所以常常在那邊使用電腦的時候，尤其一個人的時候不外乎就是在那邊開檔案Edit File存進去對不对，所以變成是一個使用去管理檔案的一個電腦跟以前只是存計算不一樣了所以這些資料怎麼辦

當然就是存在Disk然後透過File System大家都知道的檔案系統然後來去使用所以因為有很多的Interactive大家的Interactive的目的其實通常當時早期開始現在也很多都是就是想要炒作File所以必須要File System這個系統出現去幫使用者在電腦上直接的管理這些檔案就跟現在電腦是一樣的道理最後一個這些Process不只有了而且我同時會Run很多個程式對不對

所以我Run很多的時候人就會開始想一些比較複雜的程式出來一些程式跟程式之間可以溝通運作的程式出來所以現在很多程式我們知道並不是靠一支程式就可以做完很多這個Application應用程式對不對我其實是透過很多的程式然後中間去做溝通協調然後才完成實現的一個應用程

式所以就會造成有Synchronization的問題因為很多程式同時在運作的時候他們可能同時可以去修改一個Memory的Content那所以有些有Sharing的這些存在的時候怎麼樣確保程式跟程式之間的運作仍然維持正常這個是一個大問題也就是我們說的第二部分的時候synchronization的章節要教的你需要一些protocol大家要fo讓一些rule來去使用這些shared這些尤其是memory的部分才不會讓你的程式之心跟你想像的行為有所出入

好，那當然這個為了signalization就會發現你會產生一些locking的機制因為不能夠同時改嘛，所以大家要輪流啊！你最簡單的方式就是去能夠用一些lock把它lock起來那一個程式在用另外一個就可以，不就不准他去用可是如果用一堆lock呢，很有趣的是會產生de-lock也就是你擋到我，我擋到你最後大家都不用做事了，那這個是一個

衍生出來的一個嚴重的問題所以個別會是一個章節來介紹也就是當你有concurrent的程式在執行，就是同時執行很多程式而且他們之間有共用一些計算資源或者需要溝通的時候，你就會產生這些很麻煩的問題然後這會非常困難解的原因是因為因為Time-Sharing，它是幾個mini-second，意思是它只有在幾個instruction不

是各位寫的程式碼的那個一行一行statement而是CPU level很low level的instruction所以當它這麼頻繁做切換的時候其實會跟你一些Program所看見的世界是不太一樣的，所以變得更難去處理好所以希望大家稍微知道就是Multiprogramming跟Time Sharing這兩個系統最大的差別我們說Batch就是一次就一個job而且是只有一個使用者獨佔整台電腦Multiprogramming我就可以塞很多個Program進去但是是跟使用者是沒有關聯性的到了Time Sharing就是把人的因素加進來

所以你要能夠跟你的Program做互動它會有很多的IO在裡面然後會希望很多人可以同時使用但是又不會感覺受到影響這個就是Time-Sharing所以它的目的這個就希望大家記得很清楚很清楚Batch就算了Simple所以當作沒看見當BaselineMultiprogramming指的就是他的目的呢為什麼要Multipro

gram就是為了要增加資源的使用率是以系統的角度出發那Time Sharing是指人所以就剛才說的他要Interactive要互動他要很短的Response Time也就是我每一次有一個Input進去或Output的時候他可以立刻的做反應那這邊也沒有列啦,大家可以加進去,就像Siri共同去使用這台電腦,很多使用者一起去使用所以他們的目的其實是不同的一個是從系統出發,一個是從使用者的角度出發那這最後一個大家看一下就好你就會發現,

這些剛好就會Map到我們這整個OS的这个chapter里面这些很重要的chapter所以我们刚刚讲的这些刚刚的作业还有书里面的重要的章节其实都会在上面所以就是要实现这些事情你才能够达到一个其实很基本的一个作业系统的雏形那这些concept其实从来都没有变过的所以我们才说这个是核心的一些问题跟技术嗯.