undefined
所以剛剛提到這個RAID基本上它有很多的選擇就是在於它怎麼做stripingMirror還有Error Correction的部分然後根據它不同選擇的方式跟設計的方式就會成為不同類型的RAID所以RAID其實它是橫跨很多很多種不同的做法但是其實它們的目的都像這邊看見都是一樣的然後做法都是透

過這三個做法只是它們的設計上有所差異然後不同設計方式的RAID我們就會稱之為它是不同level的RAID所以等一下我們就會看從最簡單的RAID 0開始就是RAID 0RAID 1 RAID 2 RAID 3一直下去那當然常見的都是前面的這幾種那我們就一一先來依序介紹它們最常見的機種就從 RAID 0

跟 1 開始那 RAID 0 是什麼意思呢就是它只用了 Striping 這個做法而已所以我們知道 Striping 的定義就是把資料切割然後如果看你有幾顆硬碟我就把它 Stripe 對不對就是依序的把它放過去所以這是一個例子而已就是今天如果我有兩顆硬碟那我的做法A指的都是同一個data喔就是你可以

想成是同一個data block然後勒這每個A1 A2就是它data block你把它切割之後然後把它去把它放在這顆硬碟的不同的位置上面去依序的去擺放striping所以如果今天有三顆的話就變成A1 A2 A3以此類推那它都是A所以意思就是它是同一個資料然後讀的時候它就會需要全部讀出來才

能夠讀到資料的值好那所以這是所謂的這個RAID0的做法那所以右邊有例子嘛第一個file放完對不對或是說第一個data block放完之後它才會放第二個以此類推那所以它其實就是接續下去從現在開始的起始的位置它可能從任何一個位置開始然後就繼續讓Robin的方式把它strike across所有的discs這就

是RAID0的做法那它最主要的目的只有一個Performance對不對因為我們這樣讀資料的時候我就可以兩顆硬碟一起讀我的IO的頻寬bandwidth就double三顆就三倍所以ideally你的速度只要不夠的solutionRAID是非常直覺的一種solution我就用更多的硬碟下去那只要最後你IO的bottleneck是在Disk這邊而不是在其他比如說System Bus或更上游的話那其實你只要透過加硬碟的方式你就可以

增加讀取速度那通常也是如此通常最Low Lat最接近IoDevice通常是最慢的嘛所以你可以用RAID的方式你的這個讀取的Bandwidth你看到硬碟的效能就會這個成倍數的成長所以有N顆硬碟基本上你可以expect你的Performance就變成N倍讀取的速度Performance就是每秒你可以Read或Write的速度就N倍了這就是RAID0最大的好處那RAID1呢就是另外一套極端的是它只想要Reliability就是資料不要遺失因為我們知道資料很重要嘛我不一定要常常讀它也不一定讀的時候

要求要很快的讀但是我一定要我的資料一定要不要丟掉這是現在人常常會需要的一個很重要的事情對不對所以像你們大家一般的硬碟就一顆那大家就知道壞掉機率還蠻高的如果你的資料真的很重要像很多公司的資料他們就放在RAID1的這個Storage System上那意思就是我們把資料做Copy所以今天如果你有兩顆硬碟就Copy成兩份如果有三顆我就可以Copy成三份

那以此類推越多硬碟你就可以備份越多份嘛那你的這個遺失的機率當然就會成比例的減少對不對因為除非你N顆硬碟同時壞掉不然你的資料是絕對不會遺失的對不對所以這就是RAID1所以當然通常一般的general concept是備份三份就夠了啦再多有點浪費你的儲存空間那它的缺點就是儲存空間會減少對不對

所以你有兩顆硬碟這是一T這是一T你應該存兩T的資料啊可是如果你用RAID1的代價就是它的硬碟的數量能夠儲存的空間就只有一T而已，那另外一點是它讀取的速度，實它也可以順帶地提升，因為我讀一個資料的時候，我兩邊都有嘛，所以我讀A這個資料對不對，我A1可以從這讀A2可以從這讀啊，

所以我可以各讀一半的對不對然後再把它加起來，所以他讀的頻寬其實也可以跟他一樣，就是成倍數的成長，但是要注意到，他如果是寫的頻寬，就跟一顆硬碟是一樣，雖然你有兩顆硬碟三顆四顆，可是你用RAID1的話，那他的寫的速度就是跟一顆一樣，並且甚至於其實是最慢的那一顆對不對，所以其他Write的Performance甚至於還會差一點，這個比一顆硬碟的，

甚至於 1 顆硬碟還會再差一點，這是它的缺點了，這就是所謂的 RAID 1，那接下來我們介紹的2、3、 4 這些做法呢，就會進一步主要是要做到 Arrow 的 Correction 的部分了，而且是比較有效地去做 Arrow 的 Correction儲存空間上，可以作為減少因為，我們可以看見 RAID 1 該的做法，如果我有 2 顆硬碟，我就浪費掉我，如果是兩

倍的copy，我就浪費掉一半的儲存空間，所以它的data的redundancy的比例，是非常非常高的，所以這不是很efficient的做法，所以RAID2呢，就是利用coding的概念，希望把這個問題給解決，那方式一樣，你可以看見就是，我們需要很多顆硬碟那一樣我們原来有dataA1 A2 A3這是原始的data那為了我們能夠知道哪一顆硬碟上我們現在硬碟壞了對不對

所以第一個其實像RAID2它甚至於第一個想要知道的是到底哪一顆硬碟有壞掉這件事情發生有的時候壞它就只是beat flip你也沒有任何的徵兆啊對不對所以第一個要知道哪一個壞壞了之後它又要能夠兩方能夠修正它到底它的原來的值到底是多少那RAID2勒就是用所謂的這個Hemming Code所以其實大家如果再學一些

其他課可能有提到過所以這個常見的一個coding的方式在這個訊息的這邊它的概念就是像剛剛看圖就很明顯看到D就是指data的部分那P就是它的parity bit所以首先這每一個都是01 01這一定要只適用於bit level的coding所以這每個就是0或者1就對了那上面圖就可以看得到如果今天我們有四個data

就根據它的顏色有交錯的地方去算它的parity那個就是它的arrow correction code的值那所以這個目的是什麼咧就是今天有任何一個data的bit如果flip的話大家知道其實透過parity bit還有其他data剩下的值的這個數值的方式你可以去算你就會知道誰錯了而且你可以修正就是知道原來錯的那個人是誰然後那個人的值到底是0還是1

所以就像這邊就是實際的例子對不對，所以原來有四個data，那就是可能原來是1-101這樣。那、parity bit你就按照這個原則去算，就會變成010那今天只要任何一個bit一flip，你知道他會影響到這兩個人嘛，對不對。但他不會影響到那個人所以這個人就會知道有問題，這個bit錯了。而且現在的bit，如果flip之後是0，他知道錯，所以當然就是1嘛，所以他就可以

把它correct回來。所以這就是這個Hemming bit，這個Hemming的這個coding的做法的好處，所以他其實重點就是他可以去detect任何的這個value只要一個或者是兩個大家去看兩個如果錯的話，實他也可以detect。但是只有一個bit錯的時候，他是可以recover就是他甚至於可以知道到底值是多少。如果有兩個bit錯，因為他剛好可能會抵消掉，所以你只知道有兩個人錯可是你不知道到底是到底是同時被flip還是還是說

怎麼樣的一個情況你就沒有辦法去把它做correct的部分，所以它是只有single disk value的時候它可以去做recovery那兩個disk value它可以做detection好，那你可以看見這用幾顆硬碟就跟coding息息相關啦所以你看像在這個例子來講我們必須要用4個data加3個period of bit才能夠滿足這個式子對不對所以它就必須是7次也就是說你必須要有7顆硬碟嘛

然後前面四個你就是放你的data嘛後面三個就放你的parity bit所以就變成你需要七顆硬碟所以這個做法當然它的限制就是它一定有指定的硬碟的數量你要符合它的這個equation的這個值你才能夠去用這樣的方式去建你的rate2那74就是其中一個例子可以看見那它最大的好處就是大家一看就知道你看像這個例子來講

我們一樣是只要有一個硬碟壞了我們就可以去做修復喔對不對所以跟剛剛的REPICA是一樣的意思對不對那如果是REPICA一個壞的話我們知道就是要兩顆硬碟嘛所以你浪費了百分之五十的儲存空間對不對那用這個parabit你可以看見我們這也是一個壞掉但我們只用了多少七個啊對不對原來是四個那現在變七個嘛所以其實你的這個overhead就可以變得比較少你浪費掉的空間比較少對就是你原來是

四個你多浪費了三個所以你浪費了75%原來的話就是1比1嘛所以是100%對不對就是你data多少你的redundancy就是多少是100%的這個比例那這個的話是4比3所以就是75%所以可以做到一樣的事情但是他浪費的空間就變少了，所以這是RAID2最大的好處了好，那這還不夠好，因為勒剛剛是以這個Hemming code比較，是以數學的概念在思考這個問題就是我用0、1的概念所以我知道

要這樣code的才可以做correction可是，如果你結合到真實的就實際上的storage system device的特性其實大家知道一件事情每一個sector本來就有error correction code對不對就是它不能糾正的時候它其實至少知道誰壞掉了所以我其實根本不需要做detection我只要做recovery就好了detection這件事情其實在low level的formatting的時候它就幫你做掉了

所以RAID3跟4就是所謂用parity bit的概念為什麼只要一個bit就夠了就是因為其實low level的formatting會告訴你哪一個sector壞掉你上面這一層RAID只要去figure out怎麼把它recover就好那既然我們這邊考慮的都是single disk的value的事件對不對所以其實你只需要一個bit就好了嘛對不對就是一個parity bit所以這邊我們只要

知道到底加起來到底是偶數還是奇數的0就好啦偶數的奇數的1就好了嘛對不對所以我今天告訴你下面有個synchronous上來我不知道是A2但是我知道disk1可能有壞掉甚至我知道A2壞掉那壞掉之後值是多少我們只要一個bit就可以算回來了對不對所以其實根本不需要用剛剛

這麼複雜的 coding用 purity bit 就可以修復了好所以其實只要 single bit 就夠了所以當然你會看見它的 space efficiency或是 data 的 redundancy又大幅減少對不對所以這就 depends 啊你要幾顆硬碟囉對不對所以你有越多顆的硬碟的話其實你的overhead就越少像這個例子我們是四顆硬碟嘛data三個配一個parity bit那它的redundancy就是33%如果是四顆硬碟那我就可以減到25%了對不對

所以就可以減少當然這減少是有代價的也就是不要忘記當我們硬碟越多的時候多顆硬碟壞掉的機率就會提升囉所以那個還沒有被考量進去對不對我們是假設如果guarantee只有一顆硬碟壞掉的話那當然你加越多的你的parity bit數量比較少然後data用越多硬碟你浪費的空間會越少

不過rate 3跟4都是這樣就是只留一顆就是它一個陣列裡面一列裡面它就只留一個parity bit就對了好那3跟4到底差在哪3跟4的差別在於3指的是bit level就是這你看到的每個a1 a2是一個bitsingle bit要嘛是0要嘛是1這個就是 rate 3就是他在 bit level在做 striping在做 parity 的這個 checking那 rate 4 是什麼勒是 block level什麼叫 block level大家可以簡單的想就是把它想成 A1今天是一個 block比如說是 8

個 bit 好了所以這一個一次存就是 8 個 bit然後這一樣是 8 個 bit那 8 個 bit 其實你在算 parity算它叫 parity 所以不能叫 parity bit 了它就叫 parity所以這裡也是八個 bit就每個位置相對去寫就對了所以這差別只是在它的單位是一個 bit還是多個 bit 而已其實原理完全一模一樣但差在哪?效能有差什麼叫效能呢?因為我們知道其實資料在讀取的時候通常至少是一個 byte 對不對甚至於是一個 sector或是一個 data block是好幾個byte，

所以如果今天你讀的是最小最小你讀一個 byte 的話，因為這是 bit level就是 parity 3 是 bit level 對不對所以代表他要讀 8 個 bit 讀出來之後他才做 reconstruction他才知道那個 byte 的值是多少 對不對所以你就要synchronize between 這些 disk 的 drive，所以你硬碟之間必須要做同步化你才能夠把那個 byte或者是那個 sector 或是那個 block 把它讀出來那這當然就會浪費一點時間，因為你要等

對不對那如果是block level意思就是你讀就是by block對不对那或是說你讀的資料甚至不到一個block那我只要讀一個東西出來就好所以我一次如果只讀一個的話，那我當然就不要做同步化嘛速度當然就會比較快一點那缺點是什麼勒就是如果今天讀的資料量很少全部都是在同一個block裡面的話，那其他block就用不到了對不对

但是大部分的儲存在我們知道一個系統其實很多使用者啦，所以當你在使用A1的時候別的使用者要讀的資料可能就在A2或是C3對不对你在讀不同的file所以在使用者之間的平行度仍然會維持住所以就是大家讀的block是不一樣的所以沒有關係你到B level就是甚至於一個單一使用者單一一個request你都可以平行可是那其實有點太

fine-grained 因為其實不用到那樣子對不对單一使用者的話其實反正有其他使用者在，所以你那樣還需要同步化所以反而會比較慢一點好所以基本上這個三跟四差別就在於它儲存的單位那最重要就是說block level就不需要同步化但是當然它的平行度就是要照block level你要有多個block同時讀寫這些硬碟才可以同時作用好第五個、

第五個 RAID5 其實是最常被用到的一種 RAID 了那它跟前面的 RAID3 跟 RAID4 你會發現長得怎麼好像一模一樣 差在哪？ parity bit 的位置不一樣 對不對那為什麼呢?因為 parity bit 畢竟它是一個 coding 出來的 data所以使用者其實在讀資料的時候他根本不會 除非有 fail 對不對不然他根本不會去讀 parity bit所以當前面的例子我們看到把所有的parity bit都集中在一顆硬碟的時候等於對使用者而言那顆硬碟是不存在的對不對

所以它的讀寫的頻寬就只有n-1個disk可以去讀寫那這樣你的讀寫的bandwidth當然就變小了對不對那如果我們把parity把它散開來的目的所以parity這個5呢就是它用parity也把它做striping對不對所以第一個會寫在最後一個位置然後二就寫在這這順序無所謂啦但就是它是用軟軟餅對不對

去把這個parity的大家的parity把它散在每一顆硬碟上所以你讀寫的時候你看就像以A1我來講讀A我A1 A2 A3對不對A4對不對所以A1 A2 A3都可以同時讀然後如果有另外一個B也在讀檔案的話他可以先讀他的B3啊對不對所以不同人的使用者他們都可以用到每一顆硬碟

所以我的平宽就可以是N倍而不是N-1了所以这最主要的目的就是让你的I order request可以平均的散落在所有的硬碟上面那另外一个缺点是你读的角度是这样原来的话你牺牲掉一颗硬碟对读的时候你就只有N-1一颗硬碟在读写的时候更惨写的时候原来的话如果全部这都存parity bit

不要忘記你寫的時候你只要改一個值喔它的 parity 是不是就要被修改那所以write 的角度來講原來的例子最後那個存 parity 的硬碟是 bottleneck永遠是 bottleneck所有人都嗆著要寫到那顆硬碟可是這邊的話你可以看見不管是 read 或者 write它都可以平均的分配在每一顆硬碟所以它的頻寬讀的時候是 n 倍寫的時候呢維持在一顆硬碟的 performance但是如果是前面的話

大家一看圖就知道了嘛如果讀只有N-1顆硬碟如果寫所有的人都卡在這裡就全部都要寫到那顆硬碟上面去那當然他就會成為bottleneck所以像剛剛的這個refi的讀跟寫的例子我們在讀的時候給大家看當然是當然是就變成有N倍那寫的時候咧你其實再去仔細的去分析它的話

其實是有可能兩種不同的Performance就Depends on你怎麼把更新的這個 Parity bit把它做一個計算的方式仔細看的話第一種方式你可以想假設我們今天有四個嘛對不對這一個是Parity那我今天我們說我們要改了第三個Disk上的資料那第一種做法咧就是很傳統最笨的方式最難易的方式我們就把資料全部讀出來，意思就是說

我們這三個是資料嘛，我知道這個被我改了所以我當然知道他新的值，但這個兩個我不知道啊，所以我必須要知道他的值我才能算出Parity，所以我必須要先把這兩個值讀出來兩個reader讀出來之後做了計算知道新的值，我再把Parity還有新的update的data寫回去對不對，所以你其實上你的write performance是N-1個read，

N-2個read對不對，因為除了Parity跟overwrite嘛，所以是N-2對不对然後咧你又要再寫兩個write對不對所以加起來就是N，你有N顆硬碟但是你一共issue了N個request，所以算下來其實它的performance就跟你只有一顆硬碟是一樣的就是沒有任何improvement對吧好，第二個做法就是其實我真的有需要把所有人都讀出來嗎，因為其實我知道如果今天我只改了一個人的話我只要把Parity的值讀出來嘛對不对

然後我再看還有把我修改的那個人讀出來只要讀這兩個人就好然後這個新的值跟舊的值的差值我把它加到parity上不就知道新的值了嗎對不對然後我再把這個parity寫回去所以今天其實我不管有幾顆硬碟你會發現我always就是兩個read兩個write對吧我就知道新的 parity 的 value 是多少了然後就可以完成這個 write 的動作了所以用這樣的做法你就會發現我的 write bandwidth

咧如果我有 n 顆硬碟嘛我的 bandwidth 是 n 倍嘛對不對但是我的會打折扣的因為本來只有一個 request我變成 4 個所以我要除以 4 對不對那但是這個就是我加速的倍數囉所以我的 write 的確也會隨著我越多的硬碟然後它的 write 的這個速度也會有所提升就是 n 除以 4所以當然如果你今天只有 4 顆硬碟你算一算會發現還是跟 1 顆硬碟一樣可是如果你今天有 5 顆 6 顆越來越多硬碟的話其實你用這樣的做法去 update 你的 parity 的話你的 right bandwidth

也可以同時的被提升所以這個是 depends 啊你怎麼去 update 你的 parity你的 right bandwidth其實有可能是維持一樣或者是其實就可以也可以做加速READ不討論因為太trivialREAD當然就是N倍嘛對不對因為任何一個硬碟都可以讀了，所以這是-parative，這個是RAID5的做法好！最後一個，那最後一個是這個RAID6或是之後的啦，你會發現

他們都是類似的，就是他們都變得更複雜，有更多的parity在那邊目的是什麼咧，就是要解決multiple disk value，所以到目前為止0到5我們在討論的都是一顆硬碟壞掉的話對不對？那可是萬一今天有兩顆硬碟壞掉，你也希望能夠把它的值重建回來的話當然你就需要更多的redundant的information那這只是一個例子而

已啦，就是如果你需要兩個fail那就的確你就要回到那些Hemming code啊Coding的做法然後去算出來到底它的值是多少？那當然你的這個需要浪費的空間就會比較的多了，所以這只是例子而已這個我們就不會再追溯了所以就是它會變得比較多你要多個parity自然就浪費比較多空間但是目的就是你可以去解決Multidisk value的問題

那你可以去查還有 RAID 7、8、9 更多，但實際上應用比較少人會這麼做啦，因為你這個去算就知道它的 rewrite performance 都不會太好然後你浪費了不少的空間所以除非你的資料真的真的這麼重要不然比較不會去採用這麼複雜的方式好！最後一個Hybrid，那 Hybrid 簡單來講就是把不同的 RAID把它的概念把它拼在一起

那當然我們後面介紹的那些Parity啊等等通常都太複雜沒有必要在那邊做Hybrid所以Hybrid通常指的就是最多常見就是0跟1的結合簡單來講你會發現有0加1或1加0也就是你先做0還是先做1的差別而已所以如果是0加1的意思就是你先做Rate的0也就是Striping嘛 對不對做完之後再做合理卡所以你有4顆硬碟你會先做Locally的做Striping

然後呢再做 Radica 的動作那 RAID 1 加 0 就是反過來所以你有一個資料的話你會先做 Copy對不對所以 1 都會在這 A2 都在那邊Copy 完之後你再做 Striping所以就是 A1 A2 A3 A4這兩個看起來好像長得完完全全一模一樣對不對很 Detail 的話如果你去看還有一個小差別就是通常呢 RAID 1 加 0

它读出来资料fail的几率会比较小为什么呢因为当我们说零加一的时候这其实有hierarchy的意思是这边有一个rate controller所以其实这有一个controller它会先去判断资料读取的正确性与否那这有ready卡嘛所以如果今天这个掉了其实这个controller没有问题它就直接拿这个备份就好所以它就会先detect先fix这个arrow

那所以到了上面這層的時候其實arrow已經在這一層解決掉了如果是這一個大家可以看到這個controller他讀的資料當初上面的人說你要幫我讀對不對比如說你要幫我A1 A2他讀A3 A4那他讀A1 A2的時候他可能發現哇A2壞掉那A2壞掉他就讀不出來啊讀不出來他可能就直接report arrow那上面的controller才會再去跟這個controller說你幫我把A2讀出來所以來來回回

就會比較多溝通對不對所以就會delay會比較多一點所以這兩個detail來講是有差別的其實這一個通常會好一些因為他locally就先可以解決value的問題這個你可能需要跨controller之間溝通同步之後他才知道怎麼去解決不過擺法上當然很明顯你可以看見是不一樣的實際上執行上你要考慮

到哪些Controller在裡面它執行的順序的問題有興趣你想要仔細再看一看的話其實這邊有這個資料所以這就conclude第12章所以今天講兩個滿重要的一個是disk scheduling另外一個是RAID所以RAID 0到5大家一定要清楚到底是什麼因為這其實是非常實用常用的大家去店裡面應該都會看見RAID你就知道了到底他會都會跟你講說你買這個RA ID可以configure成RAID014還是他support哪些RAID值得就是這個事情所以不只是你插幾顆硬碟上去重點是你用哪一種方式去使用這些硬碟去增加它的效能跟解決你資料的可靠度的問題.