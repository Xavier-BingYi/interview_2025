undefined
那接下來我們就進入這個這張其實很重要的就是Page的Replacement Algorithm所以我們之前看到的就是當一個Page4產生你需要去找到一個Free的Frame可以把它放進去但是有可能你找不到啊對不對所有都被人家贊助了所以這個時候你就要多做一件事就是replacement那replace是誰這個就是我們這個algorithm的目的那這個algorithm

的設計對於一個電腦系統的效能影響很大因為你的algorithm的好壞就會決定你page4產生的次數對不對一個等一下就要使用的page如果你把它立刻剔出去的話你把它replace掉那他等下又要用他又要replace回來這就是一個disk access那所以他會嚴重的影響他就是決定你的page 4的次數或是page 4 rate那有page 4大家知道他對效能影響很大對不對

他非常非常的慢所以這個replacement的argument其實是很重要的一環好所以就剛才講過了嘛這個什麼時候去replace就是當我們沒有free frame的時候那有兩種solution第一個是很極端的對不對就是我說我就把整個process把它swap掉比如說我們說的midterm schedule er對不對或是我們的swapper那時候兩名詞基本上就是你可以把整個

process挑一個目前沒有在使用的process那你就把它整個swap到disk上去，但那個程式就完全不能動了，因為它整個就會離開我們的CPU的scheduler的queue所以這實際不是一個很好的方式，所以我們說OS都喜歡比較fine grade 對不對，可以有啦 當然這個還是有，但它更常使用的只是在page level那page level這個pager，它就在做replacement那

它不需要把它不用挑process它只要挑page就好哪一個page看它目前沒用的把它給swap到disk去，因為我們知道一個程式有很多page都沒有用所以實際是比較容易找到的那既然它在被swap到這個disk去的話有一件很重要的就是就有點像剛剛的memory map file它還蠻像的意思就是說當你要把一個memory content它把它swap到disk去的時候

實際我們等一下會講所有的memory content一開始並不在memory實在是disk我們這種disk把它load到memory對不對，所以我們當swap的是把它從memory再踢回到disk所以說通常這些Page呢實際是在 Disk上本來就有一份Copy在那裡那只是說它要用的時候我們把它漏到Memory不要用的時候我們把它存回去而已那很多

時候呢這些Memory的Content是根本沒改的嘛它就只是Read而已嘛對不對像Library Read Only而已啊對不對所以這些Content很多時候都是根本沒有被修改到的那如果沒有修改到你把它踢回去的時候你把它重新copy一次那就很浪費時間對不對所以說我們每個Page為了在Virtual Memory這個機制下Paging的機制下讓它更有效率其實我們每個Page Table裡面的Page會再多一個bit非常重要的bit叫做30 bit這個30 bit的意思就是說

這個Memory的Page弄在Memory弄到Memory之後它有沒有被修改過有修改過它才會把它設成1然後每次漏進來那個都是零嘛就是當然沒修改原始狀態嘛跟硬碟上的是一樣的content但你只要一做修改OS當然知道所以它就可以把這bit把它設起來所以當這個page呢要把它踢到disk去swap到disk的時候我們的OS就可以去檢查這個bit如果這個bit它沒有被設起來代表它從來沒被修改過那就不要理它嘛

Zero掉就好就剛才說的Zero掉然後就換別人Override下去就好對不對只有當這個bit被設起來的時候代表它有被修改了其中四個tab裡面的某一個byte有修改我也不知道是哪一個但是有修改那我只好把它整個再寫到硬碟去至少會比較快一些了所以會有這個30 bit的存在幫助我們OS去減少Disk IO的時間還有資料量所以

本來的話是一個Pageform是其實是不只要把Page讀出來還要有一個要寫回去那至少用了30bit的話你就不用寫回去了對不對所以這資料時間就已經減半了好那所以這個是大家知道的這是還滿重要的這個滿重要就是知道有一個30bit的存在其實可以盡量去減少我們這個Pageform處理的時間

那要去做這個replacement其實一共我們之後會探討兩個問題第一個問題是到底每一個process我應該給他多少個frame因為我們很多process所以我們不夠的時候我們到底要怎麼去給每一個process的frame的數量這個叫做所謂的frame allocation algorithm所以你要先決定每個人有多少frame的位置可以使用第二個呢還是說那因

為我不可能一個process可能要其實可能要100個frame但是我這一邊的機制可能就決定你只能只有10個因為你不需要把整個程式漏到memory對不對那這是第一個部分那第二個部分就是在那10個裡面因為你要去用嘛對不對所以當然你拿10個對不對那就是要去replace所以這就是所謂的replacement的部分

那我們會先講這個然後再講friend allocation所以我們就先focus在單一一支程式就好或者說只要focus在說到底是哪一個page要被提出去這件事情就好那不必太刻意在乎它到底是同一個process或是不同process好這有一點重複了不過大概大家簡單看過就好對不對所以replacement的話它的這個step當然就是第一個就要先去找到我到底要access的會產生造成page4的那個page在我們disk的什麼位置然後呢我們想把它swap過來所以會先去找我們的

free frame的list看看裡面是不是有空的有就先用再說那如果沒有的話那我們就會去call replacement algorithm然後去找我們在physical memory上的某一個frame當作我們的victim就是受害者然後把它做swap的動作然後當然就之前講過啦對啊當然漏進去之後你就要去update page table然後重新再執行這個instruction所以這邊寫process應該說restart process instruction就是只有那個instruction而已啦所以其實跟剛才之前都一樣就是多一個replace的動作嘛好

那所以這跟之前一樣啦 對不對所以同樣的動作嘛 對不對先是先去看一下你的這個到底原案的Page在哪裡然後再去做Swap的動作這個一樣啦所以大家不必其實扛讚再去看就好了好那所以我們接下來就要講Occursion這個Replacement Occursion到底是怎麼被Formulate成一個數學的問題然後怎麼樣有哪一些常見的演算法

那這個Operation的Goal很明確減少Page4的Rate或者說減少Page4的次數當然對不對那它的Input是什麼勒你要去Evaluate這一個Page4這個PageNow這個ReplacementOperation勒它的Input就是一個Reference String也就是一堆這個是這個Page的ID所以這個是我每一個程式在執行過程中它會去Access不同Memory的位置對不對

那因為我們是在page的replacement所以其實我們不care它到底是哪一個明確的byte address我們只care就是它在 access第幾個page對不對因為反正同一個頁它雖然不同位置我們沒有差嘛都是代表它都可以讀得到所以我們的input這邊1234125這就是你讀第一個頁第二個然後34第一個頁第二個第五所以就是一個我們的input好

所以我們等一下會勾數這些其實都算是滿基本的argorithm那其實有很多的研究在propose比較advanced比較複雜甚至有一些theory或者based on一些可能historical的data去設計很複雜的argorithm目的都是要減少Page4的次數但其實我們這邊重點是要concept所以其實大家勾數這些基本的argorithm應該就有這個concept了那所以我們就會這樣像FIFO大家可以想一想first in first out對不對

所以其實很多是非常straight forward的那裡頭最重要的一個勒又是這個LRU我們之後會介紹的這個是一般的諸位系統一般的系統都會使用的一個非常常見的agreement所以大家一定要知道好那我們就先從這個first in first out來去看那這個replacement algorithm這個問題咧就像剛才說的你需要的input就是一個這些page的reference

的這些位置對不對第二個咧你會需要的就是我的physical memory上到底有多少個frame也就這種physical memory的size嘛對不對那這邊我們當然是簡單例子所以我們當然就設一個很小很小的方便大家來看所以這邊意思就是我的physical memory我假設有三個frame的slot然後我的程式咧有多少個pages其實我不care我只care就是哪些是有被access的也就是全部都寫在我們的這個reference string裡面了嘛對不對

那first in first out或這些accurate的目的就是要決定我們到底是哪些pages要留在這個frame裡面然後當然你現在被access的那個page一定要放在frame因為他是現在要被access的嘛所以一定要處理完page4他當然要放在裡頭可是重點是其他這些位置要留給誰或者說我要踢掉一個人的時候是踢掉這些人

裡面的哪一個那我們例子通常都是簡單就是從全部都空的開始這個run起來因為前面發生什麼事我們也不知道所以假設一開始這全部都是memory空的然後開始執行這個程式了那它要的是Page1所以當然我們就把Page1放進去它有位置所以我們也不用Replace就直接放這個放進去就可

以了有一點很重要的這邊呢三個位置的順序不重要不要忘記Paging我們根本不care只要它有一個位置就好所以我這邊E我要寫在這也好寫在這也好無所謂只是方便了解這個Opposition所以我們把它寫在第一個位置然後你可以想見為了去免騙這個FIFO的這個Q所以我們會有一個header的pointer跟tail。所以如果你要implement的話你就可以想見你就是operate on這些pointer就可以很快的去implement這個algorithm那1紅色這個1呢就代表一個page4。所以我們的

目的就是要去算說這個algorithm在這個input跟這樣子數量的frame的下面它會產生幾個page4的次數越少越好然後是哪幾個Memory的Access會產生Page 4所以這邊就寫的意思就是我們現在知道Page 4產生一次了所以就是有一個E在這裡那第一次的Memory的Access你會發現它一定是Page 4啦這個跑不掉 對不對。那這個例子我們當然是縮小啦所以你會看見Page 4很多。但實際上我們說過通常是有Locality嘛所以你其實一排可能你有先一萬個E再一萬個R

然後frame的數量當然也是可能十萬個而不是現在的三個好那接下來呢第一個是放進去嘛所以第二個呢因為是FIFO，所以你可以想見我們其實Informant的概念就是會把它往下推推到下面tail就再見了對不對，因為是First In First Out所以不夠的時候我們就會把它第一個進來的踢掉，FIFO嘛所以我們2，我們就會把它寫到這裡然後1往下推，

所以這樣的寫只是為了讓大家容易理解實作的時候，你去implement有時候用一個queue應該也會長這樣子好，那2，它雖然也被放進去了，但是一樣它是第一次access，所以它是一個Page 43，所以當然所以前三個沒什麼好講其實就是這樣一序全部page4然後會因為我們在用一個fightful的queue在maintain，所以是32 fourteen來了這個時候就要replace了對不對，所以4來的時候

呢，我們要replace誰，因為這都滿了嘛，那根據FIFO的定義，所以我們就會繼續推，所以很顯然E就不見了對不對，所以被replace的人就是E，所以這個algorithm就會告訴我們E要被replace掉，那，但它這還是一個Page 4，所以你會看見前面四個月都是第一次access所以很不幸就是其實任何的演算法都救不了這個其實就是

一定會造成的一個fault那很重要的一點是我們剛才說順序不重要所以我們這邊這樣畫好像說怎麼好像我這個page從這個位置移到這個位置是不是我們memory一直在那邊做bind沒有 這個只是beta structure實際上這個3如果擺在我們frame的第四個位置譬如說任何一個n的這個位置的話它一直都留在那裡

這個只是一個queue讓我們去知道誰要被replace而已所以這是只是這個maintenance的queue去manage的data structure所以這個位置不代表實際上那個frame的位置它只是佔了一個frame而已好所以接下來E又來了對不對所以你看這就是一個不好的argument我才把E踢掉結果E就來所以它又很不幸的又是一個page 4所以就E43對不對

那再來後面大家其實可以知道對不對所以就是FIFO algorithm所以2進來一樣很不幸就是它又產生一個Page4對不對5又產生可是這時候1進來就會是一個Hit但是FIFO所以FIFO代表它是當初是最早進來的所以我不會移動它的位置很不幸的它仍然會是下一個被踢掉的人所以2進來是一個Hit3進來之後我們就會把它往下推所以1這時候

還是會是第一個被提出去的雖然說才在前面兩個SS但因為是5 for所以沒問題，所以大家就這樣go through，所以這就是我們這邊寫就是它的這個reference string然後寫我們就把它放進來放進來那最後我們就來數有幾個紅色幾個黑色這個就是你的for rate那當然string的數量一樣所以其實答案就是幾個fort會產生出來所以9個這是5 for會造成的結果

那看完剛才這個做法你一定會知道這是一個不太好的很明顯應該可以把這個數字再往下減所以我們就直接先介紹這個會造成這個FIFO除了它的FOR會比較高之外它還有另外一個很大的問題是有所謂的一個anonymy就是一個不正常的狀況這個狀況那這個現象其中一個是Blady這個Researcher 他發現的所以有一個名字這個不用背反正就是一個 Anonymy重點是 Anonymy 是什麼呢就是當我今天增加我的 frame 的數量也就是增加我的 resource

的時候你一定會想說我的 page 4 rate 會降低對不對因為越多 resource 我的電腦會跑越快所有事情都會變得更好沒有道理不好那這個 Anonymy 就是指說我增加 resource也就是在這邊 case 就是增加我的 frame 數量可是我的 page 4 居然沒有減少甚至於有的時候它還會增加這是有可能的因為就像我們剛剛完全一樣的例子我們只是把 frame 的數量從 3 變 4再跑一次那個 algorithm完全一樣的 algorithm

自己跑就好了所以 go through 這些例子大家也可以順便練習一下 FIFO 怎麼 run你就會發現它的 page 4 的次數變成 10 個剛剛是 9 個 現在是 10 個所以這是一個非常不理想跟我們預期相違背的一個狀況所以我們稱之為anonymy那這個現象在FIFO你可以很明顯看見這個aggression就是有可能會產

生那這個產生就是剛才說的越多的你給它越多的frame它有可能不是說always啦但是就是有可能因為我們這邊就證明了嘛可能它會產生更多的page form那畫出來的結果就是像這邊這樣子如果我們想說任何的一個input string然後這邊是number of frame這邊是你的page 4的次數它應該是要至少是non-increasing持平然後又不斷地下降但是你只要會產生這種不是non-increasing的那基本上它就會就是所謂的這個anonym就是它居然會有增加的狀況

那這個問題其實對於我們電腦系統的設計人來講是一個很討厭的事情因為我們系統的設計一大堆的參數就像說我到底要多少個Frame對不對這是一個系統參數那或者我要給它多少Memory我要給它多少CPU的這些速度等等大家都是背上一個Sumption就是我給你越多資源它會越好然後再來大家調嘛在那邊Tune看看最好的設定是什麼就是成本跟效能的Tradeoff但是如果呢你會有這樣的

這個Anonymy產生就代表我今天花越多錢我買更多的Memory我插更多Memory star下去結果電腦跑越慢那基本上就很難去調整一個電腦系統所以這是很不理想的一個Behaviour一個特性所以FIFO的問題其實是兩個層面第一個是當然它的Pageform不是減少了很多有可能就是會做出錯誤的決定但這是機率問題大家

更討厭的是這個現象因為代表我不知道怎麼樣去調整這台電腦系統就是它不會follow我們一般的概念就是增加越多Result它會跑越快的這件事情所以大家不喜歡FIFO或者說FIFO的這個就會很嚴重的一個concern那我們講完這個基本的我們先休息十分鐘回來我們來講直接跳到optimal的其實最好optimal的argument比你想的會簡單其實它是很隨波波就可以找到最好的argument是什麼.