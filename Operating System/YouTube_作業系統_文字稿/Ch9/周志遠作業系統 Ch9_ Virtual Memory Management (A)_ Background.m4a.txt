undefined
第九章Virtual Memory我們整個課程不斷不斷好幾次都提到Virtual Memory對不對因為Memory的管理其實不是像我們第八章這樣子只是真的在使用Memory而已其實我們說會使用到硬碟所以會有這個Virtual Memory的這個非常重要的一個機制。在那邊，那一開始我們當然會簡單介紹一下什麼是Virtual Memory。那我們也學過了Paging對不對，就是用Page的方式管理Memory。那有了Virtual Memory之後，你會看見有所謂的Demand Paging。那我們大家會介紹就是在Virtual Memory下做Paging，我們就稱有一個方式，我叫做Demand Paging。那

之前呢，其實我們也介紹過Fork Process，那個章節對不对。然後，那時候有提過，實際Process的Creation，其實就是在做Memory Allocation所以這邊，我們會講一些這個部分跟Memory的管理有關係的這個機制。那重要的，這一個章節比較重要，就我們剛才說的Page Replacement的Argorithm。所以這邊會有一個很簡單的Argorithm，所以會需要大家知道另外一個非

常非常重要的是Threshing Trashin是一個非常特別的現象就是當你開了越多的Process之後你的CPU的使用率居然是往下降那這其實跟Virtual Memory這個機制的使用是息息相關的所以其實Virtual Memory也是會帶來一些很大的效能和執行時間上的影響那我們要避免的就是所謂的Trashin所以這個會非常重要我們會解釋什麼是Trashin

那OS用什麼樣子一個基本的方式可以去避免這件事情好那我們就開始Virtual Memory的話就跟Memory管理其實是差不多的對不對就是我們知道Memory管理是相當重要的而且其實我們並不希望把所有的一個Process的Memory content在一開始就把它整個放到我們的Memory裡面所以前面的章節我們介紹過Dynamic Linking的概念或

是Dynamic Loading的這種做法可以減少一些Memory的使用我們這個章節會看見就是透過Virtual Memory的方式更是aggressively的去節省我們Memory裡面放的東西或是說放的東西要能夠更有意義那所以Again嘛 同樣的道理就是為什麼我們其實對一個Process而言它不需要把所有的Memory Content都漏在Memory裡面或是放在Memory裡面因為我們昨天說過的 對很多的Arrow 還有很多的Function Code這些根本就用不到，所以之前我們介紹過這個Dynamic Loading那就是可以很有效解決這一個問題。

然後一樣嘛對不對很多function它是不是處理arrow，但是它因為有這個branch我們program就是一堆的這個copas跟branch所以說很多是用不到的對不對。然後sendlibrary對不对，所以我們直播知道用這個dynamic linking的方式可以解決這個問題，甚至於還有很多的Array跟這些VariableMemory這個使用者去Allocate的Memory可是從來沒用過像這個前面這三

個我們介紹過了透過Dynamic Loading跟Linking可以解決，但這個對不对像這個Case就還沒介紹過這個就可以透過Virtual Memory這個就是你 Allocate一個非常非常大的Array一萬個Element結果你不小心寫的多打幾個零就放在那對不對，所以就會造成很浪費這個Memory的使用，那這個就會我們會看見Virtual Memory就可以解決到更Low Level到這種程度就是你的這些Page如果沒有被Access到沒有用到我就可以不要放在Memory中 emory裡面所以是更進一步的、更General的方式去讓我們的Memory使用更有效率好，

所以一切的目的就是增加Memory的Utilization而且，這個Utilization請注意一下喔不是說我Memory放了多少東西這件事情，而是說我放進去的東西是真的有要被Access的所以是這個使用率不是只是空間的使用率，而是它被Access的這個次數要增加所以就有所謂的virtual memory那virtual memory跟virtual address或者說這個virtual address或者logical address這邊當然

是很像就是他們都是都是這個把我們的重點就是把physical address跟logical address切開來的機制之一所以我們在前一章已經看見了本來就是為了做paging或是segmentation我們就會有這種runtime的binding所以就把logical address跟physical address把它切開來了那既然切開來了就代表我們其實不一定要把一個使用者這些 memory addressmap 到一個 physical address甚至我們可以更進一步把它 map 到這個 disk

上面去對不對或者說我們其實放在哪裡使用者根本就不 care 對不對那所以這樣做的好處就是我們之前也有提過一些的對不對總結來講第一個就是你的 process 其實可以 run 非常非常大也就是說你的這個physical memory address或是空間或許只有16個Gigabyte好了但是我們logical的address卻可以超過因為其實bit多少數我們講過嘛這是一個mapping的問題對不對所以其實甚至於你的這個logical address它的space可以比physical address還大都可以也就是說你可以run一個

比实际上Memory还要大的Program都可以或许会变慢但是你是可以RAW的所以不会受限于你的Physical的Resource这件事情第二件事情就是可以增加我们CPU或者说是这些ResourceIO等等我们记得任何这个电脑资源的使用率原因就是因为我们会看见Virtual Memory它会把硬碟也当作Memory一部分所以你的整个Memory的空间就是可以变大

變大的好處並不是說只要給一個人你也可以變成給很多人越多的人對不對所以你可以給越多的人意思就是我們一開始介紹的Multiprogramming對不對Degree Multiprogramming我說這個很重要，你就可以放更多的Process在我們的假想的Memory裡面對不對，那越多的程式在Memory裡面我們知道就是你的Degree可以越高，所以你越有機會可以去有任何資源沒有人在使用

那你就可以找到一个需要使用那个资源的程式去使用它所以我们整个硬体的使用资源的使用率就可以提升。所以是为了，就是可以放进更多的这些processes那第三个就是因为我们把它切割了，你有logical的android space跟physical，所以你的programming变得很简单，尤其这边Programming应该讲的就是像Compiler这一层，所以Compiler它也在OS上面不要忘记。所以像我们看见的这个Address Binding我们介绍过了，如果你是Logical的话其实你在做Compiler的时候

你就只要管自己程式的Memory使用就好，你不care Physical Memory上到底有哪些位置被用或者是怎么样子。你可以针对像每个Segment去做Offset，所以說你的Programming就代表你只要管你自己的程式甚至於只要管你自己的那个function code或是那个segment然後去決定你的Memory的使用就好對不對，所以整個Programming會被簡化各位看不到Compiler現在幫你做這些事，但是其實Compiler的設計就因此大幅的就可以簡單化或是Linker這些好

再來還有一個好處就是你的Program可以跑得比較快。這個我們要介紹Virtual Memory，大家才會更清楚簡單來講就是在沒有Virtual Memory的情況下，你必須要把所有程式一次漏到Memory，所以你要花比較長的時間，因為你一個Program如果很大那你的Initialization的時間當然就會久，因為你要全部漏到Memory搬的時間就會久。但是，如果我們大家看見這個Virtual Memory裡面的所謂的Demand Paging的話，

它其實一開始什麼都不漏的，它只有你要用的它才把那個Page放到Memory裡面，所以它一次就只搬4KB，所以它的時間就會很快對不對，你一次就只需要4KB搬動就好，而不是一次要搬10個MB甚至於更大，所以它的這個執行時間也會比較快尤其是在一開始啟動這個Process的時間就是把它漏到Memory我們說

execution之前loader要load，所以那個時間會大幅的被縮短，所以這邊林林總總都在列了滿多的我們這边是说virt ual memory的好處所以其實它也包含了我們前一章教的virtual address所以virtual memory是更進一步它不只是virtual address而已它甚至於包括到了我們剛才說它使用到Disk的這個程度所以會看見它的好處跟第八章在介紹Virtual Address好處的時候

有重疊但它甚至於還更多了所以是這樣子這兩個關聯性是這樣那這個Virtual Memory我們下面就有一張圖來解釋Virtual Memory的這個做法又可以分成比較常見的就是所謂的Demand Paging我們等一下會講或者是Demand Segmentation因為我們知道Memory管理分成Paging跟Segmentation嘛對不對所以當我們說把Memory Content放到這個Disk的時候我們可以同樣的想法同樣的概念我們可以Implement是放一個Page為單位對不對

也可以是一個Segment為單位因為管理上就是這樣嘛對不對那通常我們見到的會是Paging而沒有Segmentation為什麼因為Segmentation它的大小不固定對不對所以當你在那邊對它做搬移你把它搬走然後再找到一個空洞把它搬回來的時候很困難有沒有我們還介紹過什麼Best fit啊Worst fit那個你都要花至少Suppose說是old n的時間Worst case啦對不對但是pagent因為它是fixed size所以它找到空位的時間是old 1

如果大家還記得的話就是我們很簡單的有一個free list就好對不對friend free list反正大家都一樣嘛有位子就可以用嘛所以他去找位子只要order one這需要order n所以大家通常都是implement在paging這個為單位來去把一個一個page放到我們的physical disk放到我們的disk上面去雖然我們可以做啦但是很難比較難做沒有效率

而且不要忘記電腦的管理其實是當我們兩個都存在的時候是segment在上頭segmentation在上頭然後再paging為什麼大家記一下這個以前也有問過為什麼上層是segmentation下層才是paging因為大家如果記得的話segmentation是以user的角度user program使用memory的角度去做切割的所以當然你寫了一個program你用這樣子的一個logical view去寫你的程式是比較容易的我們就說call segment heap stack那就是一個一個 segment對不對

所以很容易去比較容易去使用它，但是呢當你放到physical memory的時候呢，paging這種fixed size的比較容易去管理對於硬體使用上來講，就像我們剛才說，我要找一個空位，如果我用Pagent只要O的1這個卻要O的N，所以OS可以很快的幫你找空位或者是資源的使用，這個Memory的使用上，Pagent沒有External的Fragmentation然後Internal是KB所以蠻小的了，所以你也不會浪費，所以說Pagent對於Hardware而言資源的分配而言是比較容易管理的，

但是segment比較符合user programming的view，所以當我們兩個做這個技巧把它結合在一起的時候，是segment在paging而不是倒過來的，可以倒過來沒有人說不行，但是沒有人那樣做，因為沒有好處，所以這是滿重要的觀念，不是說只是它怎麼運作為什麼電腦要這樣去做設計，所以你會只看到我們這種Demand Paging這個東西，其

實是在Paging的Level，你就不用管Segmentation了，Segmentation是其實跟Compiler那邊比較會有關聯性而已，那所謂的這個Virtual Memory的概念對不對其實就像這邊看到的它其實蠻單純就是這邊大家學過了這邊是我們的Virtual Memory或是我們的Logical Address就是一堆Page對不對然後會有一個這個Page Table這邊叫做Memory Map反正就是一個Page Table你們也知

道其實它就是Page Table會把它Map到Physical Memory但是所謂的Virtual Memory就是再加一層對不對所以當我們發現OS發現有些Page它根本沒有被Access到很久沒被Access到的時候我們可以把它所謂的Swap把它T到Disk去就像這邊它要這邊然後存在我們的Disk上面去然後等到你要用的時候一個CPU的指令下來說我要Access那個位置的Memory的時候OSM只要它能夠發現原來它在Disk那我就可以把這個資料再把它搬回到我們的

Physical的Memory上然後就一切照常當作沒發生一樣然後繼續的去做Access所以基本概念就是這樣就可以把我們的Disk當作Memory的一部分但是要注意到Memory實際上Memory大小還是沒變喔而且這個用完了就是而且就是你如果CPU要Access的話你的Page還是要先回到Memory才能夠被Access並不是說CPU直接就 Access Disk是做不到的所以才會我們後面講的到底誰該被踢到Disk這件事就是後面會介紹到的replacement algorithm的這個部分所以要決定

你的選擇會非常重要因為選錯的話你就會不斷地在Memory跟Disk之間做搬移然後也這個回應之前大家有提醒過大家的這個動作雖然是從Disk搬到Memory這個不是low program那個東西對不對這個只是單純把Memory的content就是那些bytes它根本也不care裡面是什麼就是4KB的bytes我就把這個bytes把它copy到Memory就對了

是這麼單純的一個swapping的動作跟你說漏一個process你要create page tableprocess control process不一樣的行為我們後面當然還有例子在看到這件事所以這個是swapping所做的事情所以我們就來看先看大家各位第八章的時候講過的這個方式的話如果我們run一個program發生了這個事情就是compile完嘛你的binary code那邊是你的這個memory的content那當然這個memory我們假設就是這個只是virtual的address而已只是這個physical的 memory而已是physical memory不是virtual的memory好

誒，不對，這邊應該是page table，所以我講錯了齁，這一個是page，所以這個是virtual的address，好不好，這不是physical的，是virtual的，都是這個程式的。所以我們說run一個program，第一個你要先去load，load會initialize這個PCB，對不對，還有你們看見的，實不只是program counter跟register，實還有page table。好，誒，所以我剛剛剛翻，這才是齁，所以這是page table對不對所以對

應過去那個是physical的位置了好，那如果說這個開始跑程式的時候我們知道第一個要load code，所以如果在沒有virtual address沒有在virtual memory然後也沒有用我們所有的demand page給大家介紹的話很單純就是一開始我就把所有東西都load到我們的這個physical的memory裡面去，那如果我們memory不夠或是說這個process很久沒跑的話

我們可能就會把所有東西一次踢到硬碟裡面去然後就整個就是以process為單位然後做swapping這是比較簡單的做法是這樣子，所以我們知道你漏完之後接下來就是開始執行嘛，那不外乎就是透過你的page table對不對然後找到你physical address然後去做access這是一個簡單的例子所以這邊一個page你可以看見我

們只放了一個instruction就是你就想成一個page只有4個byte吧實際上不是這樣啦這是一個示意圖嘛，所以做translation之後你就可以慢慢的去go through這些address對不对那甚至於你會看到這邊會跳出來就是說也有可能對不对你在 wrong time 才去 dynamically allocate 一些 memory所以這種時候大家也知道第八章教過了就是你會直接就修改 page table然後去把它先做 allocation

完之後才把資料放過去，所以它這個甚至於會增長那甚至於也就是我們之前說過的不是說都會很好的這樣依序用下來有時候會中間會空掉因為有segment在前面嘛對不对所以其實大家也是散落的並沒有說你一定是issue這樣子使用，所以你也會需要知道哪些是valid哪些是invalid的好，所以這是你們之前教過的，所以這只是issue的你就可以執行完然後最後結束你就會把memory還有process這些table等等把它free掉.