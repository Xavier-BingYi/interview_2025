undefined
接下來呢我們就要進入我們之前說的第二個問題了，所以剛剛我們都在介紹的是Page replacement algorithm針對一個Process他要把他的哪些Page給踢掉的事情那接下來我們就要考慮CroisProcess 對不對所以其實所有的process都要去share我們的physical的memory不是只有一個人就可以賭占的所以到底每一個process應該拿到多少的frame這個

問題而且很重要的是拿太少會發生什麼問題那首先第一個大家就要先知道最少其實一個程式他要去能夠執行他通常會有一個最少需要的frame的數量那這邊有一個非常極端的例子在這台機器上他去執行一個instruction而已他最少worst case最少需要用到的frame數量是6個只是一個instruction他就要touch到6個frame如果你運氣不好的話最糟的情況下有可能需要6個也就是說你的OS如果不能夠保證這個程式至少有6個frame的話他根本跑不起來

因為他缺一個他就沒辦法跑他要同時access這六個frame上的資料他才能夠完成這個instruction所以你就知道這個minimum frame的數量這個事情其實還蠻重要的為什麼要六個我們就來看一下，這是很早期的一個IBM的機器，我覺得是IBM吧。首先，第一個它是一個很複雜的instruction，所以它一個instruction。你可以看見是46個bit，也

就是說它就已經是超過了4個byte的事實上，就是已經到6個byte的程度所以第一件事情光去fetch這個instruction它就有可能會跨了兩個frame對吧。因為如果很倒楣，它在兩個page的中間放了那個instruction，所以它可能被切到兩個page上面去所以這兩個page都必須要在我memory所以你就至少要兩個frame再來呢這個instruction非

常的powerful，所以它是一個move的動作也就是只在做memory copy，在搬移的動作那它搬移的方式是，你會去告訴它的base address，也就是說它可以從你的user的這些memory space，就是你的memory的content，任何一個base開始然後指定它的距離，也就是說可能說第10個byte開始然後我要搬52個byte，就是一個length就對了搬到的位置也是一

樣，所以它非常坦盡它可以搬到另外一個base address然後呢，它一樣是有一個長度的所以意思就是說它可以搬它一次這一個instruction它非常power它可以搬很大量的資料而且在memory是直接對搬你知道有些CPU instruction它可能只能從memory搬到register然後register搬回memory但這台機器它是support這個instruction它直接可以memory memory的對卡那

這麼powerful的問題就是你看見剛剛你用到兩個frame那如果運氣很不好對不對我的base是在一個frame一個page裡面我的長度也不用太長啊其實如果6個byte 8個byte你就又會超過了對不對然後你搬到的地方又是超過對不對所以這可能就兩個page兩個page我們這個例子只有5個所以我們應該shift一下我們應該改一下

这应该是两个对不对然后这个是两个一二三四五六对不对所以这边有一条杠所以这是两个page两个page两个page六个page对吧所以只是一个例子大家可以看见就是非常复杂的刷新常常会增加我们computer的设计就是这样所以像这个case它就一次就六个page所以我们至少就要有六个frame空出来才能够执行这个刷新可以吗

所以這只是讓大家知道其實執行一個刷新你可能就要用到不少個frame的位置了即使一個frame是很大的可是還是很容易會有這種狀況不過通常的話當然不會到那麼誇張可是你說四個或者是兩個到四個之間的這個frame也是一定會需要的那所以frame allocation的目的就是在決定每個process我到底該給他多少的frame那有兩大類型的allocation第一個

叫做 fixed allocation意思就是說固定根據這個process它的一開始的information我就決定要給他多少frame跟long time無關的稱之為fixed這個稍微知道就好因為這個只是很基本的就是例子而已所以像equal就像譬如說我們反正有100個frame一個process嘛那當然就是平分對不對或是proportional每個process的我可以知道事先知道他的memory的size

啊load我的program其實我不一定真的load進去physical memory但我可以其實知道他到底要多少那就proportional to你未來可能會要用的嘛但重點就是run之前就決定那另外一種咧就叫做 priority所以Priority的意思就是我可能在wrong time的時候我才去做這個決定然後會根據我的每一個Process的Priority因為Pro CESS其實是可以，通常都會有Priority各位在作業3 Scheduling也會看見就是或是大家直接去你可以去Top在我們的Linux的System，如果你按Top會列出所有Process，其實前面都會跟你講它的Priority是多少，

不過簡單來講就是說它會根據Priority，Priority高的通常是比較重要的可能要先跑或是要跑比較快，所以我們就給它比較多的Size，那這個Priority，你可以Round Time可以調根據很多的因素，比如說它是已經Round了很久了，我可能就可以把它的Priority降低，直霸佔了我們的CPU跟Memory，所以，但重點就是說你是Based on這個Priority，那這個Priority可能是在Round Time可以再做調整，這是另外一大類型

然後呢，這個Allocation，我們在給它多少個Frame的時候，我們又可以從剛才是從它是Static或者是事先固定的或者是動態的來去區隔，另外一個角度我們是以所謂的Local跟Global來做區隔，所以只是不同的Classification對這些Allocation的方式所謂的Local的意思就是說今天如果我需要一個Process，它要去Replace它去做Page Replacement的話他只能

夠替換掉他自己的Page也就是通常這會跟Static就是剛才的Fix綁在一起啦就每個人都是固定嘛所以你如果需要這個Frame的話你也只能用你自己的所以就是剛才說的一個人要100可是我只給你10個位置那就很抱歉自己去搶那10個位置就是這個Process就只能用10個所以這種通常就是Local就是跟Fix是綁在一起的

好 那另外一個咧大家通常會用的可以想見就是GlobalLocal一定不好或Fix不好因為你事前一定不知道它的行為嘛那程式的行為通常變異性很高所以通常效果都會很差所以另外一個就是GlobalGlobal意思就是說我不會限制你要用自己的跟上面相對的嘛所以簡單來講就是我今天要去挑一個我的Victim的這個Page的時候我可以從任何一個

所以任何一個程式的Page只要不用我就可以把它做替換這就是俗稱的Global然後這種通常就是因為跟Priority的這種Based Allocation綁在一起所以Priority可能會Runtime會改變然後它只要Priority高的人它就可以一直去搶Priority低的人的Frame然後用這樣的方式達到整個系統的最佳的效能好 那但是呢這樣的做法

會有一個很大的問題就是你如果一直去搶別人那最小的那個人有可能就像我們剛剛看到他連六個friend都沒有那這就完蛋了對不對所以通常這樣也會造成一個問題就是他都會有一個minimum的限制，更重要的是，我們接下來要講的這個trashing的現象也就是當你的這個friend數量很少的時候或許你可以跑你的instruction，但是他會跑得非常非常的慢慢到

就是整個系統效能都會CPU都沒辦法使用的程度，這個現象叫做Trashing。所以我們等一下會主要重點的是這個東西好，所以剛剛的Global這個frame的location這只是大家稍微知道就好對不對，所以當然你可以去做這樣的區隔啦，所以一般的一定都是用Global然後加Priority，但是呢它要解決我們接下來要介紹的這個Trashing的這個

問題，所以什麼是這個StractionNetStractionNet，它的意思呢，其實就是你可以看見所謂的Straction，就是說因為我們有這個Page4的產生對不對，所以當我的這個Page不在我們的Memory的時候，我就要去AccessDisk，那AccessDisk是很慢的，我们剛才說過了，所以代表我們可以的是我們的CPU它沒有在你Page把它Swap到 Memory之前它是不能動的因為我現在執行某Instruction這Instruction需要這個Page我必須要把這個Page搬到Memory之後我的CPU才可以繼續執行這個Instruction所以等於是我們的

CPU必須要去等待我們的Io完成它是完全沒辦法Overlap在Page 4的處理的時候不像其他使用者程式你可以Overlap CPU跟Io對不對但是因為Page4是產生在Instruction的執行所以是沒有辦法去做Overlap它一定要等所以所謂的Tracking就是當你的Page4非常頻繁在發生的時候你就會有

非常多的IO那就造成我們的CPU的使用率會造成這樣一個奇怪的現象也就是說我們到之前為止我們一直在教大家就是我們Degree of Multi-Programming要越多越好對不對 可以overlap CPU跟IO嘛這也是事實所以OS通常會喜歡一直增加你的degree of multi programming只要我們的memory可以塞得下只要有程式但是這樣子一直增加的結果咧大家分到的frame數量是不是一直減少那frame的數量一直減少你的page for rate就會開始增加啦對不對

因為我的很容易就會跳出我剛剛在Access的那個page嘛， 對不對，所以一跳出去之後就開始做IO，然後我們的CPU在等IO，所以我們的CPU會開始挨抖，就整個掉下去了，且是會很嚴重的很迅速的掉下去。我們等一下會講這個每一個步驟為什麼會這樣子，但是一直增加Diffusal Multi-Programming，然後最後造成我們的CPU變成很低落的情況就是我們俗稱的Thrashing，那這個的問題就在我們的Frame Allocation沒做好造成的一個結果。

所以什麼是 Trashing 它的定義就是非常簡單，就是一句話：意思就是說我們的系統花在 Paging 的時間超過 Execution，所謂 Execution 就是 Execute User 的 Instruction，那 Paging 其實就是 I/O。 在做 Paging 的 Swapping所以只要我們的電腦系統在做 Paging 的時間超過了 Execution 的時候我們就稱之為它現在在 Trashing而且你一定會觀察到的就是它的 CPU 開始嚴重的往下掉雖然你的 Degree of Multiprogramming

是很高的所以這是一個很重要的一個現象那我們就來看一下為什麼會掉這麼快因為其實你可能會覺得那可能就慢慢掉可是事實上大家觀察到它是一個極速往下掉的現象也就是它開始進入一個惡性循環那為什麼會惡性循環我們就仔細來看一下所以假設一開始產生一些PageFour嘛 對不對

畢竟PageFour本來就會發生 對不對那隨著你的Degree of Multi-Program一直增加這個PageFour的機率就會一直往上升那問題是呢當PageFour產生的時候我們剛才說它會產生IO的動作 對不對所以這時候呢我們的CPU就會開始做Idle 對不對所以使用率就會往下掉那我們的OS自以為很聰明早期的電腦就是這樣

他一看到 CPU 往下掉他就會認為我沒做好我的工作我的 degree of multi-programming 太低了所以怎麼不用我的 CPU 是我的問題所以他就會增加 degree of multi-programming也就是說他會讓更多的 process 進入到 ready queue那增加 degree of multi-programming希望讓我們的 CPU 跟 IOK overlap那一增加我們剛才學過了增加之後這些Process它就需要Fr

ame它才能夠Run所以這些會需要更多的Frame可是本來會產生Page4就是因為Frame不夠那你今天又增加更多的Process這些Process就會去跟原來那些Process競爭Frame每一個人的Frame數量就會更少，所以更少的結果就是Page4更多很多的結果就是IO更長就變成一個惡性循環。大家可以看見對不對所以這邊已經回步到了第一個step了對不对，

所以到了這個Page4增加IO增加CPU又會Drop更兇Drop更兇的OS又會更aggressive的增加Degree of multi-programming然後就一直惡性循環。所以才會大家看見它像一個cliff一樣通常的行為是直接就掉下去了，它不是慢慢的減少而是會是這樣的一直進入一個repeat的動作然後造成最後IO的時間遠遠大於CPU然後沒辦法overlap兩個世

界，所以這就是trash為什麼會發生然後這個發生之後其實通常嚴重性是非常大的它不是只是減少10%或20%它通常就會開始整個系統就不會動了。所以怎麼解決這個問題呢？關鍵就是我們要控制正確的frame的數量或者說degree of multiprogramming因為大家只要增加degree你就要share嘛對不对然後你才會看大家可以share到多少，所以這兩個是息息相關的。那解決thrashing我們就會介紹兩個solution一個叫做walking set一個叫做page 4 frequency那我們就來介紹這兩個solution

電腦到底是怎麼去解決這個我們現在的OS通常是怎麼去解決這個問題也就是怎麼樣去決定正確的degree of multiprogramming好那working set它其實就是follow locality我一直看到memory就是locality所以working set的概念就是從locality的角度開始去思考的那它的概念就是我們給一段時間比如說十分鐘吧或者是你要一分鐘也可以就是一個time period

那因為有locality所以在那段時間內其實我們可以去算他到底用了多少個pages對不对对一个process而言所以他到底在這段時間內他用了多少個pages那他用的數量就是我們要給他的friend的數量我們給他多了他也不會去用他對不对給他少了就代表在這段時間內你可能就會產生page4所以如果能夠剛剛好match這是最理想的

那當然隨著時間為什麼跟時間有關係因為隨著時間你的Access Pattern會改變嘛所以你的數量就會改變當然OS就要Key Track這個變化好那所以剛才說的為什麼要Key Track因為其實我們的程式有Locality但是這種Locality會改變它會通常會先Access這個Array然後再到下一個Array然後到了一個Function Code它的Behaviour就完全改變所以我們的OS就是

tricky 的地方就在於他必須要一直去找這個 locality所以這個其實是跟時間是有關聯性的因為就是我們有 function code然後我們在 access 這些 data structure所以 locality 會隨時間改變好所以 working set model 就像剛才說的它的使用的方式就是第一個它會定義一個 time window所以就是我觀察多少時間一個 delta 可能一分鐘或十分鐘然後第二個

就是我觀察這段時間內我要去數它的walking set的size也就是這段時間內我到底有多少個pages那如果能夠把每一支程式的size都把它算出來那我就按照這個去分配那如果真的還不夠當然你可以想見就是可能proportional之類的那至少你可以讓它的使用是達到最有效的程度所以看圖就好就比較容易了

所以雖然說實際上他可能是時間但是只做這樣的時候通常可能為了簡單我們其實只care就是順序所以說是時間啦可是其實很多時候可能就是數count而已就是多少個memory access當然他們有重複的嘛所以可能看過去的100個或這邊例子就是10個所以我今天給你一個reference tree然後系統一直在跑那我就一直保留著過去10個的記錄然後我們就來數

所以這個Delta 10就是這個Window那像這邊你可以看見過去10個它出現的Page就是1 2 5 6 7就是5個而已就代表它的Size所以這個S代表是SizeWalking Set的Size就是5個而已所以這個Walking Set的Size就是5那隨著時間你可以看見像這邊進到另外一個Locality你不只是Page的這個值可能不一樣不同的位置而且重點是它的Size會不一樣所以有時候會變5它會變2

所以我們的OS就要隨時去觀察然後設定到最適合的一個值這個就是所謂的Working Set把它寫成Aggregate或是Program稍微複雜一點但是就剛剛的這個Concept也就是說第一個我們會定義WSS就是Working Set的Size這是我們最後想要找到的東西然後每一個Process會不同不要忘記我們現在在做Pro

cess之間的Frame Allocation所以我們重點是要找到每一個Process它的Size是多少那把它全部加總當然就是我們的Total的需要的Frame的數量啦對不對然後所有的程式很順利的去運作然後完全沒有Page4的話就是要達到這個D的這個值嘛對不對那這個值這是他想要的可是我們實際上的勒就是這個小M

也就是我們真的available的frame的數量這是comp physical memory的size所以在執行的過程中OS假設像剛剛的做法他可以知道每一個人的size他就可以算出大低然後他就可以跟他們physical的size去比那就是幾個frame去比那如果比較多OS就可以知道我現在產生trashing的危險了對不對因為有人會開始產生page4而且如果是

遠大於或大於很多就可能會嚴重的threshold好那所以基本上我們OS的control就是當它大於的時候因為它就會覺得有threshold你可以有些threshold啦什麼ε之類的等於它發現了會有這個狀況的時候它就會去suspend process它可能就把priority最低的process把它suspend掉了把它整個就swap到disc所以這時候就會meet turn scheduler對不对把整個process把它suspect清出來然後讓剩下的人對不对所以你這邊子彈就往下掉嘛所以你就會讓你的d重點就是要等於或者是小於m對吧

那相反的如果這個 AND值遠大於低，那很明顯就是你的Degree of Multi-Programming不夠了嘛，所以你其實有很多Frames空在那沒有用的所以你如果有Process想要Launch想要執行被Create出來的話，或者之前被Suspend我們的OS就可以去調看誰Property高把它可以重新Active起來對不對所以可以增加Degree of Multi-Programming然後CPU的使用率可以增加，所以就很簡單就是根據 D

跟 N 的值你就可以知道什麼時候你是要增加 process什麼時候要減少了，所以這就是 working set它的概念就是這樣而已，所以根據一個時間或者說一個 window可能是時間或者是 asset 次數一個 window去數每一個 process所以每一年好多同學都忘記把這個i放上去就只寫個wmss那是完全錯的，因為不make sense對不對你一定要

每一個process都要得到它的window size才可以，不然沒有辦法做control，所以不是大概抄一抄這個，它不會make sense，所以大家要注意到它原來的目的，所以是每個都要數然後去加總之後然後再去做一個比較，那重點就是你會知道你到底要spam process還是你要launch process來控制這個Degree of Multi-Programming好所以對啊這當然

它的這個問題它是非常這個可以很明顯可以看它就可以解決這個問題然後通常可以讓你的CPU的使用率達到很高但是又不會有Straction的問題但是它的缺點就是通常是很Expensive的就是你實作不容易啊你要去算這個WSS其實是很花時間因為這就是Counting就像我們說的Frequency的Replacement Algorithm一樣你看似簡單

你要想它真正run的時候每秒多少個Memory Access然後每一次Memory Access你對Counter的值加以那個Overhead是很高的那都是一個Instruction對不對所以說那些都是很Expensive所以通常你要每一個Memory Access你都在那邊做Counting的話你的Overhead就是你要花的其他時間會很多電腦效能可能因此反而被浪費了不少CPU在做這件事就對了

所以另外一個做法比較直覺的就是從Page4的角度因為我們說過Threshing的問題就在於我的Page4的Rate太高了很簡單就是這樣子對不對Page4的Rate高就indicate現在有Threshing了所以第二個Page4 frequency的skin就是指的就是你去Monitor這些每一個Process它的Page4的次數是多少或是機率是多少

然後根據這個你去control讓每一個process在系統上執行的時候它的rate在一個boundary中間或是在一個threshold中間比如說10%所以每一個process我的page4的rate我希望把它控制在10%到5%為什麼不是0%因為0%代表太多free的frame沒有人反正page4就很可能代表你的degree of multi-programming不夠所以其實太低

也不是一件好事那太高trash不用講所以它會把它控制在一個range裡面所以你看到系統很多就是tune就是這樣子它也沒有一定的道理它就是在一個range中間它的表現通常會是最理想的所以會有一個upper bound跟一個lower bound然後我們的process只要去estimate就好所以跟剛剛的很大的差別是因為locality不斷地改變然後它會根據

你要去Window你要記錄過去10個人對不對所以你會有很多的Counter但是呢Page4 Rayleigh你只要觀察什麼Page4的Event就好Page 4不會那麼常發生對不對幾百萬個Memory Access才發生一次喔還記得吧所以你在數Page4跟數Memory Access是完全不同的Skill所以這個方式你只要去數每一次Page4反正它也會Call OS啊Page4要處理嘛

所以那時候你再做一個Counter的值加1這個Overhead就會相對會非常非常小了你只是順便再多做一個Counter的Update而已那所以你就可以知道過去10分鐘它平均的Page4的次數等等就很容易可以估算了嘛那太高就知道我的Frame不夠所以它是以Process角度所以它超過這個Upper Bump的這些Process我就知道它的Frame不夠那我就要想辦法

去給他frame那相反的就是低的人就代表他太多所以我從哪裡找來這些free frame呢當然就是從page 4 rate太低的人身上所以我就盡量去balance就好所以我們就是在那邊做balancing讓每一個process他的page 4能夠盡量的在這個range的中間所以概念上來講就是像這樣因為Friend 增加 Page 4 一定會減少這就是為什麼我們不喜歡有 Anonymy 的目的了對不對

所以這一定會成立因為我們 follow stack algorithm然後呢，我們是在一個 range那，這個就是 tune 的東西而已，那 whatever 那個 range 在哪裡最適合這個系統我們 OS 可以只要 monitor Page 4 就好，他就可以知道你現在的 Page 4 rate 在哪然後知道誰是比較不需要 Friend誰是比較需要 Friend然後就可以做決定了，所以這是Page4 frequency的方式了。最後，這

張圖只是說，雖然說我們有兩種方式，你可以看見這兩個其實是相同，因為他們在解決同樣的問題，所以這兩個decision的相關性是非常高的，也就是說這邊，如果我們以時間的角度來看，這邊是Page4 的Rate所以它有時候會高，有時候會低對不對什麼時候會高，高的時候就是當你進入到一個新的Locality，你開

始要重新算你的window size的時候，它就會高起來了，所以實是同樣的道理，所以你在這兩個peak之間其實就代表你的walking set要做調整然後看到implementation嘛，所以walking set它通常在進入這一段時間開始Page Pro一直往上clamp 的時候，在clamp 的時候，它就會知道它會重新update它的size然後開始做調整，那如果是 page 4 frequency 的做法呢，當它升的時候，它就超過了那個 upper bar它也會開始做調整所以其實是看你從哪個 approach

去做了，但其實相關性是非常高的重點就是 locality因為我們的 memory locality 會改變，所以才要一直在 wrong time 的時候做調整。那你看你要用 page 4還是要 walk in sand 去觀察都可以，但是 walking set比較少用，因為它的 implementation overhead有點高，所以大家其實觀察page 4是比較多的。所以這個就是第九章了，所以剛好我們今天就把期中考全部教完了。最後這兩個做法 transition這個非常重要然後那兩個做法大家一定要好好的知道怎麼樣去描述期中考常常也會去問 walking set是怎麼做的 frequency 是 Petit Four Frequency是怎麼做的.