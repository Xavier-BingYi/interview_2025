undefined
我們剛剛介紹完這個FIFO很容易的，不過也可以明顯看見它可能不一定會很好對不對；然後更重要的是，它會有這個anonymy的狀況，所以說系統的使用者不太系統的設計者就比較不喜歡去用這樣的一個演算法了，那麼這個問題呢；replacement algorithm，這個問題的optimal，其實是很容易可以被描述的那我們稱之為optimal algorithm或者說bloody的algorithm就是想到這個人這個algorithm的人所提出的

他的做法非常單純，一句話最晚會被使用到的先把它踢出去其實很直覺嘛對不對所以我今天在我的這些physical memory裡面的這些page那誰該被踢出去勒當然就是踢最遠最遠這三個裡面對不對最晚會再被使用到的那個page我把它踢出去當然嘛因為我如果踢其他的代表其他一定會先被使用到就一定會先產生page 4嘛，

所以當然就是越晚用的那個我越晚去我最先把它剔掉的話不得已嘛不得要剔當然剔最不可能被用到的那因為這些Page的Access是有順序不要說時間啦，因為它隔幾秒鐘幾個mini second不重要重點是它的Orders，所以最晚的那個最晚被Access的那個我先把它剔出去Page 4不可能會更差嘛對不對所以那就是Optimal的Solution

好,但是這個方式呢說得簡單, theoretically你也很容易證明但實際上implement卻發現其實是做不到的因為這有一個條件你必須要假設你知道未來的access pattern對不對也就是說未來像剛剛的這個整個reference string雖然我在第一個時間點可是我卻已經知道未來所有的access的stream了這件事情其實不會發生對不對

就算我們今天computer technology當然compiler等等很多可以做prediction你可以去預測某種程度啦但也不可能到forever尤其是你當有一些branch我們程式難就難在這嘛它其實會有wrong time的時候會去做branch的動作所以當然不可能百分之百perfectly的知道真的access的reference string的順序所以在沒有這個future knowledge的情況下這個做法其實是

當作一個Theoretical的Operation但它可以當作一個Baseline或是Optimal的你就知道最少最少Page 4的次數是多少那這些設計者你可以去想各種不同的Operation那就看你能夠多貼近這一個Optimal的Bound那你就知道你還有多少improved的空間等等好那一樣我們就來go through這個例子假設我們今

天就有四個frame然後一樣這是我們的reference tree那前面四個就不用講反正就擺進去就對了然後全部都會Page4就算是Optimum的做法一樣是這樣子那重點是一來了一來之後我們都要提誰那跟前面的方式你看前面的方式我們都會看Q裡面是怎麼樣可是Optimum不care因為那是過去式我們看的是未來

所以你就會從1這個點開始往後看1當然講他要留著所以不用講這是一個heat所以這是一個heat所以沒有辦法做選擇啦對不對所以當然是繼續留著那2也繼續留著5這個時候我們當然要replace一個人了因為我們要把5放進來那1你可以看見他下一個時間點就要用所以我們要把他先不用還不知道是誰但我們就知道他是一個號

2 就是隔兩個 3 4 一時類推所以很明顯的最晚用到的是 4所以我們就把 4 丟掉 對不對然後把 5 放進去嘛所以就會變成 1 2 3 5你可以想像像這個 algorithm我們就沒有什麼 ordering 更不重要因為完全沒有關聯性所以其實就是去找而已那下一個 SS 來 1 2 3 很明顯當然又全部都會是 hit所以我們就保留原來的 content4 來了 對不對

4來的話我們知道唯一不能丟的就是5對不對，因為5是下一個時間點就要用到的下一個就會access的那123這當然我們因為沒有了嘛，所以其實都可以啦無所謂，所以如果在考試的時候最後面有這種pie breaker是誰都無所謂反正都是OK的，但是如果我們後面如果再寫譬如說下一個可能是2然後是3然後才是1的話，那當然我們就會把1丟掉，

所以其實就是follow一個這樣簡單的一個規則去做就可以了最晚不會用到的我們就把它丟掉，這個就會得到一個optimal的aggression好，所以像剛才你這只有6個，我們之前其實前面有9啊10啊，你就發現最好最好就是6那只是問題就在於說實際上是沒有辦法真的 implement 這樣的algorithm，但是各位就可以想見了怎麼樣去 predict 對不對，

所以很多的 algorithm 可以出來有一類型的 algorithm 的人就在想說我要怎麼樣去觀察我們程式執行的過程，那到底他下一次會被 reuse 的時間點或是 distance 是多少，所以說你預測出來最遠那個人我就把他踢掉，所以就可以去模擬這個Optimal的Operation那當然你可能就去很複雜的分析然後現在很火紅的Learning的做法那或

許有人就會去嘗試，你可以想見，但是就是可以希望能夠逼近這個Optimal好，但是實際上那實際上沒辦法嘛，所以大家用什麼方式呢？其實是用LRU是最多的，那LRU就像剛剛說的，its實大家都已經知道這個concept就是我要預測誰是最晚用的，那所以一個heuristic option提出來所謂的LRU你可以看見least recently used，所以誰要

被踢掉就是最近沒有被用到的那個人也就是說我們不能夠往未來看那我們就只好往回看嘛對不對那往回看的話很重要就是我們一再我們提過好幾次的我們程式有Locality對不对所以當你在剛使用完的那個Page應該百分之很高很高的機率你會再用它對不对而且如果你的Jump你的Memory Access沒

有很亂的話其實也就是會在附近的幾個Page然後越遠的Page越用到機會會越小或者你越久沒用到的可能就是越不會去用到它的因為裡面可能就是存一些Arrow Handling的Function根本就不會被Call到所以它就是與其往後看就往前看然後往前裡面最早最早這個被access那個就把它先踢掉了這就是所謂的LRU事實上因為locality的關係，所以大家這些系統實驗的證明去evaluate會發現其實還蠻好的還有一個非常重要我們等一下會介紹就是它的implementation非常快

他可以在order1的時間去做完因為OS什麼都要快嘛所以像我們之前說你可以用learning但是你可以想想看training然後等等很多的時間那所以通常大家還是喜歡去implement一些order1的時間的一些演算法那所以就像剛才說的這個LRU的implementation有兩種第一種呢叫Counted Implementation簡單來講就是大

家可以想像的啦就是每一個Page被Access之後我就有一個Time Step記錄我是幾點幾分的時候Access的這個Page嘛對不對然後在我Friend在我Physical Memory放的那些Page我每一個都加一個欄位然後寫個Time Step然後我就在那邊SearchLinear Scan然後誰是最慢的最久的我就把它剔掉這當然很簡單啦但是Linear Search所以是O的N嘛所以當我們的Friend數越多你就會跑得越慢

非常不好那大家真的implementation呢就會用所謂的stack有點像剛剛的FIFO也就是說我們用一個Q然後呢就可以很快的其實我們就可以判斷誰才是該被踢出去的就可以用一個order one的時間找到我們先看例子再了解一下怎麼implement好了，所以前面一樣嘛，不用講一二三四，全部fall然後就一區放進去，那

跟FIFO不一樣的方式，就在這裡當我們1進來，它也是一個heat就是說同樣的，我已經有了對不對，所以我沒有產生Page4可是我知道它是最近用的所以我不想把它剔掉對不對，所以我們就會把它從我們的Q的底部，把它拉回到頭對不對，那就可以把它2現在反而是說裡面對不对最久最久沒有被

用到下一個會被kick out的人了，所以LRU就是當他Access的時候差別，就跟Fivehole差別在當他被Access之後，他如果是有Hit的話，他其實會把他做排到最前面的一個動作，那當然你本來沒有的像一開始這種一二三四當然也就是一直往下Push而已，所以就是最近被Access的我們Always把他留在這個最上面，這個最後一個被Hit掉的Candidate，

然後2一樣嘛，所以大家就follow這個基本原則其實很容易去知道到底會發生什麼事，所以2一樣它已經有了，那我們就把它擺上去，那裡面2 1 4 3，然後呢今天5進來了哇，要不夠了怎麼辦，就繼續push嘛，所以3被踢掉，所以LRU的話，它就會把3給replace掉，那如果大家回去去檢查FIFO的例子就知道你就是不會踢3，你會踢1了

對不對，所以就是兩種 algorithm 的差別，所以後面應該這蠻說服的所以像在考試的時候或是自己去模擬這演算法其實最好就是以實作的角度因為你這個不會出錯你就 follow 這樣一定的規則自己在腦中模擬程式的運作你就會知道哪些是 page 4那這個就是所謂的LRU那為什麼它是order1其實還蠻容易看到的啦第一個

其實你可以用double linked list所以你去抽掉把它加insert in queue當然是order1的時間做到那你可能會問我那你怎麼知道比如說像1來了好了你怎麼知道1在最下面或者說2你怎麼知道在最下面對不對它的位置不一定像1在這個位置1 hit它在最下面你怎麼知道在order1的時間知道它到底在這個queue裡

面的哪一個位置那大家的做法呢其實就是會用一個hashmap所以大家知道就是hashmap所以你hash你就會知道1它會hash到裡面就有存在1在這個double linked list的pointer所以它就會直接知道1的pointer可以找到找到之後它就把它dequeue重新引queue就好了所以implementation就是一個hashmap再加上一個double linked list然後in average 12分的時間對

不對因為hash機率來講你都可以做兩個order 1的時間所以LRU是非常容易implement的非常快然後其實它的結果通常還不錯因為城市locality的關係所以是最常被使用的replacement algorithm包括了這個概念不只在pagent就是大家可能也聽過好幾次的caching在做IO我們都會介紹其實我們系統常常會用c

aching的概念caching的size也是有限的所以cache的replacement algorithm大家也都用LRU所以這次只是這個algorithm它可以拿來在我們的page replacement這邊也可以拿到很多系統的問題裡面去這是非常常用的一個algorithm這是LRU所以你可以看見他也不是最好他就是8比FIFO要好了嘛然後但是跟6還是有一

點距離但是我們剛才說的畢竟他們都是heuristic所以對於系統使用者我們其實並沒有那麼在乎heuristic的結果因為那都有可能大家care的是property特性就是他可以被證明的東西所以他絕對不會跑掉那LRU還有這個optimal呢他們都會屬於所謂的stack algorithm就是一個特性所以這是一個class of

algorithm所有符合這個我們待會講這個stack的特性的我們都稱之為stack algorithm，所以optimal algorithm是一個stack algorithm。 LRU也是一個stack algorithm什麼是stack algorithm，其實很簡單，它的定義就是今天我如果原來有N個friend就像我們剛才的例子可能是4個吧，那在四個 frame 的時候我們會有一些 page 放在裡頭嘛對不對，那我們也不管是誰反正就是一些 subset of pages

放在裡頭那今天咧，如果我是同樣的 input那我去 run 同樣的 algorithm那我把 frame 的數量把它做是加就是把它加一或加二無所謂就是增加增加的話增加之後裡面它是又有一個新的 subset對不對所以你 run 下去在這個狀態下同樣的時間點它裡面當然也會有很多的 page而且 page 數量會更多那如果是stack-opposite它就有一個特性就是這邊原來的這些 page在增加了 frame

之後一定是還是會被 include 在裡面的所以就是你增加 frame那裡面的 page 數量當然增加而且是原來 page 的superset就是全部include在裡面這就叫做StackStack就是一直加嘛 對不對，所以Stack就是你push到Stack了如果你要拿出來你一定要前面的人都先拿出來嘛就是Stack所以Stack的Occurrence也是你的Occurrence。如果用一個Stack可以实现就會有這個特性就是你的Stack越大那裡面放的東西一定是原來的SuperStack一定會全部include進去這個我們不再用數學不證明了大家

可以想一想然後其實課本有比較數學一點的證明不過其實不會太難證你可以想見所以就是你會是原來的SuperStack那所以Optimum跟LRU全部都是這個StackOperation為什麼那麼重要因為它Garantee一件事情我們如果增加Resource也就是增加Frame數量的話它的Page數量只會是原來的一定會包括對不對而且還會增加所以你

的Page4的Rate不可能變低這很容易證嘛對不对就是很直覺的所以原來的東西因為都在嘛所以你不可能會更多的Page4你只是比原來然後還多了一些Page這些Page或許可以幫助你減少Page4或許不會但至少它不會減少你的Page4所以StackOpposite只要StackOpposite它都不會有這個Anonymy的存在也就是一般系統會喜歡去選用

的一個很大的因素那LRU不只它簡單然後通常表現不錯而且它是stack algorithm你可以證明它是一個stack algorithm那我們雖然不用數學啦不過你有眼睛看一下也很容易證明對不對因為你從任何時間點你是往回看嘛對不對所以什麼人會放在你的這個你的這個stack裡面或是說你的這些frame裡面呢

就是你往回看你先看見的四個人嘛對不對那今天如果你的Stack變成五個對不對那你一樣是往前看而且是看五個人嘛五個Distinct Unique的人所以當然一定Include嘛原來四個會先看到所以一定會先被放進去嘛那第五第六你有更多位置你只是放更多人所以當然是一個Stack Opposite好沒問題所以

那往未來看optimal為什麼是同樣的道理因為只是方向不同嘛那如果是optimal就是往後看所以往後看當然四個distinct的人會在我們的stack裡面然後如果你的frame數量增加就是可以放更多而已所以一定也是一個step algorithm一個是往前一個是往後不只這兩個啦但是這兩個很明顯可以很容易的證明所以這個大家要知道不要

前面這些怎麼run當然也是需要知道但是這個theory的部分其實是很重要什麼是一個stack algorithm為什麼我們在設計一個replacement algorithm的時候我們會想要去證明它符合這個，它是屬於stack algorithm的，然後FIFO不是，所以這個是一個蠻大的考試好，那就像我們說的，其實cache的replacement的algorithm非常非常多啦，或是cache的algorithm其實它們都一樣，算法其實非常非常多，那我們

不會一一go through，因為其實太多了，大家只要知道這個concept就好，那課本上其實有提幾個，還蠻有些變化，但是比較複雜然後通常可能系統也會去考量到的一些algorithm像是additional reference bit、second chance然後什麼叫second chance呢？意思就是，有點像我們剛剛只有一個stack，所以那個stack如果你被踢出來就代表我會把它swap到disk去了。 second chance呢？就是它maintain了兩個stack，然後兩個stack，它的考量點可能是不一樣的，所以當你從第一個

stack被踢出來之後，它會把它放到第二個stack，第二個stack就是所謂的second chance，所以你已經被放到比較low priority了，然後當然要被踢出去的是從 low priority 裡面再去踢掉一個，那通常就可以結合不同的 algorithm 或 policy 嘛去 maintain 這兩個 stack所以這就是所謂的 second chance所以你可以講非常非常多的變化可以在裡頭啦然後當然都有它一些背後設計的道理在裡頭但我們不會告訴那些很複雜然後很

多樣性的這個大家有興趣的話可以在textbook自己再稍微看一下其實裡頭有介紹到的那你可能就會更清楚有哪些replacement algorithm是存在的但基本上都是LRU的變形你會發現因為他剛剛說的幾個非常重要的好處所以都是一些他的變形而已那其他還會非常常見到的就是用這個剛剛我們

看到是access的recent啊或是這個distance就是多遠會用到那還有另外一類型呢是根據frequency所以你可能會覺得這比較make sense一點就concept來講就是frequency就是最常用到的我把它放在cache嘛對不對或者說放在我的我的frame裡面啦所以我比較不會去需要去做page4的處理嘛對不對所以如果我們知道整個程式的behavior

然後我們跑過一遍了我們當然可以知道誰是比較frequently used的然後我們就把它一直留在cache或是留在frame裡面所以你的page4次數就會減少那這一類型就是所謂的frequency，就背上frequency based的argument，那就所謂的list frequently used，所以很明顯就是frequency最低的我會先把它剔掉所以如果我們frame裡面有幾個page假設我們知道它的frequency根據它

過去的使用的Behaviour，我們可以做一些Counting嘛對不對最低的那個我把它先剔掉那就是LFU了然後呢MFU呢就倒過來它就是最常用的最Frequently used那個呢我反而把它剔掉這些全是Heuristic所以當然你可以想它的道理是什麼譬如說LFU的話，它的想法就是很直接一般人應該都會同意嘛因為我常用嘛所以當然我不行我要避免他們產生PageFour

可是常用不代表它正在用喔因為我們的使用電腦程式的使用啊你如果去想常常都是我突然間一直在使用某一塊Memory然後用完之後我就不用了對不对所以我在那一個時間點一個burst的狀況下我可能就把frequency一下提到很高然後之後我都不用它就一直站在我們的Memory裡面然後就造成Page 4

可能更高所以跟Access Pattern有非常大的關係不是這麼簡單的事情，所以frequently只是覺得它反正很長，所以overall按照機率probability最常見的我就把它留著保就是這個LFU，那most frequently used就像我們剛才說的它就比較看盡說我覺得是local每一個的behavior所以我現在frequently used的人代表我等一下就不要用了很可能對不對用完了我就再也不會去用它就像大家寫個for loop一直在做某一塊array的操作用完可能就不要了對不對已經算完了，

所以他就倒過來想他就認為最frequently used我就先把它剔掉這沒有對或錯啦這個純粹是程式的behaviour然後去做一個選擇，但這些做法通常不太被喜歡那主要就是因為你要去算frequency這是非常浪費時間complexity非常高的事情，你每做一次access你要把counter的值加一然後最大問題是這個counter會overflowMemory Assets非常頻繁的一分

鐘就已經Assets幾個Million了所以大家知道Integer也就是只有那麼8個Byte所以很多時候就會有Overflow的問題，所以是很多issue在裡頭，所以當然有很多在設計怎麼樣子設計一個Counter它是可以處理無限多數字的事情，那代表其實通常都是要做一些Proximation然後你可以用幾個Byte就可以去描述它的Frequency不是這麼單純的所以通常不太被喜歡因為它通常的complexity比較高然後也不一定特別make sense對不對就是其實LRU的結果其實通常這些也是不一定會比较差甚至於更好好.