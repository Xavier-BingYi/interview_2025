undefined
ok好，那最后呢我们就介绍一些case study因为我们介绍了scheduling algorithm各式各样的scheduling algorithm对有priority shortage jobmodel level等等的那我们说那些其实都是一些基本概念然后是比较basic的一些scheduling algorithm所以接下来我们就用介绍一些真实OS它在实作上面会采用的scheduling algorithm让大家知道其实是怎么被应用在我们真实的系统里的好，那当然第一点你会发现其实大部分都是based on priority

因为它最general第一個是Solaris這個OS比较早期很早就有的這種Workstation的OS它的做法你可以看見當然是Priority based所以你會發現所有的Process只要一被Create之後你去像在這個Linux的話你就按Top你就會看見有一行它會寫它的Priority或有時候它寫他的這個Nice就是他到底是他的他的這個Priority是多少支那在Solaris裡面他的Scheduling的Priority就從0一直到169然後169是Priority最高的所以數字越高就越好我們等一下

就看見不同系統定義完全不同不過這一個可以看見是數字越高Priority是最優先的然後他就把它切成這六大類型的這個processes就是六大類型的classpriority的class那第一個當然你可以看見interrupt對不對我們說interrupt最重要嘛所以他的priority最高然後不是任何一個process都可以放在任何一個

class這個是你create的時候OS他有一定的一些policy去決定或他有些hint所以他知道對不對你應該屬於哪一個class那你被放到那個class之後呢你是不能夠你就會一直維持在那裡面所以interrupt你可以看見它最低的property也就是160然後最高它甚至於到169然後如果是realtime的它就是100到15

9然後一時類推就是system的那最後這些呢基本上可能就是你launch的一些application的那後面這四類型的你可以看見它就全部都是在0到59之間所以他就會有可能你是不同class但是你的priority是相同或者是互換都有可能好不過重點是他把它分class然後每一個class對應到整個priority的range裡面的某一塊然後一個process他就只會是屬於某一個class，他不會在class之間跳動好，所以這是我們剛才說的所以

每一個class，我們等一下就會看見它又會有它自己的scheduling algorithm，所以有點像這個Multi-Q的這個scheduling方式一樣對不對，所以每個class，它會定義它自己的scheduling algorithm，但不管什麼算法，它就轉換出來的就是它在這個range裡面的priority的一上或一下，所以會增加或減少這樣子，那對於整個OS而言呢，它care的其實是global priority，所以意思就是

第一個class做完了，你才可能去做第二個class，因為他看到就是最後globally你的priority的值是多少好，那你可以看見這個是他在這個剛剛說的前面的，這個就不用講前面這些system level的，就是60以上的基本上這些priority都是一定是不會怎麼變動的一，create之後你就會知道他的priority是多少，那對於使用者的這種比較

難以預測的，所以你會看見他的做法其實是他會建議一張表就是你一個process起來之後，他可能會initiate來任何一個地方然後based on你的這一個priority，他會開始執行你的程式對不對那執行的方式就是每一個priority他首先會對到一個time quantum所以其實每一個priority你看很多process都是屬於這個priority的那這些同樣屬於這個priority的這些process勒其實是用round robin的方式再去更fine-grained的做scheduling。所以意思就是說

我們的系統59做完了然後一路做下去對不對那30這個priority裡面可能有好幾個processes那每一個他在執行他的CPU burst他就只能做80個time counter然後做完就要換別人。跟我們前面的例子有一點像然後你就會發現Priority越高的它的Time Quantum反而是越小的因為supposedly它應該是一個shortest jobCPU burst越小Priority要越高所以我就只讓你做20而已你的Priority很高但是你只能做20的mini second就要換人那你如果超過所以這跟我們前面的例子是一樣的。

如果你超过这个time quantum它的decision就是我认为你这个job不够短所以我会把你的这个priority往后就是降低對不对。所以59的你如果超过20ms我就把你降到priority 49的那个q里面去然后以此类推所以你会发现只要超过time quantum它的priority n就会往下降那這樣的好處壞處就是他比較不會被執行了但

是好處就是你會發現他的攤框的比較長了所以他可以輪到他的時候他可以執行久一點也就是那些CPU放的程式就對了那另外呢你會看見還有一個這個純粹是System Engineering的結果就是發現如果你的程式從Sleep或從Waiting Queue重新加到一個Ready Queue的話我會把你的Priority做增加為什麼因為

你在Waiting Queue的意思代表你不再用CPU嘛所以代表你可能是一個IO棒的程式這個純粹是Intuition所以當一個程式它從Sleep的State或是Waiting Queue的State重新加到Ready Queue的時候它不是被打斷而是它結束它的IO狀這個Cycle回來的時候呢我們會把它的Priority看見它可以是維持的甚至於有些是會增加的所以你看像這個原來是20那如果它Call了一個Sleep

回來了之後我們就把它升到52因為對於CPU而言代表它其實有會做一些IO所以我們就把它Priority增加讓它先做所以這個就是Celer是裡面怎麼去調整Priority的方式就是Basic上你是不是超過了Ten Quantum超過那你是CPU棒所以我們把你Priority降低。如果你在你的這個執行過程中進到了waiting state叫了一

些這種IO的system code那我就把你的priority增加然後用這樣的方式來希望讓CPU bound的程式慢慢的沉到下面priority變得比較低然後IO bound的程式CPU burst的短的程式可以慢慢的往上升再升到上面去好， 可以齁。所以這個是Celeris的做法然後priority越高的人貪荒等會越小。所以我們之前課堂的例子那時候feedback queue的例子

跟Solaris就是非常像的下一個是這個Windows XP所以它跟Solaris也很像，因為大部分其實就是那個概念那只是一些定義上稍許的差別。所以你可以看見第一個Windows XP的話它的priority level比較少它就是0到31而已不像剛剛有到256那另外一點它的數字來講一樣是越高所以數字越高的它的priority還是越高然後呢

它的這個一樣所以跟剛才其實很像它也一樣會分成class就是這邊有1 2 3 4 5 6個class然後這六個class裡面呢它又分成了1 2 3 4 5 6 7個priority所以意思就是說你在這個class如果你是high的話一樣它就會根據你是從waiting回來跟剛剛很像我們沒有講detail可是基本上一樣就是根據你的running state它會

看你的CPU跟IO的情況如果CPU比較多它就會把它的快遞往下降IO比較多它就會往上升那每一個class它就會在這七個數字間在跳動而已那唯一不會跳動的是real time所以如果是你的這個工作一進來他認定你就是一個real time的job的話那他的priority是static的不會動的所以因為他一直都會蠻重要的所以他的priority當然最低也只有到16對不對然後一旦進來之後他就會維持在那邊那就是一個static的priority所以Solaris跟Windows XP其實是非常像就只是

切割的這個數字的Range有一些不同啦然後一樣higher priority先嘛所以這跟剛才都一樣對不對所以它也是整個OS就是看Global的Priority然後Priority相同的這些所有的Process其實會放到同一個Cube然後就用Wrapping那跟剛才不同的大概是Pine Quantum的部分這邊沒有特別講所以跟 Linux跟Solaris實是比較不同的，它並沒有說它的Quantum會不同，但原則其實是一樣的。好，最後一個例子 Linux所以它比較特別一點，所以這個是

大家常用的Linux，所以說它的Range首先，它是從0到140而已然後數字越小Party越高可以study嘛，所以這個他的設定是數字越小他其實priority越高的那一樣，他每一個priority會對應到一個time quantum，所以一樣priority越高的人他的time quantum一定是越小的對不對，然後通常對應到的就是一些real time的task，然後priority越高的time quantum比較長，但是就是一些比較不重要的好，那

一樣0到99是跟前面概念一樣0到99是屬於一些real time或是system的，所以他的priority是固定的，然後priority高的人這個priority比較低的這些通常就是user的process那他的priority就會是wrong time的時候可以去做調整所謂調整的意思就是跟我們前面例子很像可能也是根據他執行的time content有沒有expire或者是它有沒有去call

一些IO的system call去做調整，所以這一塊跟前面完全一樣差在哪裡大家稍微仔細注意一下，差在Linux的特點是它會把process變成兩個狀態。我們直接看圖會更清楚一點，它會把所有的process放在所謂的active跟expire array就是會有兩個list。那process勒什麼叫做active勒意思就是說我們知道每一個task給一個priority它有一個time

quantum比如說是200好了，那前面的OS都說輪到我，我就做一個CPU burst。它可能會超過可能會少於對不對。如果少於的話我們就浪費掉那個time quantum比如說我給你200個time quantum結果你只做了100然後這個burst就結束。那前面的scheduling algorithm就是不管那我們就在run robin回到Q的最尾巴對不對。然後讓別人做Linux認為那樣的

做法不太公平。我既然給你200個time quantum就應該讓你好好的把200個time quantum全部用完。所以呢所謂的active就是說當你一個process執行完它一個CPU burst如果它沒有expire time quantum的話就是它沒有用完它的budget的話它會留在active的這個Array就是這個Active的Queue裡面還可以被執行，但是如果你用完的話，它就會把它放到ExpiredArray所以每一次輪到，意思就是說

你每一次輪到其實你真的就是可以用200個TimeQuantum然後別人才可以去使用，意思就是等於它的執行時間就是Waited by它的TimeQuantum它是直接就是那是它的Usage的Wait一樣所以說其實一個Task它可以一直留在ActiveArray直到它的TimeQuantum用完為止，它都可以有執行權相反的那些Task它如果用完了它的TimeQuantum它就會把它給放到這個ExpiredArray裡面，那其實就會從ReadyQueue裡面Remove掉是一樣的意思那就不能執行了嘛好然後當然你如果我們剛才說超過對不對，所以說我們說你要被

Priority要降低的話是說你的Time Quantum要一次用完所以我給你200，那你用了四五次才用完，它的Priority不會被影響可是如果你一個CPU Burst就超過200的Time Quantum那你Priority就會被下降，所以跟剛才那個部分是一樣，但是每一次用完其實它只會從200的TimeQuantum裡面把它Subtract然後看看剩下多少然後繼續把它放在Active Queue裡面好，所以這是Linux的做法就是稍微有一點差別在於它想要ensure每一個process，它真的是

可以用完200個它直徑的time quantum然後才讓其他的process去使用所以它希望按照維持那個比例，那這樣的implementation其實也很容易，所以你可以看見，其實queue就是裡面的process，就是不斷的使用完它就insert回兩個queue的某一個 對不對然後等到這個QA全部空掉了，就所有人都把它攤框等用完了，那其實就把這個expired array的pointer換成active array的pointer 對不對，

那就可以繼續再做scheduling，所以雖然看到兩個，它不需要它swap很簡單，只要最後的時候把pointer交換就好然後list就可以所有的expired array的東西就變到active array然後繼續下一輪，所以這是Linux所以這是他比較不一樣的地方，在這裡它不會說你執行完一個cycle它就換人，它會希望讓你把你的time quantum全部用完，所以這

就是第五章的部分了，所以後面有些case study不會考啦，但是大家可以去想一下到底是怎麼樣把這些基本的scheduling是implement在實際的系統中，實是用一些我們看到的那些方式把那些想法把它套進去，但是並不會限制於它一定要follow某一個特定的scheduling algorithm好。 剛好那我們就休息十分鐘，我們下一堂課開始要進入第六章的部分。.