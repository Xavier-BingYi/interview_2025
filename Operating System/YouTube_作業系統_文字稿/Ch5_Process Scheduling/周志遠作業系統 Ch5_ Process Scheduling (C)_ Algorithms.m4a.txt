undefined
CPU Scheduling 這邊第一個要建立的觀念就是前面幾張 Slice其實我們的程式就是有 CPU Burst就是說它都在做 CPU 的 Instruction或者是 IO Burst 就是在做 CPU 之外的 Instruction 就對了那只要在做 CPU instruction 意思當然就是他在 running state 囉那non-preemptive 的意思就是說這個程式他一旦進入 running state那你就必須讓他做完直到他自己說他要去 IO Burst 的這個 state自己讓出來才可以做 rescheduling或者是他就是執行完了嘛那就結束掉當然可以做 rescheduling

而相反的PREEMPTIVE SCHEDULING很好判斷就是它在CPU BURST做到一半的時候它還在那邊做CPU INSTRUCTION你就把它做COMPASS SWITCH就把它替換掉別人那這就叫做PREEMPTIVE那為什麼可以做到一半就想要替換它咧我們之前有列一些CONDITION嘛其實就有兩個CASE第一個CASE就是有新的程式進到了READY STATE裡面去了就是有新的程式可以被SCHEDULED了它可能是一個

剛被Create的程式或者是可能是一個舊的程式但是他做完他的Waiting的這個狀態對不對可能是在Sleep或在IO所以他重新回來可以被Schedule加入到這個Ready Queue裡面去這時候可能就可以做Schedule或者是第二個Case就是因為我們有Time Sharing的系統所以說時間到了就會有一個Interrupt出來就會強迫讓OS做決定

所以這個時候原來的程式雖然在running state他就會強迫被放回到ready state去然後重新再被選一次就只有這兩個casepreventive scheduling就是這兩個case的時候他也會多做scheduling的decision所以這兩個這個定義其實是非常重要的就是這整個觀念應該要建立起來那當然在這個觀念之下我們上次介紹了很多的一些基本的scheduling algorithm我們當然不用再go through就從

最基本的這個first come first serve對不對明顯是不好的因為你有可能一開始schedule的這個先進來的這個process他可能是一個很長執行時間的process那他就可能會把後面的wait time把它變得很高所以如果你整個系統角度你的average wait time很大這個可能不是一個系統使用者想見到的然後我們上次就說到如

果想要把這個wait time這件事情把它minimize最小的話其實theoretically可以證明就是shortest job first最短的先排就對了就是目前在ready queue裡面最短的先排那這邊的時候你就會見到pre-emptive跟non-pre-emptive的結果就不一樣對不對所以non-pre-emptive像這邊P1雖然很長可是因為他先進來所以沒有選擇我們只好讓他先做

那一旦做下去我們就沒辦法打斷它就是打斷不是說整個程式喔而是說這一個CPU Burst所以這個P1這個程式其實是有很多Burst你在裡面的就像很簡單的你想說你寫一個for loop對不對那裡面是i++然後print ii++是CPU Burstprint i是IO Burst所以其實for loop就是一直在CPU Burst、IO Burst其實有好幾個cycle在那裡

那這例子是只有一個可是真實的程式的話或甚至於考試我以前也有出過就是跟你講說他第一個burst是7第二個burst是4中間過了幾個多少時間這其實是真實的程式的behaviour應該是那樣子那這只是一個簡單example所以你只看到一個7就結束事實上他可能等一陣子他又會再進來一個burst那你就反正就是不斷去對他做scheduling只是

CPU Burst 来的时候你就要记得这时候它就会加入到 Ready Queue 里面去所以 Non-Preempt 你就会看见它就是会变成这样子不会打断所以它的 Burst 是多少你画出来的结果一定是就是刚刚好它的长度可是如果是 Preemptive就像这边这个例子会稍微复杂一点因为你要随时去判断有没有新的人到 Ready Queue 里面去了所以你就会发现刚刚的 P1

他還是先執行但是他就被打斷了所以你可以看到他的CPU Burst Time就改變了那這就是Pre-Active的結果那所以對到我們之前說到這個就是一個Job的Wait Time對不對在Waiting Queue裡面的時間那你可以看到在Pre-Active的話他的Wait Time很可能就是因為他被打斷雖然他Response Time可能是很快的一進來我就Response了對不對但是他的Wait Time

卻還是可能會很久因為它中間這段時間P1就是在我們的ready queue裡面在等對不對直到終於輪到它才可以做完所以response time跟wait time在pre-emptive的時候也很容易就會不一樣這是兩個不同的major performance的metrics好所以這是pre-emptive的所以看到shortage job first的話就有這種pre-emptive的現象出現那當然pre-emptive我們就說一定是比non-pre-emptive比較好對不對

只是說在CPU Burst的中間執行到一半你如果對它做Content Switch的話我們下一個章節就會教會有Synchronization的問題好然後我們上次最後提到的就是Shortest Job First的這種做法雖然說Theoretical很好啊但實際上你是不知道沒有辦法實際Implement的因為你根本不知道Burst Time對不對所以你不知道Burst Time你怎麼知道誰是最小的Process對不對

所以說我們這樣最後就提到這個approximate對不對所以你可以用一些它其實就是一個time series的the numbers 對不對所以你可以用這些數學的這種time series的prediction method就是這種exponential decay的function你就可以去做一個預測一開始當然可能會很不準嘛因為你猜的是隨便猜的可能甚至於，但是如果它的這個一

個程式通常都是有些behavior的，它不是毫無規則的。很多時候，它都是有一些固定的規則，就像你跑一個for loop那，每一個for loop裡面執行的instruction不管是IO或CPU都一樣。所以其實它的behavior就是它的burst time是很穩定的。所以用這種逼近的方式有時候你就可以去貼近它接下來預測它的行為。那如果預測對了，自

然你猜中的就是最小的job那他就是最快的。那我們最後這個章節我們會介紹真的OS他們設計的一些scheduling algorithm，你就會發現有另外一套做法，但是都是一樣的concept就是希望CPU burst越短的人越先做。但是可能不會用到這麼複雜還用數學的道理在裡面。它可能用一些intuition。那我們最後會cover那一塊，那有了first come first serveshortest job first那再一個下來就是priority。那priority其實就是最general的case我們說所以其實shorted job first你也可以

把它視為一種priority scheduling因為priority就可以把它視成它的值可以視成就是它的burst timeCPU burst time。對不對所以最短的就是priority最高的嘛所以其實是一樣的algorithm只是priority的決定他可以 based 上任何東西那如果 based 上實行時間那就變成 shortage job first那當然我們看見事實上的 OSA都是 based on priority scheduling但是他決定 priority 的方式就會參雜很多其他的一些 rules或者是一些經驗或者是其他的東西但基本上都可以用 priority scheduling 來實現

那Private Scheduling的唯一的這個也不算唯一啦就是說他最大的必須要解決的問題就叫做Starvation也就是Private低的人有可能永遠都很低那永遠都輪不到他就像貧富不均一樣對不對貧窮的人沒有辦法翻身那最後就餓死了就是電腦這邊也是有同樣的一個概念叫做Starvation就是他一直輪不到他去做執行造成了一個問題那

我們也說其實這樣課本也有提到真的有這種現實生活中就是有這種例子存在所以solution呢就是用agent所以所謂的agent就是過一段時間那沒有被執行的process你就會記得去把他的priority的值做一個增加的動作所以eventually對不對一直不執行的人他的priority遲早sooner or later就會升到最高啦那他就會被執行到那至於你說

多久去增加每次增加多少那個就只是Policy而已所以那只是看你怎麼去Tune而已，但是Aging這是一個非常常見的一個做法，在有這種Priority的這種Decision裡面好，所以這個其實大家作業三都會有機會去Implement就是Implement一個基本的Aging的方式去Make surePriority Scheduling不會出問題好，那再下一個也是蠻basic的是這個叫做run robin對不對所以大家可能也都聽過這個turn了，所以在scheduling這邊當然也有所謂的run robin就是大家輪流做就對了，supposedly是最fair的方式對不对，

那run robin除了說它是輪流做之外，在這邊會控制的一個東西就是你每一次輪到的時候它可以執行多久所以當然是大家輪流做，但是你輪到之後你可以做多久就是所謂的time quantum那就是一個參數，所以你可能是每輪到大家就是做100個mini second或者是你可以把這個time quantum設小一點，每一次輪到你只能做10個mini second你就必須要換人了所以當然它因為是這個值是一個固定定值所以結果就是你會變成像pre-emptive scheduling一樣

所以不管你的 CPU Burst 多長我只要 Time Quantum 一到那很抱歉你就要讓出來所以說這個 Run Robin 會有這個Time Quantum 的一般也會伴隨著這一個參數在裡面然後當然因為它是 Run Robin 嘛所以剛做完的人當然就是會放到 Ready Queue 的最後面所以就是這樣排隊的進去所以這個攤框橫的設計如果非常非常大大家可以

想見它就變成像Fivefold或是說First Count First Serve因為它一定遠超過所有你可能出現的CPU Burst的話那只要先來的人他一定可以做完他整個CPU Burst所以當然它就是一直站著CPU了對不對那如果它真的非常非常少的話非常非常小的話當然是非常非常的Fair但是要注意的一點就是我們提過的Context Switch對不對

所以就很像Time Sharing一樣你每一次都要換人做那你Context Switch的次數一定會很多那可能也會造成一個很大的issue所以這個Time Quarantine當然是一般系統不會設得非常大也不會設得非常小好那這只是這個就是例子對不對這個Run Robin的例子假設我們攤框可能是20的話，那它的去模擬它的運行通常是比較

容易一點，因為它比較規律對不對，所以你會看見我們基本上就是每20個單位的時間我們就會強迫，雖然P1是53可是我們做20就得要換人，那同樣的P2，它因為只要17所以它會提早結束，所以這只是一些細節大家要模擬的時候是稍微注意到的，所以它如果做完當然你不會P2不會執行20，因

為它只要17，所以其實到了37的時候P2就做完了，那做完之後我們就換下一個人P3，那一樣P3超過20所以它是可以再做20，然後再換下一個以此類推然後就知道大家做完就對了，所以這個就是標準的一個Run-Robbing，那只是貪Quantum其實是可大可小的好，那這個做法通常你可以看見這只是一些不能不

能被證明啦，但只是經驗上你可以感覺的出來就是他的這個average的turnaround time通常會比較高，意思就是說我們這有定義過嗎幾個這個去measurescheduling algorithm好壞的metrics就是有wait time response time還有一個是Turn Around Time就是你整個程式做完的時間，那因為Round Robbing很FairFair的結果就是大家都很慢，你可以這樣講 可預期的，尤其你算平均

的時候如果你貧富不均有時候就這樣大家說怎麼平均大家都很有錢其實因為1%的人有了50%的財富所以你一平均下來好像很高其實大家是很窮的那這是一樣的道理如果是非常 fail 的狀況就是大家都完全一樣所以就變成整個執行時間大家都會拉長沒有人是比較短當然也沒有人比較長但是平均值通常就不能夠因為benefit少數的 process 而把它給降低好那不過相反的你可以看見就是像 response time如果你 care 的是系統的 response time它就會非常好

因為 response time 就是一個進來之後我多快可以第一次被 schedule 到那wrong-robin 保證嘛因為它是每一個 process 人流來所以你最多就是等 process 的數量然後每一個人就只能執行 20 個 time quantum也不能更久 對不對所以你可以預期很快的就會輪到你然後 response time 就會比較小所以不同的 scheduling algorithm就是我們系統這邊都是這樣algorithm 沒有所謂的

好壞或是系統設計沒有好壞只有說這個系統的使用者的需求是什麼目的是什麼你要的performance's metrics是什麼根據那個metrics去選擇你適合的演算法或是做適合的decision所以你如果是要一個response time很好的對不對的一個系統的話你就會用wrong-locking那如果你想要讓wait timeaverage wait time最小那你就用shortest job

所以這是Depends的好 那這個就是Run-Robbing那我們介紹這些基本的所以那些都是最常見然後最基本的一些做法那實際上的系統就會開始在那邊做Mixing把各種做法把它兜在一起然後根據需求做一些調整那兜在一起的話呢第一種兜法就是我不是只有一個Cue我的schedule的ready queue

不是只有一個而是很多個那就是俗稱的這種Multi-Level Queue的做法那這個Multi-Level Queue的做法又分成兩種我們先介紹第一種比較單純的第一種就是每一種queue它就是run不同的scheduling algorithm然後通常也就是放不同類型的process的工作然後當然不同類型的Process的工作它的重要

性不同所以你可能管理它排成它的方式就不同比如說我們剛才說Interactive那可能你的這個Response Time要很好所以我就用軟軟筆那我如果是System Process這是非常重要的程式Priority優先我先不管只要是我們Kernel Module裡面最重要的Process的程式我們一定要先執行所以你就會用 priority scheduling所以你就會有不

同的 queue那裡面通常是放不同類型的程式的工作那最重要的是不同的 queue 你就可以選擇不同的 scheduling algorithm那這就叫做 multi-level queue那你有這麼多 queue可是問題是你最後還是要選出一個人對不對所以你每一個時間你要選下一個要 schedule 的人你還是只能選一個雖然你有五個 queue你也不能五個都執行所以Multi-Level Q 這邊除了去定義說你有幾個 Q每一個 Q

用什麼演算法之外他要做的第三件事情就是那我這五個 Q 要怎麼做選擇那通常的做法就是用一個Weighted 的方式也就是他就Randomly 去 Pick我現在要從哪一個 Q 裡面去挑一個 Job 出來那這個 Weight 所以是一個Ratio所以你可能是可以自己去控制的像是50%的時候我都要從System Process因為畢竟它重要所以我要盡量執行它的程式然後剩下的50%我可能就分成20、

10、10、10就按照機率來那就10%的機率會執行這邊的程式20%執行這邊50%執行這邊那就是用這樣的方式你可以再去控制Q之間是誰去選擇的這件事情，那當然一個Q裡面有可能空掉，空掉當然就只是在重新選而已，所以注意到這邊雖然我們畫了五個然後有上下之分可是通常Mt。 11Q是不會

管上下是沒有意義的，它純粹就只是機率，你要從哪一個Q拿出來而已所以上面的也不代表它Assigned的位置一定要最高這個其實是隨便的只要加起來是100就好，那這個就叫做Multi-Level-Q的scheduling所以他就combine不同scheduling algorithm在一起然後會比較符合使用者系統需求因為其實程式是有特性OS其實是知道一些Hint它可以有更好的管理方式好， 可以齁，所以這個是Multi-Level-Q

另外一個Multi-Level Queue的做法比較複雜一點的叫做Multi-Level Feedback Queue所以它不僅僅是有多個Queue而且更重要的是它會Feedback那什麼叫Feedback呢就是跟剛剛的差別是等一下也有圖一樣是有好幾個Queue然後分成上下，但這邊的上下是有意義的，上面的一定是先做所以我們分成五個Queue，那就是五個Level第一個level也就是priority

最高的一定是priority最高的他一定要玩第一個queue都做完做空了他才會去第二個queue裡面去拿job所以他是上下是有差別的那相對的就是這些insert進去這些queue的這些process他可以在queue之間移動所以前面是說不行對不對我只要是system process就要進到第一個queue永遠都在第一個queue裡面那如果是feedback的話意

思就是說我會在runtime的時候去觀察它的一些behavior跟行為然後才開始做判斷它到底應該是在第幾層的queue裡面所以這些process會在queue之間移動那既然它會移動了所以對OS而言他就是當然每次就是選最上面的 queue 裡面的 process 來執行所以跟剛剛看起來很像但是其實整個運作是剛好顛倒過來的，就是你就是從第一個 queue 開始做選擇就對了那第一個空了你才會到第二個 queue那 process 在 queue

之間是可以移動的那為什麼要這樣做咧因為就是剛才說的因為你要 feedback什麼叫 feedback 就是你很多事情你要 runtime 才會知道嘛雖然我們說OS有很多Hint你可以猜啦但是畢竟多半的時候你沒有這些Hint或是難以區分像是使用者的Process好了80%的程式可能都是使用者的Pro cess可是使用者Process特性也有大相也有差異很大的對不對有些就是都在做IO有些都在做CPU所以你也不知道

沒有Hint使用者也不會給OS什麼Hint對不對都是你的程式嘛你才知道執行了但是執行之後你就知道啦因為執行完你就知道它過去CPU Burst的時間是多少Io Burst的時間是多少它執行過程中摳了哪些System ConeOS會知道但這是Round Time才會知道所以這個Feedback的好處就是它在Round Time的時候可以再去收集這些資訊然後開始幫你做分類

也就是上層的人我們剛才才提過因為上層的人一定都是喜歡放Io bound所以剛好不要想錯其實最先執行的工作通常是Io bound的程式雖然說好像Io很慢對不對可是對CPU而言它的意思剛好倒過來就是它的CPU burst很短就是shortest job first對不對所以我們知道通常shortest job first是最好的一個演算法你如果

不去做任何估算的話意思就是你去看它的執行的過程中它有沒有去call一些IO的function system call它一call你就知道這是一個IO棒的程式因為只要一call就會慢下來所以它就可以在run time的時候去觀察你如果有去做這些IO的動作或者是它的measure出來CPU的burst的時間真的比較短的話我們就把它往上提在這個level的queue裡面把它提到上面的那個level

那倒過來的當然就是像是我一schedule你結果我明明就跟你講你只能執行20個time quantum結果你做不完那就代表你很久嘛你超過20個time quantum那你可能就是CPU爆因為你做太久了那你只要一超過那個quota那我就把你往下踢所以我會幫你做完但是做完之後我就把你往下踢了就是覺得你不是一個很有善的所以就往下去移動

所以這就叫Multi-Level的Feedback Queue那當然Agent還是可以放在裡頭因為當你是只從最上層的Queue開始執行其實意思就是它某種程度是一種Priority Scheduling第一個Queue的Priority最高然後最下層的Priority是最低所以如果一個Process它會永遠卡在最下層的那個Level的Queue那就完了它就會Starvation 對不對所以通常這個multi-level queue一定也會有Agent 的

機制在裡頭所以當一個程式等太久我們也會因此把它往上提升到上一個 queue讓它比較有機會被執行因為只有最上層的人其實才會被執行所以你要讓它慢慢的往上移動所以它的圖就比較像這樣，所以這只是一個例子，就是一樣有Multi-Level的Q，但是這次不一樣的是，你會看見我們把這些Q把

它串在一起了，因為在裡面的這些Process的Job，它會在Q之間做移動那，這只是一個例子，所以在這例子裡面也可以看見它的做法是前面兩層都是Wrong-Robbing，因為這樣可以避免比較容易避免Starvation，因為Wrong-Robbing就保證不會有Starvation對不對，那你可以看見它的time quantum上面就比較小，下面比較大，因為8的意思就是，它只能執行8，所以就是CPU burst，它一次就很短然後就要換人對不對，

那什麼時候它會被往下移勒，就是你執行了一個你的CPU burst結果，你把8個mini second全部用完的話，那它就把你往下提它就會認為你一定是超過8嘛，對不對，所以只有小於8的你的CPU burst，小於8的這些程式，它才可以留在第一個level，因為它是比較小的Job，shortest的Job，對不對，不是shortest，但是shorter_than 8的Job，那這就是一樣的道理，所以那這就是中的長度的囘，所以就是那些只要16個mini second对不对，

所以如果你在16以内好吧，那我就把你保留在第二层，所以你还是可以相对比较快被执行，如果今天系統裡沒有人是這麽短的就是8個mini second以內的人的話，算就算你是在第二個queue你也可以被執行到，只要第一個是空了他就會開始找下一個，那最後的就是，如果這兩層都空了，所以顯然這個系統的程式都還蠻都是蠻CPU棒的都超過16個mini second每一次的burst那就會全部都丟在最下層那最下層你可以

看見這只是例子，所以他這邊用的是first come first serve目的是什麼呢，不會有stablation嘛，所以你反正大家就是first come first serve，所以你先來的人，你就可以先被去schedule到，所以最不容易會有stablation的問題，所以這個就是一個之所以它會這樣設計的原因很typical的OS可能就比較像是這樣子去設計跟把不同的schedule algorithm拼在一起，那這是有意義的重點，是你可以

看見通常這樣子去拼的話，你可以保證比较贴近shortest job first的scheduling algorithm，而且是runtime，你會去自動的貼近它然後，你可能比较不会有startation的問題对不对，那所以這樣的設計可能就是比較好的一個設計，相反的，如果你拼的方式是剛好反過來的，那你整個系統的效能，你就會發現可能會非常差，就是Average wait time或是其他的一些這些Performatrix可能就會比較差了問題嗎？對我說保留在那邊的意思是說，他如果下一次又進到ReadyQ的時候，

它會留在第一個你講的沒錯，當然一個程式，我們說它是CPU Burst、IO Burst，所以一個程式，它CPU Burst結束之後去做IO的時候，它會從這整個Queue裡面離開，因為這是Ready Queue，所以你講的完全沒錯，就是它做完CPU Burst之後，實它當然會離開這整個Queue重點是，它下一次加進來的時候，那它會被保留在第一個Queue裡面對，

所以要注意這一點，那當然不用怕什麼，它的status會遺失等等，因為這些資訊全部都保留在PCB裡面，Process Control Block裡面還記得裡面有一個Schedule Priority嗎？所以Process Control Block裡面其實有一塊Data Structure很重要的，就是去記這些Scheduling的Information，那各位作業生也會用一樣的做法，你一定是應該正確的做法，就是在PCB裡面自己去加一些Field去記錄你所需要的Information

那你做scheduling的時候當他要進到ready queue的時候你會知道該怎麼做才對好可以齁有沒有其他問題好所以不要忘記喔他這個queue每一個queue最下層也有機會被執行喔只要他前面的queue最後一行看到全面的queue全部空的話那他也是會被執行的不是說你一定要在第一個queue才能執

行然後feedback的意思是他會在Q之間移動根據他long time的behavior好所以Multi-level的feedbackQ你可以看見他要去設計的一些decision又再多了一點對不對所以除了說number of Q然後每個Q的scheduling algorithm之外他要去設計什麼時候他要往上upgrade就是到上一個level什麼時候他要downgrade到下一個level那他倒是不用去在 queue 之間選擇他就從最上面的 queue 開始做 scheduling 就對了所以 multilevel feedback queue

跟 multilevel queue有點像但其實完全不同名字很像但完全不同那你可以想見大部分的系統其實全部都用 feedback queue因為那是最可以 runtime 去做選擇而且其實不需要去 rely複雜的數學的一些東西不像 shortage job first 的那個approximate 的那個做法那個可能會太 time consuming然後model 的設計有時候並不是那麼的 flexible對不對很容易會有 prediction 的 error那 feedback

其實是最直接的好那這只是讓大家知道而已啦就是說其實在這方面就是 scheduling對於系統而言不僅僅是作業系統任何的電腦系統你都會發現scheduling會是其中一個非常fundamental核心的一個機制那scheduling的algorithm怎麼去evaluate我們剛才看見的第一個你要去定義你的performance matrix是什麼就是你是要minimize你的response time還是你的wait time還是你的turnaround time不同的application你要選擇不同的objective那第二點當然就會propose一堆的演算法對不對

那有一堆的演算法之後甚至於可能有些是theoretically證明它是optimal的有了這堆演算法之後你就要去evaluate說到底你今天propose一個新的它到底多好對不對那eval uate的方式我們剛剛那種做法就叫做所謂的這種deterministic的modeling就是只是說我把這個input全部都給你就是什麼都知道然後你就用模

擬的方式然後就像我們剛剛所有的size的例子一樣走過一遍那這個case它可能是最好的這就是所謂的deterministic modeling那這樣的做法當然最重要的問題就是它不generalize因為你今天只要input一改變那你結果可能就完全不一樣對不對就像我們說first come first serve如果進來的本來就是先短的再長的它表現得不錯可是如果先長再短哇 它變得最糟

所以不是很fair對不對它並不是很有理論基礎的它只是像一個例子一樣但是這是一種方式去先去了解它intuitively概念上來講它會不會有些問題那是比較基本的一個做法而已那比較多人的做法呢或者說比較嚴謹的做法最嚴謹的就是用theoretically的model因為其實一個scheduling它就是一個q很明顯對不對

一個q或者multipleq它都是q所以其實大家知道有一個叫q-in theory的東西因為這實在太popular太重要所以其實所有的scheduling algorithm其實都可以去設法把它map到一些Q-in的模型上面去，不一定可以找到exactly match，但是很多人會想要去找一個能夠去表達它行為的Q-in模型那你就可以用theoretically的方式，也就是機率的概念去

做分析所以你就會得到東西就是百分之多少的機會我的wait time是多少百分之多少的機會，它的average response time是多少所以就是theoretically非常一些機率下的原則你可以去評量它的好壞這個是很多人會去做的方式，但是畢竟它是theory，所以你知道在practical來講很多時候第一個你其實沒有辦法找到exactly match的QE模

型所以你都會有些assumption那些assumption在真實世界裡可能不會存在所以會有落差所以它其實有它的limitation就是基本上這種theoretical的一個分析而已；再來你就可以simulation對不對，所以說其實有點像是第一個的generalization就是我不會用手或者是整個build up一個simulation去寫一個程式然後去把這個演算法implement進去然後我會去收

集非常非常多的workload那這些workload的產生有可能是第一種就是real system的log對不對所以大家知道很多公司很多computer的公司他們會提供一些log或者自己去收集現實生活的log然後去產生出到底系统里面什么时候有哪些job它的burst time的behavior等等然后就未进这个simulator然后去看你的algorithmimplement进

去然后看它算出来的every response time等等的好坏那就是simulation那当然更进一步simulate也觉得不错的话你就会implement那implement差别在哪就是它会加入更多现实中会有的一些overhead比如说context switch的时间你在simulation你可能就不care但是real的它就是會在那裡那誰知道說不定它的影響就開始變得很大像是你

把time quantum設得很小那simulation如果沒有去模擬這個你不會發現它的壞處你一步一步進去之後你就發現你必須做這件事然後overhead累積下來其實很大所以time quantum不能夠tune得太小所以就是implementation所以這只是讓大家稍微知道就是說scheduling其實是一個很general的問題然後typically大家就是用這些

不同的方式去evaluate它的好壞那各位當然在我們課堂裡大概只會用到第一個deterministic然後大家去implement了Homework 3之後當然你也可以選擇用其實比較像是這樣應該算是比較還沒有到implementation畢竟是一個simulator OS的simulator但是你就可以去模擬它的一些behaviour那如果你去collect一些real的trace那你可能就比較可以更去嚴謹的去看你設計的演算法到底是好還是不好好所以我想這一塊大家最主要的就是這些argument尤其是pre-emptive non-pre-emptive知道怎麼去這個模擬它的結果然後有feedback queue跟

這個Multi-level Q這兩個要把它區分出來那當然我們講的這些Performance的Metrics衡量它好壞的這些定義一定要記清楚因為記錯了當然算出來是不對的所以千萬不要搞混了.