undefined
好，那接下來我們會稍微補充一些這個算是Additional的啦，所以就是一些跟Scheduling相關的，尤其一個很重要的是我們剛剛談的scheduling都在software level都是OS的软件CPU的ready queue的scheduling可是我們的電腦系統不是只有软件不要忘記下面有hardware就是你真的computer的hardware而且這個hardware我們知道現在的電腦就像我們一開始提到的都是Modi processor然後還有Modi core

所以Multiprocessor的意思就是你不只一顆CPU啊對不對你其實打開你的主機板它有兩個插槽CPU插槽所以那就是Multiprocessor然後咧一個CPU你買來裡面它就是Multi-core對不对所以我們說手機有八核心的CPU四核心的對不对所以它又有更多的直行的Core在那裡那甚至於我們等一下會提到像一個Core裡面你甚至於一

個Physical Core可以讓兩個Thread對不对 juste是執行序我們知道像Intel有HyperThread那新的很多一些Computing Device像GPU它的一個Core可以Run Thread的數量更多可以到十幾個甚至於二十幾個以上所以其實這個Core數在Hardware這邊你可以看見它也是一層一層抽象然後可能是很多的那對於軟體OS這邊它Care的是什麼呢就是下面的這個

他就是排順序而已就是 Hardware 跟他講我現在有 Slot 空了然後你可以選一個 Process 給我那至於我到底一次有多少的空的然後被選中的那個人到底是 Run 在哪一個 Process哪一個 Processor 就是哪一個 CPU上面的哪一個 Core或者是跟哪一些 Hyper-Threading 混在一起這全是 Hardware 決定不是 OS 了所以 OS 就是軟體跟下面的 Hardware CPU

這邊其實也是兩層的 Scheduling那我們剛才提的都只是 OS那所以我們這邊這裡最重要就是讓大家建立這個概念然後其實是有軟體硬體的然後我們會這邊硬體會稍微講一下它的一些考量點最後當然 Real-Time Scheduling我們會提非常重要因為我們剛才就說過Real-Time OS或是 Real-Time 的一些 Application是很特殊的

他的考量完全不同對不對那為什麼可以 real time他的重點就是你 scheduling 的設計所以你設計的不好大家就會 miss deadline就一定不會符合他的要求你要能夠 meet 他的 deadline就是 scheduling algorithm 要很特殊的很嚴謹的去設計所以我們會介紹兩個 real time scheduling 的 algorithm好那首先就是Multiprocessor這邊所以就是我們說的一台機器你

可能有好幾個CPU啊那OS看到的其實就是我有幾個CPU然後什麼時候我要丟Process給你去執行而已那我們一開始就有介紹過這些Multiprocessor的Computer的話它就可以分成Asymmetric跟Symmetric對不對就是所有的CPU角色都相同或者是其中有一個CPU角色是不同的那如果有不同的話通常為什麼

不同就是因為它有其中一個CPU是Master它會負責管理這整台Computer上所有的Process所以通常OS選中的Process就全部交給那個Master的Processor的Hardware上的Scheduler去Schedule就好然後那個人再去分配我這個Process要run在哪一個Processor上面去那相反的如果是Symmetric就是沒有Master所以造成的結果通常就

是其實所有的CPU會去競爭同一個Cube因為其實選中之後是先放到一個進到Hardware之前的Cube然後讓CPU去拿所以這個時候就會有Synchronization的issue因為一個Process當然不能同時執行在兩顆CPU上所以你去做DQ的動作其實同時可以做DQ的時候你就要確保只有一個人可以拿到所以Symmetric 的話就是會變成只

有一個 Ready Queue然後這個 Ready Queue 不屬於任何人然後大家要去透過Synchronization 的方式來去看到底誰可以搶到他那所以通常就會慢那麼一點點很小啦就是稍微慢一點因為你畢竟要去做這個Synchronization 嘛那但是 Master 的壞處我們也講過了嘛N-Symmetric 就是當 Master 的那個Processor基本上不會拿來執行任何一般程式所以有時候他就使用率會很低

所以一般電腦當然你看到的還是所謂的SMP的架構那不要忘記這個指的是Hardware Level那邊那另外一個非常重要跟Scheduling其實息息相關的就是Affinity也是我們一開始就有跟大家點到過的那其實這邊你就會發現跟Scheduler會有很大的關聯性那如果大家還記得的話Affinity的意思就是我一個程式我會把它綁在一個指定的CPU core上面，所以一定要

run那個core，那個core如果被別人佔總，它就要等就對了那這樣的好處就是我們說過它的cache可以reuse，因為最底層的L1的cache通常不同core是分開的所以為什麼大家會用Affinity的原因就在這它會跑得更快，所以如果你很講求效能然後其實你Round的Process數量你是可以Control的話大家都會用Affinity下一個指令跟OS

講 OS跟Hardware講就可以把它綁在這個上面那所以這跟Scheduling有關因為這等於是在Scheduling上的一個限制對不對，所以你限制這個OS，它只能夠Schedule在這個Process上所以Affinity其實是透過Scheduler來控制的那SoftHards當然就是所以我們就是它如果真的那個Core的Loading太重了或者它等太久了那我們就把它Sketch到別的Core上那Hard就是無論如何就是得在那你就是不要把它Sketch在別的地方我寧可去等就對了好 那我們時間好像不夠了那我們今天就只能上到這裡.