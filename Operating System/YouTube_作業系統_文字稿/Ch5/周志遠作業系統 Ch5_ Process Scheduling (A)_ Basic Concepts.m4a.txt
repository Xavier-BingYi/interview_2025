undefined
那我們上面一章節講完了Thread的部分所以接下來我們要講的下一個章節也是你們作業三會需要用到的就是Process的Scheduling雖然我們這邊講Process不過我們剛才也看到Thread跟Process其實很多OS裡面是把他們當作一樣的甚至於其實說Thread可能才是最基本我們說執行一個這個CPU我們在做執行的時候它的最基本的單位對不對

但是其實這邊講Process Scheduling指的就是我們在執行在CPU上面的instruction是來自於哪一個執行序的這個決定所以並沒有特別去分它是Thread還是Process基本上就是去使用CPU的最基本的執行單位的Scheduling的問題所以我們會先講一下這個Process Scheduling這邊指的到底是我們因為其實我們OS運作有很多Scheduling對不對之前有講過Job的Scheduling有CPU的Scheduling有Meetem的Scheduler對不对所以這個章節其實只會Focus在所謂的CPU Scheduling這裡而已那我們

會看見CPU的Scheduling所有的Scheduling Algorithm可能有很多但是有一個非常重要的就是不管是什麼Algorithm都有區分為所謂的pre-emptive跟non-pre-emptive就是他能不能夠去執行到一半的時候把別人打斷然後做替換的動作所以一些很基本的很重要scheduling這邊的一些定義會先講一下然後呢我們就會go through好幾個scheduling的argument都是蠻基本的那各位的作業三當然就會去implement這些argument在我們的NACHOS裡面然後一樣會在

多補充一些就是跟scheduling比較有相關的一些issue或者是一些Linux所以我們會稍微介紹一下Linux還有Solaris這兩個就是practical的真實的OS它們的scheduling algorithm的設計是什麼你當然會發現again它會mix很多不同argorithm的概念在裡面並不是屬於或者完全就只是實作某一個特定的argorithm完全就只是一些

概念然後把它湊在一起他認為測試之後他認為是比較符合這個作業系統使用者的一個scheduler所以我們也會講其中的兩個作業系統的scheduling algorithm好那為什麼要scheduling對不對為什麼要scheduler的存在尤其是為什麼要 CPU的scheduler就是again因為我們有Multiprogramming的系統對不對所以我們會塞很多的process到我們的memory裡面

他們可能同時都是Ready的但是我們的CPU的Core其實是有限的但我們就可以透過Scheduler來讓我們的CPU可以不斷的執行Instruction增加它的使用率那這是Scheduler最主要的目的那以這些Process的角度來講其實它的執行的過程中不是在做IO就是在做計算這是我們知道的所有的電腦系統所有的程式都是這樣它只有這兩種behavior其實對於系統而言那不僅僅是說它只有這兩個behavior而且如果你

把一個程式它的每一個instruction把它breakdown下來的話你就會發現它就是一堆burst就是在所謂的CPU的Burst跟IO Burst所謂CPU Burst就是說這一連串的instruction全部都在使用CPU的cycle這就叫CPU BurstIO Burst就是相反的這一連串的instruction都在做IO這就叫做IO Burst所以我們的程式其實就是在這兩

個burstness之間在做替換我一下要做CPU一下要做IO一下要做CPU一下要做 IO所以其實所有的程式我們都可以把它break down成一個程式執行的過程就是在CPU burst跟IO burst之間在做交換而且是而且是。 Exchange的就是說一個CPU Burst之後當然是接IO Burst，然後IO Burst之後當然是接CPU Burst，因為一個Burst它並沒有做

任何限制嘛，只要是CPU都在做CPU，我就可以把它串在一起變成一個Single Burst。所以整個程式就是在這兩個Face之間在那邊交換而已，那當然對我們CPU Scheduling我們Care的是什麼勒，就是CPU Burst，因為IO Burst的意思就是說這個程式勒目前它要做IO，所以他們會被放到Waiting Queue，然後在那邊做IO，然後沒有辦法被執行對

不對，所以CPU的Scheduler根本看不見正在做IO Burst的程式，我們看見的就是現在已經Ready，然後要進入或是已經在執行一個CPU Burst的程式，但是我們要決定誰可以開始執行他CPU Burst裡面的Instruction好，所以對程式而言我們其實都其實在對OS他要去管理這些Process或者說一個系統的管理者他要去怎麼樣去Tune他的

整個系統的Performance的時候其實都會需要知道這個是。一個CPU棒的程式還是IO棒的程式可能有些同學也有聽過對不對所以就是每一個程式進來其實對於一個你要管理這個程式的使用者而言你都會想要知道他到底是吃CPU比較多還是吃IO比較多也就是說它是卡在它的效能是卡在CPU是CPU的速度不夠cycle不夠還是說我的IO像我的Disk太慢對不對我的Memory太慢對不對

我這個IO這邊的Access太慢然後卡住那其實對到這個CPU Burst跟IO Burst的意思就是當它是一個CPU Bump的程式的時候意思就是說它可能在程式過程中你會發現它有一些非常非常長的CPU Burst舉例來說你有個for loop裡面就i等於i++就這樣子然後從1到1萬那這就會成為一個很大的CPU Burst對不對所以因此這個程式可能就變成一個CPU磅的程式那IoBus的程式是什麼

咧反過來講就是它沒有這種非常非常長的CPU Burst那這種時候就會變成Io Burst原因是因為CPU都是很我們知道很快嘛它的執行速度遠快於IO對不對所以說其實當我們的CPU雖然你看到很多程式嘛似乎它都要CPU的使用但是如果它沒有連在一起變成一個非常非常長的非常

非常大的CPU Burst它只是一堆很小的CPU Burst比如說我i++之後我就開始讀然後read之後就write出去，我read進來i++然後把這個值加1然後又把它write出去。你會看到我似乎就是幾乎就是一個CPU；然後就兩個IO對不對。可是問題是，這些CPU，它其實執行時間非常非常短，所以你還是會變成IO Burst

也就是說，你要CPU Burst的條件就是一定是因為你有非常非常長的CPU Burst。 ema大部分的程式，其實就是有只有少數的IO Burst，但是有一堆的CPU Burst然後它的長度都是很短的那，所以到頭來最後你可能還是卡在IO這邊所以這就是剛才講的其實一個程式，在OS這邊，它在整個運轉在管理它運作的過程中，

它就是兩個人的一個交換而已然後大部分的。 ema你可以看到這邊就是instruction所以只是一些example所以CPU就包括像是你在load memory去access memory或是你在做一些加減乘除那IO就是你在那邊做wait for IO的動作，就是你在那邊已經在那邊寫了或是讀了對不對。 ema這只是一般觀察就大家可以就是應該要知道的

基本的一個概念就是任何的大部分的程式，如果你去break down說它每一個這個這邊是CPU Burst的分佈圖，就是我的程式裡面有很多CPU的Burst對不對，那麼這是一個Histogram意思就是說百分之多少的CPU Burst它花了多少的這是所以應該是這邊是百分之多少的CPU Burst它花了多長的時間這單位是mini second所以你會看見大部分幾乎所有的CPU Burst都是非常非常短這其實是可以預期的因為你大概就執行個三、

四個CPU Instruction然後就開始做IO了那每一次做的其實它的時間都很短約一個CPU Instruction或者說就算是十個好了其實時間都相當短所以大部分的CPU Burst都是非常非常短的那但是呢你還是會有CPU BOMB的程式就是因為其實你有一些CPU Burst會非常非常的差那這種時候它就會變成一個CPU BOMB的程式不過大部分的其實大家可以預期以現在電腦的這個技術CPU越非常快所以大部分的程式其實都是BOMB在IO對不對

這也是為什麼我們的OS要load一大堆程式到我們的Memory所以說大家都卡IO嘛所以CPU每次做所以你有很多程式來那我就可以大家來去使用CPU的cycle了好所以我們這個章節講的CPU的scheduling或是說process scheduling指的就是這個CPU的部分所以就是我們剛剛說的就是在ready queue裡面誰可以進來到running state去使用我們的call去做執行那個scheduler

所以當你進到IO Burst的時候其實跟Scheduler是無關的因為你進到IO Burst那你就會強制的自己對不對去換到Waiting State那它也還沒有在Ready因為它還在做IO在等嘛對不對所以Scheduler也不會在這Queue裡面看到它所以沒有Scheduling的問題那但是呢它做完IO回到Ready Queue了那這個Scheduler它就可以去考慮要不要讓它先做執行的動作了

所以我們今天談的就是這個CPU的Scheduler那Scheduler這邊非常重要就是我們剛才說的有所謂的Prehentive跟Non-Prehentive這是非常非常重要的基本概念那Prehentive Non-Prehentive意思就是說你的Scheduling的點什麼時機點你可以做Rescheduling的動作那如果你看整個我們說整個Process的

Life Cycle就是從Waiting到Ready等等State的轉換這個角度來看的話你可以做Schedule的點基本上最多就是這四個第一個Running to Waiting意思就是說原來正在執行的程式它自己到了Waiting這就是代表它做IO了所以它正從CPU Burst的結束它現在進入IO Burst那這時候這個Process就會換到Waiting State那我

們的CPU就空了所以這時候scheduler就會被叫起來對不對然後看誰要來去做下一個執行所以這就是第一個狀況第二個狀況勒是running然後到ready這個是什麼時候勒你既然都在running了為什麼會又被踢到ready勒這就是time sharing嘛對不對所以你有timer file出來我每100個mini second我就file一次timer說我要做sharing rescheduling

所以雖然說你還在CPU Burst的Cycle裡面可是Timer出來了所以這時候我就把你Kick out強迫你回到Ready State然後讓我們的OS重新掌控權看看誰要繼續執行也可以選同一個人但是他也可以換別人這樣就可以Share我們的CPU Cycle了第三個Waiting到Ready這就跟第一個倒過來也就是一個程式他的IO Face做完了

他又回到ready state了對不對所以他是一個新的candidate對於scheduler而言說不定剛做完IO的這個人他是很重要的人所以我們可能想要讓他立刻進到執行的這邊所以這就是當你的waiting進到ready的時候代表你的ready queue有新的candidate那這個時候你也可以trigger scheduler來做新的決定。最後一個termination指的就是一個process

從running到terminate啦。所以這當然不用講啦。所以一個process執行完當然scheduler應該要被叫起來看看誰可以去使用這個CPU的cycle對不對。所以這是第四個狀況。根據這四個狀況所謂的non-preemptive，它是什麼叫non-preemptive呢？就是說你不能打斷人家。所以這是比較detail的這個信息，但是什麼叫non-preemptive其實各位可以從字面的意思來講就是

說你不會打斷別人的schedule也就是說現在在執行的這個人如果他可以繼續執行也就是他在一個CPU Burst的中間的話你就不要去打斷他這就叫做non-preemptive。所以你可以看上面四個condition第一個Running到Waiting，所以我們剛才說了這就是從CPU Burst變成IO Burst所以你CPU Burst已經結束了所以不打断。個狀況non-preemptive就會去做scheduling的

動作，第四個terminate當然囉，所以它根本就結束了嘛，所以當然也是代表著你的CPU burst全部做完了，所以這也是non-preemptive，所以non-preemptive呢，它只會在1跟4這兩個狀況下會做rescheduling的動作或者說會去做scheduling的動作，相反的preemptive的意思呢就是我們說的它會打斷你，只要有機會只要是需要的，有可能會改變我scheduling decision的時間點，

我就重新做scheduling，所以簡單的就是一二三四全部都會對不對，所以你看二跟三的意思，二就是我在running一半到ready，所以實我們剛才說他在CPU burst的中間對不對可是因為我的timer起來了，所以我就run到一半，我就被kick out出來，那如果是pre-emptive他就會去做scheduling，他就會去選，他就有可能會選別人，所以本來是E這

個程式CPU burst run到一半，他就因為這個timer出來我的scheduler是pre-emptive所以他就說好，我打斷你，我去run第二個程式，你就在ready queue裡面再等一下，那就是叫pre-empt ive了，如果是non-pre-emptive這個狀態發生的時候，他會知道我是non-pre-emptive，所以即使他被放到ready state，我會馬上再把他放回到running state去，因為我不能打斷我知道他還沒做完嘛，所

以我就把他放回去所以這就是pre-emptive跟non-pre-emptive他們的決定就會不一樣，waiting到ready對不對也是同樣的意思，就是說在running的人，其實他正在running啊，所以他還在他的CPU burst的中間對不对，所以譬如說我們那是程式1好了對不对，然後這時候程式二，它從ready進到ready它從waiting進到ready了，那如果是pre-emptive它就會去判斷Process二會不會是一個更好的程式，它的priority是不是

更高對不对，如果更高更好Pre-emptive scheduler就會說Process one你現在直接讓開來讓Process two執行那即使你在CPU burst的中間我也把你打斷，這是pre-emptive，那如果是non-preemptive lane他就會ignore這件事情雖然有新的candidate進來可能是更好的可能會更重要的可是礙於他是non-preemptive的scheduler他就決定讓他繼續跑跑完之後我們再說對不

對所以他跑完之後either那個人進到waiting或者是terminate那這時候scheduler才會去把processer拿去做執行所以就是preemptive跟non-preemptive所以簡單來講就是他會不會在CPU burst的中間打斷它其實這是最容易去判別的因為之後我們會介紹不同的Operation各位就是去模擬在一個CPU上面它現在在

執行哪一個程式的CPU Burst如果說今天你畫它的過程中它只CPU Burst畫到一半就會換別人那就是Pre-Active那如果是你一定要把那個CPU Burst run完才能夠去換人的話那就是Non-Pre-Active所以其實是很好做區分的那時間點就像上面看到其實在實作上的角度來講就是四個conditionscheduler會被叫起來他會去做判斷什麼時候可以做rescheduling就可以

implement不同的argorithm好那對於pre-emptive的這個scheduling其實它在大部分的系統雖然是PREENTIVE 跟 NON-PREENTIVE 最大差別在哪裡呢其實大家應該也可以猜得到Prehentive 的效能通常比較好對不對因為我比較DYNAMIC我可以Schedule 你的時間點比較多我有四個時間點另外只有兩個所以其實它是一個 Super Set所以DYNAMIC Scheduling或者說Prehentive SchedulingScheduler一定通常可以讓我們的 CPU 的使用率達到更高或者是達到更好的整體的系統效能

但是它有一個很大的缺點就是你在CPU Burst的Round到一半的時候你把它打斷會產生Synchronization這件事情我們第六章的一開頭就會給大家看到一個example現在大家先稍微知道就好之後就會有一個很明顯的例子去證明這件事情所以你現在需要知道就是Prehentive它基本上它有一個很大的issue就是當我們的CPU Burst執行到一半你在做Content Switch的話會造成Synchronization

那如果是一個CPU Burst全部做完意思就代表什麼呢一個Process沒有再Touch Memory了因為CPU Burst才會去Access MemoryIo Burst是Access Disk跟其他的東西那Synchronization呢只會發生在Memory所以說當你 CPU執行完Io是其實不會造成Synchronization的所以說你在CPU Burst執行到一半的時候你就要去會有Synchronization的問題那Programmer就要去解這個問題

那當然我們就像之前一再講的這個其實是很浪費時間的事情或是很複雜的事情所以就會影響到了OS了因為當我們說被打斷的時候不只是User的程式包括了Kernel自己的程式也是CPU Scheduler在Scheduler的Process之一所以今天如果你的OS是使用一個Pre-Emptive的Scheduler事實上大部分OS是這麼做因為你的整體效能才會比較好那你就要解決Synchronization那解決的方式是什麼呢你可以

看見基本上第一個就是你可以在你的Kernel程式裡面自己要去做Synchronization的solution所以你只要去access一些shear的data structure你可能就要去那邊做lock跟unlock的coding才會make sure你的OS自己不會有Synchronization的issue那當然這就是很囉唆OS變得很複雜第二個solution你可以看見其實大部分Linux這邊Linux作業系統的solution就是當我們是在run一個kernel的process的時候它會把interrupt給disable它會把schedule的這個interrupt把它disable掉意思就是說

因為你只要disable了timer的interrupt其實就不會打斷自己啦對不對就不是Time Sharing了意思說Colonel在Run的時候就沒有所謂的Time Sharing他就是一次把它執行完所以你只要把這個Timer把它Disable掉之後其實你的Scheduler就會從Pre-Active換成了Non-Pre-Active的Scheduling了所以其實大部分的Trick是這個樣子就是用Pre-Active的Scheduler但是當Colonel的Process在執行的時候

它會disable你的timer然後就讓這個OS的程式自己把它執行完不讓它打斷那這樣就不會產生synchronization的issue了所以這個是一般作業系統其實是用pre-emptive但是為什麼它可以減少它kernel implementation的effort的原因就是它採用這樣子的一個方式所以這again again就是告訴大家為什麼kernel programming通常要寫得很精簡

因為其實你有很多的代價其實你如果寫得又臭又差那你整個系統的反應就會變得很慢因為它其實很多interrupt被disable掉了那這只是稍微知道就好所以我們知道有scheduler是這張的重點它的scheduler的目的就是在選誰要做下一個執行那在OS裡面除了有scheduler之外其實它下一個人是叫做dispatcher

因為scheduler只是負責選誰要做執行對不對那選了之後呢他就會把這個決定告訴dispatcher由dispatcher去執行這個換人的動作所以dispatcher在做的就是這件事情所以之前我們教過的context switch其實是在dispatcher這一個module下面的動作因為他知道要換誰了嘛那至於到怎麼換這是dispatcher去implement的動作

那當然還有像是program對不對所以你讀instruction loading的位置啊所以你讀到不同的process換了所以像是你的我們之前教的這個page table的pointer對不對還有你的program counter等等這些動作就是dispatcher在做的基本上就是幫你把它load到新的這個state就對了好 所以基本上它的這個稍微知道就好啦所以Dispatcher這個動

作其實也需要花一些時間那最主要的時間就是在於這個去做Context Switch然後當然還有這個Interval Enable Disable各位在作業上在Trace Code的時候其實你要特別留意你應該會看見這一行就是當你在做Context Switch在做Scheduler之前它其實會把 Timer 也會做 Disable 的動作所以大家 Transcode 的時候稍微留意一下應該會看見那一行然後當然就是 Scheduling所以你要做 Dispatcher它是比較大的 Component所以它當然就是 Quick Call Scheduler做 Scheduling 然後做 Dispatch 的動作.