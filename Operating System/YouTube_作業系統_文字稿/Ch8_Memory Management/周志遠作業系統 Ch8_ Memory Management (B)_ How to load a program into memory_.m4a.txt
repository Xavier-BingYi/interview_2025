undefined
所以之後我們講Pagent Segmentation全部在講的就是這兩個Address的Translation的部分在講Translation之前我們就先介紹我們剛剛說的了竟然有了这个wrong time的概念在里头了那所以我们其实是可以为了优化我们的这个memory的使用就会有出现了所谓的dynamic loading跟linking的做法好所以第一个什么是dynamic loading当然它就是跟loader有关嘛意思就是它做的事情就是要把你的program

這些Memory Accountant把它Load到Memory裡面或者是把它可以Create出來就是Loader在做的事情我們剛剛講過了那早期的Loader我們稱之為Static Loading的意思就是那我就把整個Memory當你要Run之前我把它Create出來放到Memory裡面去全部都放好所以你就可以開始用但是這樣的問題是什麼呢就是你要把整個Entire Program對不對它的memory content

全部create出來而且全部要佔住那個memory的空間但是你們都寫過程式就知道你的程式往往會使用allocate了一大堆memory卻不用它舉例來講你可能create一個integer array一萬個element因為可能破關寫得不夠好其實你要只要十個element的位置你就allocate一萬個因為不小心多加了幾個零反正很容易那你也知

道對電腦而言supposedly就是他就要allocate10倍100倍的空間給你而且在low time的時候他就要把它暫住對不對你這個program要嘛所以我就給你那就會浪費掉非常多可能根本用不到的memory空間所以對於整個電腦效能會很差所以其實這個問題解決一個方式就是我們俗稱的dynamic loading也就是說其實我是在用的時候

我發現你真的要的時候我才去把它load到Memory不然其實它不用急著去把它allocate出來所以就算你今天寫了一萬個0或多寫了十個0多寫兩個0、三個0其實如果你沒真的用到那個空間或是沒有使用的話我們OS它可以不去把它真的去allocate它可以就放在那裡等你要再使用就好那當

然如果你把它這個概念啦我們剛才舉的例子是那種你的variable的空間所以這個其實比較難管理的那對於OS呢它沒有做到這麼底層但它有做到的是以routine的概念在做loading也就是以function codeloading這個routine意思就是function code啦所以意思就是這個function code你要code到它的時候它才會load得到memory裡面

去沒有code它其實是不存在的它就只是一個code嘛對不對所以code它這個function code要使用的memory空間我就全部都先不用allocate我只要知道這個code有被define就好好所以就像我們剛才說的為什麼是做在routine的level呢因為你會發現其實這個程式裡頭你一定會寫很多的function code尤其是OO的概念你寫更

多了對不對你寫一堆method然後define一堆object可是不一定真的會用到因為程式的特色就是它都是dynamic所以你runtime在看你要不要用所以實際上的結果是大家觀察到一個program其實有非常多的routine從來沒用到過因為它要support各種可能性但事實上可能性實際上的只有一個pass而已所

以其實很多function code根本不需要漏到memory頭去尤其是如果你到了公司跟commercial code你會看見更是如此因為可能70%的function code全部在處理error handling就是在那邊，robust我們都知道早期電腦常常會boost screen軟體會crash很討厭，那怎麼辦？就是你要處理很多的Error Handling各種可能性都要考慮，所以寫Program當你在開發Product Code的時候可能80%的時間都在做Testing還有寫這些Error Handling，但是每個Error Handling都是一個Function Code所以你可以

想80%的Code都是沒有用的本來就不應該被用到所以這些Code當然我們就不想要把它漏到Memory頭去這邊甚至我以前有聽過一個笑話，不算笑話，是真實的經驗，是IBM那邊的人說的曾經他們就是有一個開發好的應用程式，只是為了想要加一個flag去做一件很簡單的事，print out某一個message而已花了他們將近半年的時間，因為他要從頭到尾 tester過一遍然後每一個這個地方有沒有會造成error

然後花了很多的時間，加了很多的程式碼再加那一個flag，那你就可以想見那個effort很大而且會造成很多不必要的浪費，所以用這個方式loading它就可以避免掉這些不用的function，不需要load那這個所謂的dynamic loading，這個概念什麼時候可以在Runtime load進來這個方法呢OS是提供這個功能的但是OS不會主動幫你去做這件事

在現在一般的OS裡面的設計並不是由OS來決定哪些function code是屬於dynamic loading的function code哪些不是其實是交由使用者來做決定的那我們來看例子到底是什麼各位都可以直接用這個technique了programmer嘛所以其實在C裡面大家都很熟悉普觀在C裡面來例子的話來講你想要用dynamic loading的方式就是這樣而已其實不會很難就是你會去include這個dynamic function.

h的header意思就是它可以去使用這些system code了嘛 對不對那方式呢你可以看見就是這樣你會把你的這些需要做dynamic loading的function先把它自己compile成一個library這個如果大家不清楚你稍微查一下就知道其實並不是所有的 function code 要直接所有的程式要直接 compile 成執行檔我們可以不需要有 main那樣的情況下就是我們俗稱的 library像 C library 對不對所以你其實是可以把你自己寫的 function code變成一個 library 的這個程式嘛那裡面就會有很多的 function那這些 function

呢在這例子來講就是我們 runtime 會想要去link到或是使用到的這些function code所以你就像這邊看見一樣我們會先define一個cosine比如說cosine這個function那我們給它一個function的pointer所以代表這個程式知道有這個function的存在那這邊會有一個handler這邊就是在dlopen的意思就是我們把這個之前conferred library把它打開來註冊的意思所以裡面就會有很多的function是所謂我 runtime才會去

access它的function那我要把它定義這些function是所謟的dynamic loading的function的話就是在我的code裡面在wrong time做這個binding所以你可以看見cos這個function到底是什麼勒它是這個system的dynamic library裡面的這個cost裡面寫的那個function那這邊開了嘛所以他會找到所以他會知道是在這個Library裡面裡頭會有一個叫做COS的function code這個會跟它是同樣的東西會對在一起所以就等於是知道它是一個dynamic loading的function了好那這個function竟然是dynamic loading意思就是說

當我們這個程式漏到memory的時候這些function code並不會漏到memory只有當你code了這一行我call了cosine它知道cosine是一個dynamic loading的library是一個function所以wrong time的時候這時候我才會把它去從library的那個image裡面disk. code裡面把它load到memory開始執行所以這一行其實就是你在用一個dynamic loading的function然後當然就關掉嘛把它deregister等等

所以這個就是各位在coding裡面你想要用dynamic loading的方式就這幾行而已那dynamic loading有很多好處其實對於系統而言我們剛才提到它是主要是來解決這個memory浪費的問題對不對對於programmer呢如果你看著這個code你應該會發現它讓programmer很有彈性因為我今天define了一個cosine的function可是我在

runtime我才要去做binding我才要去決定到底它是bind的到cosine還是我後面可以一個cos double意思是它可能是比較精準的一個cosine function我不同的OS 不同的系統它有一些function有捨破 有一些不行你知道很多這種library的問題所以你可以在runtime根據你當下一些logic一些program去決定到底要call哪

一個function call所以dynamic loading其實現在的programmer的用法大部分其實並不在care memory夠不夠啦那是OS的問題programmer會想要這樣做就是因為他想要runtime決定那個function是誰然後去使用它所以這個function其實會變成一個dynamic loading的一個function所以簡單的圖示如果剛剛那個code還有點抽象的話對於OSM會發生

的事情就是假如你一個程式本來有define的三個function如果是所謂的注意到這只是disk image所以只是各位compile出來的binary code所以有很多的東西可能都在裡頭了那如果是static loading就是我們知道的它會整個就load到memory可是如果是dynamic的話呢當我在init的時候假設B跟C都是透過我們剛才的

程式碼 define成dynamic的library的話那其實一開始就只有這些static的function會被load到memory而已那當你call了我們剛才define的這個loadingdynamic的這個function的時候它才會被load到memory所以你不會load我們這邊可能ABC一直到Z嘛對不對無所謂其實我們都不會把它放到Memory裡面去那你摳完了對不對自然它就可以

離開所以它就會Dynamic的去使用Memory的空間了好 可以齁所以這個是所謂的Dynamic Loading那其實是Programmer去用這個技巧的那其實現在比較多是拿來做剛才說到的就是有一點像Inherit的那個概念OO的那個但這個它是以 function library 的方式在那邊動態來決定到底是誰好那剛剛我們講完 loading 了所以有 static 跟 dynamic loading接下來我們要講 linking那什麼是 linking 咧大家應該都有這個觀念就是在我們的這個 program

裡面對不對我們 call 一個 printf就代表你要去 link c library 對不對所以我們該 include header 目的是什麼就是因為我想要去link某一個 library嘛 對不對這樣我們的程式才會完整至少要link我們的system的library 對不對那這個library所以我們都有經驗像cprogram如果我們今天電腦系統裡面有很多的program有很多program的話那你在link的你在一定每個program如果都是c它就會有clibrary 對不對

所以每一個人是不是都會去include C library然後就會去link到這個Library的部分所以如果今天我們要把三個程式因為電腦ROM很多程式所以所有使用到C library的程式如果在同時執行的話其實這個Library會重複的被漏到我們的Memory裡面雖然說對於一個單一程式而言它沒有重複用然後它也一定要用但是其實對電腦系統對OS而言你會發現跨Program之間它其實有很多Duplicate的這些Library那就會造成浪費的事情所以我們先下課回來我們來解釋一下這個怎麼樣Dynamic Linking的方式去解決.