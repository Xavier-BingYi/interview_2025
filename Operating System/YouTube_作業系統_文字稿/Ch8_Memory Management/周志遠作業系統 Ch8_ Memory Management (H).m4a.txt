undefined
所以這就是我之前說的，我們這個章節這一塊當然是比較有變化一點。你要稍微去想一下，那所以這個就需要大家多花點時間，然後去消化一下，然後去看課本裡面的那個描述上課的，這個聽完很容易忘嘛。大家可以去那個我們線上系統去看影片，可能再去把我說的話再聽一遍，然後再邊想，然後邊go through一些例子。

這個當然沒有辦法在一堂課立刻洗手，這我很了解，所以大家需要回去再花點時間。但是有幾個很重要的觀念就是大家不要混淆，就是你不仔細讀你容易忘記的事情；第一個，我們之所以要去切這些data structure的原因是因為我們想要把一個這個page table size變小，因為這樣子我們放到因為這個page table要

放在physical的memory啊對不对可是我們的physical memory不要忘記他已經被切成frame了，這有點小啦，不過大家應該還記得對不对；變成4KB 4KB的frame他只有4KB而已喔。所以今天如果你要放一個連續的一個很大的page table的時候，他就必須要連續的frames那這件事情就不太容易做到對不对，因為我們的Memory管理就是希望Discontiguous嘛。那你今天跟我們的

MNU說我要10個連續Frame，這個不太容易不是不行啦，但是會不容易對不對很有可能他就找不到所以就跟你講Out of Memory可是其實你是有Memory的對不對這是第一點很重要的第二點的話就是hierarchical基本上你可以看見其實它的entry數量是變多的只是page table變小而已每一個變成比較小的那它的代價就是你要去lookup很多次所以你的memory access time就會變得比較慢第三點跟hash的差別在哪裡就是這個是一個table所以實際上我們的program的memory的使用不要忘記

並不會是很乖乖的從第0個位置然後開始依序使用這個是ideality實際上不會因為你會dynamic location然後你有heap stack各種memory content對不對所以其實真實在使用的時候你的這個應該說這邊就是你的virtual address這邊你的user space的memory這邊其實它會是亂跳的那如果是table的話亂跳的結果是什麼就是在一個table裡面你只要上面有中間如果有沒用到的那你都還是必須要把它allocate出來對不對

因為我剛剛有跟同學講個例子嘛對不對比如說你要用到的是這個array的第一個element跟最後一個那但是要是array所以你知道你中間就算是沒有allocate的，你知道是還沒用到的page你都還是要保留這些page的entry對不對？你即使有valid bit invalid bit還有我們之前說的lens都沒有效對不对你就是必須要把它都allocate

出來然後用bit後面這個有效無效的這個bit來判斷它是真的有要用到。所以為什麼要hash因為hash的話我們知道它是沒有它是把我們的是把這個一樣是這個pagetable只是我們把它裡面有用到的entry我們才會拿去做hashing放到我們的bucket裡面去沒用到的我們幹嘛放我們不需要4,000LK嘛，因為hashing本身就是一個link list的概念

所以你沒有用到的Entry我們就不會放到Bucket裡面去了。所以，在真實的電腦系統的應用上來講的話，Hashing通常就會比較有效率了，因為你其實並不會把如果你的空間很大，但是你真正使用到的是很散落然後其實數量很少的Entry的話，用Hashing是比較有效率的。你可以省掉很多不需要用到的Entry，不需要在那邊做Lookout

那但是很不幸它還是一個link list啦，所以我們說稍微改良大家可以想見的一些做法就是你可以把它做grouping所以，你一次可以一樣這可以是 4KB啊，所以你可以一次load了1,000個entry在這裡頭，那當然我們的MAU是要一個一個找過去啦，不過呢至少它讀memory只要讀一次我就把1,000個entry一起load到我們的

MAU的hardware然後開始search所以至少可以減少讀memory的次數，所以hopefully大家可以比較有點概念就是很重要就是知道這些不同做法到底是怎麼做。 Adjective translation然後它的好壞處稍微能夠分別一下最後一個最後一個是inverted page table那就如字面所說的，它的想法是我們不要用PageTable了，我們就用FriendTable吧，所以轉換translation它是一個mapping嘛對不對

所以我們當然可以倒過來做mapping喔對不对那，所以我們來看一件例子那用這個InvertedPageTable意思就是用FriendTable那其實我們之前講過什麼是FriendTable呢，就是你這個Table的index其實是FriendNumber所以跟PageTable把它倒過來那因為frame的number是index了是這個table的index所以裡面存的entry裡面存的是page number剛好倒過來就對了，那但是大家不要忘

記一個很重要的點就是Frame只有一個，但是Page同樣數字的Page有非常多個，因為每一個Process有自己的Page Table對不對有自己的Page的值，所以除了存Page Number之外，實際這個Entry裡面還必須要去存Pid，所以我知道這是第幾個Process的第一個Page，比如說，所以每一個Process都有Page Number One所以到底是哪一個Process的，所以這個就是Front Table裡面必須要去存的，那存這個有什麼好處為什麼要倒過來一樣是為了要減少我們Memory的這個使用的問題，那倒過來的好處是什麼就是

我們說Page Table它會隨著越來越多Process我會有越來越多的Page Table，因為每個Process有自己的Page Table，所以我今天我的OS裡面要管一萬個Process就等於我要去Manage一萬個Page Table，所以我其實會用很多很多的空間然後每個Table當然也可能會長很大對不對然後我又不知道它Size是到底多大，因為它動態成長所以才會有前面那些Solution就很複雜，

那用Frame的好處是什麼呢就是我們的Frame是Hardware啊，所以從來都沒變過對不對所以其實frame table它是可以事先就被allocate而且size就不用動它的而且它的使用率應該是百分之百因為其實大家都需要去share這些physical的memory對不對所以其實這個frame table裡面你可以想見啊基本上每一個frame大概都被某一個process的某一個page給贊助了

如果沒贊助的就是你還需要更多空間基本上就等於是out of memory所以它就直接存frame這個table就好就是它的大小其實是被bounded by hardware的size所以這個table就比較小當然會比你一個page table大可是整個系統所有的process的page table的size加起來一定是遠大於frame table的但是我invert it過來的話我就只用frame table去做

address translation那我的size其實就是就是看我的physical memory有多大而已而且這個table大小是不會變的所以我就可以allocate用array我也不用hash了我就直接一個array放來拿就可以但是它的運作起來會變什麼樣子這個有兩個缺點我們等一下就看見了第一個就是它在做address translation的時候，它的時間很不幸的也會非常非常的

長也會比較長啦，因為我必須要去search這個frame table還記得page table的目的就是我可以lookup嗎-mypage是3我就跳到第三個entry嘛，所以我就直接用跳的。但是這邊來講，因為每一個frame它可能是屬於不同的process而且是屬於不同的page所以沒有ordering的順序對不對，所以我們今天讀的是讀完第三個page要讀第四個的時候第四個page會被放到哪個frame我們其實不知道

我們就必須要去做searching的動作那第二點的話來講我們要做shearing就很難了，所以這是它最大的缺點其實我們OS很喜歡做memory的shearing可是如果你反過來的話，因為一個entry只能一個frame只能像這邊來講一個frame只能對到一個page所以如果我們今天一個frame想要對到兩個page那就沒有辦法了對不對，因為這是一個array所以它只有一個entry而已，

那怎麼做sharing可以啦， 但是會很複雜，所以就比較不容易做page的sharing好， 所以我們直接看圖就知道什麼意思這邊還是叫page table可是其實它是frame table因為in verted的方式，所以我們這邊雖然還稱之為page table可是它其實就是frame table了，那它裡面當然就我們說的每個entry就是PID還有它page的number第幾個frame，它是對到

哪一個process的哪一個page所以做translation的時候你就可以看見我們的這個P必須要做scan必須要去search因為我們只會做logical to physical的translation我們的電腦不會反向，因為沒有意義；使用者都是從logical過來的，所以今天給你一個PID跟P，你就是要Search也就是一個一個Entry的去Lookup然後去找到你符合的這個Entry，那第幾個Index，它是第幾個Entry，我就知道它是第幾個Frame，然後我就一樣去做Translation，這個好處就是我們說的，其實我們一般的程式

Virtual address 的 bit 數量都是遠大於 physical address，因為我們用 virtual memory 等等概念嘛對不對，所以其實 bit 數這邊通常都比那邊要多，那這樣倒過來的話，其實這個 size 只是跟 physical memory 的 size 有關，所以它的 entry 數量就是會比較少然後整個系統，我不用一大堆的 page table 了就一個就好了大家都用哪一個就好了對不對所以它會比較的節省我們的 memory 的空間

那缺點就是這個search的動作了那當然你可以argue啦我可以把這個因為它是連續的table entry嘛所以一樣的道理我可以把這整個load到mmu然後裡面再去做linear的search所以可以做一些加速啦所以當然你還可以解決那個問題但是它沒辦法解決的或是說更難解決的問題就是page的sharing這個基本上很難做對你譬如說

你可能就要這邊要 reserve 五個 entry 嗎就是只有五個 process 可以去 share 它對不對然後沒用到的就留空大家自己可以想一想啊當然有些做法但是都不會太好啦所以這個做法很少見因為 page sharing 是太重要了所以實際上會比較少見到這個做法雖然說它真的可以省空間很大幅的省空間時間Search是它的

缺點但是比起說你要好幾個Memory Access不要忘記這是連續的所以其實是可以像Hash那種做法很有效的去節省它的Search的Memory Access的次數啦當然還是要O的N的時間Worst case啦但是Memory的AccessIdeally它如果夠小我可能只要分幾次就可以漏到我們的Hardware那不會需要讀太多次最大問題還是在

沒有辦法捨破Page Sharing或是應該說很困難捨破啦也不是不行啦所以這個是後面我們介紹的這幾個Page Table的做法上Paging的做法上的變化，所以需要大家很清楚這幾個做法。最後了，最後我們要介紹的是segmentation。我們剛剛一直都在講的是paging，但是大家寫Program都會發現你們拿到的不是page4，你們拿到的是segmentation4所以其實我們的OS，它是又有用paging又有用segmentation，而且離使用者、 離programmer這一層比較接近的是segmentation。

那我們就先不要把兩件事混在一起，我們先介紹segmentation，所以大家可以暫時把Paging這件事情放到一邊去。那我們最後會把兩個結合在一起。所以，什麼是segmentation？還記得我們一開始就有講過memory的location分成fixed size跟variable size對不對？ Variable size，那fixed size那fixed size就是大家看到的Paging，因為它就是fixed 4KB的大小。那Variable size，這個idea用

到這個discontiguous這邊的allocation。的話變成的名字就叫做segmentation那，segmentation你可以看見它不只是不一樣大小而且更重要的是，它是以使用者的角度去想說，我要怎麼去切割我一個program的memory，那其實這個切的方法怎麼切其實很straight forward，因為我們都知道我們的program是好幾個Code Segment有好幾個SegmentMemory的Segment 對吧！比如說你有這個Code Segment 對不對，然後你的Code Segment裡面又有分Function 對不對或者是OO裡面你有Object 對不对，所以它都是一個一個的為單位的東西 對不對，

那更不用講我們有所謂的 heap stack，如果各位有學過一點compiler就知道，compiler完之後，你會需要一個symbol table，知道每個variable到底放在哪一個address binding的總之，那又是一個object一樣的東西，所以其實我們整個program組成事實上是比較是這個概念的沒錯吧！就是一大堆的物件，這就是為什麼OO好用！就是這樣其實比較符合programming的behavior

所以其實就是一堆這些，而且每一個size是不一樣的，所以我們的stack跟heap它可能動態還會漲然後這個program有大有小所以它其實都是variable size那所謂的segment認為就是這樣我們的一個program其實我們應該把它切成這些component就是一個一個的物件然後每一個大小其實是個別去處理它可以不一樣然後動態也可能會去個別去做增長的

這就是segment的概念我們把它根據code的裡面的memory content內容把它變成一個一個所謂的segment所以這個動作就叫segmentation所以有寫過assembly code就知道其實它甚至於就直接叫做segment對cosegment然後data segment其實指的就是這個所以完全就是按照其實programmer的這個方式去做切割好那假設這邊我們compile完之後其實你就會去identify出

這些segment出來了那接下來的問題again就是當我load這個program的時候我要怎麼擺它那大家學過paging所以就知道了discontinue概念一樣我們會需要一個segmentation的table做translation嘛然後我就可以把它放到physical memory的任何位置了對不對但是這裡比較討厭的一點我們之後會看見就是你會external的fragmentation會很嚴重，因為它是variable size對不對，所以好處是我們可以一樣可以把它切成比較小的單位，然後個別去擺放，但是一樣要找到有空間的話跟paging比起來會比較困難一點好，那我們

就先來做這個translation那Segmentation 這邊你的 Logical Address 呢，它的這個 Address 裡面內容跟剛剛 Paging 很像，但是不太一樣前面一樣是 Segment 的 Number，所以就是你是第幾個 Segment，然後 Offset 就告訴你說這是在這個 Segment 的哪一個位置，所以有寫過 Assembly Code 就知道你寫 Code 的確就是這樣，所以你會寫說這是哪一個 Segment 開始然後就開始 Instruction，然後其實 Compiler 就會幫你算出來

你是在那個segment的哪一個offset的位置，然後就可以轉換成這個它的logical address了，這邊你可以看見有一點不同很大的不同是還記得page裡面的offset是只有4KB嗎，所以它是一個page size對不對，是放得白一個比較小的數字，但這裡呢Segmentation因為一個segment可以長到任意大對不對，你最大最大的時候你甚至於可以長到

整個physical的大小對吧所以說這裡offset的bit的數量或是說它可以描述的長度其實是不受任何program任何segment的限制對吧你可以所有的memory空間都只allocate給某一個segment也theoretically也可以啦對不對所以其實它的bit的數量是沒有受限的就只跟你電腦系統裡面定義一個segment可以長到多大有關而已所以有些人會定義說你的Dynamic Located Memory只能用4GB意思就是你這邊offset segment offset的bit的數量最多描述到4GB但是total size可能沒有直接的關聯性只跟那個segment可以長多大有關係

那它的table跟PageTable是很像的所以你可以看到一樣基本上每一個entry就指到的就是某一個segment那裡面會存的就是這個segment它的base address但是多了一個東西是這個limit為什麼要limit因為現在你的一個segment的長度可以是任意對不对所以說必須要一個Limit的存在他才知道說你的那個Offset是有效的位置還是無

效的因為每一個Segment它的Limit長度都可以是不一樣，所以不像之前我們說Process有一個那就是Page Table的那個長度嘛對不對可是這邊是以Segment為單位所以每一個Segment都必須要去Indicate說它的Limit到底是多少，那這當然是在你在Compiler OS幫你去決定，有allocated它才會去漲這個limit，不過每一個segment的limit可以是不一樣的好

那這其實跟paging是一樣也就是一樣這個整個segment table我們必須要有一個pointer所以存在process control block裡面，所以我們會知道這個table到底存在哪裡然後裡面就是這些資訊另外一個一樣是lance所以就是這個segment可能一樣一個process可以使用到1,000個segments可是可能你現在只用到前面4個那我就寫了4所以我後

面就不需要去allocate這個table的entry了，所以這個部分是一樣的就只是操作上方便OS做一些判斷而已啦好 所以這張圖就是最重要的這個就是segmentation的address translation所以一樣我們的address變成前面的segment number然後是offset然後其實非常非常像你可以看到就是s會就等於他的index，所以你是第幾個segment那裡頭一定會有一

個base address這裡是加所以加的意思是說我們前面是有點像append一樣對不對，就是說我們知道如果這邊存的是那個frame的base address的話，如果是page table後面基本上都是0對不對，因為你offset是有page offset的決定，但是這裡因為它可以放在可以看到這個沒有任何單位對不對，所以這個segment可以從任意的一個byte的

位置開始然後加上任意的一個offset所以這個加是真的要加也就是我們如果例子的話，就是它後面也有可能會是不是全部都是0的所以它不是剛好落在4KB這個boundary沒有這個限制所以這真的就是兩個數字做相加就對了然後會得到原來的值那這邊是一個很快的判斷啦 對不对，所以你的這個offset其實你會根據這個limit很快的去判斷它必須要小嘛 對不对

超過就代表你是一個無效的也就是各位學過的所以大家一天到晚看到的segmentation fault就跑出來了那如果符合的話它去相加就會得到它真實的位置好 可以齁所以它會多一個limit去做這些檢查的事情所以才說其實你的使用的空間其實每一個segment是完全獨立的去做control的所以比如說你的heap可

能就只能到4GB你的data它說明只有1GB也有可能因為你的limit可以設不同的那用完了就是用完了它就會去throw一個segmentation for然後當然你也可以講這邊也可以也是可以有什麼read write對不對所以也可以是read only write only所以permission不對等等他也都可以丟segmentation form這直接就丟出去了這個

例子看不出來就是說這每一個segment當然這都是不能夠重疊的因為segment就是獨立的嘛所以當然你不能把永遠都不能夠把segment就是不同segment永遠不會有overlap當你要overlap的話可能是因為你想要做sharing對不對如果要sharing的話我們後面會講就是你會去create一個segment獨立的segment然後說這個segment share by兩個process你不能夠把兩個segment重疊在一起這件事情在做memory allocation的時候我們的

MNU就會知道它不會去做重複的allocation你只能把一個segment share給不同process你不能夠share部分se gment的content所以，這個是永遠不會overlap那在translation的時候，你在allocate的時候數字當然就會點對所以你在做address translation你對應到的位置一定是只有你這個去使用就是一定是屬於某一個segment裡頭而已你不會有某一個physical address然後belongs to兩個不同segment這件事情是不可能發生的

所以這只是summary幫助大家再review一下而已啦所以你可以看見很像但是不要忘記就是Page裡面的話它是frame的base address那我們的segment裡面的entry它除了base address之外還有limit所以這是一個不一樣的地方第二個是它的segment的base address可以是任何位置，但是Page的話它一定是Boundary就是Page的Boundary就是說Frame的Boundary4KB 4KB的單位然

後做計算的時候如果是Page的話有時候我們會偷可以偷幾個bit就是只是記Frame的第幾個number而已然後後面就直接用Append的方式大家可以想像因為後面都是0沒有意義所以我們用Append就可以做一些Trans lation這邊的話就是要乖乖地用加；然後去把兩個數字加起來就是Segment的話就是要用加的方式所

以這就是實際上的例子，所以跟之前很像我們有一個process它可能有很多的memory content每一個content我們就會讓它是一個segment是讓你寫code的時候就已經告訴我們OS你有多少segment了所以你漏到這個Memory的時候就只是看你上面寫的你是第幾個Segment然後你會告訴OS你要Allocate多少空間這個MMU會去用FreeList去找到有空間的地方然後把Base Address把它填上去這樣就完成了那當然他就知道沒有Overlap所以他要找到足夠的空間那就只是一個

對 variable size allocation 的時候你要去找到適合的空間所以就有可能 best fit, worst fit 我們教過的嘛一樣的道理只是每一個 segment 獨立去找有可以使用的空間好所以就會長得像右邊那樣子所以它還是 discontinuous然後它是 variable size 的那要 sharing 就像我們剛才說的其實跟 Paging 的概念一模一樣啊所以尤其是其實你可以看見

為什麼segment在上面了因為還記得我們paging的例子嗎一個editor他可能橫跨好幾個pages對不對甚至於他可能不在那個boundary就是那個page他沒有全部用完所以你在那個level做sharing是很複雜的就是你要知道他在哪幾個page但是program本來就是segment寫的所以你會看見這邊editor他一定是一個segment

很简单对不对然后你要load一个library那就是一个新的segment然后是for那个library所以其实就是在我们segmentation的这个table里面的一个single entry而已而且这个entry有多少byte是可以control的对不对所以这editor可能刚好你可以看见就是43062个byte就是这样exactly就是这个数量多一个byte我们也不会share对不对即使他们是

只是不在任何boundary裡面只要再超過這個長度我們就是認為它不能夠被share所以其實在segmentation level做sharing才是真正現在電腦系統的做法概念跟paging是一樣的但實際上是在這個level就做sharing所以一樣的例子所以你可以兩個editor其實就是兩個segment但是它會指到同一個ph physical的segment去

那Protection 所以又來了對不對所以你可以看見這裡就是通常就會拿來做Rewrite了我們說Paging的Evaluate Bit,Evaluate Bit是等一下是我們未來Virtual Memory章節會用到的那Segmentation的這個Bit通常就是拿來做Rewrite了因為你就是Share Library Level或是Share File Level這是一整個segment所以你就會有這些re-write甚至於你常會拿來share整個你的data section還記得我們的這個thread嗎對不對就是說

heap是sharedstack不shared對不對所以其實stack跟heap就會是兩個segment那stack這個segment我們就會說是non-sharing就是它是根本讀不到的那如果是heap它就可以那如果是file我們就可以知道這個file是read-only,寫只還是可執行就會用在這個level去做control所以不只是可以去control它的permission也可以拿來做溝通就是thread就是這樣子去用的那最後呢所以可以看見方法很簡單就是把base的address設成相同直到同一個physical的位置在這個table裡面直到同樣位置就可以

所以這個是Segmentation基本上跟Page的概念一樣但是記得它是可以指到任何位置然後它是長度可以是任意的那我們真的寫Program其實是在Segment上面去寫的最後了最後其實我們電腦我們說過Segmentation是在上面大家只有Programming是用這個概念去寫Program的但是它的壞處是什麼呢會很容易有這些external的fragmentation對不對那所以我們的

電腦其實是在segment之後我們再對它做配角有點抽象但是看這個圖應該很容易看得出來就是這是各位一個process它的memory content不同顏色就是不同segmentcall segment heap stack大家可以這樣去想像中間這裡會有一個對應到的就是我們segment這是一個假的空間大家先不要急這個空間我們等一下會看到它叫做linear address所

以是另外一個名字它根本不存在完全是假想的就對了但是它只是一個數字的轉換所以你可以想見假設我們今天會把它先map到一個很大的空間裡面那segment所以每一個位置每一個segment可以放在不同的地方然後可能就會有一些洞的存在，但是這個空間是完全假象，所以還不是physical的位置，所

以我們先不要管其實有洞也無所謂，但是一個segment我們是可以再把它切成好多個page對不對，所以我們再把每一個這一個很大的空間我們再把它用paging大家學過的把它切成fixed size所以一個segment就是跨三個或四個page也不一定對不對我們也不care因為反正變成這堆page之後我們就可以用套用我們

之前學的paging再把這一個addressmap到這邊這個就是真的physical的memory了，所以只要我們physical有位置我們就把這些page一個一個放到這些frame上面去就會完成我們整個的address translation，那好處就是你可以看到Programmer我可以用這個Code Segment我寫程式很容易對不对然後我們的Compiler也很簡單他只要知道你是哪個Segment他在這個Segment哪

一個位置他就直接算就好他不用管他會落在哪一個Page裡面跟Physical怎麼去使用管理Memory是完全無關的，那到了這一層之後我們的MNU會去做這個轉換所以他會再去把它切成很多小的所以變成很多小的Page的好處就是我們完全沒有External Fragmentation；然後Internal又很少所以Memory的使用變得很有效率可以很高就是使用率可以很高不會因為你的一個Segment很大無所謂你可以看見這個很大可是我們會把它放到好幾個地方那就可以去很有效去使用這個空間；

這就是我們概念上來講的什麼叫做segmentation；再加上paging就是指的是這樣的一個過程所以officially是長的是這樣整個過程就變成這樣了你會有一個CPU送出來的logical就是我們剛才圖例的最左邊；然後會先做segmentation所以會把它變成中間的那個空間的位置那個位置我們稱之為linear address所以它有一個別名它就是

一個它也是一個address可是它既不是logical也不是physical它是一個中間的有點複雜了但是無所謂它就是一個address對不對那又要做區隔所以我們稱之為linear也就是把它整個變成一個linear上面平面上的一個點就對了那這個位置呢我們再把它當作一個這只是一個位置因為對paging而言他也只是要一個address

嘛他不care那個address叫什麼名字他也只是一堆bit給我就對我們就照著做translation對不對所以說你就把這個linear address送到我們之前說的paging裡面然後再把它做一次轉換就會成為physical address的位置了所以其實是這樣子一個兩步驟然後得到這樣的結果。中間這個Segmentation Unit跟Page Unit都是在MNU裡面所以其實MNU它就是把這兩件事情都做了然後先用Segmentation，再用Page好，可以嗎？

好，來我們看具體的例子，這個是Penten，比較早期的Intel的CPU，它的這個Addressing的設計怎麼被Translate它是如何結合兩種Translation在一起的。 所以首先你可以看見你一開始拿到的是logical address space對不對就是那個logical的address就對了，那我們剛才說了上面第一層要做segmentation，所以這一個我們假設是這個address，它譬如說是48個bit，實多少個bit都無所謂，那反正它會分成兩個part後面這個part就是segment offset所以你可以看見32 bit就代表

最多一個segment只能漲到4GB，這是為什麼早期的memory你的allocation只能到4GB的原因，因為它在logical address這邊的offset只給你32個bit，所以你一個segment再怎麼漲不會超過4GB所以其實不是整個程式不能超過4GB而是你的heap或是你的stack不能超過4GB前面有selector畢竟這是commercial的的solution所以當然會複雜一點，然後你可以看見更

符合我們使用的需求也就是說前面這16個bit它只有13個bit是segment number，所以大家一看就知道代表我這個程式最多我可以compile出來2的13次方個segment至於你會用到那麼多是另外一回事，最多就是這麼多然後這邊會有一個bit，這個bit你可以看見它指的是share跟non-sharing這邊應該會這樣應該有吧這邊嘛 對不對，

所以你可以看見這個只是一個 bit所以它會indicate它是一個local的segment還是一個shared segment也就是說只有shared segment你才可以再叫OS跟它shared給別人用如果你一開始create這個process的時候你就說這個segment是private那你後面你說你想要把它shared這個library出去OS也做不到因為這個 bit 就會擋掉這是純粹 commercial 的做法而已啦就是這個 bit 它就已經先先已經限制住了這個 segment未來它是可以 share

還是不行比較好的 protection然後後面有一個 protection bit有沒有就是我們說的 read write就是這個 segment 是 read onlywrite only 還是 executable就是用兩個 bit 來去做區別好 所以真的有意義的其實只有這13個啦然後這裡還有一個Bit所以其實應該是2的14次方個Segments但是有一半是Share一半是不Share的好 所以這邊就可以看到最多程式就是2的14次方個Segments然後一個最多就是4GB在這個Computer Design上就已經把它限制住了好 那

在做Translation的時候大家就先不要想Page雖然說過程是兩個都有用但是策略就是你先不要把兩個混在一起一步一步做就好所以先我們就去看這是一個Segmentation的Translation所以我們知道前面Center前面會有那個Beat對不對0跟1那個Local跟Private的意思就是它其實會有兩個Segmentation的Table所以Private跟Share是兩個完全不同的Table所以絕對不會亂用就對了

那如果你是share假設這是share好了那你就會去找到一個share的segmentation table然後你前面有13個bit所以我們就會看它是第幾個index然後就會讀出來這邊一串的數字我們不管反正就是我們所謂的number就對了我們的base address就對了然後呢就把這個base address跟這個offset相加那不要忘記這邊這個bit的數量跟這個bit的數量也沒有什麼關聯性反正只是兩個數字想加所以這裡可以是14個bit那只有7個bit你就照加就對了反正offset就是加在後面對不對

所以不要把它想太複雜了它就是這樣子做就對了所以加完之後你就會得到一串數字你也先不要想說這到底是什麼數字反正你會得到一串數字那個數字就是我們俗稱的linear address那這邊我們會寫32的意思就代表這邊這個base address一定是有32個bit那offset它可能像剛剛有看到也是32 bit所以其

實它是兩個32 bit加在一起變32 bit所以就是這兩個加在一起就對了那你的長度這個linear address長度當然就是bombed by bit數最多的一個當然off set不可能多於base address所以其實是bombed by base address的bit數好所以你就會得到一串數字那它就會變成所謂的linear address那這個數字大家先不要看後面這個太複雜的部分只要先看上面這邊那在這個Intel Pentium它是用2 level page table所以說剛剛我們看到的32 bit它就會跟我們的例子很像就切12個bit的offset

然後10個bit這邊有10個10個12個他就這樣切32個bit然後就一樣嘛前面10個bit他就會去看這個outer page table第幾個entry對不對然後之後找到了你的inner page table再用後面10個bit去找他的這個第幾個entry然後得到他的friend number再加後set就會得到最後的結果所以其實這兩個動作是完全拆開的啦因為你

在做paging你也就是吃一堆bit所以你不care那個bit是叫做linear address還是virtual address不重要你重要只是知道他到底有幾個bit然後在自己這個paging的架構下到底哪些bit會拿來當作alter拿來當作inner這就是結合在一起好那我們再來看真實系統為什麼他就是會做很多trick這邊的轉換你可以看見Page Size 4K

B可是我們說很多系統就是越來越大我們會喜歡用更大的Page Size所以在Intel裡面其實它可以捨破4KB同時捨破4MB它的做法其實是什麼呢就是同樣是32個bit進來的時候它可以兩種解讀方式前面是跟剛剛一模一樣就是我拿10個bit去看這個Alter Table可是Auto Table轉換完之後它後

面會塞一個bit說這個是指到一個4KB Page的這個方式的方式去做Location還是是一個4MB如果是4MB後面的這22個bit全部把我拿來當作Offset所以22個會轉換成就是4MB Page TablePage Size 對不對所以它可以動態決定這三個Part用法是什麼你可以傳統的話原來的話當然D4就是前面是兩個

層的Table然後Page只有4KB可是它還可以把後面這兩個整個併在一起當作Offset然後對到一個4MB的這個空間所以如果方便想像一點的話意思就是如果這是一個Physical的Memory對不對Intel它這個管理MAU這個Memory的時候它可能就把前面都是4MB的Page就很大的然後下面是很小的4KB可以嗎所以你就可以有兩種不同類型的這個大小看你的Pro gram是不是

很大很大的 Program你可能就要大一點的 Page Size它就用這一塊空間反正它知道要用那一塊所以這裡它就會照著貼對不對。如果發現那個Program很小，那我就只要4KB就好，那我就去就知道這裡其實有很多的你還要再去做break down就對了。所以這個是實際上的電腦系統複雜很多，但是它就在這些上面去做調整，概念是完全一樣的好，可以嗎？這邊可以，所以這個就是真實的系統會是這樣子，那當然

大家不用把那混到那麼複雜啦，只要把基本的Paging Segmentation還有兩個加起來的方式知道怎麼轉換就好，不用再動態調整這個了好。所以最後summarize我們整套的做法，我們可以go through這個例子，這個現在稍微講一下回去，大家一定要自己看反正前幾年每次期中考都會考類似的，所以大家至少把這一題可以做得出來

比較完整的就會像這邊看見的比如說我們說 physical memory size 512 bytes，所以你要很快的腦中就要想到那我的 physical address 的 bit 數量就是 28 次方，就是 8 個 bit 對不對。然後 page size 32 個 byte，所以你腦中馬上就要跳出來，代表 5 個 bit 是我的 page 的 offset 對不對。然後呢 一共有 8 個 segment所以，你知道 virtual address 的前面 3 個 bit就是我的 segment 的number，

剩下的是不讲的，就全部都是Segment of Set這樣你就可以開始做translation了。所以，比如說我們說你給一個448的logical address大家當然要先把它換成0x101的bit，所以這個書名大家沒問題有問題趕快複習一下這個大1應該就會了然後12個bit所以當然應該會變成12個bit所以一共是12bit然後轉換成變成這個樣子，那我們的Hint就告訴你嘛3個bit是segment，所以你就看前面3個bit，那答案就是2嘛對不對

所以假設我給你這個是segment table那個是page table那Segment table是第二個，所以我們當然就去查第二個位置對不對給你吧，那讀出來的這一個address，我們就會去跟Segment Offset，所以不要重複到不要忘記就是剩下的那，我們就把剩下的bit跟這個bit做相加嘛，你就會得到一串數字，那個就是我們俗稱的Linear Address，那這個Address again就回到Paging所以大家應該要更熟悉了Paging我就要判斷again Page Offset是5個bit，所以這是5個bit剩下就全部都是page number對不對

所以我知道4個bit了，我就可以再轉換成數字，那是第5個entry對不對，所以我就會知道那我就看 page table 第五個 entry 是 2 對不對，那 2 是 frame number，所以不要忘記2 就是前面這四個 bit 變成 2 就對了 對不對然後後面就照抄，所以就是 physical address好， 可以齁所以其實過程就是這樣子而已，那你就可以做一個 translation，那你不需要去太擔心說translate 出來這個 address會不會跟其他的 program 或是其他的 process 撞在一起

那件事情是MNU，他在allocate譬如說你這個segment到底可以長到多大對不对的時候他要去找到有效的空間的時候會幫你確認的事情他給你就代表那是有效的address，那如果是你一個這個page然後你有一些是沒有用到的還記得就是他會有這個segment對不對，Segment它是長度不同嘛，所以你不用不是說整個Segment的空間都是有效的，其實完整的例子它還會知道這個裡面會說它會有幾個長度對不对

然後你如果這個Offset超過就被打掉所以其實是不會Overlap就是不會有這些狀況，那是MNU會幫你確定的，你只要知道怎麼做Translation就好好 那我想就這樣子所以這個就是第八章可以看見我們後面其實我們上了很多的例子大家一定要在考試前go through這些例子不然可能會有很多變化你可能會沒辦法翻過來好 那我們今天就上到這.