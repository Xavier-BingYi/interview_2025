undefined
Demand Pageant是什麼意思Demand Pageant跟這個一般做法差別就在於說所謂的Demand就是指說你要你才去做這件事就叫做Demand所以簡單來講就是我不是一次就把Page全部漏進去而是你要這個Page我才做這件事所以我們稱之為Demand Page那跟剛剛的比很明顯你就可以看見我們說的好處就是第一個

它的IO比較少也就是說漏Time啦對不對剛剛我們要漏的10MB嘛那10MB那我們等一下看見它一次只漏一個Page啊一個Page4KB嘛那你就是搬4KB就好所以速度當然就會快第二個就是剛剛看見我們如果全部漏進去那麼Memory的使用量比較大那如果我要用我才去搬那其實使用率就是可以提高然後剩下的空間可以給別的程式用那別的程式也可以漏到我們的Memory裡面增加我們的

Degree of Programming所以就算我們沒有什麼Dynamic Loading或者是Linking這些機制其實光從Process使用Memory的行為我們如果透過Demand Paging以Page為單位去決定到底是要把它放在Memory還是就先把它留在Disk上面去就可以就是所謂的Demand Paging但是如果用Demand Paging的話要注意到的就是有一個事情要處理就是當你去Access一個Memory的時候你必須要判斷說這一個Access的Address它到底是沒有效是真的無效就是超過你的

程式的Memory有Allocate的範圍對不對因為你也是Allocate Memory才能使用嘛對不對所以所謂Invalid Reference是指說它真的就是沒有Allocate所以它就是超過你使用的範圍所以根本就是是真的不應該去Access的一個Address但是你也要去區分另外一個Case因為我們現在沒有在Memory有可能原因是因為我們還沒做這件事對不對我還不知道你要用嘛你要了我才開始做這件事所以你第一次要的時候

他會發現有可能他根本不在Memory可是不是無效只是因為他還沒搬所以這時候我們就要去做Paging這件事情對不對就是Demand所以其實這個是一個會造成錯誤的一個Memory Access可是他就會告訴我們的OS說這個是Demand來了然後去做這個Paging的事情好所以所謂的Pure Demand Paging就是我們大家看見差異的例子簡單來講就是說一開始的時候

Memory裡頭什麼都沒有啦就是當我漏一個Process的時候我就Create Page TableProcess Control Block就這樣結束了然後真的開始Wrong我才開始去把這些Memory把它Create出來然後Create出來之後就開始放到Memory裡面去好所以這就是所謂的Pure就是完完全全全部都是On Demand是這樣子做的當然這是比較極端的啦實際上系統大家可以想見它可能不會是Pure它前面幾個

一定會需要的Memory Content它可能或許就先漏的了嘛所謂Pure就是什麼都不放就對了除非就是你有真的需要用到時候才去做那件事好所以我們看到Demand Pageant所以要跟我們之前教過的Metern Scheduler或者我們俗稱的Swapper的差別現在就會比較明顯了對不對所謂的Metern Scheduler或是Swapper的定義就是說

我是以Process为单位然后我就把它整个把它Swap到Memory里面去这是Swapper做的事情那我们这个章节教的这个Demand PagingVirtual Memory其实是在Pager这个地方做的事情所以它的差别在它是以Page为单位它并不会一次把整个Process给放到Disk去所以才有Demand Paging你这个Process你要哪一块MemoryPager再去帮你搬那它也只是

要把它包到Disk也是以Page為單位所以不需要把整個Process給把它Suspend你其實可以部分在Disk然後維持這個Process的運作所以這是Pager在做的事情那整個OS的系統當然你通常還是會有Swapper也有Pager啦他是不同Level的管理嘛對不對所以意思就是說如果Swapper把一個Process整個放到Disk那就Pager就沒事做了啦因為全

部都在Disk但是Swapper他可能說這個你幫我留在Memory但是Pager說這個Memory但是裡面其中哪些Page我不要所以其實是不同Level的嘛所以是都可以同時存在沒有衝突不同程度的管理好那所以剛剛我們提過這個要Paging的話你必須要處理一件事情就是你怎麼知道這個到底是有效的還是無效的一個Memory Address的Reference那就像我們前面章節提醒過大家的是什麼勒就是靠我們Page Table裡面的Value跟Invalid Bit其實那個Bit主要用途是拿來做Virtual Memory用的

那所以你可以看見如果是1這個當然你可以除掉不重要對不對就是如果你把它設起來的話可能就代表它是在Memory ory那如果是0呢就代表說它其實是有效的，但是它只是目前不在Memory所以看到0之後我們的這個OS就可以自己再產生一個這個Memory Access的時候，如果看到是0的時候就會產生一個Fault就是我們俗稱的Page Fault。

然後OS接到這個for之後就會去處理這個paging的動作，把這個page把它搬到memory裡面去。如果是demand pagepure的demand page，我們說一開始沒有page在memory所以所有的bit都會設成0來去告訴我們的OS說現在他們全部都需要做搬的動作，那這個我們也之前提過了對不對，這是基本我們要完整的例子。所以PageTable的設計就是要做這個修改，它的定義上會不太一樣，這個Invalid bit跟Valid bit就是拿來做這件事情用，而已。那你可能問我說怎麼Rewrite access對不對

那些不要忘記那個通常就在Segmentation的那個bit裡面會去做了。所以其實Segment跟PageTable他們的角色是很明顯不一樣的，那些Permission control你會在Segment level做，然後Paging這邊只要去管它是在Disk還是Memory就好，然後當然所謂的Swap到底去哪就是我們之前說過的Back in Store；然後，實它跟File System是不一樣那我們這個OS課的最後講到File

System管理會再稍微提一下Swap Space跟File System的差別好那我們就再看一次剛剛完全一樣的例子，但是如果我們說用Demand Paging這個概念的話會發生什麼事簡單來講就是，一開始的時候呢，就像我們說的，你load的它就是create a page table，但是裡面什麼都沒有就空的；然後，就說我已經load完了當然process control block還是要create啦，但是沒有任何東西被放到memory裡面去，那當你開始執行程式你要第一個

你刷群那這個時候呢，我們的memory access一樣，它就去看page table嘛想要做memory access，但它會發現valid bit是invalid所以這時候呢，就會產生一個這個PageFault因為這是Paging的過程嘛，所以這個Fault叫做PageFault，而不是叫SegmentationFault那這個Fault產生之後就會去Call OSOS接到Interrupt就要處理那處理的事情就叫做Paging所以他就會去知道當初你要的這個J行指令或這個這個M emory Accountant是放在Disk的什麼位置然後就把它漏到Memory裡面去

然後load進去之後他就知道位置了知道位置之後我們就來update我們就把page table裡面他現在位置把它修改然後把valid bit把它設起來設起來之後你就可以再執行一次所以這時候OS會叫把program counter我們知道本來的行為是你執行一個instruction會加4嘛移到下一個instruction所以當paging這個page4產生之後他把它搬完之後其實他還會把

這個程式的Program Counter把它檢視把它再移回去移回去之後再叫CPU你繼續做你的Fetching的動作吧它就會重複執行剛剛一模一樣的指令但這一次你就會發現有東西了對不對所以它就會正常執行了所以其實沒差最後結果就是你還是可以執行到你要的東西對不對所以以此類推後面都是重複所以一樣下一個指令你一樣會去檢查

那如果是不同的page就會產生一個fall你就搬進去update table再做一次access然後就這樣一直重複的去做這件事而已所以你就會看見右邊主要是就是慢慢慢慢的去成長所以我們說這叫做demand pageok好所以這就只是流程所以圖示化而已所以你會看見其實會有valid跟invalid bit；然後這邊會有更多的是會有空缺的狀況了，因為並不是說他沒有被allocate喔，只是說他還没有再放到memory頭而已，那你可能會問我說那我怎麼知道這個address到底是不是

有效還是無效的這個address答案是我們之前講過每一個segment他有segment的length對不對，所以寫在上一層他就會知道會先判斷通常到了pagent這層的時候已經經過了很多這種長度的檢查所以已經知道那是有效的的一個address然後才會進到這邊進到這邊之後他只是要去看他是不是在memory而已，所以這只是文字把剛剛的步驟把它列下來而已，所以

會用Virtual Memory而且是那種Pure Demand Paging的時候通常會發生的這個步驟第一個你會去Access嘛，那你會發現如果是Invalid他就會先去Throw一個所謂的Page fault這是一個Interrupt然後我們說是Software的所以叫做Trap，所以比較完整說法應該說這個Page fault的Trap你要說直接Page fault也OK啦；然後呢我們的OS就會去看當你Page fault產生的時

候他可能會先去再去再次檢查一下這個位置到底跟我的segment的length或者是我的process對啊我們說一個memory的limit就是這一個process到底使用到的memory size有多少等等他可以在PACB裡面有一些資訊他是可以判別他到底是有效還無效的如果有效了他才會再去看這個他的valid bit invalid bit然後如果

是Invalid如果是這個Invalid的話那它就會繼續的去做Paging那是Valid的話應該說這是有效的啦那如果這邊它不在的話我們就會去做Paging的動作那如果它是Valid我當然就直接Access Memory就好了嘛好那如果它發現不在Memory對不對那我們就會進入到Step 2Step 2就是我們要把Disk上的Memory content搬到Memory裡面去所以我們要去找一個Empty frame對不對然後找到這個frame的時候

就用這個Free listAll the one時間就可以找到那如果找到之後我們就會做Swapping嘛對不對就把Memory copy過來而已然後copy過來之後我們就會去Update我們剛剛的這些Memory page的Paper裡面的Content而且要把Value bit把它設成是Valid對不對然後最後叫很重要大家不要忘記的最後一步其實是Restart，

所以你的PC這個Program Counter其實要把它減四，就是把它移回去重新再執行一次之前的指令那就可以正確的運作了好所以這個大家的步驟對不對其實就是你會第一個會先就是不管反正你就先去Access試試看試了之後你就會看這個bit，如果是無效那你就會產生一個interrupt這interrupt就會被OS的這個pager給catch住然後catch抓住之後他就知道我是要做paging那如果你

問我說那這個到底Memory原來的content放在disk什麼位置勒當然你在load或者是你把Memory搬到disk的時候你就會記下來嘛所以我沒有講那麼detail可以想解或是當然可以他其實是知道在哪裡的所以他知道在哪裡之後根據那Information他就可以把它找一個位置把它搬回來搬回來之後Update Page Table然後重新再執行剛剛的那個指令那就會正常運作所以這個是Page 4的一個流程是這樣子所以在這個流程下面我們剛才說的

剛剛的case是說如果你就是有free frame的話那也很單純就那樣就好了對不對可是萬一是沒有的話怎麼辦對不對所以如果沒有的話就是必須在剛剛在找free frame的下一面我們其實要再多一步就是要決定replacement也就是我們必須要強迫某一個page從memory把它swap到disk去清出一個位置那才讓另外一個人接替對不對

所以要把誰踢出去那個演算法就是所謂的replacement algorithm所以他就是要決定哪一個memory page要把他swap到disk去那這個也只有在必要的時候會被trigger因為剛剛的流程看見我們當然還是會先去找free的frame只有當free frame沒有的時候我們才會去call replacement的動作然後去強迫一個人先把他踢到disk然後再讓新的人去使用那個空間所以這個流程它怎麼樣會影響它的效能其實就取決於這個Replacement Algorithm的設計了我們在介紹這個Algorithm之前我們先來看一下

這個就像TLB 的E-Rate的感覺一樣所以這邊我們先看一下如果用了這個Demand Paging會對於你的Memory Access Time的影響到底是什麼所以計算方式一樣很類似對不對也就是說你會我們假設用一個P簡單的公式而已所以就是用一個簡單的一個P去indicate說你的Page 4的Rate也就是百分之多少會百分之多少的M emory Access會產生Page 4這是我們Page 4 Rate對不對Page 4發生的機率而已那所以當然你可以看見我們的如果要算它的Memory Access的時間的話

當然就是如果1-P嘛所以代表是沒有發生PageFour對不對那我們就直接乘上MemoryAccessTime那MemoryAccessTime我們這邊是直接用一個MA一個變數就把它代替掉了那如果你要算細一點其實就是大家可以結合上一個章節TLB那邊算過的東西所以其實MA並不是一個定值因為看你TLB有沒有HEAT嘛如果有HEAT你就會比較快找

到做translation這些對不對那另外一點是這邊的MA它不只包含了你address translation它是access memory content的時間所以其實它還要包括的是你transfer那個bytes或是4KB或者說你去你一個Memory Access讀4個byte好了那就是Transfer 4個byte從Memory的Chip到CPU的Register的時間好不好所以這個是你這個Memory Access去不只要找到位置還要把Memory把它讀回來的時間那如果是有Page4產生當然就是乘上一個PFT所以就是假設你需要搬動這整個

Memory從Disk到Memory然後再回到這個CPU的時間，這個是所謂的Page4和好那，所以可以看見，如果我們帶一個簡單的公式下去一個簡單的Input當作例子的話，这純粹是要讓大家感覺一下Page4的影響到底有多大，那在這邊你可以看見Memory Access其實通常是很快的那，Page4為什麼會到Minisecond就是基本上就是十倍以上的速度，因為這個是

要從Disk把Memory的Content搬回到Memory所以其實等於就是一個Disk Read Time，所以其實PFT在所有的系統裡都一定是遠大於MA的，所以用剛剛這個簡單的公式去算的話，如果我們的這個Heat Rate對不對是在這個例子來講，你可以看見我們把它整理是說，即使我們先把t給抽出來，你會發現它就是proportional to這個非常非

常大的時間演在來講，就是說整個access的performance就是正比於你的page4的時間乘上你的page4 rate而已前面那一項其實不重要，因為disk非常非常慢，所以其實重點就是你的page4的時間，這個太長了，所以你的page4 rate其實要非常非常的低，那多低呢？其實我們看這邊的例子假設是這樣的數字帶下去1,000個裡面我只會有一個for一個for產生所以是for rate是0.

1%這麼小那代一代你會發現它會慢40‰¹⁰⁰⁰個裡面一個for你就會慢這個40的這個時間事實上是40倍不是40%這個是8. 2個mini second所以是原來只要200個narrow second所以就會慢40倍，那反過來講啦就是意思是說，如果我們今天希望我們的系統有用virtual memory然後有可能用到disk的話，我只想要慢10%這是比較合理嘛。電腦慢10%的速度，你會發現你的heat rate要這麼這麼高，就是你要小於我已經算不出來了，所以這是1萬分之一嘛。

所以，這個大家其實不用使勁啦，這個其實是一個例子讓大家知道，你如果讓電腦的系統有在Virtual Memory的運作下，它的效能只有很少的影響的話，你的Page-4 Rate要非常非常低極低應該是到幾萬分之一了吧對不對要非常非常低的一個機率，那為什麼我們的電腦可以有Virtual Memory可是你卻不覺得電computer變慢呢？原因跟TRB是相同的道理，因為Locality

對不對，因為你今天一個Page很不幸的不在Memory，你或許用的是Disaccess吧，那你就把一個Page是4KB一次搬到我們的Memory，所以後面的999可以對MemoryAccess甚至於你寫一個for loop你就一直在Access同一個Array對不對，所以其實你的locality其實是更強的，它並不只是instruction讀完，你有時候你還會對for loop你又回到原來的位置，所以說其實這個因為locality所以我們的heat rate通常真的是非常非常的

高所以高到就是一般電computer系統我們正常運作下發現的結果是virtual memory其實不會有很大的影響，因為有locality的關係，所以不要忘記一件事情，就是一個Page4產生的時候，我們是會搬一個page的content到disk的那之後的全部都可以reuse所以你的heat rate其實是相當高的好 很好，那為什麼會這麼高這個不意外啦，就是如果我們把breakdown我們前面那幾個step像第一個

當然你要先去發現有page4嘛 對不對，然後OS去處理這個trap然後它會去搬，但這個就是主要的時間了，因為你要把這個page去做一個disk的access，那disk速度就是比memory慢100倍10倍到100倍，所以當然時間就完全dominateBy那個Disk Asset Time，所以就純粹就是你的這個Rate必須要也要是幾萬分之一才可以，那後面這些都不花時間啦什麼Restart啊對不對然後這個其他的動作什麼去Reset Page Table這當然都是非常快的事情好所以剛剛那個Slice

主要就是讓大家只是看到說Page4 Rate這個其實要相當低然後因為Locality其實都OK那接下來我們就來看這個有了Virtual Memory這個概念之後其實對於我們這個Process的管理還有我們去使用一些Memory Content它也可以有帶來的好處有哪一些所以Process跟Virtual Memory有什麼關聯性勒那第一個就是我們看見的啦如果你

用Demand Pageant的話其實它只有Low Time會很小對不對然後你每一次要去做Swapping的時候它可以很快這已經是看見就是Demand Pageant就是一個可以影響Process效能的一個機制了第二個呢就是在我們前面簡單講過的Fork這個行為有沒有Fork是要做Memory Copy可是我們有了所謂這種Virtual Memory或是Virtual Address的概念的話我們就可以用所謂的Copy and Write的方式讓它真的Memory Content不一樣的時候

再去Create一個Page出來反正這個Page本來就是Runtime我們可以再去Create的第三個Memory Map File所以這是在做IO的時候目前大家在做IO我相信大家都是用F read F open那些透過file system去access file但是透過file system這個方式有一個問題就是file system畢竟是一個系統所以它會go through很多的步驟所以你去access你的

這個file content的時候會比較慢一點那我們下一次會介紹這個memory map你會發現它的概念就是反正你最後要讀一個file它也要在memory裡面所以我們就把file的address它的那个offset那个位置跟memory的address把它绑在一起那也就是我可以跳過file system我就把一个file disk content当作一个memory content来看就像virtual memory里面一样嘛其实一个page可以放在disk对不对所以memory map是倒过来把一个disk上面的file content当作memory content来做access所以它的效能会比较好所以我們下次會講這兩個比較特殊的機制這個大家未來其實蠻有機會用到因為很多人其實是用Memory Map方式去 Access File而不是透過File System.