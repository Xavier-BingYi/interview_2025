undefined
那上次有這個例子齁這個如果大家還記得的話，TLB我們有一個簡單的有一個算式嘛，在算他的Memory的這個應該說是在去查去Memory 的Access Time那這邊也有因為你又多加一層就是有Disk Access的部分也是Page 4 製生的時候，但是這邊這個公式大家就不必太刻意記了純粹只是因為它的結果太兩極化，你可以看見就是整個時間就是Dominate by 的Page 4因為我們的Disk速度是我們Memory的100倍的慢，

所以這純粹只是一個例子讓大家看到，就是說你可以用很簡單的數學的model去衡量evaluate這個page 4的這個rate對於你memory access time的影響，那不用講它的影響是非常非常大的所以說你可以用這個以使用者的角度去分析這個問題的話，你可以想說一般人可以容忍的這個performance degradation也就是你的這個access時間被拉長的比例

假設要10%的話那你可以去算一下Page4 Rate大概就是這麼這麼低幾百萬分之一非常非常的低，那遠低於我們之前看到的這個像是TLB 的Mist Rate所以因為這個Disk更慢嘛對不對它甚至於不是我們這個一個Render的一個方式那所以原因就一樣之前其實也有提過就是Locality就是我們城市的Locality的關係所以

很重要的一點就是不要忘記的就是當你一個Page 4產生的時候它或許很慢但是它會一次搬進一個Page的大小到Memory裡面也就是我們說的通常Page Size都是4KB嘛那現在的電腦甚至於有到8KB還有如果大家還記得在我們介紹Pantone的這個Intel的CPU的時候它會讓你選4KB或4MB對不對所以它Page Size甚至於更大到4MB

所以你就可以想見一次就帶進這麼多的資料進來那每一次的Memory Access其實就一個Byte或四個Byte而已對不对就是幾個Byte所以你可以想見一次Page4其實接下來只要在這一個Page裡面的Memory Access全部都不會再產生Page4了所以它這個機率其實是可以蠻低的在真實的電腦系統運作來講它其實還是可以

容忍就是可以達到剛才看見那個非常小的這個比例但是不是沒有影響喔就是還是真的會當你Page 4有時候你的程式跳來跳去或者是你電腦你為什麼說你Run一堆程式的時候它就開始越來越慢因為就Memory不夠了嘛所以你的Page 4的機率越來越高那你的程式的效能就真的會Page 4的機率就越來越高越來越高你的這個影響速度當然就越來越慢

所以啊，現在都這樣，大家去買電腦啊！大家這個都會問你說，你要不要去用一個SSD對不對？就是你的一個HDD，要不要把你的OS裝在SSD為什麼？因為其實就是因為可以把你的這個SWAP切在SSD上面，那SSD它讀就會快很多了，所以你的整個電腦效能就提升了！其實是你的Page4那個讀那個Page4的速度，Disk的速

度變快了，因為這完全是dominate這個時間，所以通常還蠻有效果，這為什麼大家都會用SSD的原因？其實蠻大的一個因素在於，你們刷Space是在SSD上然後，你們Page4的處理會快很多！好，那接下來我們就會介紹其他幾個，我們上次說過跟Memory也相關的，第一個是Demand Page，這不用介紹這個是之前講過的，就是每一次

執行的時候，他只要去Access一個Page，所以他一次只要搬4KB的大小就好！那我們今天主要講的是這兩個Copy on Write，就是我們說在Fork的時候，他如何用Copy on Write的方式讓他Fork這個動作變快，另外一個就是，在IO這邊File的Access通常，我們知道你們都用過的，就是透過File System，但是File System其實是一個System，所以它其實會

有很多的步驟才能夠讓你去Operate on一個File，不管是打開或者是Read或Write等等那我們會教一個叫做Memory Map File的這個方式所有的OS現在都Support這個東西那用這樣的方式去操作File的話它可以完全跳過File System所以它的速度會比較快當然有很多缺點我們會來稍微提到一下好所以先是這個copy on write那大家就稍微回想一下對不對

我們說過現在大部分的OS這個提供一個fork的方式去create一個新的process然後他們default的behavior通常都是說把他的parent跟這個child的memory就是parent的一個copy而已所以它裡面的counter會完全一模一樣一開始的時候對不對那一樣的話那這樣去copy就當然就會很浪費時間可以想見的那所以我

們教過了paging所以知道其實我們這個MMU是一個mapping的動作所以其實對使用者而言他其實不一定需要知道這個data是不是被copy裡面的東西如果其實完全一樣的話我們其實可以只用sharing的概念就可以讓他看見一樣的content但是畢竟這兩個程式是不同的程式對不對我們說他行

為上是完全不同的所以說也就是說其中有一個人如果改了他的Memory Content的話你必須要把他完全的independent的拆開來那所以什麼時候會改呢就是write對不對所以Memory Asset不管就是read或者write那read當然沒有問題可是當write的時候為了要區別那這個時候我們的OS才會去做copy的動作這個就叫做copy on write所以他只有在必須的時候

他才會去做memory copy所以當然你可以想見他的整個memory這個create這個新的process時間就可以大幅減短了但是執行過程中就會一點trade off對不對他就是跑的時候他才做copy所以就會慢一點很多的優化都是這樣子大家如果想回到之前說的Dynamic Linking Loading等等都是在Round Time你才去做這些事的話就是必要的時

候才做所以你可以省掉很多功夫但是你的Round Time會稍微慢一些那這沒有這個只是稍微提一下而已啦就是因為有這種Sharing的概念啦所以說當一個Free Frame我們知道要去使用新的Page的Frame的時候我們要的時候其實不只是找到通常都會把它Zero Out啦就把它整個清光光不然你沒有清光的話你可能就會看見前一個process對不對在使用那個physical memory時候的一些content那可能就會造成一些security的concern對不對

尤其現在很多的bug很多的這種透過網路的攻擊的使用者當然都會去explore這些事情如果你的OS沒有去做這些基本的一些protection的話所以這只是不用特意在意主要是copy和 write這件事情所以概念上來講就像剛才提到的如果我們有 parent 跟 child那一開始在做 fork 的時候我們知道是完全完全 content 一樣唯一不一樣的東西其實就是他的 process control block 的那些資料可是不要忘記那個其實是OSmaintain然後一定有 copy 一份那個不是 user 的 memory那是 OS 的 memory 去 maintain 的一些 data

所以user的data的話來講一開始Folk的定義它就是會一模一樣那所以當然我們就不需要copy了對不對其實physical memory就用sharing的方式page table設成一樣就可以了只要OS知道當初它這是其實是Folk出來的當然可以記錄一下嘛那差別就在這邊看見的對不對我們都學過Folk的定義啦所以我們知道我們可以用這個Folk回來的ID然後讓他們parent跟child做不一樣的事

所以像这边来讲如果我们的parent我们本来有这个test1我们去新create的一个variable那就会可能会在他的比如说这是在一个func里面所以可能在他的stack里面那他就会去create这个新的variable跑出来那一create这新的variable这就是一个write的动作嘛所以PageC的content现在parent跟child就会不一样啦对不对

所以不一樣的時候那我們就做所謂的copy and write嘛對不對所以當然本來parent是擁有這個ABC的對不對所以說這個如果你去Dodge到的是C的這塊的話來講那我們的這個parent就把它copy分出來變成一個新的那child可能就是用舊的這個無所謂啦這個OS implementation而已反正就是會有兩份誰要用舊誰

要新的無所謂啦那重點是你會有一份copy然後這兩個process它就可以看見不同的像對於parent而言那它就會是裡面就會有test1這個variable那對於child而言就是沒有因為沒有嘛不存在嘛對不對所以兩個程式就可以正常的繼續運作了所以這個概念其實是透過我們的Memory的管理可以很容易實現的再來下一個比較特別的是我們說的Mem ory Map的File我們後面會有例子一樣先看一下

它的概念簡單來講所謂的Memory Map File就是希望讓我們使用者ProgrammerUser的Program可以透過Memory Access的方式去Read或者是Write的一個File那什麼叫做Memory Access的方式呢就是Array啦簡單來講 對不對所以就是你有一個Array A那如果我們假設File裡面也就是一個ByStream嘛所以其實你可以想把一個FileMap到一個

ByString 的 Array 裡面去對不對那你要讀哪一個 Byte你就自己去 Operate 這些 Byte 就是了嘛對不對所以就不需要透過什麼 f read f write也就是說我們假設我們可以透過一個指令就把整個 File然後 Map 到 Memory 的位置上面去那之後你就透過像 Array 的概念Pointer 的概念去使用這個 File這就是我們俗稱的 Memory Map File

好那這個事情其實也很容易達到啊因為其實你去想Virtual Memory對不對就是一樣的概念嘛其實就是你的這個其實指到的雖然是一個Memory可是其實它對到的是它Swap到Disk上面的一個位置對不對所以其實我們的OS也很容易可以做到這件事情就是把一個Memory Address把它直接對到了就是Swap Space上面的裡面的一個Disk上的一個Content

那至於什麼時候update等等這當然是implementation了，但基本上是可以做這種one to one的mapping好，那所以所有的對於這個file的這些rewrite的指令基本上就像array你去overwrite A1的值把它改成某個值你只是對這個memory似乎是對memory去做修改而已，但是因為你當初開了這個file，它是用這種形式所以OS會知道其實你改了這個memory，這個位置指到的就是這個file的哪一個byte然後它就去把它寫進去就可以

了我們等一下會有實際的一step by step的整個過程還有code，不過概念上大家可以想今天就是把file map到memory然後你就可以在memory操作然後結果會可以寫直接回到disk上面去，那它的最大好處就是你 bypass 的整個 file system，因為你是 memory access 對不對，那所以 bypass file system 的好處在哪呢就是 file system 畢竟是一個 system，所以它有很多的程序，你隨便說一個 f read 或是 write它可能就要去檢查你的 permission

然後檢查你這個File是不是Open了對不對？然後很多很多的Check你可以想見它是一個System本身就是一個系統了所以它的這個時間當然會比較久一些因為它有很長的一個Code Pass所以通常你Rewrite或File System它會做很多事情那如果這些事情是不重要對你而言不會影響你的這個使用的話它可能就會讓你的執行時間變得比較長一點

好那另外一個還有當然就是像sharing對不對，所以說如果說我們把這個file的content我們把它放到了memory裡面的話我們看見可以用paging的方式啊對不對或者是你可以下指令跟OS講這一塊memory就是哪些process是share所以很容易可以做到一些sharing的動作反過來想就是你看這個file system它是很嚴謹的系統所以大家都知道如果一個file啊它被open

with write permission的話第二個人是沒有辦法再用write permission打開的對不對他會跟你講這個file已經被lock住了對不对，所以你不能夠同時有兩個人有write permission去overwrite這個檔案當然很多時候都是必要的所以方向式人只是做一些必要做的事情，但如果在你的應用當中你不care，就像我們之前說過有點像Share Memory Programming一樣，

programmer很聰明，他就寫了程式碼，我就用一些locking的機制自己來maintain這個file，那我就可以讓把這個file Map到一個很多程式一起Share的一塊Memory空間然後大家自己來看怎麼寫那你就可以去很Fine Grained的去Control現在誰可以寫這個位置誰不可以寫然後仍然符合你的使用者要求所以簡單來講就是很容易做Sharing的因為Memory本來它就是

算是一個Shared Address對不對所以比較容易去做這些Sharing壞處其實壞處還蠻多的啦所以其實這只適合就是那種很講求效能然後使用情境非常單純可能只有使用者或少數使用者然後你自己可以寫一些locking機制去跑酷file的人才會用Memory Map File它最大的concern是第一個就是其實是相對的很容易使用也就代表它很容易弄壞嘛

對不對因為每一個人你一個Process這個Memory是他只要他可以使用到的Memory他可以做任意操作別的程式一點Control都沒有對不对所以說你很難去定義所謂的Access control我們後面file system會再多講所謂的access control基本上就是rewriteexecutable這些permission啦所以那是對file才有的概念file system就是在做這件事那你

先跳過它了自己來那你Memory就沒有這些概念嘛就只是Share或Non-Share就這樣子對不對那所以這些就全部都使用者或者Process所有使用這個File的Process自己要去Follow才能夠去Maintain這些Assets Control的正確性第二個Data Lost因為你在Memory裡面所以我們等一下會看見它是會寫到Disk

但是不可能隨時寫到Disk跟File System的定義不太一樣所以你只是把它Map到Memory那Memory只要一斷電Memory就沒啦所以你的Data很容易就Lost掉反觀File大家都現在知道File System以前早期電腦一個當機真的data真的就lost可是現在大家都有經驗像word這些對不對馬上就跟你講

還原點你可以回復到哪裡對不對所以基本上現在已經很少會有狀況說因為一個斷電或機器的crash然後資料遺失這種都是file system會去幫你處理的事情那你跳過它again嘛，所以就是你跳過它那，這些你就要自己想辦法囉，那一般是這個不容易做，實你要讓它資料不會掉然後，又可以很快的

recover這個，實這等於是一個recover的機制這是很複雜的，所以要一個系統，那你自己來那就是什麼都沒有自己implement你乾脆用甩幅10層算了，所以簡單就是，如果你直接map到memory的話很快很快，但是它可能也很快就掉了一個crash memory就全部都沒了，最後就是Programming對不對，所以我們知道像File你有很多的API嘛，F-seq F-rewrite各種的Rewrite對不对，

你就call API就可以去操作File都是很明確的Define很容易學這裡就是一個Memory，所以Array對啊，Array要怎麼Access它到底是4個Byte的資料還是8個Byte還是12個Byte對不对，它的檔案可能前面是Integer後面變成了Character，你什麼時候轉換你全部不是很清楚對不对，所以說這些東西就是programmer自己要負責，所以那就相對可能

會需要比較大的effort還有你要對那個file的content要夠了解的人，你才知道怎麼去使用正確的去讀寫這個檔案，你只要shift一個byte可能就毀了對不對，所以這就是很明顯的一個相對性啦。對不对所以你的使用很單純，資料很單純然後你要很快然後可能是這種temporary的一些file的operation然後只有單一的使用

者或少數的使用者，那你就可以用memory map file。那其他的general的case，你可以想見，這是為什麼大家還是需要file system的原因了。所以它的用途是完全不同的，那memory map file比較多就是像剛才說的，實是比較系統層的一些軟體或programmer會使用，因為其實很多時候我們的系統是在operate一些這種很單純的檔案譬如說SWAPVirtual

Memory，這個把 Memory這個把Memory Counter放到Disk或Disk and Memory的這個Mapping這個裡面就是4KB 4KB的資料然後它就是一堆Byte。我們也不會真的去很單純的，所以就可以透過這樣子Memory Map的方式，就Virtual MemoryMemory Map，實是同樣的機制，就可以很容易的去使用然後又快然後不需要file system所以蠻多的系統層的話然後你再做一些系

統資料管理的話可能就會使用這種方式了。好，所以知道的話，這張圖看起來很複雜，但不太重要啦。只是一個示意圖而已簡單的就是這是你的disk我們知道它file其實放在disk它也是被align它也是會被這個linearize變成serialize變成一個byte對不對然後排過去的所以跟我們的Memory沒差

嘛所以就是這樣翻上去而已一個Page就對到4KB的Content就這樣一次類推那你Memory Map之後意思就是他把它放到Memory了然後你Memory Map File就很容易的可以讓很多的Process同時一起Map到這個File那Map的方式就是把Page Table設一下那大家就可以Access到同樣的Memory Content然後會有一對一的關聯性

好 這個比較重要 這比較具體啦 應該這樣講這就是程式嘛 大家一看就會很清楚了所以咧 上面這個是大家熟悉的啦 對不對就是open file嘛 然後再seek到一個位置然後再對它做read然後可能你shift一下它的pointer位置 對不對然後再去調整位置 然後再做read反正就是re-write的動作這就是所謂的file system就是透過read跟write還有seek這些動作去操作一個file

那其實這個事情會發生的是右邊這邊看到的這是各位的user space的memory這是file所以在硬碟上那file system是在幹嘛呢。它做非常多事我們之後會講更多啦，包括剛剛你提到的assets control啊、recovery啊對不對還有一個很重要的。其實，它在做buffering或說caching，因為disk太慢了嘛對不對。所以，當你去open一個file的時候，它就

會不只是知道這個file是被open出來了，它其實會有一個IO的buffer在那邊。所以，當你在做read的時候，它其實會先把它copy到file system的memory因為你可能read只是一個byte可是它會做所謂的prefetching，因為它你讀完一個write可能就會讀下一個byte對不對。所以，它可能一次就有它自己的大小，一次就抓譬如說10個byte或者是當然通常比它更大256個byte譬如說

就會抓一個buffer size的資料全部把它抓上來然後使用者要讀的可能就像這邊他只是要一個int四個byte而已可是我抓了256所以他就把那四個byte再copy到user space的memory空間也就是那個buff的那個memory的位置然後就以此類推你就可以去修改。其實，就是剛才說的buffering就是他一次就buffer 很多然後把它 cache 在那邊所以你要重新再讀資料它就直接去讀嘛，才會快，這是 file system

做了很多事的其中之一，那所以今天如果你要 write也是同樣的道理就是你改了那一個 byte 而已對不對，但是呢，它寫回去的時候它就會寫到第一個 byte 有改變就是它會寫到你的 buffer然後等到你說這個 file 的 close 的時候這個時候它才把它 flush到我們的硬碟裡面去，所以有時候你們可能有用過F-Flush對不

對，差別就是在F-Flush，它就會強迫它趕快先寫到硬碟，你不用F-Flush它就留在File System Buffer而已，那有時候還是會有遺失的問題或者說你不會立刻看見它在IoT Device上面，就是因為有了這一層Buffer好， 所以這個是大家常見的File System那我們來看這個Memory Map File差在哪裡Memory Map File首先呢，當然我們就完全不管右上角那個

了，因為那是File System，所以我們說它會比較慢一點的原因也包括了就是像你可以看見它的讀寫其實是Memory Copy兩次對不對，你要先在System那邊Copy一次然後再到User的Space，那如果是Memory Map File的話，當我們去Open之後呢，使用方法是這個樣子open一樣嘛，有一個file handler然後就跟我們的OS講我要用memory. file大家

查一下就知道C裡面應該都有就是一個API然後你就跟它講你要map這個file的哪一個區段到我們memory的哪一個位置所以你就會return的就是這個一個pointer而已memory. pointer它實際上是一個array 對不對甚至於它應該說連data pipe都沒有的因為它反正就是bytes就對了所以這個Memory Map File這個值以下

去的意思就是像這邊看見的它就會整個對過去就對了就是直接就是一對一的關係然後OS會知道這個Memory Address值得是Disk上面的哪一個位置這個File的哪一個Offset然後最大的差別就在這你可以看見前面是透過Rewrite這些File System Code這裡沒有就是我們說的就是Memory的Access的方式值得就是這個意思用Pointer

嘛所以我們就自己看這integer還是什麼datatype就知道位置在哪了對不對然後就直接對它做操作加加所以那其實就是一個write所以這就是等於是一個fwrite一樣然後位置這邊其實這裡就全部自己control你可以寫一千一萬對不對你就直接就跳到那個位置直接寫了好那寫下去的結果就像這邊看見的所以

你一寫的話呢其實就是更改自己的 memory content 而已嘛所以這時候它們兩隻其實不會 sync 在一起畢竟它在 memory 裡面所以這個就是為什麼我們說會 data lost 了因為這時候你還沒有 flush 回 disk 去那這時候如果一個斷電 memory 沒了那資料就完全沒了那也沒有人幫你去做任何的 protection因為這全部是使用者 program 在做的事情OS 就不管了

所以只有當你在call onMap的時候這個時候他才把它寫下來然後寫下來的時候他也不是去看說你改了哪一個byte他就是整個dump過去整個再寫一遍就對了因為他不知道你到底寫哪裡所以這整個過程你就是在對memory操作而已但是他照mapping的關係所以當你一個onMap就像flush一樣他就把整段空間再把它

只能重寫到我們的file裡面去所以這就是所謂的Memory Map File所以如果你的寫的這種是你可以講很大量的比如說我從這邊從第一個byte全部重寫一遍然後寫完之後我要去output到我的device那我用Memory Map File就會非常快最好的例子是什麼呢顯示卡嘛有沒有顯示卡就是這樣你一直在畫新的大家知道其實我們的螢幕上的那裡就是一個File然後就是看裡面的Content

秀在Screen上而已那些螢幕上的東西就是Pixel其實就是一個Memory Content而已或者說就是一個Array的Drag就是那種Bytes而已所以就會把顯示卡對到我們的Memory裡面去用Memory Map File的方式去操作這個IoDevice然後就一次整個寫 寫完整個Flush就非常非常的快所以很多的這些device,IoDevice其實是透過這樣的方式去操作的對啊，這個是API的設計所以它不需要，所以這FD只是說你還能不能夠對它去做操作而已，我應該沒有寫錯啦。

我可能可以再去check一下，應該是沒有寫錯不過，這是sudo code，所以可能不必太concern每一個系統當然API會設計有點不一樣，所以只是說重點是你要做這個onMap的動作然後跟close。其實是不一樣的一個是Memory一個是FileHandler，所以會兩回拆開來回去看一下，這個會不會應該這不是真的程式嗎。但是不會差到哪裡

去，那我可能會再看11的話順序應該是什麼樣子好，可以吧。所以這是Memory Map File大家應該要知道的，這個也是其實還滿容易會碰到才對未來大家是有機會的好， 所以我們前半段我想就是這個Pager然後就是我們剛才講的Copy on Run，尤其是Memory Map File這兩個是比較特殊的Memory上的操作使用而且跟DISC息息相關的大家稍微知道一下.