undefined
那所以剛剛這個就是Send跟ReceiveMessage Passing這邊那最後一個勒就是這個不是最後一個我們還有兩個所以另外一個Message這個passing的方式呢我們提到的就是用所謂的Socket所以我們之前提過了嘛用Port跟IP來指定哪一台機器上哪個程式來做溝通那這個各位在Network之後的課應該會講更多我們今天不會講到那麼深啦不過基本上你可以

看見右邊就是整個我們說的Socket Programming的流程其實是像右邊這看到這個樣子也就是Server端他要掀開一個所謂的Socket那就是說這是一個Entity他用Socket這個方式來做溝通那他必須要Bind到一個Port也就這只是一個Channel而已Logical的Channel然後他要Bind到一個Port因為這樣OS才知道是哪一個人要用這個Port來做溝通然後因為是有兩邊對不對

所以Server端呢他必須要先Listen所以Server要先打開來就像我們知道的Web Server要先上線使用者才可以連嘛所以他會先去Call這個Listen這個步驟也就是在等有沒有人進來那如果Client端同樣會開個Socket然後會去Call Connect所以他要去連過去那你這邊Connect過來的時候他這邊會一直等嘛所以他一定是Block等到有人過來的時候那就會去Touch到這個Accept的動作了所以他就會建立兩邊真的把這個Link給建起來了那建起來之後當然你就可以

開始做Rewrite不管是叫Re還是Write就是大家所熟悉的就可以開始透過這個Channel做溝通那最後當然兩個人都可以選擇Close如果Close掉就是這邊Close就只有這個Sock可以關掉這邊Close的話不只Sock可以關掉他連他的整個Port這個都會把它關掉那就沒有人可以連進來了那有一點大家可以補充一下因為我們也稍微講了Thread的概念所以大部分的Web Server你可以

看見都知道一個Web Server或是這種Socket Programming的這個Server Site它都是會設計就是希望很多人連進來對不對所以如果今天這個Server它是一個Single Thread的程式的話那一定代表他只能去handle一個使用者對不對所以其實不可能做到我們看見這種可以同時的同步的這種這種同步化處理很多人的這個動作所以

實際上發生的事情是accept之後這個server site他會去create一個thread來handle每個request read動態的因為你這邊有connect request進來嘛，所以這個main thread看見了這一個connect動作之後他會去create一個新的thread，然後用這個thread為什麼不是process，因為你可以想見很多的資訊他們還需要share的，所以他會create thread而不是process。在這邊來講然後create那個thread之後去跟這一個thread去溝通所以這兩個人所以其實他真正使用的方法不一樣，然後去做這個溝通的事情。那么有下一個人來的時候

其實這個原來的這一支thread是不會被擋住的，他其實是繼續Created 那個 lesson 去使用了這個 client 的 thread接著之後它又會回到繼續 lesson 這邊然後等下一個人。所以我們知道 web server 都是multi-thread programming 就是這樣，實在是在 connect 的那個時候去 create 新的 thread好，所以這就是我們俗稱的 socket programming所以因為現在網路實在是非常的基本的

的一種溝通方式嘛，所以大部分其實我們也是用Socket所以這個會很建議大家還是要稍微知道怎麼去做這方面的Programming就是大致上那樣的流程那重點就是這個溝通的特色就是我們之前說的這個Unstructured String of Bytes所以標準的嘛HTTP的這個例子Body裡面是任何的東西好那所以Passing的部分是由Programmer負責Socket只

是負責建立那個Channel而已好最後一個我們要介紹的是RPC我們說了Socket因為它是只有bytes沒有data structure所以說不好使用對不對我們喜歡就是call function call所以RPC我們上次也介紹了就是透過網路的它可以是個remote的一個function call所以它call起來還是function call但其實是一個remote端的所以說會很貼近於大家一般熟悉Programming的方式那為什麼可以做到這件事情

原因是因為提供RPC的這個Library這個程式它會有這個所謂的Stops就是一個小的一個Demon讓在這個Client端跟Server端去幫忙處理這个Parameter在那邊做傳遞的事情所以是要進去看一點的意思就是其實client跟remote端可以看見client端有一個stop那remote端我們叫做skeleton不過反正就是兩隻小的程式負責implement使用者不需要去implement的東西那其實為什麼可以變成一個function code呢跟socket的差別其實是很接近的就在於說這邊它可以有datatype所以為什麼要有這兩個人

就是因為這兩個人要負責把這兩個parameter把它做package跟unpackage的動作對不對所以這兩個人就可以做溝通其實這兩個中下面的溝通的方式通常也是透過sake是一個選擇所以它只是一層包一層對不對越來越方便programmer而已所以重點是他就要很重要的這件事情其實是要去package跟unpackage這個parameter然後當然幫使用者

透過像是SARCAD的這個實作方式把資料傳出去那就可以去實現所謂的RPC的這個動作好所以啊這個RPC這邊尤其是這個client端最重要的就是我們剛才說的PAC這個Parameters這個東西我們通常又叫做Parameter的Marshaling這個不需要刻意記啦因為這個有一點未來你們走網路的人的時候

可能才會用到那重點是你們要知道一件事實很重要的觀念是喔這個RPC的特色是可以跨電腦那跨電腦不是這麼簡單的事情因為電腦的作業系統都不一樣對不對所以舉例來說大家可能有聽過Big Addient跟 Small Addient的差別對不對就是你的值放在我們的Memory的時候它到底從高位數開始排還是低位數它是哪一個方向

這兩台電腦可能設定不同啊因為不同OS管喔所以說你只是單純把一些Memory Bytes做Copy不是這麼簡單的它可能會讀出錯誤的方式或者是Integer大家常常在Declare Variable都說INT INT可是大家有注意到INT在有些電腦是16個bit有些電腦是32個bit嗎不一樣喔不同OS的定義是不同的所以

說當你在用這個RPC的方式的時候他沒有辦法確定Sender跟你的個別是什麼他們的設定至少都可能不一樣所以這個Masuring他在做這個Packaging Unpackage的時候他灌上去的時候就必須要去處理這些很繁瑣的事情那這其實是一些挑戰所以就是他來負責而不會讓使用者自己去處理所以

這個就是我們說的這個Marshalling就在做這件事情他在管理而且是很嚴謹的管理讓他們可以能夠互相的溝通那後面其實就很單純了所以當然就是call了然後像是blocking的方式一樣然後去做傳遞而已但是Marshalling其實是一個滿大的一個issue他會去support還有其實各位很建議大家稍微看一下課本那個章節

他會提到RPC有非常多其他的問題，Marshalling是其中最大的一個要解決的問題。第二個大家可以realize的是，雖然它是一個function code可是，如果你只要pass一個data structure的話，而且重點是如果你要pass一個pointer其實是一件非常累的事情。大部分RPC是不捨過的，為什麼？因為不要忘記pointer指的是指到一個localMemory的位置，所以今天如果你把一個pointer傳到另外一台電腦是沒有意義的對不對。

如果要有意義的話，他要把那個pointer指到的所有你可能會使用到的Memory content全部也copy過來，那個pointer才能夠被reuse對不對。所以這其實也是一個很大的issue所以RPC它有一些它可以捨破部分的就是，如果你只是傳一個很小的一個你已經 well-defined他的 memory 的 scope 等等他會幫你做copy，但很多他是不願意的是，你不能夠傳一個 pointer 就對了。你可以傳一個data structure是一個完整的 memory

空間把它 copy 進去，這他可以幫你，但是如果是 pointer他就因為這個 effort 太大太沒有效率了嘛，所以他不知道要 copy 多少 memory content。所以他就會選擇不提供，所以其實有滿多的 issue 在那邊，那這是RPC，那其實所以我們這邊大家可以注意到的是溝通，這裡我們所以溝通這邊雖然我們作業沒有，但是對於大家未來

的學習是很重要的，因為如果你學平行程式，你就會用到Shared Memory跟Message Passing，如果你走網路方面，就會用到Socket，如果你走到比較整個分散式系統，比較大型系統，你就會用到RPC，那其實觀念就是我們剛才提到的好。那我們今天就上到這邊下次開始上第八章，是最重要的請大家一定要來仔細聽，那個章節然後記得應投影片.