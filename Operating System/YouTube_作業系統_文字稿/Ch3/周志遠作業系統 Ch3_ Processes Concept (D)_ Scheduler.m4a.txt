undefined
尤其是在這個執行的過程，這邊的話OS除了在這些Stage切換之外，它必須要做Scheduling的動作，因為我們要去執行要真的到CPU執行的話，它的數量是很少的CPU只有個位數或是十幾個CPU core而已可是要執行的程式我們說在Memory裡面，其實非常多的因為Multiprogramming的概念，所以可以輪流去使用這個CPU。且各位要run程式的這些Program那更是多隨時準備希望能夠被load到Memory的這些Program的數量當然是又更多

所以Memory也是有限的嘛對不對。所以並不是說一個使用者說他要執行某個程式的時候，他就一定可以load到我們的Memory裡面，所以這個過程中其實也是需要被排成決定到底哪一個人先哪一個人後的那如果對到我們剛才講的這個狀態的話所以大家把它串在一起CPU這邊就是Running State你的Process在這個地方就代表它在Running你的Process。如果在Memory裡面，

這叫ready因為它是ready to run，所以當然叫ready。那如果它還在disk裡面，那只能叫做new，因為就只是被initiate只是被create而已可是根本還沒有ready所以它就代表它還在disk上等著要搶位置進到我們的memory所以光這邊你就已經看到了三個state了那你執行完整個離開的程式結束那個就terminate就不用講了對不對唯一

特別就是waiting那waiting大家就記得幾個狀況就是自己要等別人的或者是很特殊的就是你被這個你有時候是要去有這個別人的interrupt進來或是你自己code比如說像sleep對不對這樣子的一個system code的時候就會在waiting的狀態了也就是它沒有雖然在memory但是咧還沒有能夠立刻被執行的這些程式是因為自

己或是別人的原因就是沒辦法立刻就算CPU空他也沒辦法執行的話你就知道他是在Waiting的State那 Waiting的原因有蠻多的希望大家稍微知道一下好那所以咧看到這三個過程階段的話我們就看到這邊我們就稱之為所謂的CPU 的 Scheduling這邊都要Schedule嘛因為要搶就需要用 Schedule來排稱那進到 CPU我們就叫做 CPU Scheduling

那進到 Memory我們就稱之為 Job 的 Scheduling或者說這個Job 的這個Scheduler所以其實會有不同的這個 Scheduler的存在好那 CPU 的這個 Scheduler 或這個 Scheduling的動作我們常常又稱之為所謂的Short-term，意思就是它很頻繁，你就以它的這個字面的意思去理解它就好對不對很頻繁的原因是什麼？ Again time sharing對不對所以每幾個mini second就會有一個alarm產生，然後就打斷我們的

這個執行程式，把OS的schedule叫起來重新排程對不對，所以他的這個頻率非常非常的高，所以就稱之為short term，非常快，他就要做reschedule的動作，那job這邊呢我們就稱之為long term，意思就是說很久相較於這邊來講可能幾分鐘對不對那才會需要做甚至於幾秒也跟這邊比也叫做慢了對不對幾秒鐘或是幾分

鐘你才要做一次scheduling，所以我們稱之為long term，那之所以要幾分鐘幾秒也很簡單啊，因為這裡就是使用者嘛，所以人去產生需要去launch process才會需要被schedule對不对，所以人的動作大概就是幾秒鐘，你會create一個process對不对，那搶著要進到memory，所以這個當然它的時間相對於mini second就會比較長，所以就稱之為所謂

的long term了，所以它是它的別名而已，所以我們short term指的就是CPU這邊，long term就指的是job scheduling有新的程式被產生要執行的時候要做的scheduling狀態所以這邊有狀態的mapping大家要記得那兩個中間其實還有另外一個scheduler在設計上的角度來講我們還有一個稱之為 metered scheduler那 metered scheduler 呢跟剛剛這兩個的這個作用有一點不一樣metered scheduler 指的是它什麼時候呢會把一個 process從 memory

這邊把它 swap 回 disk 上面去這個等大家後面我們講到 memory 的時候就會看得更清楚了所以Meeter Scheduler其實是跟Virtual Memory的概念結合在一起而產生的一個Scheduler也就是我們知道Memory是有限的對不對所以說我們會把Disk的一塊部分拿來當作Memory的空間來使用讓它擴展得更大我們說過的但畢竟它在Disk上面所以當Meeter Scheduler來的時候它當你的Memory不夠的時候

那他就知道必須要把一些Process從Memory踢回到Disk去那這個動作就是我們所謂的SwappingSwap就是把Memory Accountant把它給Dump到Disk去的這樣的動作把它存過去的動作這個就是Meeter Sched uler在做的所以他的目的就是當他發現其實我們後面我們馬上下一章就會講一個程式的Memory的Space可以很大嗎因為你就

我可以 allocate 一個gigabyte memory 對不對我寫程式我就 allocate 一個很大的空間但我真的會用嗎不會嘛 對不對有時候至少會立刻去用它所以其實我們程式的 memory 啊很多的空間呢你去把它 allocate 之後它並不是真的被使用所以這些空間呢其實就會透過這個Metering 的這個部分它去把它給切換到這個Disk 上面去去保留我們這邊的儲存空間

所以METER其實它就是在這個SWAP IN跟OUT這個MEMORY的動作就是後面我們講到VIRTUAL MEMORY大家就會串起來了所以因為它會RUN到這個它把它切換到整個PROCESS把它搬到DISK去所以這個時候它也會進入所謂的WAITING STATE因為它的CONTENT在DISK所以其實它是需要透過OS到時候真的要執行的時候要先把它的Memory Accountant翻回到

Memory它才能夠執行的所以它已經進入到Ready了可是因為這個Meet and Schedule了因為要清除一些Memory的空間所以我們的OS有時候會在Runtime的時候去挑出一些Process出來把它Swap回Disk上面去，但是跟你的程式不是檔案的形式，是Memory Accountant的形式把它在把它Swap到Disk去這時候我們就稱為Metal Scheduler了，所以當這邊有空或者

是那個Process被選中要執行的話會Metal Scheduler要先把它再把它放回到Memory那它才能夠回到Ready State然後開始執行好，能夠所以這個Metal Scheduler是這個它的扮演的角色是比較特殊一些的就是從Process從Memory再把它Schedule回到Disk上面去剛剛我們看到這三個scheduler，它都扮演其實相當重要的角色。 meetern我們剛才講比較多你可以看到long term這邊其實它扮演的角色是什麼呢，它就是在控制我們電腦的degree of multiprogramming，這個term非常重要我們下一個章節你又會再用到

Degree of Multiprogramming的意思，就是指的是這台電computer上目前有多少個程式在Memory裡面就這樣子，因為Multiprogramming指的就是我們Memory有很多程式，Degree就是幾個，所以就是它會負責控制我們的電腦的M emory裡面到底有多少個Process，所以就像剛剛我們看到的這個Long Term Schedule會決定你New的這個程式能不能夠被放進Memory，所以它其實就

是在控制degree of multiprogramming我們後面會講更仔細這個degree如果太少的話發生的事情是我們的CPU可能會idol就像早期我們說最簡單的batchdegree是等於always是1結果我們CPU在等IO所以utilization會下降當這個degree太高的時候我們後面就會講它會產生一個叫做trashing的狀況就是太多process在增強很有限的memory結果大家就在disk跟memory之間一直在做swapping然後電腦就基本上還是在做IO我們之後會講得更清楚但是就是這個degree of multi-programming其實很重要它不能太高也不能太低

那所以我們剛才講了所以為什麼叫做long term因為就是它執行的頻率並不是這麼高而且它是由使用者來去driven它的對不對沒有新的process進來的話long term scheduler就不會需要它去做任何的事情那long term scheduler咧它去選這些process對不對所以誰可以進到memory它不能全部讓它進來啊對不對所以到底要怎麼選其實也會很影響這個電腦的運作的效能

因為我們知道在這個在Memory的目的是什麼就是希望我們的程式執行的CPU跟IO的時間可以overlap，Multiprogramming的最終目的對不對所以overlap的定義就是我CPU執行的時間要差不多跟IO的時間一樣這樣我才能夠對不對就是CPU跟IO都有事情做，如果我們漏進來的程式舉例來說雖然我漏了很多可是它全部都

是CPU bug的意思就是說它只需要執行CPU的instruction就是這些加減存計算沒有碰到IO的這些指令那就算我漏了很多在Memory裡面我CPU還是會非常非常忙啊對不對，然後我的IO呢我的IO device我的mouse我這些還是放在那裡沒有做事啊所以就沒有重疊了對不對，那我就只有使用到CPU，我IO的bandwidth就浪費掉了反過來講，如果今天我們load進來的程式很多可是它全部都要做IO然後沒有人要做CPU，每一個都在call printf skipf全部都是這些程式的話對不對

那相對的就是所有的程式全部都在等IO的時間因為IO很慢嘛對不对，然後CPU的指令很少或者說執行的非常非常快所以變成CPU仍然是Idle，這也不行啊對不對，所以這個Long Term Scheduler，它的目的去選Process的很重要的是，目的也是要在選進來的CPU跟IO的時間上能夠盡量的是Balance，所以這樣我們的CPU可以很忙碌的做事，然後IO也可以很忙碌的做事兩邊都才不會Idle這樣使用率才可以增加

所以其實這個Lunken Scheduler也是蠻重要的，那所以程式畢竟是使用者的程式啊，所以其實有可能一下子突然間來的全是CPU棒程式，有時候突然間來的是IO的，那Scheduler就要去能夠去在裡面挑去找到一個比較好的這個Mixed Ratio在那邊，但是咧你可以看見在一般的啦現在一般的server啊 電腦就是比較powerful的電腦，

memory比較大的電腦的話其實long term schedule的角色其實是已經被比較淡化了或是沒有那麼重要，因為memory足夠嘛對不對，所以其實只要使用者說他要run只要一直行run的話，只要memory加上virtual memory的概念所以基本上他都會把process直接就load到memory再說，所以你可以看見到比較新的這些OS的話來講其實它就不需

要再有Long Term Scheduler它就全部放到Memory就對了那這個角色呢就會留到誰呢就會變成是Meet Term Scheduler要去做的事情了就是它什麼時候再把它全部都先錄到Memory那只是說漏進去之後哪一些Process或是哪一些Memory Content可以把它Kick out到Disk把它Kick out回到Disk上面去所以這個mixing的角色變成是metern scheduler在做所以在這邊來講大家比較重要的其實是要知道在我們這個ready queue裡面的這些process它的CPU I.

O.棒其實是很重要的，還有它的degree of multi programming是很重要的。至於是long term scheduler還是metern scheduler還是哪一個機制來去控制這兩件事情，在現在的OS或許有所改變了，但是這兩個事情是仍然是非常重要維持著的。那在比較早期來講，是long term scheduler在負責這件事，那現代來講可能是virtual memory的管理或是metern scheduler來做這件事好，那另外一個就我們剛才說的short term scheduler對不對

那short term很短，因為你可以看見通常大概就是100個mini second甚至於更短，它的這個頻率咧最基本的就是被控制在你那個那個timer的alarm上面，就是多少mini second我們會做一次reschedulingtimesharing的，那個基本的period，所以那個就至少會被叫起short term schedule的一次那你更不要提中間使用者可能還會再去call自己call system call對不對或者

是IO device會再去丟一些signal進來這些interrupt所以它的頻率，它被call的時間可能會比那個時間還要再更短，所以我們說叫做short term好，那這兩串起來就我們剛才說的了long term在這邊，那short term在後面，那執行完之後，你有可能因為IO所以會回到ReadyQ那重點是這個short term scheduler，它的特色是它的演算法scheduling 是演算法而

且是個非常重要的演算法，那像short term scheduler的演算法，它想要確保的事情，我們後面有一整個章節在介紹最主要的第一個是它的這個wait time，所以很多人在ReadyQ裡面要等著使用CPU，所以我們定義效能的一個方式就是用平均大家等了多少時間很直觀嘛對不對大家都不喜歡等很久中午去買食物對

不对去等這個用餐的時候大家都平均來講，你希望它越短越好譬如來講，那我們就到時候會介紹不同的scheduling algorithm同樣的人進來同樣的順序喔，但是不同的演算法不同的排程演算法，你得到的average的wait time就會不一樣，所以你能夠設計一個好的話，它的這個我們用這個定義下的效能就可以變得更

好或者是Fairness我們後面也會提到有這個Priority啊或者是有這個Round robin的Scheduling algorithm為了確保的就是Fairness就是每一個人等的時間希望盡量一樣，有時候平均很低不代表大家都很高興啊對不對像這個我們經濟常常在講這個大家的收入嘛對不對一個國家收入很好不代表他很均富啊對不對所以說這也

是同樣的道理，所以一個scheduler他有一些是為了要確保fairness所以最久的人不能夠等無限久比如說會去確保這些事情那這些全部都是由CPU scheduler來決定因為最後程式看見他的這個等待的時間上這件事情就是由shortened scheduler來決定的，所以它其實會直接的就會影響到這個程式執行的效能跟它使用者看

到的這個response timeinteractive的這個速度那所以它其實很重要那要達到剛剛那些事情當然需要一些演算法可是呢這個shortened scheduler它的設計的演算法偏偏卻必須要非常的有效率也就是說它計算時間不能太長比如說你這邊 q 如果很長你要 go through 一遍即使是 linear time大家現在正在學了一些 algorithm 的 complexity對不對如果說它的這個演算法它需要 n square那你算一算那個時間可能就相當的驚人了當你的程式很多的時候你要少一遍或是 n square 的時間可能就很久那

問題是你可以看見short term這邊舉個例子來講假如我們100個mini second你就要做一次scheduling 哦那你每一次那個accuracy只讓10個mini second夠短了吧那你的overhead 就是10%也就是我們的這個CPU有10%的時間都是所謂的overhead根本沒在幫使用者做事情那你再想一想如果你今天設計一個100個mini second 50% 哥,CPU你看它讓100%的使用率結果1.

5%的時間它根本不再做使用者的事情那當然會覺得這台電腦很慢喔對不對所以說這個scheduling algorithm其實是相當重要而且它的這個一個基本條件是它執行的時間不能夠很長要非常非常短尤其是根據它被reschedule的頻率來講去比你的這個overhead必須要能夠控制在合理的範圍內所以

這個是short-term scheduling它的特色在這裡我們會有一個章節解釋它的設計的方式但這邊大家先記得其實這演算法你不能夠想一個太複雜的在現實中可能是不practical的一個solution因為它會耗費太多的時間那Meeturn我們剛才也簡單講一下對不對所以Meeturn跟剛才兩個就很不一樣他在做的

叫做Swap out跟Swap in所以他是在Disk跟Memory之間在做切換的那個Scheduler所以Swap我們在OS的世界裡就是跟Disk之間的溝通的部分所以Swap out就是把一個Process從Memory再把它搬回到Disk上面去但為什麼要搬因為要控制degree of multiprogramming因為太多的話我們後面會介紹會產生trash那結果就是一樣CPU很忙碌但是使用者根本不在run使用者的資歷所以沒有用你還是會覺得電腦很慢

再來Swap In 對不對就是因為你有Swap Out啦所以你當然會發現這個有時候Memory位置就空出來了所以這時候它就要把它給切換回來了所以讓這個等在Disk的人可以再回到Memory做一個執行的動作那它當然就是可以對不對最主要就是Improve Process and Mix指的就是CPU跟IO啦，所以全部load到Memory可是你可以再去挑

哪些人應該留在memory哪些可以先離開所以它可以去控制這個ratio的部分因為我們說現在的電腦沒有long term嘛，所以來的我都進來了嘛可是進來之後我要怎麼去再做進一步管理就是靠 Meetern 了，因為實際上的Memory空間還是很小的只是Disk很大而已那第二個就是free of Memory對不對所以就是當我們太多人去搶

去搶我們的Memory的時候，那麼我們的Degree太高我可以用這個方式去減少他的Degree然後把這些Memory讓出來給這些真的正在執行的程式而不是那些在等的在Waiting只是在等的這些程式好，所以這個剛才講的這個Meetern Scheduler其實它都是跟Virtual Memory這個概念結合在一起的所以我們到講Virtual Memory的時候就會講比較清楚什麼時候會利用這些Swap的動作去管理Memory裡面到底要留下哪一些的這些Memory的Content但那個角色就是所謂的這個Meetern Scheduler嗯嗯.