undefined
知道一個Process它的管理的它整個Life Cycle還有它如何在Cube之間還有在CPUProcess之間去做交換之後我們這邊先簡單的介紹OS裡面有的這個Scheduler是有哪些那Operation其實是之後我們才會仔細去介紹的那Process的Scheduling在OS裡面是非常非常重要的因為我們知道我們會有很多的Process落在Memory裡面也就是我們一開始介紹的

Multiprogramming的概念對不對所有的現代系統都是這麼做的這樣才可以Maximize我們的CPU的Utilization這我們提過了然後同時呢不只是很多在Memory在Ready而且我們其實希望很頻繁的在那邊做Context Switch因為可以實現Time Sharing對不對所以才可以有Interactive的一個結果這樣的一個系統那所以這些

Process其實是必須要輪流去使用CPU那這個輪流誰先誰後的這個動作就是由Scheduling這個Argorithm或是OS裡面的這個Module來去負責的所以一定要等到CPU有Free出來沒有人要執行或者是它被強迫被Contact Switch的時候這時候我的OS的Scheduler就會叫起來然後去選一個新的Process去執行所

以像我們剛才說的這個Process在Schedule的過程中其實它就是被放在這個Queue裡面這個Queue裡面其實會有可以看見整個OS的過程中它有的Queue並不只是我們剛才看到的Ready Queue其實還有這個Job Queue跟Device Queue也就是所謂的Waiting Queue所以其實所謂的scheduling其實會發生在只要有queue的地方我們就會需要做一個schedule來決

定下一個人是誰這個動作那最主要的是ready queue就是誰去使用CPU這件事情但除此之外像比較早期的OS早期的電腦我們說memory比較有限的時候甚至於誰能夠從這個從program的狀態去進到new的這個狀態去讓它去launch的這個狀態都還有一個queue叫做Job Queue也就是說什麼時候我可以允許一個process一個program load到我們的

memory成為一個process這是第一層的Job Queue那進到Job Queue之後你進入到完成你被選中進入到Ready Queue之後你還會再被做一次schedule你決定什麼時候就可以使用CPU如果你在Waiting的State裡面會有這個Device Queue也就是為什麼叫Device Queue，因為每一個Device通常會有自己的Queue那其實像Sleep或是被Interrupt這些其實當然也就是你不是在做IO你是被Forced的被這個把它踢出來要自己或是自己要做Sleep的動作的話並不是要做IO只是要Sleep的話當然也還會有其他的Waiting Queue的存在

但是你會有很多個Device Queue for不同的Device所以他可以知道你在做哪一個Device的IO所以可以看見這個是通常Queue的管理就像這樣子所以你會有一個Ready Queue這是for CPU的部分然後IO的Waiting Queue這邊其實通常會有很多個那就看你是哪一個Device甚至於是哪一個Disk他會有自己獨立的然後就是利用Process Control Block裡面的Pointer把它串起來那有時候甚至於你會看見它會有這種Tail跟Head都把它串起來所以它可能比較容易譬如說去做Reordering因為其實Depends on the scheduling algorithm對不對

有時候你可能甚至於是Dynamically的去決定Ordering就是Round Time你可能會去做調整所以有可能你會需要其他的Pointer把它串起來變成雙向或者是至少是前跟後要把它記起來這個像你們作業三implement這個比較複雜的scheduling algorithm的時候就會看見像ready queue也不是只有一個可能會有level 1 level 2 level 3所以可以用這些方式去做管理所以對於這個我們剛才說ready queue這邊是最主要的

那Ready Queue這邊是最主要的這個scheduling的動作對不對所以我們剛才也看過他在這個各個State之間的轉換所以這邊可以看他可以看見Queue跟這個State轉換之間的關係其實就是我們說的Process通常會在Ready Queue裡面等的到CPU但是當你自己發出了一個IO request我call printf這個時候你

就會被放到IO Queue就是Monitor的那個Waiting Queue那個Device Queue等到他做完IO了他會再次Throw一個Interrupt回來OS就知道你可以把它放回到Ready Queue所以這時候他就在Queue之間做移動或者是我們剛才說的Timer的這個Alarm被Fire了因為Time Sharing所以他會從CPU直接回到了Ready Queue或者是

我們下一次會提到的Process它可以去Create Process因為我們程式裡面為什麼可以這麼多Process其實不是天生的就像人一樣其實是要去產生的其實它有一個Parent跟Children的關係其實它是一個Tree我們之後會提到所以在Linux裡面去Create一個Process的動作我們叫做Fork所以假設你今天去create

一個新的trojan新的process出來的話那有可能你會有兩種就是有可能你可以自己繼續執行讓trojan去等你執行完再執行但也有可能是你讓你的trojan先執行對不對這個設計都可以但如果是讓trojan先執行的話那原來的processagain它就會被放到一個waiting queue等到這個trojan執行完了他才可以再回到

ready cue之心所以這也是一個可能的原因好那最後一個就是wait for interrupt就像sleepsleep就是這個例子了所以他call了sleep100個second他的意思其實就是他會告訴我100個second之後幫我fire一個interrupt然後告訴幫我自己給wake up起來所以你就會被放到了waiting cue裡面然後等著這個interrupt的發生那它就才可

以回到Ready Queue裡面所以這個只是這張圖的話大家稍微知道就好就是可以知道其實Ready Queue跟Waiting Queue這個Waiting Queue其實是有蠻多種情形的發生那不同的情形OS通常就會有一個專門的Queue去處理這種Event就對了那其實會有很多種原因你會從CPU被踢出來進入Waiting Queue裡面的

時間差不多了我們下禮拜一的話我們會再繼續把這個scheduling這邊介紹完我剛有提到了job的scheduling對不對跟CPU的scheduling所以我們會來仔細看一下這邊他們兩個的差異到底在哪邊甚至於其實還有中間的我們所謂的meeturn的scheduler所以我們會來講解一下這三個的差別在哪裡.