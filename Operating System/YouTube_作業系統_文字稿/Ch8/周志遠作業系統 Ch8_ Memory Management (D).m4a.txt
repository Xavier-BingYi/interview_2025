undefined
好，那接下來我們很快講這個Swap因為其實這個到下一個章節才會介紹更多一點那所謂的Swapping我們已經提了好幾次了對不對？其實就是指的就是Disk跟Memory的記錄是Memory的Content所以跟Loader不一樣是Memory你已經Load到Memory之後，那這個Content如果在Memory跟Disk之間再移動的話我們才稱之為所謂的Swapping那它到底Swap到哪裡去我們剛才都只講說是Disk Disk那到底Disk哪裡呢？可以想見它其實是放在Disk某一個指定的空間就是因為是OS在使用的

所以其實它是有一個指定的空間的就是Disk上其實並不是只有檔案系統還有很多東西的所以其實你在灌OS的時候其實有灌過的人就會發現其實他會問你你的Swap Space要多少？那個其實還蠻重要的因為你的Swap Space不夠的話你就會Out of Memory很快就Out of Memory因為其實out of memory 是指你 swap 都用完你才會 out of memory不是說實體 memory

空間而已所以如果自己有灌過 OS 你就會發現它都會問使用者你要切多少的空間給 swap space那這個 swap space 它有另外一個名詞叫 back in store這個很不要背了， 這無所謂swap space back in store，但它的確就是說它是一個特殊的一塊空間，它不是檔案系統的空間，它是還沒有打開系統，它就會先切出來的一塊空間，

那我們後面會講更多啦，那這個Swapspace切出來之後，這個Back-in-Store切出來的目的是什麼呢？就是我們之前有介紹過的Meet-and-Schedule對不對，所以當我們程式Memory不夠了，我們就會Meet-and-Schedule，就會挑一些Process把它整個Swap到Disk的Back-in-Store，讓其他程式可以先執行，那後面我們講的這個Virtual Memory會看見，實際這個Swapping的動作，不一定只是在以一整

個Process為單位，它甚至於可以到我們之後會介紹的Page，所以可以到很小的單位4KB為一個單位，在做Swapping，所以它可以很fine-grained，基本上就是for這個Virtual Memory跟Meeturn Scheduler會去使用的，就對了，那就像剛才說的，它其實是一個chunk of disk，就是一塊空間，而已啦，而且你灌OS通常，它就會physically把它切出來，你就只能夠放這些Memory content，

那跟File System通常是切開的我們之後會講更多當然有一些作業系統比較複雜的作業系統或比較這個彈性的它甚至於可以結合兩種做法啦，但基本上Swapspace因為它畢竟不是檔案，它是一堆Memory的Content是Page我們之後會教的東西，所以它並不是一個User的檔案所以並不會交給File System來管理，而是OS的MMU直接來管理的所以就像剛才說的為什麼會有這個機制為什麼要做Swapping

理由很簡單啦， 因為你要free out memory嘛 對不對，有時候很多memory是wrong time allocate的嘛dynamic allocate memory，所以它會漲啊，所以你不知道到底夠不夠所以有時候你會發現不夠那另外的話就是我們就會看到的這些process有些是比較重要的嘛我們想要讓它先跑，有些比較不important所以不重要它可能會等很久所以既然等那麼久你一直浪費memory也不好所以就會把它先把它swap到disk去，所以可以讓

正在執行的這些Process可以有比較多的Memory可以使用好，那這個Swap的機制或者我們說Virtual Memory的機制跟Binding Address的觀點性是什麼勒，其實我們之前已經講了啦，如果你是Binding Time對不對論的 Binding是在 Compile Time或者是 Low Time的話對不對，那我要做Swapping的時候，這時候問題就大了，因為不是不行，但是你必須要swap回原來的

位置對不對。你只要wrong了，你只要一漏到memory之後，你就必須要在那裡，所以你沒有你，如果離開了那個空間，你讓別人就代表你離開，就代表要給別人使用所以當你要回到你要使用的時候，你前面那個人必須要離開才行，那這就因為它比較相同的位置，這個問題就很大對不對，因為當初把你踢掉那個人可能他是比較重要的嘛，

那你今天要回來那個重要人一直都站在那，那你這個原來這個人就永遠都沒有機會回到原來的位置，那可能就永遠都等在那了，就很沒彈性簡單來講對不對，那如果是Execution Time該介紹的對不對透過了這個base register MMU runtime決定，那你的這個位置可以不一樣的就是你swap回來的地方可以不一樣所以才有可能

很有效的去使用你的Memory空間然後誰重要我只要有空間，我就讓他可以跑了，所以才會對於Memory的管理是非常重要的事情，所以Swapping其實一定要跟Execution Time的Binding一起使用才有效果，不然可能效果就會很差，那有一件事情有一個觀念大家要有很重要的事情，是當一個process被swap掉的時候，也就是它已經load

了嘛，所以代表它已經是在我們所謂的這個執行的在memory裡面，那它或許現在暫時不用，所以我們會想要把它swap到disk去，但是swap的時候對於OS的時候必須要做一個檢查，也就是這個process不是隨時都可以swap的其實，它必須要是在所謂的idle什麼叫Idle呢？簡單來講，就是很重要的就是它不能再做IO也就是說，一個Process它之所以會把Memory想要讓出來，我們知道是因為它沒有在使用CPU嘛，所以CPU沒有要用它的Memory Content可是，要注意的一件事情

是我們OS的Design其實，就是要Overlap什麼CPU Time跟IO Time還記得嗎？所以當一個Process，它在Waiting Queue的時候，它雖然沒有在用CPU可是，它在做IO意思就是還有別的IO Device它是在同時用我們的Memory Bus把它的資料從硬碟比如說搬到它的Memory空間，所以如果它在做IO的時候雖然沒用CPU可是，它在做IO的時候你把它做Swapping那就完了對不對，因為我們的IO Device也是把資料寫到Memory對不对，所以

它的順的程式是正在使用那個Memおり的所以說你如果在IO的時候做刷屏它就會寫錯或是沒有地方可以寫所以你那時候其實是不能夠做刷屏的所以這個刷屏一定要Idle Idle不只是單純的CPU Idle是IO也要Idle不然就會有Memory寫錯地方的問題跑出來了所以這是其實要注意到的一個Swapping的時候

他如果在Io的Waiting Queue也是不行他如果是在Sleep的Waiting Queue是OK可是如果是在Io的Waiting Queue是不行做Swapping的那Solution是什麼所以這當然就很討厭因為我們的Process常常在Idle的原因就是因為他在做IO所以我們才想要把它剔掉對不對可是你又要去Access他所以solution通常是兩個第一個比較強力一點所以就是我只

要做IOIO之前他會把一個flag設起來所以OS知道他在做IO他在IOQ所以他就不做swapping他就等等到你做完了我再把你swap第二個其實比較常用的做法是IO雖然一個程式想要做IO他要把資料搬到他的memory但是他是透過OS做IO所以OS會有一個OS的buffer所以做IO的時候其實OS會幫那個程式create一

個自己這個OS的一個buffer在那邊你把資料先搬到OS的memory那搬完之後呢你的這個程式就被搬的時候你的程式因為沒有touch到他的memory所以那個程式就可以被swap掉等到IO做完了我們再把那個程式swap回memory然後這個OS的buffer的content再把它copy到那個使用者program的memory空間對不對所以就是所謂的buffering就是這個意思所以因為OS一定存在嘛所以OS不會想要把它swap掉但是使用者的program我就可以把它做IO的時候

我也可以把它swap不用擔心因為其實IO是寫到OS的buffer而不是寫到user program space的buffer那等到你swap回來我再copy就好這個其實是比較常用的方式所以其實IO它會我們OS裡面會create一堆的buffer在做這些事情那就可以讓你的這個memory就可以把它清出來然後讓別的程式使用所以這是比較常見的解決方式所以稍微注意到swapping

它其實是IO的話也要去做處理的一件事情那個程式它可能還是需要使用到它的Memory的空間所以當然這個Swapping時間其實很重要因為我們一直在強調Disk很慢CPU很快Memory也比Disk快很多很多至少100倍吧所以說今天在Swapping的時候，這個swapping的時間你可以想見當然就是proportional to你的size

啦對不對。所以你這個如果你一次就swap一整個process那這個process有4GB的memory好了那你就要搬4GB的memory到disk喔。所以大家應該都知道很慢很久對不對。所以這是swapping他必須要考慮的另外一個很大的問題就是怎麼樣可以讓他的swapping很快對不對？搬的資料要越少越好，還有一點就是你不要搬錯人了。所以如果你把P1搬過去萬一它馬上使用者就說我要執行P1的instruction又把它搬回來那就不得了了對不对。所以我們第九章Virtual Memory討論的就是這一塊怎麼樣

可以去盡量的減少Swapping它的大小，所以我們不會搬一整個程式其實Virtual Memory會發現是搬一個小Page而已，直只搬4KB然後另外就會有一個 algorithm 來決定到底誰要被 swap那是一個非常重要的 algorithm去 minimize 班儀的次數。但過這邊只要有概念就好Swapping 是什麼我們下一個章節再來講這個部分接下來我們就要進入這一個章節的重點了就是在 allocation所以單純的我們只要看 memory 就好我們先把 disk 丟到一邊去了

所以Memory我們要怎麼把它分配給這些程式分配的方式我們會看見第一個叫做contiguous簡而言之就是連續所以我就是用連續的空間給你我們等一下會講比較複雜連續的很好理解但是難的就在於是discontinuous也就是它會是不連續的我們先看連續的就好因為連續也比較符合我們Programming的概念我們說你有Cosection,

你有Hyp,你有Stack我們在談的時候我們都說它是連續的我們畫圖也是畫一個連續的所以我們先假設我們就按照這樣的方式去分配記憶體空間這就叫所謂的Contiguous Allocation一個層次反正就是要一個空間反正它也是連續的所以分配的方式第一種我們叫做Fixed Partition也就是我們就把我們

的程式連續的空間我們就先把它做一個切割或是說我們把分配的單位我們Physical Memory是一個空間我們就先把它也是做一個Partition變成有點像停車我每次都喜歡用這個例子Fixed Partition就像是我們怎麼去規劃停車場那Fixed Partition就說我們的車子有些是機車有些是摩托車卡車對不對那有些

是這個不一樣大小的汽車那Fixed Partition就是像我們現在的停車場一樣我們就切成相同大小就對了一個一個停車格那這些停車格就讓每一個城市去使用所以一個車子就只能停一個停車位就對了那我們切了多少個格子就代表我的degree of multiprogramming對不對就代表多少人可以同時在我們

的memory裡面啊所以fixed partition的方式它就是很容易的就可以control我們的這個電腦裡的degree of multiprogramming是多少然後管理上很單純就是一人一個位置就對了但是這個問題我們都知道現在也都有了路邊停車就跑出來很多重型機車對不對就是說我才停那一小格位置Fixed Partition所以我就是那一格只能停我一台可是就有很多人開始投訴為什麼你一個小機車只用了四分之一個位置而已還可以停兩三台嘛對不對

這樣很浪費空間尤其台灣停車不容易對不對所以就所謂的Variable Size Partition的概念也就是好吧那你要多少空間你跟我講我就切多少空間給你這就是Variable Size所以每一個人他去Allocate的他分配給他的空間是可以是不一樣的那不一樣的話呢你可以想見那怎麼樣子可以把所有空間用完呢就是你要去找了對不對

所以像這邊的話，你停哪一個停車格是沒有差別的對不對，反正大小都一樣，所以只是位置在哪而已，但是 variable size 呢，你這樣用的話，我們等一下會有吐司就會看見你就會有一些洞了嘛對不對，那所以像大家亂停車一樣對不對，那所以就會要大家開始找洞是side對不對，所以就會有不同的篩法，大

家就會看見Variable-sized partitioned algorithm相對就是在討論，我要怎麼去哪一個洞，我可以篩進去當然夠大才能篾可是你一定會有很多個洞對不對，都可以篾那這個時候你的decision，你可以去決定到底要篾哪一個洞好，所以可以看見這個就是 variable size 的話，就像這樣我們剛剛看動的意思就是這樣對不對，所以為什麼會有動首先就是因為即使你一開始把它填滿好了，所以 ideal 的 case可是我們知道process

每個大小都不同而且它會 join 或 leave就是會進來又出去對不对程式就是這樣所以當它離開了之後，你就會產生動了對不对而且它是 runtime然後不斷在改變的，所以這個 variable size partition他就要去 wrong time 的時候去找哪裡有這個洞的存在，那像這個例子很單純你只有一個洞，但是萬一今天我們比較複雜也可以想像可能上面有一個很大的洞下面有一個很小的洞，那都可以塞得下的話，那我們都要塞哪裡對不對好，

所以這個我們沒有圖示，因為太說服我了大家自己想一想就會知道對不對所以很常見的當然這是Basic啦，對不對所以最直覺的你可以想見的幾個Archery人就有所謂的First FitBad Fit跟Worst Fit所以First Fit的概念就是第一個就對了，因為它是有洞嘛，所以我就從頭開始找第一個找到我塞得下趕快停免得又被人家佔走了這叫First Fit，Best fit就是你會全部找過一遍然後找到一個最match的對不對

所以我就是這比較替別人著想對不對，所以我就把它這個空間剛剛好的，我可以把它填滿，這是最棒的對不对，就不會有產生其他的後出來，所以這就是所謂的Best fit，它的概念就是這樣，他認為可以把它剛好站滿，但是你會發現，有時候你的出發點是好的結果是不好的，因為有可能你還是佔掉

不少，你還是有可能就算是 best fit，你還是有可能會剩空間而且那個空間通常會剩得更小小到很難再有人去使用它，所以反而就等於是浪費的意思對不对，所以Worst fit 這個演算法，它的概念這純粹都只是純粹以概念的角度設計，Worse fit的概念就是倒過來，那我不要跟人家爭，我就是找最大的洞，所

以只是最大最寬的那個我先去用它，它的概念的想法就是因為它這個空間很大所以我今天用了它一部分之後它應該還會有留很多所以別人可以再去用所以並不會直接就浪費掉剩下的空間了所以運氣好說不定就剛好全部用完所以這是所謂的Worse fit這個不用這個大家直接了解一下

或許我們考試會問一下你就是用這個模擬一下去擺放位置就對了那根據誰會離開誰會進來去決定空間使用的變化這個課本的章節後面也有一些簡單的實體練習非常單純的你可以自己練習一下就知道那我們今天討論的是那這三個做法實際上到底哪一個好呢其實你會發現比較

多人反而用first fit為什麼因為這些都是Heroic algorithm所以你都不知道真的是結果如何那但是有一點是確定的first fit的complexity大家再show algorithm他的complexity他的這個average case一定是最好的因為他運氣好的話他第一個動他很快就找到第一個後然後就結束了所以他不需要scan through整個這個memory的listprocessed list但best fit跟worst fit你就

要全部少過所以通常會比較花時間在效能沒有保證比較好的情況下很多人當然就是以實作上比較有效率的方式為準所以這就是所謂的variable size的partition的方式各位剛剛看到兩種的allocation的方式最大的問題是什麼可以看見就是它有可能會造成一些空間的浪費對不對那這個空間的浪費在我們的

Memory管理裡面是有專有名詞這個一定要記住FragmentationFragmentation是非常重要的一個概念那Fragmentation指的就是它有零碎的空間嘛對不對那這個Fragmentation的問題呢我們又把它分成所謂的External跟Internal那什麼是External呢External的意思就是程式外嘛所以都按英文解釋就好意思就是像這邊這個例子

對不對我們有一些洞在程式的中間那如果今天我們有一個程式想要執行但是它沒有辦法去塞進任何一個洞的話或是這些洞明明就是有空的卻沒有辦法擺任何程式的話我們就稱之為External它是在程式外的所以你會看見是P1跟P2的中間所以它是external to任何一個process的fragmentation就稱之為external fragmentation這個做法我們剛介紹兩種所以你會看見這個做法其實只有在variable size會發生因為如果是fixed size大家都切好的格子

只要有一個process來我就一定可以找到一個位置挺進去嘛對不對，但是variable size它就是會有會有洞這些洞其實在process的外面所以稱之為external fragmentation好，那有external我們就剛才說也有internal，所以internal指的是什麼呢？就是右邊那個在fixed partition的時候會發生的事情，因為什麼原因呢？像這邊來講我們可以看見每一個Process要的

Memory空間是不一樣的當然都是這樣子，但是在Fixed Partition我們不管我們就是給他很大的空間所以在他Allocate給他的這個Memory空間裡他會出現沒有用到浪費的這個Memory空間的問題就稱為Internal Fragmentation，像剛才說停重型機車結果大家看了就很眼紅站著不給人家用對不對所以就是造成浪費所以這叫所謂的internal fragmentation，所以就從右邊看它是只有在fixed partition的時候

會發生這件事情，這個就會發生比較嚴重的這件事情好那所以像這一個這個其實是沒有什麼solution因為是internal嘛，所以唯一的解決方式是什麼勒就是你要把你的車位切得更小也就是我們等一下會我們今天大概來不及了下一次講開始重點了Page，就是在解決這個問題，那如果你是Variable Size的話解

決方法倒是有就是Compaction也就是去做壓縮也就是我們會定期我們可能就可以做一次Memory的清理然後把這個空間給清出來那這樣就不會有hole所以永遠都只有一個這個概念其實在Memory用到的還沒有那麼多用我們之後會提到Paging其實會把這個問題減少很多了，但是這個Contaction還有所謂的External Fragmentation在Disk Space的Location，我們後面最後會講的時候

就常常發生所以大家應該都有經歷過吧我的硬碟怎麼跑這麼慢電腦系統怎麼那麼慢有人就跟你講你有沒有清理硬碟啊，在幹嘛就在做compaction所以它會把空間清出來，所以你去放檔案的時候它比較容易找到空位，所以就一樣的道理不過Memory也是有同樣的現象，但是Memory其實我們之後就會看見它會先把它切成很小的Page，所以這個狀況其實不是那麼多除非你就是沒有用我們後面的做法直接就用最傳統的Variable Size

才會有這個問題，所以剛剛的external跟internal fragmentation非常的重要所以接下來我們今天會稍微講一點點的paging到底什麼是paging 那 paging跟剛剛的差別就是我們剛剛講的都只是contiguous連續的所以真的在放的時候你要不要說真的另外一種放法就是所謂的non-contiguous也就是我們一個層次 單一個層次它的memory的空間就本身不是連續的這個就是所謂non-contiguous那不連續的方法也有分成兩個也就是variable-sized的non-contiguous跟fixed-sized的non-contiguous那我們先看這個fixed-sized的non-contiguous其實就是我們俗稱的pages

什麼是paging呢跟剛剛的差別就是他想要不連續怎麼樣不連續呢其實最簡單的想法就是我們竟然有logical address跟virtual address或者說這個logical的這個virtual address或者說是還有另外一個physical的address對不對我們今天兩個就在做擺放嘛也就是在做mapping對不对那如果想要non-contiguous的意思就是我們就把兩個勒都個別的去做partition

前面我們只partition這個physical這邊對不对那logical這邊我們想要讓它變成non-contiguous意思就是我們logical我也切那physical那邊切出來的一個一個單位我們稱之為frames所以它是一個空間像車位一樣logical這邊切出來的我們叫做page所以你的程式其實是一堆的page那frame跟page這兩個字要記好frame是physical的memory的空間的切割

Page就是Logical這是非常明確的其實嚴格來講你們在未來只要去形容到Paging的時候這兩個Turn的用法其實是不能夠互換的你講Friend你講就是Physical的Hardware的Memory空間的管理Page就是Program這兩個是不互通的但是他們兩個的Size其實是完全相同所以大家常常比較粗心或不care的

人就會隨便用像我的program用我的program locate一個frame不對locate只是一個page被放到一個frame裡面去但是這兩個因為要做mapping所以其實這兩個的size是完全相同所以今天一個program因為它的memory大小不同我們就會知道它可以變成多少個page所以每一個page的數量是不同的但不管是多少我們就是目的就是要找到相同數量的frame

然後把它擺進去對不對那這樣我們就可以去做一個allocation那要做這件事情我們OS要做幾件事第一個他要知道有哪些friends free的對不對所以因為這樣才能夠去分配對不對。第二個最重要的就是這個章節的重點page table到底什麼是page table。所以其實你可以看見了這整個mapping就是page number跟frame number之間的mapping。所以這個mapping的關聯性就是放在一個memory的table就是array啦簡單來講。所以那個table我們稱之為page table它會幫我們負責做translation時候需要的這些information

用了這個paging概念之後很明顯的你可以看到第一個就是我們的這個physical的address space可以用non-contiguous的方式分配給我們的使用者。所以使用者看見的這個空間他以為是連續的可是我可以把透過map到不同的frame其實實際上他擺放的位置看見的他就會不連續。所以實現我們說的non-contiguous的allocation然後另外一個好

處是因為配取是fixed size所以它其實沒有external的fragmentation完。全沒有那internal的fragmentation我們剛才說的它可以盡量的減少因為其實你配取切得越小你的fragment的maximal就被綁得住了所以你切得越小這個問題也可以被減少當然也不能切太小我們之後會有很多的討論切得太小你可以想見比如說你

的page table的entry會很多你要去找到它會很慢等等所以其實它有trade off在那裡第三個最重要其實這是非常重要的就是share memory的概念我們之前有介紹過Programming你可以create share的memory或者是我們剛有講到dynamic linking我們去share library的程式到底怎麼做到的其實因為有了這個mapping所以其實我們

就可以在這個page table動手腳它也是存一個reference嘛所以pointer的概念我們只要把它指到相同的frame那其實他們看到東西就相同啦就可以share對不對而且不用duplicate對不對而且為什麼要變成page或者是切割咧因為我們不是share整支program啊我們只sharecosection對不對我們只sharelibrary的某一個function所以

當你切割之後你才有辦法做這種fine-grained的sharing而不是整個程式被別人看光光對不對所以paging就可以做很多事情就可以達到剛才說的那些非常重要的功能了好 正好我們今天可以看完這一個所以到底什麼是paging看這張圖其實就一目了然了啦 對不對所以這個就是各位的Program

LogicalMemorySpace它可能是CodeSession等等的反而是各位程式的這些MemoryContent那右邊呢是Physical的Frame所以是我們實體記憶體空間那我們就會把它切成最大小看起來一模一樣那為什麼要一個PageTable就是你可以看到譬如說這邊Page0我放到的是Frame1Page1放到的是Frame4對不對所以我可以隨便亂放

我只需要透過這個PageTable裡面有個map0-1473這個大家一看就了解所以這樣我就可以做Discontinuous的Allocation所以這個東西就是我們俗稱的PageTable所以這個PageTable你可以看見它是為了執行一個層次的時候要的另外一個Data Structure所以這個PageTable其實是OS去做Allocate而且是OS

去做Maintain使用者是不能去Touch它的有點像我們說的Process Control Block一樣，這些其實都是OS去Maintain的，而且很重要的一點是每一個Process有它自己的Page Table對不對。所以今天假設我們還有另外一支程式，那它的Page 0對到的可能就是Physical Frame的2，所以它其實會有它自己的table然後0的entry就會寫2。所以每一個人程式是有自己的page table的，但是我們可以去做sharing，因為其實我們只要裡面的pointer就是frame number寫得一樣，它就可以

做memory的sharing了對不对。那另外它還有一個好處就是你可以看見一個program，我們說它不能夠去access別人的memory對不对，怎麼去保護呢？同樣的，只要在page table裡面我沒有寫到別人的frame number，你根本就不可能access得到對不对，因為我們這邊寫14，37，所以代表這支程式，我們在MMU裡面哈維爾在做事的時候，他只會touch

到這四個frame的content，別的程式或許占掉了5，但是他不可能touch到，因為根本指不到，所以就可以達到memory protection的目的，所以這就是所謂的Page Table這個Paging的做法就是這個樣子，那後面 translation 我們要等到下一次了，因為這個是看到是 page 跟 frame可是你要注意到我們 program 指的是 by address所以我們可能是 access 是某一個 page 的第幾個 byte那我們要把它轉換到它實體第幾個 byte 的位置所以不能只是 page frame 的 mapping我們接下來會講 address 的這個 binding 的 mapping 好， 那今天就先上到這.