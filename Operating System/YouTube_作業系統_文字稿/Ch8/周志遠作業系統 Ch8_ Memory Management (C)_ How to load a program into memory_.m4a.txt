undefined
剛剛有個同學問一個問題所以讓你們知道一下也好就是比較不會confuse就是

就是我們說Low Time的這個Address Binding啊當我們說Low的是說從Disk Image到Memory嘛對不對那是說是從這個Low到Memory的時候他去做Address的Binding那我們後來講到Wrong Time對不對我們說這個是所謂Low Time那Wrong Time或者Compile Time的話我們是說當你在做這個比如說Virtual Memory的機制我們在做Swapping的時候對不對當我們把這個Memory Accountant從Disk要搬回來的時候

我們再去設這個Address然後去做Translation這兩個很像的地方在於說都是把我們的Program的Memory Accountant從Disk搬到Memory可是Loader跟做Swapping我們通常叫Swapper這兩個人是不一樣的那Loader他是Assuming這整個程式是重新開始所以他其實做非常多事情不只是把單純的說把一個Program變成Process的過程它要去Create我們之前說的Process的Control BlockMemory要

做Init因此，載入器（loader）所以會有非常非常多的事情不是只是單純把你的Code從這個Binary Code然後搬到Memory而已還有Heap、Stack這些所有的這些Structure、Data Structure為了管理這Process Data Structure都有Loader來去做這個Create然後去做這個allocation的動作所以是很複雜的loader。但是，swapper我們後來說的我們下一個章節要介紹的這個virtual memory的這個專

門負責在這個搬移memory content這個部分的時候他只是單純在搬移memory的content而已；意思就是說你memory裡面假如他有這個一個位置他有多少個byte那他覺得不要了他就把它搬到disk他覺得要就把它搬回來很單純就這樣而已；他只在做Data的Copy在Memory跟Disk之間那個是Swap而做的所以這兩個是有像的地方就

是他們都跟Involved Disk跟Memory但其實這兩個人是完全不同的程式不同的System Component，所以像Loader如果你說叫Loader去改他的位置意思就是整個程式重來的意思重跑，但是你叫我們之後介紹Virtual Memory的機制他在搬移的時候，他去 reset 的時候，他是 wrong time 的。他只是很簡單地把這個值去做修改然後修改之前我們到最後都會介紹他會先把 content

從 disk 搬到他要的位置。他已經確定位置之後，他在這邊做設定就好就這樣而已，所以很單純的所以其實做的人是不同的。然後一個還是稱為 low time，那一個是稱為 wrong time。雖然兩邊都是在這個Memory跟Disk相關啦，但Load它是從一個Program變Process的過程那我們之後談的Virtual Machine只是很簡單的是Memory content在Disk跟Memory搬移就只是這樣而已，Data的Movement而已，所以其實差別還蠻大的。我們剛剛提到這個Linking所以一般的Static Link

就是各位在Compile現在大家一定都只用也不是只用過啦，但我相信你們現在Default Command Default Command就只是用Static Linking的做法也就是你知道GCC的時候它會Code Linker嘛對不對然後Linker會做的事情就是你把它Program其實很小可是你Linker完之後你會發現你的Binary檔案變大了為什麼因為你其實還要把其他Library的程式碼把它一起並在一起，所以你的程式碼就變大了。

那它會把它全部都變成一個single的這個binary的程式裡面的binary code裡面就已經把所有的code都放在一起，這就是我們俗稱的static linking。 Link完我就把它放進去了，所以我在load的時候你可以看見loader load的時候它load是一整個，因為它就是拿到一整個嘛！它也不知道怎麼分啦，所以它就把它整個load到memory。但這個問題就是這邊看見的，我們當有很多很多library為什麼叫library就是大家都要用嘛！

所以很多程式一定都會share很多的library的程式嘛尤其像C library就不用講了對不對，所以你可以看右邊尤其這些library都不小啊對不對，所以你可以看到右邊我們整個memory可能就被這些程式的這些library給佔滿了而且它都是duplicate的所以會變得非常的不理想對這個系統而言。那這個問題跟剛剛我們才介紹過的dynamic loading是不一樣的喔！因為你要記住dynamic loading只是對一支程式對不對，

我們剛剛是programmer自己的程式的這個什麼時候去使用它的這個問題，那像這個問題你可以看見是跨程式所以對於這支程式而言，它就只call一個library就是它要的嘛，所以它當然還是要load到memory對不對，所以loader沒有辦法解決這個問題，就是dynamic loading算算你把這些變成所謂的dynamic loading的function也沒用，因為他真的

要，所以他還是會有他自己的一個copy所以就算你如果是用所謂的static linking，但是你加上dynamic loading這個問題仍然會存在的，那要解決的方式呢就是我們要介紹的dynamic linking了，所以什麼叫dynamic linking呢？簡單而言之，就是我們知道linking的概念，就是說你的function去call另外一個library的call嘛，那這就是你要link過去的意思，所以dynamic的話就是again wrong time linking的意思所以也就是像我們就看右邊的圖對不對，所以我們的

程式漏進去的時候可能就只有main program而已那當他要去用C library的時候，其實我們只需要放一份啊，因為library的定義就是他不會改嘛，因為它大家都要用所以它其實是所謂的immutable就是不能夠被修改的就是所謂的 static 的 code 在那邊，所以其實你可以讓他們去做 sharing所以你要去 code printf 的時候，那我就再 link 到這個 C library 的printf 的 function code 就好了，所以 runtime 我再去找為什麼要 runtime

呢，因為這樣的話，如果這支程式假設它先 code 了，所以它在 code 的時候，它就會把它 load 到 memory然後開始使用第二支程式，它也要扣printf的時候，它就可以先去看有沒有這個library已經漏在memory了有的話，它就直接用了對不對它就不需要自己再copy一份了，所以它在run看的時候去找那，如果都沒有人用，那當然還是會去漏的它，但是你可以確保，所以我們的OS就會確保只有一份library在這個整個系統裡，所以你就不會有duplication的問題了對不對，

所以當我們說Dynamic這件事情就是在概念啦，所以真的要實作要能夠做到的意思，就是其實你在Compile這個Library的時候啊，它有兩種Compile的方式，一個叫做把它Compile成Dynamic Library，一個是把它Compile成所謂的Static Library，你把你的程式Compile成Dynamic Library像是Windows裡面，其實大家很熟DLL到底什麼是DLL一大堆檔案你如果去看系統檔你看一大堆的DLL檔案

那些全部就是dynamic library所以你可以想見為了系統效能通常會prefer把它變成dynamic library所以它不只是library而且是所謂的dynamic也就是說你在runtime的時候你可以去call它它才會被load到memory那為了要在runtime的時候所以你在compile的程式的時候當你在include library的時候其實你對link也需要下一個flag去告訴它這個library是dynamic的還是static的

那如果是static就像我們前面看到的它就會把你們的程式全部綁在一起然後變一包丟給loader然後你的binary code裡面就已經全部都在裡頭了那如果是static如果是dynamic的話那其實第一個你的library必須要compile的時候它就要compile成dynamic library的形式它才有辦法還可以在runtime去使用它而且你會發現你的程式就不太

這個檔案Binary檔案就比較小因為其實你根本還沒有include這些進去你的Image裡頭沒有這些code所以它會變得比較小那為什麼我們說Compile的時候它 Compiled ile的方式不一樣因為你就可以看見基本架構就是這樣其實你如果是Dynamic的話在你的Compile time還有Linker的時候它會去加這些程式嗎會幫你偷加啦所以其實這個MainProgram它知道它的這個Linker是Dynamic

他就會去加一個stop簡單講就像這個我們剛才講RPC他反正就是加一個去幫你做這個轉換還有去address的去找的這些code所以我們通稱為這種叫stop就是一個很簡單的小程式然後一樣它其實是function level所以他會知道這個function是一個dynamic linking的function他就會在code的這個function的過程中加一些程式碼做轉換也就是他會去問OS

你有沒有已經load了這個library了然後load的話它在哪裡就這樣子所以其實是塞了一點code才能夠讓這件事情實現的所以當然你的被code的人也要被修改所以才說這個library對不對它被compile的時候你會要跟它講到底它是不是一個dynamic library是的話它被compile的方式會不一樣這樣子我們的OS才有辦法去讓它跟你的程式溝通在run time

所以這就是所謂的Dynamic Library的形式所以就像右邊看到，所以那個Stop會跟OS去問然後找到位置然後再去做Linking的動作，那沒有它會再去Load它，這就是所謂的Dynamic Linking，所以它的最大的貢獻跟剛剛的差別就在於它是不但可以節省Memory的空間而且是節省程式之間的，所以這個才是這個programmer就沒有辦法control了；

Programmer就只是你決定你是用dynamic還是static的library，那一旦是static那它所有裡面的function都是用這種方式去做linking的，那它有一個小缺點啦，如果你看了右邊的圖就可以想見到跟static的差別是，它多了這個stop，所以代表它runtime，它才要去找call一些system call，所以會比較慢，所以如果你是用dynamic的方式去link library的話，你在execution times的代價就是它會跑得會慢一點，但也不是很多啦對不對，

所以它會稍微慢一點，但是static好處就是比較快然後你也不需要OS所以OS的這邊的support，因為有一些我們說像embedded或是現在很多就是越來越IoT的device越來越簡單，它OS很簡單所以它可能根本不支持dynamic這個 linking的事情那像這個其實OS要support嘛對不對不是只是program這邊所以也不是OS你都可以用這種

方式的，但大部分是啦，所以你會看見我們OS一大堆dynamic library。 By the way，你會注意到我們這邊，我們雖然有講了dynamic loading跟linking，但是不管你是要用dynamic linking或loading去access一個library的話，那個Library都同樣，我們稱之為Dynamic Library就是你Dynamic Library的這些Function Code就是可以拿來用在Dynamic Linking或是Dynamic Loading上，那只是用法上不一樣，但如果你是Static就沒選擇了Static Library，意思就是你根本就不能夠做剛剛說的這兩件事情，這兩次一個是OS幫你做，一個是Programmer自己可以去做的。

前半段我們講了非常多很重要的東西，所以這三個 address binding 的差別要很清楚當然越下面越有彈性，你可以做很多 runtime 的 memory 的 management，但是越上面的好處就是越簡單，OS 的設計也可以簡單然後你的執行的時間其實會比較快，因為它就是沒有Round Time那堆有的沒的像MMU就算是Hardware，它也要時間所以說當然越上面越單純它跑起來其實通常是越快的所以越簡單的Device可能會選擇上面這都是有的

Virtual Address 跟 Physical Address 的概念非常重要而且其實它們的區隔很明顯就是一個是從 CPU 送出來的 Address一個是送進 Memory 的 Address所以送進 Memory 的我們才叫做 Physical Address那從 CPU 送出來的我們統稱叫做 Virtual Address 那我們 Programming Against CPU所以其實我們是看見的我們都是在做 Virtual Address 的 Programming 而已最後這個linking跟loading的動作什麼是dynamic的linking跟loading這

個需要知道因為這個其實很常見各位真的去用自己尤其如果自己要去裝一些application或比較複雜一點的系統套件的時候你一定會發現它會跟你講它是static還是dynamic像dynamic loading你在寫program的時候其實是很好用的你要很多porting的問題你可能是透過dynamic loading那一套方式去解決的.