undefined
那我們就開始正式進入我們會跳到第八章了。我們一開始就有提過這一章是最重要的一章就是尤其是上半段的課程裡面Memory的管理因為我們對Process的基本的概念有了之後我們就來看到底是怎麼去管理這個Process它的Memory因為我們看到Process其實當我們Program變成Process的關鍵就在於它漏到Memory裡面了

它有Memory的Content了。所以這些Content到底是怎麼被管理的就是我們這個章節要開始講的了。所以當然基本的先介紹一些關於Memory的使用上尤其跟Program之間結合的這些基本的概念然後會介紹swapping。所以我們還記得的話意思就是memory跟disk之間的這個運作當我們在memory的content在disk跟memory之間在做翻譯的時候我

們叫做swapping因為我們下一個章節virtual memory就會看見就是based on這個做法那接下來的呢四個部分就是最重要的部分全部都是在講這個memory我們知道它就是一個一塊空間嘛而且是連續的對不對那這些空間到底是怎麼對到我們程式裡面之前才說的什麼Code SegmentHipStack這些Memory的這些Space他們到底是怎麼把它分配給這些程式的而且尤其是這些Memory空間我們馬上就會看見為了有效率的去應用我們實體的儲存空間其實會被做切割然後

散落各地所以會透過所謂的paging跟segmentation的概念來做管理所以各位看到其實都是一個假象真正的OS其實它會用另外一套方式把你的使用的memory空間map到實體的空間去甚至於map到硬碟的空間去那segment大家就可以看見了segmentation fault為什麼你們在用pointer說使用到SSL無效的記憶體空間你會得到一個segmentation

fault就是因為其實我們OS在管理的最上層的時候最接近使用者program的時候其實是透過segmentation的概念所以是在這一層出了問題他發現你的程式有fault出現所以才會丟一個interrupt 所以叫segmentation form然後叫OS幫你處理然後使用者要看到的就是這個program就terminate掉了那最後你可以看見有paging 有segmentation所以真正的作業系統當然是複雜所以它其實是結合兩者在一起那當然我們會先介紹個別的介紹那最後其實這兩個方式是可以套在一起使用的好Mem ory

為什麼那麼的重要就像我們一開始就有說過第一個Memory有非常多特色。第一個是它是唯一CPU可以直接access的。我們知道CPU在fetch你的instruction、fetch你的data的時候都是fetch在Memory上的content而已。它可能是instruction可能是你的data，但全部都必須要放在Memory裡面就算有所謂的Cache那些都只是中間為了加速暫存的東西而已。 Eventually，實它就是一定要都在Memory裡面那也沒辦法Access到Disk或任何其他的Storage的Device。再來，我們也知道就是為了要增進這個系統的效能。我們的

電腦在運作的時候並不會只放一個Process那是最早期的我們說的Batch早期的Memframe做的事情。後來為了增加我們的CPU的使用率大家這個一定還是要記得的。所以，我們有Multiprogramming對不對？又來了。所以就是把很多Process放在Memory裡面同時可以執行。那這樣一做就複雜了，因為就必須要去這個OS要Control每一支程式到底可以用多少的Memory空間

然後這些Memory空間到底散落在哪裡以及要做Protection對不對。隨意的去改變別人程式的Memory空間所以這些全部都在Memory Management這邊要能夠Support那我們都會看見這個它基本的Solution最後就是我們說的其實我們Memory畢竟還是有限所以說我們為了讓它可以擴展我們現在的電腦甚至於有了這個Virtual Memory的概念所以把Disk也當作Memory的一部分所以變成Disk跟Memory之間必須要在那邊開始做切換了所以也會有這個issue的存在你可以

看見這個是一般電腦都會有的這些問題但是當然也不是全部都一定有像是手機手機其實大家知道它的Disk也沒多大對不對所以像手機或是一些Embedded System它或許就沒有Virtual Memory的概念或許就會把這個拿掉但是大部分的電腦基本上都是要去想辦法管理Memory甚至於把硬碟把它納進來當作它管理的這個空間之一好

所以這邊我們對於Memory管理的以使用的角度來講會先介紹就是到底這個Address Binding到底是什麼我們把Program跟Memory要能夠把它對在一起那各位在寫程式的時候Run程式的時候一定會常常我們知道所謂的我們說有Loading的時間還有Linking其實是有很多過程的而且這個過程很多可以發生在Run Time不一定是

在執行之前所以有所謂的Static跟Dynamic那其實你們未來去執行程式還有去開發程式尤其比較系統程式的話就常常會聽到所謂的什麼叫做Dynamic Loading或是Dynamic Linking那這邊我們就來會介紹一下這個機制到底是什麼好那最後當然就是swapping跟這個paging跟segmentation這些管理上的動作我們會花比較多的時間好那我們

就先講program跟memory之間的連結到底是什麼那首先第一個他們的連結其實就是這種所謂的address binding我馬上就會講到的也就是說你的program寫了很多的variable對不對大家都知道這個variable會變成某一個memory的address可是這個memory address到底是map到physical address的什麼位置這件事情其實並不是compile完就已經知道其實是有很多種可能性的我們等一下會一一介紹所以這些可能性基本上可以根據它的時間點會分成三個

不一樣時間點就從一個程式從compile到最後執行的流程我們來做一個區隔第一個部分就所謂的compile time當然指的就是你做comp ile的動作所以意思就是你在compile完的compile的這段時間內你如果就做一個決定就叫所謂的compile time那你compile完之後你到了这个link起来之后你要真的要去执行我们说你要漏到memory对不对那这个时间我们就称之为所谓的low time所以low time就是当你准备要把这个程式放进我memory的时候

我们称之为low time那最后呢到了memory之后开始真的执行了这个我们叫做execution time或者说是wrong time啦所以還蠻直接的嘛 對不對所以知道我們程式的過程就是要Compile Link然後再Load然後Run四個流程的話那其中的這三個Compile TimeLoad Time跟Execution Time指的就分別是這三段時間那所以我

們之後會介紹的就會看見的就是當你要把這個一個Library我們大家知道像CLibrary好了 對不對甚至於你寫程式會用很多的Library這個Library其實會分成你是在這個一開始static就是你在compile time我就應該說我在link time我在link time的時候我們那時候就是說link就是為了要把不同的library把它對不對link進來放到我們的程式碼裡對不對所以這個時間就是我們俗稱的static的loading就是固定的還沒執行我就把它load進去

我們之後會介紹的dynamic loading指的就是wrong time不意外對不對就是在執行的時候我才把它漏掉我們的memory裡面去還有dynamic的linking指的也是wrong time的意思如果是static的linking就是我們說你在linker就幫你解決掉static的loading指的就是我在low time他就把它解決掉那我們說dynamic的linking跟loading是什麼意思呢就是wrong time去做這件事

情所以就會我們之後介紹這四個名稱那我們之後會分別再解釋這四個到底差別在哪還有address的binding其實會在這三個時間都有可能會發生的好那我們就來開始介紹了第一個純粹是這個 address binding 這邊就像我們一般的很簡單的程式嘛有 data 對不對所以 data 是一個 variable我們知道它要 bind 到某一個 physical address 上面那所以最早期的這個方式binding 的方式就是在 compile time 就去做也是在我在 compile 一個程式的時候我就 assign 它的 physical address 的位置

所以不意外你看見的就像這樣子compile我們知道它就是把它轉成機器碼那翻成機器碼的時候你就必須因為是instruction所以它吃的東西不是variable name_it吃的是address所以當它是一個所謂的compile time的address binding的定義就是在compile的時候我就要決定這些variable它的address physical memory的address到底在哪裡所以我在送進我們的CPU的時候他就知道去哪裡去把這個variable的值讀出來了對不對

所以我們程式才可以運作所以可以想見的當這樣子compile time決定完的一個code當它漏到memory的時候你就會發現一件事因為我在compile time我已經決定好它的位置在哪所以當我漏到memory的時候我的位置就要一模一樣對不對因為不然就會mismatch我就會讀錯資料嘛對不對所以像這邊如果我們在compile time的時候

就寫0x1000意思就是這個program我assume它在執行的時候它會被漏到0x1000的位置對不對然後接下來因為我自己的counter 哪麼所以我知道這個剩下的空間會怎麼發所以擺進去之後， 當執行的時候我們CPU就只是一行一行讀而已那它看到什麼位置就去哪裡讀資料，所以因為擺的位置跟我當時說的一樣，所以它可以正確的讀到它要的值沒問題吧！ 對不對所以這就是所謂的Compile-Time Address Binding。那你可以想見，如果今天我們電腦就一個程式而已，

然後他有知道所有的記憶體擺放的位置在哪的話，他當然就可以這樣子起Comparison的時候，就先決定好我要執行反正只有我一個人在用這台電腦，所以你就把我擺在我要的地方這個就是比較早期沒有什麼Competition Memory的管理比較單純的時候的做法就是這樣那事實上其實對OS而言尤其是它因為它

是最早第一個被啟動的程式所以有時候尤其像我們做早期的DOS這些作業系統就是用這樣它全部就是自己寫完這種Compile-Time Address Binding，所以我們又稱為Absolute Code，這只是一個別名啦！所以就是絕對的位置簡單講這個的好處就是非常簡單然後你Runtime的時候會非常快，因為CPU它要的位置就在那裡，所以你給

它的位置是什麼它會直接就可以去做Access我們之後看見還需要透過翻譯，你就會想接的是比較慢所以它是非常快。而且寫程式非常簡單，但是它的缺點很明顯是什麼。如果今天我們要去搬動這個程式在memory裡面去搬動的話，這整個程式是就完了對不對，因為如果我們就把它比如說從0x100把它搬到0x2000哇，那是不是就不行做事了對不對。

位置就跑掉了那因為這是compile，所以我們已經把它寫死在我們的code裡面了所以除非你recompile，不然這個值是沒有辦法去改變它的對不對。所以它的缺點就是如果今天你要去搬移程式，你必須要recompile那不只是recompilerecompile完之後等於就是要rerun了整個程式就等於是kill掉再重來一次的意思而且還要重新compile、compile完你改了這個base address重新compile重新load重新execute，這個就是Obsolete Code的它的缺點

當然對於一些簡單的我們說簡單的Embedded Device然後是這個你寫只有一個人在使用的話常駐的一些程式你就是會站住那塊Memory的話當然還是可以用這種方式，但是對於General的電腦還有對於很多使用者很多Process共同去Share一個這個Memory空間的電腦而言這方法就會非常的不理想尤其是我們接下來會

介紹的這些所謂的Dynamic這些事情Linking Loading等等，意思都是我 Runtime我才會知道什麼時候我要去哪裡讀我要的Memory Content。那基本上，這個Compile Time的Address Binding就沒有辦法去做這些Support的動作。尤其是我們下一個章節講Virtual Memory，意思就是你會好奇我程式為什麼要搬來搬去。第一個就是我們剛剛說的wrong time之後，你可能才知

道你到底要指到誰對不對跳到什麼位置第二個更主要的原因是，實我們的這個process and memory的空間會做搬移的。他會搬到硬碟，因為當空間不夠嘛。 мы說他把它搬到硬碟，那你搬到硬碟，你搬回來，那可能那個空間被別的程式佔住了對不對，那你就沒有辦法放到原來的位置了。那Solution,簡單的就是等嘛但是你不知道等到什麼時候對不對

所以如果你想要搬到其他位置那這個Compile time的話就要重新Compile就等於是不行啦所以你可以想見就做不到Virtual memory要做的事情好那稍微好一點很快大家就發現那可能對於作業系統本身的層次或許可以這麼做吧但是對於使用者的Program隨時新增移除然後很多的變化的話是非

常沒效率的方式所以做了一點改善就把它變成所謂的Low Time也就是把這個決定Address的時間把它做一個Delay那什麼叫Low Time呢就一樣的例子我們來看它的差別非常小所以大家仔細的看也就是在compile的時候呢我們剛剛的例子會看見因為是compile time決定所以這邊會寫的就是絕對位

置可是呢我們要在delay的意思就是我們要在下一步這只是compile所以compile我們還不想決定那不想決定的方式很簡單就是有一個叫做base register的這個變數把它留下來這一個register值我們在loader所以不同的這些systemloader的時候他再去設compiler不決定這件事情他就把它只是說register你到時候你可以透過register去改寫這個initial的位置那我要管的就只是我這個program裡面反正這裡面都是我的空間嘛對不對

反正是個連續的所以again我可以知道它的相對位置是什麼所以我在compile的時候我就只是塞一個Base Register然後算出我的相對位置那什麼時候它必須還是要變成實體位置啊不然CPU看不懂嘛對不對所以當你在Load的時候這個時候就Depends on當時當下這個電腦的Memory哪裡有空間那我就去找然後我就知道Base Register值是多少所以Loader這時候他才去看哪裡有空嘛對不對

那他知道之後他就把這個職做改寫所以把他放進去的時候他就會替換掉變成正確的位置了，這就是所謂的Low Time對不對。所以你可以看見Loader來決定Address的Binding，這個就是所謂的Low Time的這個方式那這個方式就叫做所謂的Relocatable，意思就是我現在就可以搬了，所以所謂搬的意思是說我Compile完之後，我可以搬到我們Memory的任何一個空間，所以比較有一點彈性的，至少我在Compile跟寫程式的時候，我不需要知道哪裡會有空間流出來，我在執行前，我在Load的時候，我再來找位置就可以，這就是所謂的Load Time，

但是這個就算這樣的，它在load的時候它可以重新決定可是問題是，again，如果我在wrong time的時候，我想要換位置怎麼辦對不对？如果把這個程式swap到disk我再swap回來，我放的位置想要不一樣的話，again很明顯的你就必須要reload啦對不对，因為這個動作必須要重做嘛，因為只有loader知道位置在哪對不对，所以如果今天想要改回到0x1000

那很抱歉你還是要把你的程式給kill掉然後重新code load尔然後再run一次，但至少不用compile了ok那而且勒你能夠找到空間因為你compile完到你真的執行的時候會隔很久啊對不對我們都知道code只是compile完嘛那隨時都可能或者隔很久你才會去run它那如果是low time的話你就不用擔心反正你先考判完再說我要執行的時候我自己再去 figure out但是你沒有辦法去把它做扳移在 wrong time

的時候重新扳移就還是要再去 code loader重新 wrong 一次所以對於很多使用者如果你的 memory 管理是比較單純的我們就是一旦我找到空間我就把你限制在那裡的話那 low time 這個 solution 就有足夠的彈性了但是如果你想要在 wrong time 再把它做翻譯它也還是做不到所以它叫做所謂 relocatable code大家記這個 low time compile time 比較簡單然後這個名詞就只是輔助就是比較專業一點的人比較這個 domain 的人他們可能會用這樣的一個 term不過大家只要知道它是 low timeloader

去做這件事就對了好那最後一個，所以可以看見這還沒有達到我們最後想要的目的還有現在電腦的運作的方式所以我們想要達到的是什麼呢?就是這個Round Time或者說Execution Time的Address Binding那原因就是因為我們可以有Virtual Memory的概念還有在Round Time可以Dynamic去做這些Memory的使用的這個方式那所以到底怎麼用Round Time呢?

_again我們來看同樣的Example這次他在compile time跟load time的時候你會發現沒有差別你會發現他就只是都是相對位置這邊之所以0x18意思就是從頭開始的0x18相對於這次程式的位置所以compile的時候就跟loader一樣他就直接知道他位置在哪就好因為這只跟自己程式碼有關那在low time的時候你會發現仍然一樣喔所以看起來好像是最簡單的Solution對不對就是我什麼都不去動它那0x18我就真的是

只是放一個0x18在這個位置上面那為什麼可以work就是我們等一下之後通通要教的就是所謂的Wrong Time的做法但是Wrong Time的Address by name重要的是你會發現的事情是它裡面的Address放在Memory跟它實際的位置居然是不一樣的對不對在前面兩個SolutionEventually放上去之前它一定要把它Match對 才可以但是Wrong Time所以它就算漏到這個Memory它還是不做Translation它還是就放一個相對位置而已所以你看它實際上的位置應該是2018才對但是我們的

Instruction裡面放的Memory Address還是把它放0x18而已所以這個Address就是我們所稱的Virtual Address所以它是假的就是虛擬的因為即使放到了我們的memory送到了CPU的時候它還是一個假的Address所以我們稱之為所謂的Virtual Address那0x2018那個才叫Physical那才叫真的未知好所以為什麼這會work咧答案是我們等一下就會看見是因為其實咧我們的

CPU當他想要去讀這個Memory content的時候他把這個0x18位置送到我們的Memory之前會有另外一個Component叫做MMU MEMORY MANAGEMENT UNIT這個人他會在Wrong這就叫做Wrong Time因為他是都已經CPU完渾然不知他就是以為 0x18 就是正確位置他就送到 memory可是送在那之前這個 MMU 會把他這個時候才做Address 的轉換然後把他變成了 0x2018所以這叫所謂的Wrong Time所以在 Memory 你都還看不見正確的位置事實上 CPU 也都不知道唯一知道的人就是MMU

所以我們這個章節後面在講的paging跟segmentation到底implement在哪就是implement在MAU是implement在這個裡面的那它其實是part of OS它是OS做的事情之一但是因為我們可以想見這個memory的access是非常頻繁的在我們run程式的時候而且每一個address你都要做翻譯所以真的在實作的時候這種真實的電腦系統這個MNU這些程式

是用Hardware其實它是把它用Hardware把它Hardwire一個Logic在裡面把這個演算法implement在裡面然後讓它去運作所以才夠快就像我們說Cache加速所以這個部分我們介紹的觀念其實實際上是被寫到MNU裡面然後做這個 address 的 translation而且是送到 memory 之前他才做的所以叫所謂的 wrong time所以所謂 wrong timedo 到底發生什麼事其實在 memory 裡面都還完全看不出來那所謂的 wrong time 的意思就是像剛才說的CPU

呢他會送一個所謂的 logical 或是 virtual也就是他在 memory 裡面看見的那個 address可是其實是假的那我們都知道CPU要fetch data它一定會下一個fetch的指令，然後下給Memory的unit，然後給它一個address可是這個address其實是假的，就像剛才是0x18而已，如這邊就只是一個346可是送之前送到asset之前runtime asset之前這一個MMU，它其實會先送到MMU這個component裡，然後它就會做address轉換，

然後得到真正的位置，那個位置就是我們說的physical，所以像一個很簡單的translation你可以想見的就是我們假設記憶體都是連續的話，其實我就是只是加一個base register值嘛對不對，如剛剛是0X1000還是2000或是這個例子或許我是把它放在14000對不對，所以其實它也就是一個base register值而已，所以那個register值其實是會送到MNU的，然後Runtime他去做加Shift之後他就知道真正的位置在哪對不対

所以他就可以讀到正確的值所以 Runtime的時候你可以想見如果我們今天在Runtime要移動一個程式他可能從14000移到24000沒關係啊我在執行那個程式之前我們還記得Context Switch嗎對不对，所以Context Switch的時候裡面其實這個content裡面有一個就是這個mem ory base address的值，它就把它漏進來再開始執行你的程式，所以它就會shift到24,000，所以你怎麼辦都無所謂，反正我runtime都可以找到你，所以就是所謂的這個runtime的address binding了，那其實實現的方式是透過這個MNU，那這個就要

手機，你一天到晚應該都會聽到MMU MMU， 指的就是這個Memory 的 Managed Unit，其實它是 hardware 做的，所以這樣我們就算有 Virtual Memory 等等都不是問題了，我們 always 可以透過這個方式，但是不會是剛剛那麼簡單，就是加一個值而已，我們後面講的Paging 跟 Segmentation 就是在講還有什麼 address 所謂的Translation，所以MMU就是在負責address的translation，那其實是可

以到很複雜的，所以我們講完這個address binding最重要的，除了剛剛三種不同時間點做address binding的方式之外，大家要現在開始建立的就是所謂的logical address跟physical address的概念，所以logical定義就是它是一個virtual address，那最標準的定義就是它是從CPU送出來的Address，我們其實統稱叫做Virtual Address那CPU居然是假的，对不对所以誰是來真

的呢？真的是Memory Module所以是真的送到Memory Module的那個Address我們稱之為Physical Address這兩個Address我們剛才看進根據你不同Address翻譯的方式有可能一樣有可能不一樣，对不对所以像是Compile Time跟Low Time你就會發現這兩個address是相同的，对不对所以你漏到memory你就已經是真實的physical address了所以你的virtual跟physical其實是一模一樣的也一定要一樣。但是在wrong time或是execution time的特色就是它們兩個不同，所以其實是wrong time的時候他做所謂的address translation然後去找到最正確的一個mapping的關係

那這個設計非常非常的重要，因為你可以想見第一個就是我們未來會看見的因為這個不用match所以我們在OS在管理我們的physical resource的時候非常有彈性只要有空位有位置我就可以辦法去使用它只要透過一個translation使用者都可以去match到它那更重要的是對programmer大家真的使用者對不對我們都知道

你在寫你的Program的時候還有像Compiler對不对它要把你的Program變成Memory的位置的時候它其實只要管的是Logical Address就好對不对意思就是對於其他程式它可以完全視而不見然後到底電腦的Memory的使用跟管理方式它也可以視而不見對不对你只要管你自己的程式管好就好所以因為你是對logical的address在做這些programming還有compiler等等的動作所以它大幅的可以減少這整個系統使用的一個複雜度所以Compiler其實benefit最大因為它Compile就很單純就是跟原來一模一樣所以前面例子你會發現Loader Compiler什麼事都不用做不用擔心Address Finding全部丟給MMU就對了嗯.