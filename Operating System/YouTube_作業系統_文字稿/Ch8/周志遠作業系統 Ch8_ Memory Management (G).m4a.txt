undefined
好，所以上次我們最後看到的就是這邊對不對，就是如果給你一個這個TLB的rate的話，你可以看見畢竟這個TLB是Hardware，所以它的速度會非常非常的快，至少十倍以上的快，那這是例子啦，那如果你不讀TLB，你要讀Memory的話，它就是會比較慢，所以像這例子就是20個Ns跟100個Ns那，所以大家可以很簡單去算一下給你一個Heat Rate，那不要忘記Translate的這個過程，就會知道第一個部分是有Heat的話，我只要看一次Cache，就是這個TLB

然後我就可以直接去讀我memory的content所以應該是120個neural second而已可是，如果我是miss的話那當然這個TLB這個優化它也是有代價的，就是如果它miss你還是要把這個時間算進去，因為你要先看了才知道是hit還是miss嘛所以其實這20個neural second不管怎樣都會發生的，那如果我們不信你是miss的話那就更慘了，因為你要先去把page table裡面的值讀進來也就漏到說我們的這個

MMU裡面然後讓他可以開始做translation就是剛才那個table lookup的動作那translate完之後才能夠去access我的memory去讀我真的要讀的那個byte的值，那又是一個100個narrow second所以就變成220所以算一算就可以看出來雖然是有些代價要配啦但是你可以看見有這TLBHT rate如果70%的話速度還是會比原來沒有沒有就是200個narrow second對不對

還是快了將近25%啊所以還是蠻好的那更不用講如果我們的heat rate是98%大家去算一下就可以把它bring down到122那所以這個TRB的這個對performance來講就是memory的access的時間是很有幫助的尤其大家知道我們program在run的過程中不斷不斷的就在access memory嘛所以這其實是非常必要的一個手段那上次還沒跟大家提到的是98看起來非常驚人我要98%我才能夠到120而已還不到100對不對

你可能會覺得真的有這麼厲害嗎會不會只能加速個百分之20%我的hear rate會不會只有40%對不對那事實上電腦系統這個hear rate會非常非常的高事實上遠高於可能99%以上那原因其實非常的單純因為其實我們的電腦大家知道是很多特性存在的像我們的program在讀資料的時候也就是讀memory裡面的這些data的時候

其實會有很強的所謂的locality我們等一下下一章會更會用到這個概念也就是說你讀的資料其實都是有順序性的對不對然後都在附近簡單來講就像各位寫的codeinstruction by instruction所以是不是你也是move program counter所以其實它就是四個byte 四個byte 四個byte 連續的在讀那不要忘記我們一次cache這個TLB它cache的是什麼一個page喔所以是4KB喔10的12次方-wow!

所以你第一次去讀一個page裡面任何一個位置的時候你很不幸你會miss但是你就會把它的這個前面這個entry對 page entry就把它load到TLB接下來的一千個假設你就是四個byte四個byte在讀一千個扣掉第一個了九百九十九這全部剩下的同一個page的SSL全部都會是heat因為他們都在同一個page裡你只要

距離不要在4kb不要跳到別的page的話其實你一個一個byte你會讀好幾次的或者是你寫一個for loop大概都有經驗寫個array然後我對它做每個element做加一的動作這array或許很大但是你是連續的讀啊對不對那其實後面自然而然都是heat因為你都會維持在同一個page裡面的memory在那邊讀對不对所以因為這個程式啊有很強的locality所以其實這個heat rate通常是非常非常高的。自然，它就會非常高那你如果你動一些手腳或是你在compiler的時候

你多去做一些猜測啊或是之類的事情很多advanced的技巧或許還可以再把這提高不過其實你可以知道這個heat rate通常是相當高的所以98%就122了那再高的話大家可以去想想看其實就可以盡量接近100ns好所以大家知道這個TLB的這個作用所以在做Azure translation的時候不要忘記其實TLB是一個優化的動作可以不需要但是有的話你的時間就可以大幅做減少了

那至於translate的過程其實是沒差的只是你去memory裡面讀pagetable的值還是你去tlb裡面去lookup那個mapping的值而已好那所以hopefully大家已經清楚整個paging的這個做法是什麼因為大家在homework 2希望大家已經開始動手了其實要你們做的就是要去implement這個pagetable所以你就可以去看見應該很快就會發現原來NACHOS的PageTable它沒

有Physical跟Virtual address的概念所以它的值的對應的時候如果很多程式一起在跑它就會使用到相同的Physical的位置了那你們就是要用PageTable的概念要知道PageNumberPaging的這個值這個Virtual address的值不一定會等於Physical address的值。你們其實可以introduce一個table讓他做這個不一樣的mapping的話多一層level的mapping的話，那translate出來時他們就可以是

不同program就在不同的位置所以相同你為什麼跑下去會有error就是這樣其實他是互相寫到對方的address去了。所以這是你們的homework tool那大家就希望可以去實際的implement一下知道它的作用好接下來我們就要講這個PageTable其他相關的一些需要知道的事情第一個部分就是這個Memory的Protection。我們已經提過了，就是我們每個Process都有自己的Memory是不能夠隨意去Access別人的。所以在這個PageTable裡面其實我們通常會再加一個Beat當作所謂的Protection Beat，

這個bit你可以看見就是這邊的protection意思是說這個bit譬如說它可以拿來去indicate說這是有效或無效的或者是你也可以幾個bit去indicate說這個page是read only還是執行所以它在執行這個去access這個memory的時候它就知道它哪些動作能做哪些不能做就有一點像大家像比如說去File對不對我們也知道開一個FileFile有分Read Only、

Write Only等等那File要被程式去讀的時候其實也是漏到Memory裡頭對不對然後採去送到我們CPU去做處理所以當它漏到Memory的時候它可能就可以透過這個Bit很快的就可以告訴OS這個File是能讀還是不能讀或者是大家可以知道其實程式語言的時候有些變數你可以定義對不对它是不是就是always它是一個constantsign之後就不能動它了對不对所以有一些這些permission上的東西也可以

透過這個bit很快去做判斷那重點就是說它其實是有一些bit可以indicate在page table後面讓always可以很快的知道去做這塊memory這塊page它Access的時候到底有什麼樣子的限制或者是它是有效無效的好那它有很多可能性啦但是General的OS的話其實在這邊用到最主要就是只是Value跟Invalue而已那所謂的Value Invalue就是這一個Page對到這個Friend裡面的Content目前到底是不是可以使用的為什麼會不能使用呢？我們等一下就會看見譬如說

你開了一個這個Process它可能一開始程式就幫你先Allocate了很大的Memory可是你還沒有真的去使用到它也就是說它先幫你Reserve起來可是使用者還沒有真的去Call Matlock或是你的Stack還沒漲等等的所以說就有可能是這個Memory空間是已經存在Reserve給你但是它現在還沒有辦法可以使用那更重要的是實是我們下一個章節介紹 Virtual Memory 的時候我們就非常依賴這個 bit因為這個 bit 當它是 invalid 的時候就告訴我們的 OS

說這個 page 它其實是存在的所以才會在我 page table 裡面但是他現在被swap到disk上去了所以是invalid所以其實最常見是這個case不過就是有bit所以你可以知道到底是不是現在我現在去access做這個address translation就是要去access那個memory對不對那我可以擋住他的一個方式就是在這邊invalid bit先把它設起來就會知道你現在是不能夠去用這一塊

空間的因為某些原因可能是permission也有可能是我們OS動了一些手腳它還沒有ready讓你可以讀的這個狀態所以通常會有這個valid bit跟invalid bit的存在所以一個例子就像這邊看見的所以一個program它可能很大對不對那它都有對應的page table可是我們知道我們的program其實會長的所以比較早期人的做法是我們的

page table就事先根據我們比如說我們page number有多大我們知道最多可以有多少page所以我們就可以先statically的事先的先allocate一個page table然後有8個entry比如說我們page number就3個b而已所以最多就8個pages可是我們的program會漲啊 對不对所以一開始它並沒有這麼大像這邊我們可能只用了6個所以就有可能

會向右邊看到的情形PageTable前面都是Valid然後最後兩個我還沒有做Location對不对但我PageTable先把它Create出來了所以我就會用Invalid來indicate說6跟7這還不能使用所以你的Program還沒有長到那所以今天如果你有你的這個Pointer的使用的時候不小心只到一個 page 6 或 7 的話你可以看見我們在查 page table 的時候立刻就會被 return

掉對不对我們 OS 就會丟一個 segmentation for其實這邊是一個 page for 就是一個 for 出來擋掉這個 memory 的 access 所以這個是 bit 的好處那但是像這例子你就可以看見啦萬一今天因為我們的程式我們電腦其實Memory都很大所以其實這個實際上PageTable的Size絕對不會這麼小我們可以Access的空間是相當

大的那如果我們的Program很多都是很小的啊不就會變成很浪費Memory的一個行為因為你就前面幾個是V可能前面十個吧後面九千個Entry全部是Invalid所以你就很浪费空间你create一个非常非常大的page table可是其实program根本就很小然后你会存的就是一堆invalid的bit在那边结果就是造成很多无谓的浪费就是这个table会变得比较庞大可能显然没有必要所以实际上的做法是大家要判断你一个memory address到底是不是有效的时候

除了有這個Invalid bitInvalid跟Valid bit之外其實會存另外一個這個Pagetable的Lens Register其實就很像大家回憶一下我們在Chapter 1吧對不對有介紹怎麼去Protect Memory對不對不是有一個Memory Lens嗎那其實在Pagetable這個Layer是同樣的概念就是會有一個Pagetable的Lens所以像這個例子

來講我們並不會create八個entry我們就是你allocate了多少memory長到哪我們就allocate多少個entry然後這個length我們只要記錄它是寫譬如說6所以你只要小於等於都是有效大於我就return我就不需要去create後面這一堆沒有用處的entry了對不對所以比較直接的方式其實就是有一個length的值存在讓我們知道這個page table到底長到哪裡就可以

那即使有了這一個我們說bit這個東西必須要留著那為什麼必須要留著呢有兩個很明顯的原因第一個你可以看見這個length的部分它只告訴你在第幾個page對不對第幾個page的entry所以說它只能以page為單位來知道這塊空間是有效還無效對不對可是呢問題是你可以看見我們這邊所以剛剛說的這個Entry它有一個好處是為什麼

要這個Length第一個是可以縮短它的距離就是不需要存這些有的沒的第二個最主要的原因是因為你可以看見像這個例子來講如果是Invalid bit跟Valid bit它只能以Page為單位可是我們在做Memory Allocation的時候我們是以Byte為單位對不對所以有時候我們Access到的位置其實是在某一個Page裡

面的中間某一段後面是無效的前面是有效的所以我們還是會需要這個Lens的東西在裡面知道說我們的這個Memory到底漲到第幾個Byte然後就像我們第一章介紹那個方式去把它Filter掉所以除了有這個invalid bit跟valid bit之外一定還是會存一個lens才知道就是如果說我就算存了那個lens好了那我後來我program在之前的時候我會一直在locate新的memory那這樣子

可是我那些後面的變相後面的配箱六七我還是不能用因為我用的時候如果說它之後增長我又用到那怎麼辦所以它會動態而locate所以這個table也是一樣的animate就是allok所以就像你的現在是五個page那如果你繼續漲下去如果它這個像我們這個例子它這還在同一個page裡面還有沒用的嗎你繼

續漲的話它只是改變它的長度而已然後beat那邊不變但是如果你漲到第六個page的時候OS會知道嗎它不夠用了所以它就會再create這個table這個是一個entry然後再加進去變成valid然後就大家就不能用它嘛但是現在它沒有標記那就變成說其他的它還是要標記所以我說它這個標記是一定會留著的這一個 bit在 page table

裡面，它一定會有那我會說的是，有的是說當你在這個 lens 的範圍內的話，它一定會有；就像現在這個program， 如果只在長到 5嗎，所以其實我們會存的只有存到這而已，然後這個是Valid Bit，那為什麼會變成Invalid是因為我們下一章節教Virtual Memory的時候，這個Page被Swap到Disk，它就會變成Invalid的了；所以實際的時候你會

看到裡頭還是會有1有0的狀況出現，那當然你這樣長下去只要是在Memory的基本上都是會變成V，然後你如果你的Program很小那其實你可以Access空間很大還沒有Locate的話，我們Table就只是存到前面而已所以剛剛這個Beat有很多作用，所以剛剛其實有點混淆；大概是說我們把好幾個情形混在一起了；所

以彭澤你現在這樣講好了，就是說PageTable裡面大家可以知道，你是可以加一些所謂的Attribute就是Beat或是一些形容的，你可以去統一的去Indicate，可以告訴OS這個Page上Assets上的一些條件跟限制；我們OS常會用這樣可以去做一些很快的做一些判斷，所以是有你可以去加這些東西做判斷的那在這個例子來講第一個問題是，你要知道你ac cess一個memory的時候它到底是有效無效對不對那，這個solution呢。它通常是結合了一個bit還有一個length

那它其實主要是依靠這個Lens因為Lens可以到幾個byte的level是最fine grade的，所以它可以透過Lens知道它是真的是有沒有out of memory的狀況出現那為什麼你還是會需要這個中間這個bit。勒有兩個原因第一個是我們說過了它可能會被swap到disk去所以這時候它還是要check一下，即使它是在這個長度內可是有可能它被目前放到disk，所以不available，所以你還是要check一下尤其第九章我們會看見那個過程中，那個動作第二個原因是。啦ideally它是這樣子

sequentially的漲啦。但是我們也知道嘛。我們的program不是這麼這麼的連續的其實你的heap你的stack對不對。其實它中間可能會有流動的狀況所以說其實你還是可能會需要一個bit去indicate這個page到底有沒有被allocate因為我們使用Program做的時候它不會這麼好的真的全部都是sequentially的排在一起所以你還是會去檢查一下到底是不是一個有效你已經有located的值所以大概是這樣子

所以這是剛才說的為什麼Memory Limit那個我們一開始介紹的值它一定還是會需要存在因為它要知道它的長度到底在哪邊光那個bit是不夠的還有沒有其他問題所以這只是例子有時候它不會在Page的Boundary所以你還是需要知道你的這個Process到底它的長度到底是多少那有了PageTable之後第一個是你可以很快去判斷到底是有效無效的一個Memory空間所以你不會跟其他的程式撞在一起第二個

是反過來的就是有時候我們刻意想要去做Sharing我們之前提過的對不對很多的我們的這些Memory的Content我們想要做Sharing比如說我們說ShareMemoryProgramming就是希望有一些Memory可以去Share對不對或者我們說create一個process的時候我們想要去不需要立刻整個做copy還記得嗎我們可以copy and write對不對當你有變動的時候我們再copy那些有被變動的部分因為process of creation其實就是memory copy可是你沒有改變的狀況下就直接copy是很浪費時間的所以有時候你也可以做shearing

更重要的是我們後面還提到我們很多的程式都會有share的library對不對我們想要去share這些漏到memory之後我們大家就可以共同去使用所以很多情況我們知道share memory裡面不管是程式碼或者是data都有可能所以這個動作我們其實也可以透過pagetable來實現那實現的條件就是你可以看見基本上我們是

可以share尤其是code的部分我們會用Pagetable的方式去做那這些程式有一個條件就是它是所謂的這個reentrant code只是一個名字大家就pure code就好那最重要就是說這些code其實我們就像library基本上OS知道你是做一個library的時候Library的定義就是一個Pure Code就是沒有使用者可以去修改它的Code對不對這是Library的特

性所以其實有時候OS是知道哪些程式這些它是所謂的Pure Code那這些Code其實它不會改變所以我們如果很多人同時要用我們就可以透過Sharing的方式漏的一份在Memory就好所以很多例子什麼Editor ApplicationLibrary這些東西其實全部都是所謂的Pure Code所以就像之前說的所以當然自然它是所謂的Pure Code它就有個特

性就是其實我們只需要一份Copy那其他人只要能夠Access得到就可以，那如果有很多人要用同一份的時候，Sharing其實概念很單純就是我們在Page Table裡面做Mapping就好了對不對，所以不同的Program，它可以有不同的Process，它可以有不同的Virtual Address然後，可以把它指到同一個frame去同一個physical address，那它就可以讀到相同的content，

但是每個人會誤以為他自己已經漏的這一份到memory頭去了好，那Paging的好處我們之前也說過，因為Paging是只有一個Partition而已，所以其實兩個Process，它在做這些Sharing的時候，不用把所有的Memory都Sharing，只要有需要，例如說這個Library，它可能只用在我Code裡面的某幾個Page，那我們就只要把那幾個Page做Sharing就好，而不需要整個去做Sharing，所以沒有共用的部分就是所謂像是用Private的Data它就可以用它原來自己的Memory的Content就好

簡單來講就是這樣子，因為其他的概念其實蠻單純的也就是不同的process，我們知道它有它自己的page table，原來的話我們知道它裡面對到的frame是不應該重複的OS會避免這件事情，但是當OS它發現其實這些code是所謂的re-entry code，然後又已經漏到memory的時候，它就可以動一個手腳來去減少我們的memory的浪費像這邊來講可能這兩個人都有他的editor對不對

都是word然後用了三個page的空間然後這邊是你的data的部分那前面三個我就可以都對到三四六所以你如果對到physically其實我的editor只露了一份可是data卻有三個不同的那每個使用者這邊有三個使用者其實看到的結果是相同的對不對其實不影響也沒有任何的問題因為那個是所謂的Pure Code所

以像我們之前說Pagetable可以設定很多東西啊所以譬如說像這個你是Sharing你也知道它是Pure Code所以它的Read Only就會把它Set起來所以就絕對不會出問題了對不對就是知道它是Read Only所以你才可以這麼做那你所有的這些你要去對這個Memory空間比如說你要寫一個Write好了對不對那其實OS就會看見這個Beat寫Read Only喔那你現在是Write這個位置當然就直接丟一個For出來對不對

就可以擋掉就可以保護這個Editor的程式碼了好所以這個是怎麼去做Sharing其實就是透過這個Page Table裡面的Entry ry的Making的方式而已好那接下來就非常重要了接下來我們要介紹的是不同的PageTable的Structure也就是說我們前面介紹是很單純的就是PageNumberPageOffset加起來就得到答案但是這個做法其實是有一個問題的它有一些Limitation的最大的Limitation就在這裡就是隨著我們的

程式越長越大也就是你可以使用的Logical的Address越來越大的時候你會發現一件事情如果你還用我們之前這種所謂的one level就是轉換一次就可以得到答案的結果的話我們算過嘛page table的entry數會非常非常的驚人對不對因為一個page只有4kb而已那如果說像之前說的如果你一個我們的這個virtual address你想要讓他可以asset4個gb的file的話這個空間的話

那你其實去轉換一下32次方嘛那你就需要2的20次方的這個Page Table的EntryEntry的數量而已喔還不管一個Entry要幾個Byte給大家除一下就知道了4KB是2的12次方嘛所以就等於你要2的20次方的Entry在那邊那你會說這個問題是什麼勒2的20次方你轉換下來的話你就知道每

一個如果是4個byte光這個page表本身就4個megabyte這樣的大小，那4個megabyte我們說過因為這是MNU讀的，所以MNU要讀到的是physical address對不對，所以代表這4個megabyte的空間必須是連續而且是在實體記憶體空間上連續沒錯吧，因為沒有人在幫MNU做address translation了，所以當他在讀一個page table的時候他說第三個entry那他

其實就是physical entry，physical的memory就跳到第三個位置而已，所以說你今天要4MB這4MB在physical的memory必須要完全連續雖然我們有paging的概念說是4KB可是這個page table是不能夠再被切割的，因為他是沒有再做translation直接去lookup而已沒錯吧，所以要注意到這一點，所以這樣的結果就是變成我們其實在存這個page table的時候變

成一個很大的問題，就是我們physical memory其實很難找到4MB連續的空間或者說你要找到的話其實也是一個很大的限制就是必須要reserve很大一塊空間然後專門存page table可是這是非常沒有效率的，所以很大的問題是,如果這個1 entry的話其實我們的這個page table會非常大而且是要一個連續的空間所以會很難去locate一塊空間去放這個page table所以我們接下來

為什麼會有這麼多structure呢就是要解決這個問題就是說我們怎麼樣可以把一個page table的size把它變小當我們想要Access的Memory空間還是很大的時候怎麼樣可以把這個Page Table的Size縮小讓我們可以放在Memory的零碎的可以有空的位置裡面去所以我們會介紹Typical的做法一共有三個第一個是這個Hierarchy然後Hash然後是Inverted那待會我們周述這例子的時候大家就特別留意那個Page Size的變化是什麼

就是那个page table它的大小的变化在不同的做法下面那第一个做法就是原来是很大的page table那我们可以把它用hierarchical的方式把它切成很多小的table简单来讲就是其实直觉来讲就是这边其实有非常非常多的entry对不对就我们说的因为logical address很大所以page table非常非常大我們可以把它縮小一個地方很簡單我們就把它partition這邊一個小table這是一個 對不對

我們就把它貼成好幾個就好這每一個因為我們想要把它放在一個小的空間裡面所以其實這每一個table都是一個獨立的小table；然後我們可以把它塞到不同的physical memory的位置上面去可是因為它放在不同的位置所以我必須要知道第一個page table的位置在哪第二個在哪等等對不對所以為什麼會

有hierarchy就是我們前面必須要再create一個table；那這個裡面指到的是第一個小page table的位置在哪然後第二個在哪裡然後第三個在哪裡以此類推那所以這樣的話的目的就是可以把這個大table拆成很多小table；然後但是因為它很小然後我可以讓它像就等於像這個pointer的概念了對不對所以我只要能夠

找到這些table就可以把它放在不同位置可是因為它可以放在不同位置所以就等於我又要再建一個table去知道它到底存在什麼位置好所以這就是所謂的hierarchy等一下會有圖啦我們會看得更清楚；那這個概念其實我們會go through兩個level的例子原來我們學的叫做one level；我們等一下會介紹Go Through的例子是Two Level；大家可以很容易去extend把它想成三個Level

四個Level因為做法是相同的那Two Level怎麼做呢簡單來講就是一樣假設我們input就是32个bit而已，因為這個數量不會變嘛，对不对，那原來的做法我們知道就是前面可能是後面12个bit所以前面有20个bit，所以這個Page Table非常非常的龐大，那麼我們把它切割的方式就是把它變兩個 hierarchy 兩個level，就是把它再切變成 10 10 12就變成三塊就對了，那變成三塊之後你可以看見一樣的後面的這 12

幣當然是完全一樣就是 page 的offset，对不对，但是前面的話呢我們就會把它變成所謂的這個inner跟outer的page number，所以本來是連在一起我們把它切成兩段外面的這個叫outer，就是前面這個叫outer，那這個是inner那這個目的咧其實大家看見的就是outer是用來查這個table所以這個其實是outer的page table然後這個是inner，所以前面那10个bit是這個table的index然後後面10个bit是

你所說的那一個小的table裡面的index所以其實加起來你還是可以找到它原來的位置，那這個概念其實大家在寫Program大家可能熟一點啦其實很簡單是這樣大家應該用過比如說一個array是1,000吧，对不对，那這個你就要連續的locate1,000个element的空間，对不对可是你知道我們可以把它寫成2 level array對不對所以我們可以把它變成10

然後100對吧這兩個其實大家可以做轉換很容易嘛對不對就是任何一個位置A3我在這個這個Data這樣子的Data的Alignment下或Layout下我還是知道有同樣的位置對不對但是差別在哪這本來是一個1,000個Element的Single Array這個是10個100個Element的小Array對不對所以這就是2D的概念你可以想我會繼續猜嘛10,10,10對不對我也可以把它拆成三層那我這個是不是就越來越小了對不對所以這是完全一樣的概念其實就只是在做這個mapping的array怎麼去做拆解的問題而已好但是這樣拆解所以大家很明顯看到這樣拆解之後我最大的page table就是只有2的十次方的entry

你整 Entry 是這些 Table所有的 Table 加起來 Entry 數嗎？對，沒錯，你講的沒錯所以這個是大家常常誤解的地方這裡這個 Table 跟原來 Table 長得完全一樣所以其實 Entry 數沒有變少喔所有的 Entry 數沒有變少因為你要 Map 到的位置是相同數量嘛，對不對？事實上，就像這些同學點出來的，這個做法，你的entry數是增加的，因為你多了一個table嘛，所以這個還好。你要再計算這些數量對不對所以,total的entry數是增加的，但是我們的

重點是什麼呢？這個是變小了，所以原來可能要4MB，這才能夠存下這整個對不對可是，我一切之後，這個假如說是10個bit只要4KB對不對，所以我現在只要在我的Physical Memory裡面找到4KB的連續空間就好事實上4KB是什麼一個Page嘛，所以剛好會塞進去，所以我就說我這是在這個沒有做Translation可是，我因為是Paging

的關係，所以本來就可以有4KB 4KB的連續空間可是，如果你要跨Page的話然後你要Physically是連續這件事情是不太容易做到的，因為我們已經把Physical的Memory做切割了，重點是要把它變小，所以我們才一直在講說不要誤會囉；變小是指說單一一個page table變小，total是變大頭，所以，這每個都4KB，那這個其實也是4KB，在我們的例子裡面，所以剛好就是我們physical memory只要有空的frame你就把它塞進去就可以了，所以，你可以把它散落在任何地方

代價是因為它散落，所以，你要再多一個table去找到它們到底在哪裡所以不要誤會囉，這個目的不是要讓我們的page table整個total的size變小，而是每一個你必須要連續LK的這個最小單位的table。可以變小

那這個的代價就更明顯你可以看見它會從兩個Memory Access我們之前說的變成三個因為看箭頭就知道了嘛你的Translation是要先去查這個表那是一次Memory Access再查這邊這個Layer的某一個表兩次Memory Access最後讀資料三次所以你切得越細你要讀的次數就越多就越慢所以TLB的功用就更大了

來直接看圖示就應該很清楚了 對不對所以我們剛才指的就是像這樣子To level 對不對十個十個十二個指的就是前面你會有二個十次方的entry 對不對然後這裡面每一個指的不是frame number喔而是這一個page table存在我們這個第幾個frame上面所以那裡面就是存在我們的那個小的inner table了那所以這裡

面存的這個才是它最後你要讀那個資料的frame的number那轉換過去之後所以這邊就會知道它到底是存在哪一個所以這整個你看見外面的這個框框這個就是原來one level的table是沒有變的但是two level的意義就在於我們可以把它切成很多小的對不對但是切成小的隨便放的結果就是我們還需要另外一個table去找到它們這個其實是代價

但是每個table都會變小所以我們就可以去篩到比較好去存放這個page table即使你的整個page table是非常大的我們可以把它做拆解去存放好那最後當然一樣啦這就是指到不同位置那OS在做memory allocation他會自己會知道不要指到相同的physical的位置嘛除非你要做sharing那個部分是一樣的好所以為什麼會三個嘛因為

第一個 p1 會去 alter page table當作他的 index 去查這是一次 memory access然後查出來之後你就會知道 page table 2這個第二層 level 的 table 在哪裡然後呢 你再用 p2 去查它裡面的位置 對不對然後查出來的這個才終於是我們原來真正要的那個 frame number然後再去加 offset加完之后你去读资料那就是第三次了所以这是two level的这更多例子啦所以这都一样的这就更concrete一点了啦所以你可以看见这边就是我们说的下一层就是altered page table那

這個outer page table會存在哪咧就是我們之前教過的你會有一個PCB裡面會存page table的registerbase register所以那個是在PCB它只會有一個它會直接有一個initial它會知道你的tableouter存在哪但是它就看不見後面幾層了，所以它必須要去查表對不對去知道裡面比如說你說欸第二個012第二個這個inner table那裡面

可以填任何的數字所以我的拆解出來的小inner table可以放在任何地方都沒關係這是一個pointer而已那這個裡面才是我們的frame的base address然後去加上offset然後去讀資料所以剛剛這個做法就是hierarchical的PageTable就是這種做法我可以隨便切所以其實是都沒差的我可以三個Level 四個Level 五個Level然後每個Level到底幾個bit也無所謂那個就是Control每一層它的Table的Entry數量的差別而已問題是這種這套做法你可以想如果我們今天有64個bit就是現代的電腦

你可以看如果我們要2 level那我第一層可能一個切法是42加10加12所以42這個alter table16個Terabyte所以你可以想見這個table可以長到多大所以其實兩個level都還不夠如果你有64個bit兩個level的page table你還是很難把它下面這個page table切到N小頂多你對分好了對分之後每一個人還是20幾個bit所以還是非常非常的

大所以你可以看如果是64bit的solution你可能要切到就是這樣10個bit， 10個bit因為沒10個bit或者說12個bit啦12個bit就等於是4KB所以剛好fitting一個frame超過12其實都不太行了，所以一個做法就是這樣一直切一直切，那麼64bit的address就在切成你可以看見大概是6個level吧1 2 3 4 55個level就要切到5個

level，所以total memory access就是6倍，所以变成6倍慢，所以这个做法的问题就是当你的address真的很多的时候，你用这种hierarchy，它的成效是还蛮有限的，就是它的trade-on就是你的memory access它会暴增，每多一层它就是再慢一个memory access，那这个做法在实际的真实电脑是有的，但是最多大概就做到4 level就受不了了，就是你總是

會有cash miss的時候，所以miss的時候如果是四倍慢這大概就practically大家能接受的範圍了，你切到五個六個level其實是無法的，所以這个效能上可能不是很理想，所以這是hierarchical的問題就是它會隨著你切的level越多你想要把它table切得越小你所要花的memory asset時間是不斷地增長的，這是它的一個limitation，所以不意外怎麼辦

這個其實就是一個lookup的動作所以大家在data structure可能就學過了我們有很多strategydata structure可以解決這個問題其中一個就是hashing大家應該都知道基本的手段是什麼意思那hashing在這邊怎麼用Hashing 這邊的用法就是它基本上有一個這個bucket所以就是我們知道就是分bucket對不對所以

你可以看你要多少個hash的bucket那它hash的方式可以是很簡單這只是例子所以譬如說我們就很單純的如果我們有5個bucket那我們就module 5對不對看它的餘數就對了所以任何一個這個我們要的這個位置的lookup的這個就是Virtual轉到Physical的這個Payer的Entry就可以放在這個

Bucket的某一個位置裡面所以當然我們Hash的東西因為我們一開始只有PageNumber啦所以當然就是Hash by PageNumber然後進去查那進去之後這個好處跟剛剛的差別在哪裡就是我到底有多少個Bucket是很有彈性的就是沒有受到我Virtual Address的Bit的限制是無關的我Bucket可能也很

少很少的時候我們知道它會有很多Collision就會很多對不對所以壞處就是你找到這個Bucket之後很不幸的接下來就是一個一個的去做Searching所以會變得很慢可是如果我們Bucket Create非常非常多的話其實每一個裡面可能就只有一兩個這個Payer在裡面對不對就是當初PageTable的Entry在裡面所以我們找的時候

就可以很快的可以找到了好所以這是基本上Hash的目的就是這樣就是不管你的這個Virtual Address的空間到底有多少我可以Construct一個這個Bucket出來去分散你Lookup的時間然後用一個Hash function很快的去找到你在哪一個Bucket裡面所以那就是1只要一個Memory Access對不對那當然你Bucket數夠多的話裡面這個不會Tribal很長你的Memory Access time就會減少

那當然要選多少個bucket那是一個tradeoff啦所以還是有它的好壞在裡面其實只是不同形式的data structure而已好那這個有一個好處的原因是在於說我們的程式我們之前有講啦我們並不會使用的這個logical就是virtual address我們不會真的完完全全連續使用因為你有heap你有stack所以其實它是有點分散的也就是

說一個Program，它有用到的位置或許真的Expand就是說跨過了4個TB可是你真正用到的空間可能才4個GB而已那如果是之前這個例子，你會注意到前面的話因為它跟你的使用的空間無關所以你最大是多少它就必須要全部到Entry放在那邊所以有一個可能性就是像這個例子來講好了對不對這

一個空間裡面恐怕只有三四個page是有用到的其他都根本沒有allocate就很多空在那裡對不對你只是說可以用這麼大的空間所以他就把它reserve下來要create一個很大的page table然後中間有洞你都必須要有entry對不对因為你可能很不幸的頭跟尾都有使用到嘛中間都沒有用到可是這個做法就必須要全部把它reserve entry下來

對吧 沒錯吧就算有什麼Lens也沒有辦法我們只能看Invalid Bit、Invalid Bit而已但是這個就不一樣了為什麼這個在真實的應用中可能效果會好的原因是因為反正我是Hash所以我沒有使用到的這些Page不會存在Bucket裡 對不对而且每一個Page有用到沒用到都無所謂沒有關聯性因為只是Hash function而已 對不对所以有可能

你用的算是你只要用的很少然後很散落的話其實這一個bucket並不會長到很多的page在裡頭對吧其實你用的只要夠少我就可以很快的找到即使說total你可以用的page數量很多可是你真的用到其實往往是很少所以用Hash會比較有效率這是它最大的差別了好那所以它當然也是缺點啦就是你

會有很多pointer對不對所以這每一個都是一個pointer所以那就是一樣會有很多的memory access而且你會浪費掉4個byte尤其這裡不要忘記昨天存的只是一個friend的base address喔所以也才4個byte那你pointer就用掉4個byte你等於浪費了一倍的空間對不對所以這是它一個比較大的一個缺點然後你可能運氣不好的時候就要做triversing那是個link list

那每一次Triverse都是一個Pointer那就是一次Memory Access就像你用幾個Level的還有Rocky Code的Hash Table是一樣的意思所以它的Translation就會長像這樣子對不對 你有一堆的Hash Table是不是Hash Table每個是一個Bucket那你用你的Page Number直接做Hash你就知道你如果在哪一個Bucket裡然後你就開始Triverse那裡面的話不要忘記它是這個每一個它會有這個PQ也就是這邊來講的話你要去檢查一下它到底是哪一個這個配取的值對不對

因為它們的餘數可能都是3嘛可能是3 13 23所以你要看你這個值到底是多少所以它還是要原來的值然後要相同那它才能夠去知道對應出來的這個SR就是frame number啦所以就是第二個Entry是FrameNumber第一個Entry是PageNumber然後第三個Entry是一個Pointer所以你可以Triverse那這樣去做一個Address的Translation好講完這個就好我們就可以下課這個很快只是補充的啦就是你剛看見了這個Hash的缺點在於他要走一個Link List

所以它可能會非常慢一次只能看一個entry的值而已所以萬一那不對那你又要再讀一次memory所以會非常的久所以有很早的時候大家在討論這個做法的時候就有人提出來的做法是其實很簡單的一個extension就是它不會只是這個每個link list並不是只是放一個entry而是放list of entry所以有點像你有33

23 33 43這樣子那你這三個把它包在一起所以33 23就把它包在一起然後是存在連續的memory空間裡面所以你去look up的時候你會找到這個等於說是一個sub table一樣像inner桌一樣的概念對不對然後你就可以一次比對這三個人是否有熱連續的好處就是你可以一次找到它們然後可以一次落到MMU的Hardware然後做comparison就算你要scan through也沒關係

至少你可以一次把它讀進去而不是在那邊找好幾次所以用這種方式你就可以盡量去檢找這個link list traverse的數量了你把它group在一起然後一次去找好幾個entry所以可以達到局部性的解決這個問題我想我們就先下課我們最後講最後一個Inverted Page Table的做法。.